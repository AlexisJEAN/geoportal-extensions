/*!
 * @brief French Geoportal Extension for Itowns
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * copyright CeCILL-B
 * copyright IGN
 * @author IGN
 * @version 2.0.0
 * @date 2018-07-25
 *
 */

/*!
 * Sortable -- minimalist JavaScript library for reorderable drag-and-drop lists
 *
 * Released under MIT LICENSE
 *
 * Copyright 2013-2016 Lebedev Konstantin <ibnRubaXa@gmail.com>
 * http://rubaxa.github.io/Sortable/
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4
 */

/*!
 * Proj4js - Javascript reprojection library.
 *
 * Authors:
 *
 * - Mike Adair madairATdmsolutions.ca
 * - Richard Greenwood richATgreenwoodmap.com
 * - Didier Richard didier.richardATign.fr
 * - Stephen Irons stephen.ironsATclear.net.nz
 * - Olivier Terral oterralATgmail.com
 * - Calvin Metcalf cmetcalfATappgeo.com
 *
 * Copyright (c) 2014, Mike Adair, Richard Greenwood, Didier Richard, Stephen Irons, Olivier Terral and Calvin Metcalf
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  _THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE._
 *
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("itowns"), require("xmldom"), require("request"));
	else if(typeof define === 'function' && define.amd)
		define("Gp", ["itowns", "require", "require"], factory);
	else if(typeof exports === 'object')
		exports["Gp"] = factory(require("itowns"), require("xmldom"), require("request"));
	else
		root["Gp"] = factory(root["itowns"], root[undefined], root[undefined]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 9);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _loglevel = __webpack_require__(14);\n\nvar Log = _interopRequireWildcard(_loglevel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar LoggerByDefault = {\n    /**\n     *logger statique\n     * @param {String} [name=\"default\"] - the logger name\n     *\n     * @returns {Object} logger\n     */\n    getLogger: function getLogger(name) {\n        // Substitute global constants configured at compile time\n        // cf. webpack.config.js\n        undefined ? Log.disableAll() : Log.enableAll();\n        var logname = name || \"default\";\n        return Log.getLogger(logname);\n    }\n}; /* global __PRODUCTION__ */\nexports.default = LoggerByDefault;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcz81YjExIl0sIm5hbWVzIjpbIkxvZyIsIkxvZ2dlckJ5RGVmYXVsdCIsImdldExvZ2dlciIsIm5hbWUiLCJfX1BST0RVQ1RJT05fXyIsImRpc2FibGVBbGwiLCJlbmFibGVBbGwiLCJsb2duYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7SUFBWUEsRzs7OztBQUVaLElBQUlDLGtCQUFrQjtBQUNsQjs7Ozs7O0FBTUFDLGVBQVksbUJBQVVDLElBQVYsRUFBZ0I7QUFDeEI7QUFDQTtBQUNDQyxRQUFBLFNBQUQsR0FDTUosSUFBSUssVUFBSixFQUROLEdBQ3lCTCxJQUFJTSxTQUFKLEVBRHpCO0FBRUEsWUFBSUMsVUFBVUosUUFBUSxTQUF0QjtBQUNBLGVBQU9ILElBQUlFLFNBQUosQ0FBY0ssT0FBZCxDQUFQO0FBQ0g7QUFkaUIsQ0FBdEIsQyxDQUhBO2tCQW9CZU4sZSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIF9fUFJPRFVDVElPTl9fICovXG5pbXBvcnQgKiBhcyBMb2cgZnJvbSBcImxvZ2xldmVsXCI7XG5cbnZhciBMb2dnZXJCeURlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICpsb2dnZXIgc3RhdGlxdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9XCJkZWZhdWx0XCJdIC0gdGhlIGxvZ2dlciBuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBsb2dnZXJcbiAgICAgKi9cbiAgICBnZXRMb2dnZXIgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyBTdWJzdGl0dXRlIGdsb2JhbCBjb25zdGFudHMgY29uZmlndXJlZCBhdCBjb21waWxlIHRpbWVcbiAgICAgICAgLy8gY2YuIHdlYnBhY2suY29uZmlnLmpzXG4gICAgICAgIChfX1BST0RVQ1RJT05fXylcbiAgICAgICAgICAgID8gTG9nLmRpc2FibGVBbGwoKSA6IExvZy5lbmFibGVBbGwoKTtcbiAgICAgICAgdmFyIGxvZ25hbWUgPSBuYW1lIHx8IFwiZGVmYXVsdFwiO1xuICAgICAgICByZXR1cm4gTG9nLmdldExvZ2dlcihsb2duYW1lKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMb2dnZXJCeURlZmF1bHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar Utils = {\n\n    /**\n     * this method is called by the constructor.\n     * this information is useful to switch to touch mode.\n     * Detection : test for desktop or tactile\n     *\n     * @returns {Boolean} isDesktop - true for desktop userAgent, false for mobile\n     */\n    detectSupport: function detectSupport() {\n        var isDesktop = true;\n        var userAgent = window.navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf(\"iphone\") !== -1 || userAgent.indexOf(\"ipod\") !== -1 || userAgent.indexOf(\"ipad\") !== -1 || userAgent.indexOf(\"android\") !== -1 || userAgent.indexOf(\"mobile\") !== -1 || userAgent.indexOf(\"blackberry\") !== -1 || userAgent.indexOf(\"tablet\") !== -1 || userAgent.indexOf(\"phone\") !== -1 || userAgent.indexOf(\"touch\") !== -1) {\n            isDesktop = false;\n        }\n\n        if (userAgent.indexOf(\"msie\") !== -1 || userAgent.indexOf(\"trident\") !== -1) {\n            isDesktop = true;\n        }\n\n        return isDesktop;\n    },\n\n    /**\n     *  Copies all source object members to dest\n     *\n     * @param {Object} dest - destination object where properties and method will be copied\n     * @param {Object} source - source object from which properties and method will be copied\n     * @returns {Object} dest\n     */\n    assign: function assign(dest, source) {\n        dest = dest || {};\n        for (var prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                dest[prop] = source[prop];\n            }\n        }\n        return dest;\n    },\n\n    /**\n     * Merge two objects parameters (deeper than assign)\n     *\n     * @param {Object} dest   - destination object where properties and method will be merge\n     * @param {Object} source - source object from which properties and method will be merge\n     */\n    mergeParams: function mergeParams(dest, source) {\n        if (!dest || !source) {\n            return;\n        }\n        for (var param in source) {\n            if (source.hasOwnProperty(param)) {\n                if (_typeof(source[param]) === \"object\") {\n                    if (dest.hasOwnProperty(param)) {\n                        this.mergeParams(dest[param], source[param]);\n                    } else {\n                        dest[param] = source[param];\n                    }\n                } else {\n                    dest[param] = source[param];\n                }\n            }\n        }\n    }\n};\n\nexports.default = Utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzLmpzP2YzM2MiXSwibmFtZXMiOlsiVXRpbHMiLCJkZXRlY3RTdXBwb3J0IiwiaXNEZXNrdG9wIiwidXNlckFnZW50Iiwid2luZG93IiwibmF2aWdhdG9yIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiYXNzaWduIiwiZGVzdCIsInNvdXJjZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlUGFyYW1zIiwicGFyYW0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsSUFBSUEsUUFBUTs7QUFFUjs7Ozs7OztBQU9BQyxtQkFBZ0IseUJBQVk7QUFDeEIsWUFBSUMsWUFBWSxJQUFoQjtBQUNBLFlBQUlDLFlBQVlDLE9BQU9DLFNBQVAsQ0FBaUJGLFNBQWpCLENBQTJCRyxXQUEzQixFQUFoQjs7QUFFQSxZQUFJSCxVQUFVSSxPQUFWLENBQWtCLFFBQWxCLE1BQWdDLENBQUMsQ0FBakMsSUFDQUosVUFBVUksT0FBVixDQUFrQixNQUFsQixNQUE4QixDQUFDLENBRC9CLElBRUFKLFVBQVVJLE9BQVYsQ0FBa0IsTUFBbEIsTUFBOEIsQ0FBQyxDQUYvQixJQUdBSixVQUFVSSxPQUFWLENBQWtCLFNBQWxCLE1BQWlDLENBQUMsQ0FIbEMsSUFJQUosVUFBVUksT0FBVixDQUFrQixRQUFsQixNQUFnQyxDQUFDLENBSmpDLElBS0FKLFVBQVVJLE9BQVYsQ0FBa0IsWUFBbEIsTUFBb0MsQ0FBQyxDQUxyQyxJQU1BSixVQUFVSSxPQUFWLENBQWtCLFFBQWxCLE1BQWdDLENBQUMsQ0FOakMsSUFPQUosVUFBVUksT0FBVixDQUFrQixPQUFsQixNQUErQixDQUFDLENBUGhDLElBUUFKLFVBQVVJLE9BQVYsQ0FBa0IsT0FBbEIsTUFBK0IsQ0FBQyxDQVJwQyxFQVF1QztBQUNuQ0wsd0JBQVksS0FBWjtBQUNIOztBQUVELFlBQUlDLFVBQVVJLE9BQVYsQ0FBa0IsTUFBbEIsTUFBOEIsQ0FBQyxDQUEvQixJQUNBSixVQUFVSSxPQUFWLENBQWtCLFNBQWxCLE1BQWlDLENBQUMsQ0FEdEMsRUFDeUM7QUFDckNMLHdCQUFZLElBQVo7QUFDSDs7QUFFRCxlQUFPQSxTQUFQO0FBQ0gsS0EvQk87O0FBaUNSOzs7Ozs7O0FBT0FNLFlBQVMsZ0JBQVVDLElBQVYsRUFBZ0JDLE1BQWhCLEVBQXdCO0FBQzdCRCxlQUFPQSxRQUFRLEVBQWY7QUFDQSxhQUFLLElBQUlFLElBQVQsSUFBaUJELE1BQWpCLEVBQXlCO0FBQ3JCLGdCQUFJQSxPQUFPRSxjQUFQLENBQXNCRCxJQUF0QixDQUFKLEVBQWlDO0FBQzdCRixxQkFBS0UsSUFBTCxJQUFhRCxPQUFPQyxJQUFQLENBQWI7QUFDSDtBQUNKO0FBQ0QsZUFBT0YsSUFBUDtBQUNILEtBaERPOztBQWtEUjs7Ozs7O0FBTUFJLGlCQUFjLHFCQUFVSixJQUFWLEVBQWdCQyxNQUFoQixFQUF3QjtBQUNsQyxZQUFJLENBQUNELElBQUQsSUFBUyxDQUFDQyxNQUFkLEVBQXNCO0FBQ2xCO0FBQ0g7QUFDRCxhQUFLLElBQUlJLEtBQVQsSUFBa0JKLE1BQWxCLEVBQTBCO0FBQ3RCLGdCQUFJQSxPQUFPRSxjQUFQLENBQXNCRSxLQUF0QixDQUFKLEVBQWtDO0FBQzlCLG9CQUFJLFFBQU9KLE9BQU9JLEtBQVAsQ0FBUCxNQUF5QixRQUE3QixFQUF1QztBQUNuQyx3QkFBSUwsS0FBS0csY0FBTCxDQUFvQkUsS0FBcEIsQ0FBSixFQUFnQztBQUM1Qiw2QkFBS0QsV0FBTCxDQUFpQkosS0FBS0ssS0FBTCxDQUFqQixFQUE4QkosT0FBT0ksS0FBUCxDQUE5QjtBQUNILHFCQUZELE1BRU87QUFDSEwsNkJBQUtLLEtBQUwsSUFBY0osT0FBT0ksS0FBUCxDQUFkO0FBQ0g7QUFDSixpQkFORCxNQU1PO0FBQ0hMLHlCQUFLSyxLQUFMLElBQWNKLE9BQU9JLEtBQVAsQ0FBZDtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBekVPLENBQVo7O2tCQTRFZWQsSyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFV0aWxzID0ge1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiB0aGlzIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCB0byBzd2l0Y2ggdG8gdG91Y2ggbW9kZS5cbiAgICAgKiBEZXRlY3Rpb24gOiB0ZXN0IGZvciBkZXNrdG9wIG9yIHRhY3RpbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBpc0Rlc2t0b3AgLSB0cnVlIGZvciBkZXNrdG9wIHVzZXJBZ2VudCwgZmFsc2UgZm9yIG1vYmlsZVxuICAgICAqL1xuICAgIGRldGVjdFN1cHBvcnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc0Rlc2t0b3AgPSB0cnVlO1xuICAgICAgICB2YXIgdXNlckFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAodXNlckFnZW50LmluZGV4T2YoXCJpcGhvbmVcIikgIT09IC0xIHx8XG4gICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZihcImlwb2RcIikgIT09IC0xIHx8XG4gICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZihcImlwYWRcIikgIT09IC0xIHx8XG4gICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xIHx8XG4gICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZihcIm1vYmlsZVwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIHVzZXJBZ2VudC5pbmRleE9mKFwiYmxhY2tiZXJyeVwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIHVzZXJBZ2VudC5pbmRleE9mKFwidGFibGV0XCIpICE9PSAtMSB8fFxuICAgICAgICAgICAgdXNlckFnZW50LmluZGV4T2YoXCJwaG9uZVwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIHVzZXJBZ2VudC5pbmRleE9mKFwidG91Y2hcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBpc0Rlc2t0b3AgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIm1zaWVcIikgIT09IC0xIHx8XG4gICAgICAgICAgICB1c2VyQWdlbnQuaW5kZXhPZihcInRyaWRlbnRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBpc0Rlc2t0b3AgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRGVza3RvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogIENvcGllcyBhbGwgc291cmNlIG9iamVjdCBtZW1iZXJzIHRvIGRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IC0gZGVzdGluYXRpb24gb2JqZWN0IHdoZXJlIHByb3BlcnRpZXMgYW5kIG1ldGhvZCB3aWxsIGJlIGNvcGllZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggcHJvcGVydGllcyBhbmQgbWV0aG9kIHdpbGwgYmUgY29waWVkXG4gICAgICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICAgICAqL1xuICAgIGFzc2lnbiA6IGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICAgICAgZGVzdCA9IGRlc3QgfHwge307XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdHdvIG9iamVjdHMgcGFyYW1ldGVycyAoZGVlcGVyIHRoYW4gYXNzaWduKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3QgICAtIGRlc3RpbmF0aW9uIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2Qgd2lsbCBiZSBtZXJnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBzb3VyY2Ugb2JqZWN0IGZyb20gd2hpY2ggcHJvcGVydGllcyBhbmQgbWV0aG9kIHdpbGwgYmUgbWVyZ2VcbiAgICAgKi9cbiAgICBtZXJnZVBhcmFtcyA6IGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFkZXN0IHx8ICFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwYXJhbSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbcGFyYW1dID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0Lmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZVBhcmFtcyhkZXN0W3BhcmFtXSwgc291cmNlW3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W3BhcmFtXSA9IHNvdXJjZVtwYXJhbV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W3BhcmFtXSA9IHNvdXJjZVtwYXJhbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tbW9uL1V0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nvar _itowns = __webpack_require__(8);\n\nvar Itowns = _interopRequireWildcard(_itowns);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"GlobeViewExtended\");\n\n/**\n * @classdesc\n *\n * Extended itowns.GlobeView.\n *\n * @constructor\n * @extends {itowns.GlobeView}\n * @param {HTMLElement} viewerDiv - Where to instanciate the Three.js scene in the DOM\n * @param {Object} coordCarto - longitude, latitude, altitude\n * @param {Object} [options] - Optional properties.\n * @param {String} [options.position=\"relative\"] - \"absolute\" or \"relative\"\n */\nfunction GlobeViewExtended(viewerDiv, coordCarto, options) {\n    viewerDiv.style.position = !options || !options.position ? \"relative\" : options.position;\n\n    this._itowns = Itowns;\n\n    // stockage de l'élément html porteur du globe\n    this._viewerDiv = viewerDiv;\n\n    // widget container\n    this._widgets = [];\n\n    // mapping des evenements\n    this._initEventMap();\n\n    // pour savoir si le globe est initialise\n    this._isInitialized = false;\n\n    // call constructor\n    this._globeView = new this._itowns.GlobeView(viewerDiv, coordCarto, options);\n\n    var self = this;\n    this.listen(GlobeViewExtended.EVENTS.GLOBE_INITIALIZED, function () {\n        self._isInitialized = true;\n    });\n\n    this._globeView.addFrameRequester(this._itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, function () {\n        clearTimeout(this._preRenderTimer);\n        self._preRenderTimer = setTimeout(function () {\n            if (self._fetchVisibleColorLayers || self._fetchVisibleElevationLayers || self._fetchExtent) {\n                var event = {\n                    type: GlobeViewExtended.EVENTS.PRE_RENDER\n                };\n                if (self._fetchExtent) {\n                    event.extent = new self._itowns.Extent(\"EPSG:4326\", 180, -180, 90, -90);\n                }\n                if (self._fetchVisibleColorLayers) {\n                    event.colorLayersId = [];\n                }\n                if (self._fetchVisibleElevationLayers) {\n                    event.elevationLayersId = [];\n                }\n\n                self._getCurrentSceneInfos(self._globeView.scene, event);\n\n                self._globeView.dispatchEvent(event);\n            }\n        }, 100);\n    }.bind(this));\n\n    if (this._globeView.controls) {\n        this.freezeControl();\n    }\n}\n\n/**\n * intializes the evenements map\n */\nGlobeViewExtended.prototype._initEventMap = function () {\n    if (!GlobeViewExtended.EVENTS) {\n        GlobeViewExtended.EVENTS = {\n            RANGE_CHANGED: this._itowns.CONTROL_EVENTS.RANGE_CHANGED,\n            CENTER_CHANGED: this._itowns.CONTROL_EVENTS.CAMERA_TARGET_CHANGED,\n            ORIENTATION_CHANGED: this._itowns.CONTROL_EVENTS.ORIENTATION_CHANGED,\n            LAYER_ADDED: this._itowns.GLOBE_VIEW_EVENTS.LAYER_ADDED,\n            LAYER_REMOVED: this._itowns.GLOBE_VIEW_EVENTS.LAYER_REMOVED,\n            LAYERS_ORDER_CHANGED: this._itowns.GLOBE_VIEW_EVENTS.COLOR_LAYERS_ORDER_CHANGED,\n            GLOBE_INITIALIZED: this._itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED,\n            VIEW_INITIALIZED: \"viewinitialized\",\n            PRE_RENDER: \"prerender\",\n            MOUSE_MOVE: \"mousemove\",\n            AFTER_RENDER: this._itowns.MAIN_LOOP_EVENTS.AFTER_RENDER,\n            OPACITY_PROPERTY_CHANGED: \"opacity-property-changed\",\n            VISIBLE_PROPERTY_CHANGED: \"visible-property-changed\",\n            SEQUENCE_PROPERTY_CHANGED: \"sequence-property-changed\"\n        };\n    }\n};\n\n/**\n * Constructor (alias)\n */\nGlobeViewExtended.prototype.constructor = GlobeViewExtended;\n\n/**\n * Get GlobeViex Object (parent)\n * @returns {Object} itowns GlobeView object\n */\nGlobeViewExtended.prototype.getGlobeView = function () {\n    return this._globeView;\n};\n\n/**\n * Indicates if the globe is initialized or not\n *\n * @return {Boolean} isInitialized\n *\n */\nGlobeViewExtended.prototype.isInitialized = function () {\n    return this._isInitialized;\n};\n\n/**\n * Detects when the camera movement stops, then launch the callback given as parameter\n *\n * @param {Function} cb - The function to execute when the event occures.\n *\n */\nGlobeViewExtended.prototype.onCameraMoveStop = function (cb) {\n    var self = this;\n    function afterRenderHandler() {\n        self._globeView.removeFrameRequester(self._itowns.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, afterRenderHandler);\n        cb();\n    };\n    this._globeView.addFrameRequester(this._itowns.MAIN_LOOP_EVENTS.AFTER_CAMERA_UPDATE, afterRenderHandler);\n};\n\n/**\n * Disables globe controls until the globe rendering is completed\n */\nGlobeViewExtended.prototype.freezeControl = function () {\n    // disable navigation\n    this._globeView.controls.enabled = false;\n\n    this.onCameraMoveStop(function () {\n        this._globeView.controls.enabled = true;\n    }.bind(this));\n};\n\n/**\n * Associates a function to trigger when an event is received.\n *\n * @param {String} type - the event type. Can be any of {@link EVENTS}\n * @param {Function} callback - The function to execute when the event occures.\n * @return {Object} key - The event key\n *\n */\nGlobeViewExtended.prototype.listen = function (type, callback) {\n    if (typeof callback !== \"function\") {\n        logger.warn(\"no callback provided for event : \" + type);\n        return null;\n    }\n\n    var target = this._getEventTarget(type);\n    if (!target) {\n        return null;\n    }\n\n    if (type === GlobeViewExtended.EVENTS.AFTER_RENDER) {\n        target.addFrameRequester(type, callback);\n    } else {\n        target.addEventListener(type, callback);\n    }\n\n    return {\n        target: target,\n        callback: callback,\n        type: type\n    };\n};\n\n/**\n * Associates a function to trigger when a layer event is received.\n *\n * @param {Object} layer - The itowns layer.\n * @param {String} type - the event type. Can be any of {@link EVENTS}.\n * @param {Function} callback - The function to execute when the event occures.\n * @return {Object} key - The event key\n *\n */\nGlobeViewExtended.prototype.addLayerListener = function (layer, type, callback) {\n    if (typeof callback !== \"function\") {\n        logger.warn(\"no callback provided for event : \" + type);\n        return null;\n    }\n    layer.addEventListener(type, callback);\n    return {\n        target: layer,\n        callback: callback,\n        type: type\n    };\n};\n\n/**\n * Returns the target of a given event type\n *\n * @param {String} type - the event type. Can be any of {@link EVENTS}\n * @return {Object} target - The event target.\n *\n */\nGlobeViewExtended.prototype._getEventTarget = function (type) {\n    switch (type) {\n        case GlobeViewExtended.EVENTS.RANGE_CHANGED:\n        case GlobeViewExtended.EVENTS.CENTER_CHANGED:\n        case GlobeViewExtended.EVENTS.ORIENTATION_CHANGED:\n            return this.getGlobeView().controls;\n        case GlobeViewExtended.EVENTS.LAYER_ADDED:\n        case GlobeViewExtended.EVENTS.LAYER_REMOVED:\n        case GlobeViewExtended.EVENTS.LAYERS_ORDER_CHANGED:\n        case GlobeViewExtended.EVENTS.GLOBE_INITIALIZED:\n        case GlobeViewExtended.EVENTS.PRE_RENDER:\n        case GlobeViewExtended.EVENTS.AFTER_RENDER:\n        case GlobeViewExtended.EVENTS.VIEW_INITIALIZED:\n            return this.getGlobeView();\n        case GlobeViewExtended.EVENTS.MOUSE_MOVE:\n            return this._viewerDiv;\n        default:\n            logger.warn(\"unhandled event : \" + type);\n            return null;\n    }\n};\n\n/**\n * Cancels an event listening\n *\n * @param {Object} key - The event key\n *\n */\nGlobeViewExtended.prototype.forgetByKey = function (key) {\n    if (key.type === GlobeViewExtended.EVENTS.AFTER_RENDER) {\n        key.target.removeFrameRequester(key.type, key.callback);\n    } else {\n        key.target.removeEventListener(key.type, key.callback);\n    }\n};\n\n/**\n * Cancels an layer event listening\n *\n * @param {Object} layer - The itowns layer\n * @param {String} type - the event type\n * @param {Function} callback - The function to execute when the event occures\n *\n */\nGlobeViewExtended.prototype.removeLayerListener = function (layer, type, callback) {\n    this.forgetByKey({\n        target: layer,\n        callback: callback,\n        type: type\n    });\n};\n\n/**\n * Cancels an event listening\n *\n * @param {Object} type - The event type\n * @param {Function} callback - The event handler\n */\nGlobeViewExtended.prototype.forget = function (type, callback) {\n    var target = this._getEventTarget(type);\n    if (!target) return;\n\n    this.forgetByKey({\n        target: target,\n        callback: callback,\n        type: type\n    });\n};\n\n/**\n * Overload itowns.GlobeView addLayer method\n *\n * @param {Object} layer - The itowns layer\n * @return {Promise} promise\n */\nGlobeViewExtended.prototype.addLayer = function (layer) {\n    // FIXME : to delete when itowns commit 2e9ed61eb4aa2a4bbe0e17c8e2650953844b099e\n    // is integrated into an iTowns release \n    try {\n        var promise = this.getGlobeView().addLayer(layer);\n        this.getGlobeView().notifyChange(true);\n    } catch (error) {\n        return Promise.reject(error);\n    }\n\n    return promise;\n};\n\n/**\n * Overload itowns.GlobeView removeLayer method\n *\n * @param {String} layerId - The layer id\n */\nGlobeViewExtended.prototype.removeLayer = function (layerId) {\n    this.getGlobeView().removeLayer(layerId);\n    this.getGlobeView().notifyChange(true);\n};\n\n/**\n * Set layer opacity\n *\n * @param {String} layerId - Layer id\n * @param {Number} opacityValue - opacity value in [0 1]\n */\nGlobeViewExtended.prototype.setLayerOpacity = function (layerId, opacityValue) {\n    this.getColorLayerById(layerId).opacity = opacityValue;\n    this.getGlobeView().notifyChange(true);\n};\n\n/**\n * Set layer visibility\n *\n * @param {String} layerId - Layer id\n * @param {Boolean} visible - New visibility of the layer\n */\nGlobeViewExtended.prototype.setLayerVisibility = function (layerId, visible) {\n    this.getColorLayerById(layerId).visible = visible;\n    this.getGlobeView().notifyChange(true);\n};\n\n/**\n * Move layer to the specified index\n *\n * @param {String} layerId - Layer id\n * @param {Boolean} index - new index of the layer\n */\nGlobeViewExtended.prototype.moveLayerToIndex = function (layerId, index) {\n    this._itowns.ColorLayersOrdering.moveLayerToIndex(this.getGlobeView(), layerId, index);\n    this.getGlobeView().notifyChange(true);\n};\n\n/**\n * Remove event listener from the globe\n *\n * @param {String} type - event type\n * @param {Function} callback - event handler\n */\nGlobeViewExtended.prototype.removeEventListener = function (type, callback) {\n    switch (type) {\n        case \"mousemove\":\n            this._viewerDiv.removeEventListener(type, callback);\n            break;\n        case \"centerchanged\":\n            this.getGlobeView().controls.removeEventListener(type, callback);\n            break;\n        default:\n            this.getGlobeView().removeEventListener(type, callback);\n            break;\n    }\n};\n\n/**\n * Defines if the current view extent have to be computed on pre-render event\n *\n * @param {Boolean} b - tells if the view extent info should be fetched by the event PRE_RENDER\n */\nGlobeViewExtended.prototype.preRenderEventFetchViewExtent = function (b) {\n    if (typeof b === \"undefined\") {\n        b = true;\n    }\n    this._fetchExtent = b;\n};\n\n/**\n * Defines if the list of the color layers displayed have to be computed on pre-render event\n *\n * @param {Boolean} b - tells if the displayed color layers info should be fetched by the event PRE_RENDER\n */\nGlobeViewExtended.prototype.preRenderEventFetchColorLayersDisplayed = function (b) {\n    if (typeof b === \"undefined\") {\n        b = true;\n    }\n    this._fetchVisibleColorLayers = b;\n};\n\n/**\n * Defines if the list of the elevation layers displayed have to be computed on pre-render event\n *\n * @param {Boolean} b - tells if the displayed elevation layers info should be fetched by the event PRE_RENDER\n */\nGlobeViewExtended.prototype.preRenderEventFetchElevationLayersDisplayed = function (b) {\n    if (typeof b === \"undefined\") {\n        b = true;\n    }\n    this._fetchVisibleElevationLayers = b;\n};\n\n/**\n * Defines if the list of the layers of all types displayed have to be computed on pre-render event\n *\n * @param {Boolean} b - tells if both displayed color layers and displayed elevation layers infos should be fetched by the event PRE_RENDER\n */\nGlobeViewExtended.prototype.preRenderEventFetchLayersDisplayed = function (b) {\n    if (typeof b === \"undefined\") {\n        b = true;\n    }\n    this._fetchVisibleColorLayers = b;\n    this._fetchVisibleElevationLayers = b;\n};\n\n/**\n * Get layer by its id\n *\n * @param {String} layerId - Layer id\n * @return {Object} layer Object\n */\nGlobeViewExtended.prototype.getLayerById = function (layerId) {\n    var layer = this.getGlobeView().getLayers(function (l) {\n        if (l.id === layerId) {\n            return l;\n        }\n    })[0];\n    if (!layer) {\n        logger.trace(\"[GlobeViewExtended]  : no Layer found for the id '\" + layerId + \"'\");\n        return;\n    }\n    return layer;\n};\n\n/**\n * Get color layer by its id\n *\n * @param {String} layerId - Color layer id\n * @return {Object} layer Object\n */\nGlobeViewExtended.prototype.getColorLayerById = function (layerId) {\n    var layer = this.getGlobeView().getLayers(function (l) {\n        if (l.id === layerId && l.type === \"color\") {\n            return l;\n        }\n    })[0];\n    if (!layer) {\n        logger.trace(\"[GlobeViewExtended]  : no colorLayer found for the id '\" + layerId + \"'\");\n        return;\n    }\n    return layer;\n};\n\n/**\n * Get imagery layers\n *\n * @return {Array} imagery layers\n */\nGlobeViewExtended.prototype.getColorLayers = function () {\n    return this.getGlobeView().getLayers(function (layer) {\n        if (layer.type === \"color\") {\n            return layer;\n        }\n    });\n};\n\n/**\n * Get vector layers\n *\n * @return {Array} vector layers\n */\nGlobeViewExtended.prototype.getVectorLayers = function () {\n    return this.getGlobeView().getLayers(function (layer) {\n        if (layer.protocol === \"rasterizer\") {\n            return layer;\n        }\n    });\n};\n\n/**\n * Get elevation layers\n *\n * @return {Array} elevation layers\n */\nGlobeViewExtended.prototype.getElevationLayers = function () {\n    return this.getGlobeView().getLayers(function (layer) {\n        if (layer.type === \"elevation\") {\n            return layer;\n        }\n    });\n};\n\n/**\n * Get the current view extent\n *\n * @returns {Array} current view extent\n */\nGlobeViewExtended.prototype.getExtent = function () {\n    var options = {\n        extent: new this._itowns.Extent(\"EPSG:4326\", 180, -180, 90, -90)\n    };\n\n    this._getCurrentSceneInfos(this.scene, options);\n\n    return options.extent;\n};\n\n/**\n * Recursive method to fetch information about the current view (extent, layers displayed...)\n *\n * @param {Object} node - itowns node\n * @param {Object} options - object containing objects to fill with info if specified\n * @private\n */\nGlobeViewExtended.prototype._getCurrentSceneInfos = function (node, options) {\n    if (!node || !node.visible) {\n        return;\n    }\n    if (node.level) {\n        if (node.material.visible) {\n            if (options.colorLayersId) {\n                for (var i = 0; i < node.material.colorLayersId.length; ++i) {\n                    if (options.colorLayersId.indexOf(node.material.colorLayersId[i]) < 0) {\n                        options.colorLayersId.push(node.material.colorLayersId[i]);\n                    }\n                }\n            }\n            if (options.elevationLayersId) {\n                for (var j = 0; j < node.material.elevationLayersId.length; ++j) {\n                    if (options.elevationLayersId.indexOf(node.material.elevationLayersId[j]) < 0) {\n                        options.elevationLayersId.push(node.material.elevationLayersId[j]);\n                    }\n                }\n            }\n            if (options.extent) {\n                options.extent.union(node.extent);\n            }\n        }\n    }\n    if (node.children) {\n        for (var child in node.children) {\n            this._getCurrentSceneInfos(node.children[child], options);\n        }\n    }\n};\n\n/**\n * Add a widget to the globe\n *\n * @param {Object} widget - The Widget object to add\n */\nGlobeViewExtended.prototype.addWidget = function (widget) {\n    if (!widget.getTarget()) {\n        widget.setTarget(this._viewerDiv, \"absolute\");\n    }\n    widget.setGlobe(this);\n    this._widgets.push(widget);\n};\n\n/**\n * Returns all widgets.\n *\n * @return {Array} widgets - The array of widgets.\n */\nGlobeViewExtended.prototype.getWidgets = function () {\n    return this._widgets;\n};\n\n/**\n * Removes a widget.\n *\n * @param {Object} widget - The Widget object to remove\n */\nGlobeViewExtended.prototype.removeWidget = function (widget) {\n    widget.setGlobe();\n    for (var idx = 0; idx < this._widgets.length; idx++) {\n        if (this._widgets[idx] === widget) {\n            this._widgets.splice(idx, 1);\n        }\n    }\n};\n\n/**\n * Get html target element\n *\n * @return {HTMLElement} Globe container element\n */\nGlobeViewExtended.prototype.getTargetElement = function () {\n    return this._viewerDiv;\n};\n\n/**\n * Returns current view scale\n *\n * @return {Number} Scale\n */\nGlobeViewExtended.prototype.getScale = function () {\n    return this.getGlobeView().controls.getScale();\n};\n\n/**\n * Sets tilt\n *\n * @param {Number} tilt - Tilt value\n * @return {Promise} promise\n */\nGlobeViewExtended.prototype.setTilt = function (tilt) {\n    return this.getGlobeView().controls.setTilt(tilt, false);\n};\n\n/**\n * Returns tilt\n *\n * @return {Number} - Tilt\n */\nGlobeViewExtended.prototype.getTilt = function () {\n    return this.getGlobeView().controls.getCameraOrientation()[0];\n};\n\n/**\n * Sets azimuth\n *\n * @param {Number} azimuth - Azimuth value\n * @return {Promise} promise\n */\nGlobeViewExtended.prototype.setAzimuth = function (azimuth) {\n    return this.getGlobeView().controls.setHeading(azimuth, false);\n};\n\n/**\n * Returns azimuth\n *\n * @return {Number} azimuth\n */\nGlobeViewExtended.prototype.getAzimuth = function () {\n    return this.getGlobeView().controls.getCameraOrientation()[1];\n};\n\n/**\n * Gets the coordinate in lat,lon for a given pixel.\n *\n * @param {Number} x - The pixel x-position inside the Globe element.\n * @param {Number} y - The pixel y-position inside the Globe element.\n * @return {Coordinates} position\n */\nGlobeViewExtended.prototype.getCoordinateFromPixel = function (x, y) {\n    return this.getGlobeView().controls.pickGeoPosition({\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Gets the coordinate in lat,lon for a given mouse position.\n *\n * @param {MouseEvent} mouseEvent - A mouse event.\n * @return {Coordinates} position\n */\nGlobeViewExtended.prototype.getCoordinateFromMouseEvent = function (mouseEvent) {\n    var coords = this.getGlobeView().eventToViewCoords(mouseEvent);\n    return this.getGlobeView().controls.pickGeoPosition(coords);\n};\n\n/**\n * Get all visible features that intersect a pixel\n *\n * @param {MouseEvent} mouseEvent - A mouse event.\n * @return {Array} visibleFeatures - The array of visible features.\n */\nGlobeViewExtended.prototype.getFeaturesAtMousePosition = function (mouseEvent) {\n    var vectorLayers = this.getVectorLayers();\n    if (!vectorLayers) {\n        return;\n    }\n    // array of the visible features on the clicker coord\n    var visibleFeatures = [];\n    var geoCoord = this.getCoordinateFromMouseEvent(mouseEvent);\n    if (geoCoord) {\n        // buffer around the click inside we retrieve the features\n        var precision = this.getGlobeView().controls.pixelsToDegrees(5);\n        for (var i = 0; i < vectorLayers.length; i++) {\n            var idx;\n            var layer = vectorLayers[i];\n            // if the layer is not visible, we ignore it\n            if (!layer.visible) {\n                continue;\n            }\n            var result = this._itowns.FeaturesUtils.filterFeaturesUnderCoordinate(geoCoord, layer.feature, precision);\n            // we add the features to the visible features array\n            for (idx = 0; idx < result.length; idx++) {\n                visibleFeatures.push(result[idx]);\n            }\n        }\n    }\n    return visibleFeatures;\n};\n\n/**\n * Changes the center of the scene on screen to the specified in lat, lon.\n *\n * @param {Object} center - Center object\n * @param {Number} center.longitude - Coordinate longitude WGS84 in degree\n * @param {Number} center.latitude - Coordinate latitude WGS84 in degree\n * @return {Promise} A promise that resolves when the next 'globe initilazed' event fires.\n */\nGlobeViewExtended.prototype.setCameraTargetGeoPosition = function (center) {\n    return this.getGlobeView().controls.setCameraTargetGeoPositionAdvanced(center, false);\n};\n\n/**\n * Retuns the coordinates of the central point on screen in lat,lon and alt\n *\n * @return {Object} center\n */\nGlobeViewExtended.prototype.getCenter = function () {\n    var cameraCenter = this.getGlobeView().controls.getCameraTargetGeoPosition();\n    var center = {\n        lon: cameraCenter.longitude(),\n        lat: cameraCenter.latitude(),\n        alt: cameraCenter.altitude()\n    };\n    return center;\n};\n\n/**\n * Returns the actual zoom.\n *\n * @return {Number} zoom\n */\nGlobeViewExtended.prototype.getZoom = function () {\n    return this.getGlobeView().controls.getZoom();\n};\n\n/**\n * Sets the current zoom.\n *\n * @param {Number} zoom - The zoom\n * @return {Promise} promise\n */\nGlobeViewExtended.prototype.setZoom = function (zoom) {\n    return this.getGlobeView().controls.setZoom(zoom, false);\n};\n\n/**\n * To convert the projection in meters on the globe of a number of pixels of screen\n * @param {Number} pixels - count pixels to project\n * @return {Number} projection in meters on globe\n */\nGlobeViewExtended.prototype.pixelsToMeters = function (pixels) {\n    return this.getGlobeView().controls.pixelsToMeters(pixels);\n};\n\n/**\n * Projection on screen in pixels of length in meter on globe\n * @param {Number} value - Length in meter on globe\n * @return {Number} projection in pixels on screen\n */\nGlobeViewExtended.prototype.metersToPixels = function (value) {\n    return this.getGlobeView().controls.metersToPixels(value);\n};\n\n/**\n * Returns the \"range\": the distance in meters between the camera and the current central point on the screen.\n * @return {Number} number\n */\nGlobeViewExtended.prototype.getRange = function () {\n    return this.getGlobeView().controls.getRange();\n};\n\n/**\n * @return {THREE.Vector3} position\n */\nGlobeViewExtended.prototype.moveTarget = function () {\n    return this.getGlobeView().controls.moveTarget();\n};\n\n/**\n * To get the layer event infos\n *\n * @param {Object} evt - event\n * @returns {Object} object with event properties\n */\nGlobeViewExtended.prototype.getLayerEventInfos = function (evt) {\n    var propertyName = evt.type.replace(\"-property-changed\", \"\");\n    return {\n        propertyName: propertyName,\n        previousValue: evt.previous[propertyName],\n        newValue: evt.new[propertyName]\n    };\n};\n\n/**\n * Sets background (specific to miniglobe)\n */\nGlobeViewExtended.prototype.setBackground = function () {\n    // Set a 0 alpha clear value (instead of the default '1')\n    // because we want a transparent background for the miniglobe view to be able\n    // to see the main view \"behind\"\n    this.getGlobeView().mainLoop.gfxEngine.renderer.setClearColor(0x000000, 0);\n};\n\n/**\n * Sets camera position\n * @param {THREE.Vector3} target - Target position\n * @param {Number} distance - Distance from target\n */\nGlobeViewExtended.prototype.setCameraPosition = function (target, distance) {\n    this.getGlobeView().camera.camera3D.position.copy(target).setLength(distance);\n};\n\n/**\n * Sets camera orientation to look at specified target\n * @param {THREE.Vector3} target - Target position\n */\nGlobeViewExtended.prototype.lookAt = function (target) {\n    this.getGlobeView().camera.camera3D.lookAt(target);\n};\n\n/**\n * Notifies the scene it needs to be updated\n */\nGlobeViewExtended.prototype.notifyChange = function () {\n    this.getGlobeView().notifyChange(true);\n};\n\n/**\n* Resizes itowns\n*\n* @param {Integer} width - canvas width in pixels\n* @param {Integer} height - canvas height in pixels\n*/\nGlobeViewExtended.prototype.resize = function (width, height) {\n    this.getGlobeView().mainLoop.gfxEngine.onWindowResize(width, height);\n    this.getGlobeView().notifyChange(true);\n};\n\nexports.default = GlobeViewExtended;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0dsb2JlVmlld0V4dGVuZGVkLmpzPzIwNjgiXSwibmFtZXMiOlsiSXRvd25zIiwibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiR2xvYmVWaWV3RXh0ZW5kZWQiLCJ2aWV3ZXJEaXYiLCJjb29yZENhcnRvIiwib3B0aW9ucyIsInN0eWxlIiwicG9zaXRpb24iLCJfaXRvd25zIiwiX3ZpZXdlckRpdiIsIl93aWRnZXRzIiwiX2luaXRFdmVudE1hcCIsIl9pc0luaXRpYWxpemVkIiwiX2dsb2JlVmlldyIsIkdsb2JlVmlldyIsInNlbGYiLCJsaXN0ZW4iLCJFVkVOVFMiLCJHTE9CRV9JTklUSUFMSVpFRCIsImFkZEZyYW1lUmVxdWVzdGVyIiwiTUFJTl9MT09QX0VWRU5UUyIsIkJFRk9SRV9SRU5ERVIiLCJjbGVhclRpbWVvdXQiLCJfcHJlUmVuZGVyVGltZXIiLCJzZXRUaW1lb3V0IiwiX2ZldGNoVmlzaWJsZUNvbG9yTGF5ZXJzIiwiX2ZldGNoVmlzaWJsZUVsZXZhdGlvbkxheWVycyIsIl9mZXRjaEV4dGVudCIsImV2ZW50IiwidHlwZSIsIlBSRV9SRU5ERVIiLCJleHRlbnQiLCJFeHRlbnQiLCJjb2xvckxheWVyc0lkIiwiZWxldmF0aW9uTGF5ZXJzSWQiLCJfZ2V0Q3VycmVudFNjZW5lSW5mb3MiLCJzY2VuZSIsImRpc3BhdGNoRXZlbnQiLCJiaW5kIiwiY29udHJvbHMiLCJmcmVlemVDb250cm9sIiwicHJvdG90eXBlIiwiUkFOR0VfQ0hBTkdFRCIsIkNPTlRST0xfRVZFTlRTIiwiQ0VOVEVSX0NIQU5HRUQiLCJDQU1FUkFfVEFSR0VUX0NIQU5HRUQiLCJPUklFTlRBVElPTl9DSEFOR0VEIiwiTEFZRVJfQURERUQiLCJHTE9CRV9WSUVXX0VWRU5UUyIsIkxBWUVSX1JFTU9WRUQiLCJMQVlFUlNfT1JERVJfQ0hBTkdFRCIsIkNPTE9SX0xBWUVSU19PUkRFUl9DSEFOR0VEIiwiVklFV19JTklUSUFMSVpFRCIsIk1PVVNFX01PVkUiLCJBRlRFUl9SRU5ERVIiLCJPUEFDSVRZX1BST1BFUlRZX0NIQU5HRUQiLCJWSVNJQkxFX1BST1BFUlRZX0NIQU5HRUQiLCJTRVFVRU5DRV9QUk9QRVJUWV9DSEFOR0VEIiwiY29uc3RydWN0b3IiLCJnZXRHbG9iZVZpZXciLCJpc0luaXRpYWxpemVkIiwib25DYW1lcmFNb3ZlU3RvcCIsImNiIiwiYWZ0ZXJSZW5kZXJIYW5kbGVyIiwicmVtb3ZlRnJhbWVSZXF1ZXN0ZXIiLCJBRlRFUl9DQU1FUkFfVVBEQVRFIiwiZW5hYmxlZCIsImNhbGxiYWNrIiwid2FybiIsInRhcmdldCIsIl9nZXRFdmVudFRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhZGRMYXllckxpc3RlbmVyIiwibGF5ZXIiLCJmb3JnZXRCeUtleSIsImtleSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMYXllckxpc3RlbmVyIiwiZm9yZ2V0IiwiYWRkTGF5ZXIiLCJwcm9taXNlIiwibm90aWZ5Q2hhbmdlIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVtb3ZlTGF5ZXIiLCJsYXllcklkIiwic2V0TGF5ZXJPcGFjaXR5Iiwib3BhY2l0eVZhbHVlIiwiZ2V0Q29sb3JMYXllckJ5SWQiLCJvcGFjaXR5Iiwic2V0TGF5ZXJWaXNpYmlsaXR5IiwidmlzaWJsZSIsIm1vdmVMYXllclRvSW5kZXgiLCJpbmRleCIsIkNvbG9yTGF5ZXJzT3JkZXJpbmciLCJwcmVSZW5kZXJFdmVudEZldGNoVmlld0V4dGVudCIsImIiLCJwcmVSZW5kZXJFdmVudEZldGNoQ29sb3JMYXllcnNEaXNwbGF5ZWQiLCJwcmVSZW5kZXJFdmVudEZldGNoRWxldmF0aW9uTGF5ZXJzRGlzcGxheWVkIiwicHJlUmVuZGVyRXZlbnRGZXRjaExheWVyc0Rpc3BsYXllZCIsImdldExheWVyQnlJZCIsImdldExheWVycyIsImwiLCJpZCIsInRyYWNlIiwiZ2V0Q29sb3JMYXllcnMiLCJnZXRWZWN0b3JMYXllcnMiLCJwcm90b2NvbCIsImdldEVsZXZhdGlvbkxheWVycyIsImdldEV4dGVudCIsIm5vZGUiLCJsZXZlbCIsIm1hdGVyaWFsIiwiaSIsImxlbmd0aCIsImluZGV4T2YiLCJwdXNoIiwiaiIsInVuaW9uIiwiY2hpbGRyZW4iLCJjaGlsZCIsImFkZFdpZGdldCIsIndpZGdldCIsImdldFRhcmdldCIsInNldFRhcmdldCIsInNldEdsb2JlIiwiZ2V0V2lkZ2V0cyIsInJlbW92ZVdpZGdldCIsImlkeCIsInNwbGljZSIsImdldFRhcmdldEVsZW1lbnQiLCJnZXRTY2FsZSIsInNldFRpbHQiLCJ0aWx0IiwiZ2V0VGlsdCIsImdldENhbWVyYU9yaWVudGF0aW9uIiwic2V0QXppbXV0aCIsImF6aW11dGgiLCJzZXRIZWFkaW5nIiwiZ2V0QXppbXV0aCIsImdldENvb3JkaW5hdGVGcm9tUGl4ZWwiLCJ4IiwieSIsInBpY2tHZW9Qb3NpdGlvbiIsImdldENvb3JkaW5hdGVGcm9tTW91c2VFdmVudCIsIm1vdXNlRXZlbnQiLCJjb29yZHMiLCJldmVudFRvVmlld0Nvb3JkcyIsImdldEZlYXR1cmVzQXRNb3VzZVBvc2l0aW9uIiwidmVjdG9yTGF5ZXJzIiwidmlzaWJsZUZlYXR1cmVzIiwiZ2VvQ29vcmQiLCJwcmVjaXNpb24iLCJwaXhlbHNUb0RlZ3JlZXMiLCJyZXN1bHQiLCJGZWF0dXJlc1V0aWxzIiwiZmlsdGVyRmVhdHVyZXNVbmRlckNvb3JkaW5hdGUiLCJmZWF0dXJlIiwic2V0Q2FtZXJhVGFyZ2V0R2VvUG9zaXRpb24iLCJjZW50ZXIiLCJzZXRDYW1lcmFUYXJnZXRHZW9Qb3NpdGlvbkFkdmFuY2VkIiwiZ2V0Q2VudGVyIiwiY2FtZXJhQ2VudGVyIiwiZ2V0Q2FtZXJhVGFyZ2V0R2VvUG9zaXRpb24iLCJsb24iLCJsb25naXR1ZGUiLCJsYXQiLCJsYXRpdHVkZSIsImFsdCIsImFsdGl0dWRlIiwiZ2V0Wm9vbSIsInNldFpvb20iLCJ6b29tIiwicGl4ZWxzVG9NZXRlcnMiLCJwaXhlbHMiLCJtZXRlcnNUb1BpeGVscyIsInZhbHVlIiwiZ2V0UmFuZ2UiLCJtb3ZlVGFyZ2V0IiwiZ2V0TGF5ZXJFdmVudEluZm9zIiwiZXZ0IiwicHJvcGVydHlOYW1lIiwicmVwbGFjZSIsInByZXZpb3VzVmFsdWUiLCJwcmV2aW91cyIsIm5ld1ZhbHVlIiwibmV3Iiwic2V0QmFja2dyb3VuZCIsIm1haW5Mb29wIiwiZ2Z4RW5naW5lIiwicmVuZGVyZXIiLCJzZXRDbGVhckNvbG9yIiwic2V0Q2FtZXJhUG9zaXRpb24iLCJkaXN0YW5jZSIsImNhbWVyYSIsImNhbWVyYTNEIiwiY29weSIsInNldExlbmd0aCIsImxvb2tBdCIsInJlc2l6ZSIsIndpZHRoIiwiaGVpZ2h0Iiwib25XaW5kb3dSZXNpemUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7O0lBQVlBLE07Ozs7OztBQUVaLElBQUlDLFNBQVNDLDBCQUFPQyxTQUFQLENBQWlCLG1CQUFqQixDQUFiOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFTQyxpQkFBVCxDQUE0QkMsU0FBNUIsRUFBdUNDLFVBQXZDLEVBQW1EQyxPQUFuRCxFQUE0RDtBQUN4REYsY0FBVUcsS0FBVixDQUFnQkMsUUFBaEIsR0FBNEIsQ0FBQ0YsT0FBRCxJQUFZLENBQUNBLFFBQVFFLFFBQXRCLEdBQWtDLFVBQWxDLEdBQStDRixRQUFRRSxRQUFsRjs7QUFFQSxTQUFLQyxPQUFMLEdBQWVWLE1BQWY7O0FBRUE7QUFDQSxTQUFLVyxVQUFMLEdBQWtCTixTQUFsQjs7QUFFQTtBQUNBLFNBQUtPLFFBQUwsR0FBZ0IsRUFBaEI7O0FBRUE7QUFDQSxTQUFLQyxhQUFMOztBQUVBO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixLQUF0Qjs7QUFFQTtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsSUFBSSxLQUFLTCxPQUFMLENBQWFNLFNBQWpCLENBQTJCWCxTQUEzQixFQUFzQ0MsVUFBdEMsRUFBa0RDLE9BQWxELENBQWxCOztBQUVBLFFBQUlVLE9BQU8sSUFBWDtBQUNBLFNBQUtDLE1BQUwsQ0FBWWQsa0JBQWtCZSxNQUFsQixD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b0JzQixZQUFwQixDQUFpQyxJQUFqQztBQUNILENBRkQ7O0FBSUE7Ozs7OztBQU1BL0Usa0JBQWtCdUMsU0FBbEIsQ0FBNEIrSixNQUE1QixHQUFxQyxVQUFVQyxLQUFWLEVBQWlCQyxNQUFqQixFQUF5QjtBQUMxRCxTQUFLL0ksWUFBTCxHQUFvQmtJLFFBQXBCLENBQTZCQyxTQUE3QixDQUF1Q2EsY0FBdkMsQ0FBc0RGLEtBQXRELEVBQTZEQyxNQUE3RDtBQUNBLFNBQUsvSSxZQUFMLEdBQW9Cc0IsWUFBcEIsQ0FBaUMsSUFBakM7QUFDSCxDQUhEOztrQkFLZS9FLGlCIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgKiBhcyBJdG93bnMgZnJvbSBcIml0b3duc1wiO1xuXG52YXIgbG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcIkdsb2JlVmlld0V4dGVuZGVkXCIpO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBFeHRlbmRlZCBpdG93bnMuR2xvYmVWaWV3LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge2l0b3ducy5HbG9iZVZpZXd9XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB2aWV3ZXJEaXYgLSBXaGVyZSB0byBpbnN0YW5jaWF0ZSB0aGUgVGhyZWUuanMgc2NlbmUgaW4gdGhlIERPTVxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkQ2FydG8gLSBsb25naXR1ZGUsIGxhdGl0dWRlLCBhbHRpdHVkZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucG9zaXRpb249XCJyZWxhdGl2ZVwiXSAtIFwiYWJzb2x1dGVcIiBvciBcInJlbGF0aXZlXCJcbiAqL1xuZnVuY3Rpb24gR2xvYmVWaWV3RXh0ZW5kZWQgKHZpZXdlckRpdiwgY29vcmRDYXJ0bywgb3B0aW9ucykge1xuICAgIHZpZXdlckRpdi5zdHlsZS5wb3NpdGlvbiA9ICghb3B0aW9ucyB8fCAhb3B0aW9ucy5wb3NpdGlvbikgPyBcInJlbGF0aXZlXCIgOiBvcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgdGhpcy5faXRvd25zID0gSXRvd25zO1xuXG4gICAgLy8gc3RvY2thZ2UgZGUgbCfDqWzDqW1lbnQgaHRtbCBwb3J0ZXVyIGR1IGdsb2JlXG4gICAgdGhpcy5fdmlld2VyRGl2ID0gdmlld2VyRGl2O1xuXG4gICAgLy8gd2lkZ2V0IGNvbnRhaW5lclxuICAgIHRoaXMuX3dpZGdldHMgPSBbXTtcblxuICAgIC8vIG1hcHBpbmcgZGVzIGV2ZW5lbWVudHNcbiAgICB0aGlzLl9pbml0RXZlbnRNYXAoKTtcblxuICAgIC8vIHBvdXIgc2F2b2lyIHNpIGxlIGdsb2JlIGVzdCBpbml0aWFsaXNlXG4gICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gY2FsbCBjb25zdHJ1Y3RvclxuICAgIHRoaXMuX2dsb2JlVmlldyA9IG5ldyB0aGlzLl9pdG93bnMuR2xvYmVWaWV3KHZpZXdlckRpdiwgY29vcmRDYXJ0bywgb3B0aW9ucyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkdMT0JFX0lOSVRJQUxJWkVELCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZ2xvYmVWaWV3LmFkZEZyYW1lUmVxdWVzdGVyKHRoaXMuX2l0b3ducy5NQUlOX0xPT1BfRVZFTlRTLkJFRk9SRV9SRU5ERVIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByZVJlbmRlclRpbWVyKTtcbiAgICAgICAgc2VsZi5fcHJlUmVuZGVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9mZXRjaFZpc2libGVDb2xvckxheWVycyB8fCBzZWxmLl9mZXRjaFZpc2libGVFbGV2YXRpb25MYXllcnMgfHwgc2VsZi5fZmV0Y2hFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgOiBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuUFJFX1JFTkRFUlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2ZldGNoRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmV4dGVudCA9IG5ldyBzZWxmLl9pdG93bnMuRXh0ZW50KFwiRVBTRzo0MzI2XCIsIDE4MCwgLTE4MCwgOTAsIC05MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9mZXRjaFZpc2libGVDb2xvckxheWVycykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5jb2xvckxheWVyc0lkID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9mZXRjaFZpc2libGVFbGV2YXRpb25MYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZWxldmF0aW9uTGF5ZXJzSWQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLl9nZXRDdXJyZW50U2NlbmVJbmZvcyhzZWxmLl9nbG9iZVZpZXcuc2NlbmUsIGV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHNlbGYuX2dsb2JlVmlldy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKHRoaXMuX2dsb2JlVmlldy5jb250cm9scykge1xuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRyb2woKTtcbiAgICB9XG59XG5cbi8qKlxuICogaW50aWFsaXplcyB0aGUgZXZlbmVtZW50cyBtYXBcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLl9pbml0RXZlbnRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMpIHtcbiAgICAgICAgR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTID0ge1xuICAgICAgICAgICAgUkFOR0VfQ0hBTkdFRCA6IHRoaXMuX2l0b3ducy5DT05UUk9MX0VWRU5UUy5SQU5HRV9DSEFOR0VELFxuICAgICAgICAgICAgQ0VOVEVSX0NIQU5HRUQgOiB0aGlzLl9pdG93bnMuQ09OVFJPTF9FVkVOVFMuQ0FNRVJBX1RBUkdFVF9DSEFOR0VELFxuICAgICAgICAgICAgT1JJRU5UQVRJT05fQ0hBTkdFRCA6IHRoaXMuX2l0b3ducy5DT05UUk9MX0VWRU5UUy5PUklFTlRBVElPTl9DSEFOR0VELFxuICAgICAgICAgICAgTEFZRVJfQURERUQgOiB0aGlzLl9pdG93bnMuR0xPQkVfVklFV19FVkVOVFMuTEFZRVJfQURERUQsXG4gICAgICAgICAgICBMQVlFUl9SRU1PVkVEIDogdGhpcy5faXRvd25zLkdMT0JFX1ZJRVdfRVZFTlRTLkxBWUVSX1JFTU9WRUQsXG4gICAgICAgICAgICBMQVlFUlNfT1JERVJfQ0hBTkdFRCA6IHRoaXMuX2l0b3ducy5HTE9CRV9WSUVXX0VWRU5UUy5DT0xPUl9MQVlFUlNfT1JERVJfQ0hBTkdFRCxcbiAgICAgICAgICAgIEdMT0JFX0lOSVRJQUxJWkVEIDogdGhpcy5faXRvd25zLkdMT0JFX1ZJRVdfRVZFTlRTLkdMT0JFX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgVklFV19JTklUSUFMSVpFRCA6IFwidmlld2luaXRpYWxpemVkXCIsXG4gICAgICAgICAgICBQUkVfUkVOREVSIDogXCJwcmVyZW5kZXJcIixcbiAgICAgICAgICAgIE1PVVNFX01PVkUgOiBcIm1vdXNlbW92ZVwiLFxuICAgICAgICAgICAgQUZURVJfUkVOREVSIDogdGhpcy5faXRvd25zLk1BSU5fTE9PUF9FVkVOVFMuQUZURVJfUkVOREVSLFxuICAgICAgICAgICAgT1BBQ0lUWV9QUk9QRVJUWV9DSEFOR0VEIDogXCJvcGFjaXR5LXByb3BlcnR5LWNoYW5nZWRcIixcbiAgICAgICAgICAgIFZJU0lCTEVfUFJPUEVSVFlfQ0hBTkdFRCA6IFwidmlzaWJsZS1wcm9wZXJ0eS1jaGFuZ2VkXCIsXG4gICAgICAgICAgICBTRVFVRU5DRV9QUk9QRVJUWV9DSEFOR0VEIDogXCJzZXF1ZW5jZS1wcm9wZXJ0eS1jaGFuZ2VkXCJcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIChhbGlhcylcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2xvYmVWaWV3RXh0ZW5kZWQ7XG5cbi8qKlxuICogR2V0IEdsb2JlVmlleCBPYmplY3QgKHBhcmVudClcbiAqIEByZXR1cm5zIHtPYmplY3R9IGl0b3ducyBHbG9iZVZpZXcgb2JqZWN0XG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRHbG9iZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsb2JlVmlldztcbn07XG5cbi8qKlxuICogSW5kaWNhdGVzIGlmIHRoZSBnbG9iZSBpcyBpbml0aWFsaXplZCBvciBub3RcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBpc0luaXRpYWxpemVkXG4gKlxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuaXNJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyB3aGVuIHRoZSBjYW1lcmEgbW92ZW1lbnQgc3RvcHMsIHRoZW4gbGF1bmNoIHRoZSBjYWxsYmFjayBnaXZlbiBhcyBwYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IG9jY3VyZXMuXG4gKlxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUub25DYW1lcmFNb3ZlU3RvcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBhZnRlclJlbmRlckhhbmRsZXIgKCkge1xuICAgICAgICBzZWxmLl9nbG9iZVZpZXcucmVtb3ZlRnJhbWVSZXF1ZXN0ZXIoc2VsZi5faXRvd25zLk1BSU5fTE9PUF9FVkVOVFMuQUZURVJfQ0FNRVJBX1VQREFURSwgYWZ0ZXJSZW5kZXJIYW5kbGVyKTtcbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHRoaXMuX2dsb2JlVmlldy5hZGRGcmFtZVJlcXVlc3Rlcih0aGlzLl9pdG93bnMuTUFJTl9MT09QX0VWRU5UUy5BRlRFUl9DQU1FUkFfVVBEQVRFLCBhZnRlclJlbmRlckhhbmRsZXIpO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlcyBnbG9iZSBjb250cm9scyB1bnRpbCB0aGUgZ2xvYmUgcmVuZGVyaW5nIGlzIGNvbXBsZXRlZFxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZnJlZXplQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkaXNhYmxlIG5hdmlnYXRpb25cbiAgICB0aGlzLl9nbG9iZVZpZXcuY29udHJvbHMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5vbkNhbWVyYU1vdmVTdG9wKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmVWaWV3LmNvbnRyb2xzLmVuYWJsZWQgPSB0cnVlO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFzc29jaWF0ZXMgYSBmdW5jdGlvbiB0byB0cmlnZ2VyIHdoZW4gYW4gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB0aGUgZXZlbnQgdHlwZS4gQ2FuIGJlIGFueSBvZiB7QGxpbmsgRVZFTlRTfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBvY2N1cmVzLlxuICogQHJldHVybiB7T2JqZWN0fSBrZXkgLSBUaGUgZXZlbnQga2V5XG4gKlxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiAoY2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJubyBjYWxsYmFjayBwcm92aWRlZCBmb3IgZXZlbnQgOiBcIiArIHR5cGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fZ2V0RXZlbnRUYXJnZXQodHlwZSk7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5BRlRFUl9SRU5ERVIpIHtcbiAgICAgICAgdGFyZ2V0LmFkZEZyYW1lUmVxdWVzdGVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0IDogdGFyZ2V0LFxuICAgICAgICBjYWxsYmFjayA6IGNhbGxiYWNrLFxuICAgICAgICB0eXBlIDogdHlwZVxuICAgIH07XG59O1xuXG4vKipcbiAqIEFzc29jaWF0ZXMgYSBmdW5jdGlvbiB0byB0cmlnZ2VyIHdoZW4gYSBsYXllciBldmVudCBpcyByZWNlaXZlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBUaGUgaXRvd25zIGxheWVyLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB0aGUgZXZlbnQgdHlwZS4gQ2FuIGJlIGFueSBvZiB7QGxpbmsgRVZFTlRTfS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJlcy5cbiAqIEByZXR1cm4ge09iamVjdH0ga2V5IC0gVGhlIGV2ZW50IGtleVxuICpcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmFkZExheWVyTGlzdGVuZXIgPSBmdW5jdGlvbiAobGF5ZXIsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiAoY2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJubyBjYWxsYmFjayBwcm92aWRlZCBmb3IgZXZlbnQgOiBcIiArIHR5cGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0IDogbGF5ZXIsXG4gICAgICAgIGNhbGxiYWNrIDogY2FsbGJhY2ssXG4gICAgICAgIHR5cGUgOiB0eXBlXG4gICAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQgdHlwZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gdGhlIGV2ZW50IHR5cGUuIENhbiBiZSBhbnkgb2Yge0BsaW5rIEVWRU5UU31cbiAqIEByZXR1cm4ge09iamVjdH0gdGFyZ2V0IC0gVGhlIGV2ZW50IHRhcmdldC5cbiAqXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5fZ2V0RXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5SQU5HRV9DSEFOR0VEOlxuICAgICAgICBjYXNlIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5DRU5URVJfQ0hBTkdFRDpcbiAgICAgICAgY2FzZSBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuT1JJRU5UQVRJT05fQ0hBTkdFRDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JlVmlldygpLmNvbnRyb2xzO1xuICAgICAgICBjYXNlIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5MQVlFUl9BRERFRDpcbiAgICAgICAgY2FzZSBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTEFZRVJfUkVNT1ZFRDpcbiAgICAgICAgY2FzZSBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTEFZRVJTX09SREVSX0NIQU5HRUQ6XG4gICAgICAgIGNhc2UgR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkdMT0JFX0lOSVRJQUxJWkVEOlxuICAgICAgICBjYXNlIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5QUkVfUkVOREVSOlxuICAgICAgICBjYXNlIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5BRlRFUl9SRU5ERVI6XG4gICAgICAgIGNhc2UgR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLlZJRVdfSU5JVElBTElaRUQ6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRHbG9iZVZpZXcoKTtcbiAgICAgICAgY2FzZSBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTU9VU0VfTU9WRTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3ZXJEaXY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIud2FybihcInVuaGFuZGxlZCBldmVudCA6IFwiICsgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENhbmNlbHMgYW4gZXZlbnQgbGlzdGVuaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSAtIFRoZSBldmVudCBrZXlcbiAqXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5mb3JnZXRCeUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5LnR5cGUgPT09IEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5BRlRFUl9SRU5ERVIpIHtcbiAgICAgICAga2V5LnRhcmdldC5yZW1vdmVGcmFtZVJlcXVlc3RlcihrZXkudHlwZSwga2V5LmNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXkudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LnR5cGUsIGtleS5jYWxsYmFjayk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIGFuIGxheWVyIGV2ZW50IGxpc3RlbmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIFRoZSBpdG93bnMgbGF5ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gdGhlIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgb2NjdXJlc1xuICpcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnJlbW92ZUxheWVyTGlzdGVuZXIgPSBmdW5jdGlvbiAobGF5ZXIsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5mb3JnZXRCeUtleSh7XG4gICAgICAgIHRhcmdldCA6IGxheWVyLFxuICAgICAgICBjYWxsYmFjayA6IGNhbGxiYWNrLFxuICAgICAgICB0eXBlIDogdHlwZVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYW5jZWxzIGFuIGV2ZW50IGxpc3RlbmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlIC0gVGhlIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGV2ZW50IGhhbmRsZXJcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmZvcmdldCA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl9nZXRFdmVudFRhcmdldCh0eXBlKTtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuXG4gICAgdGhpcy5mb3JnZXRCeUtleSh7XG4gICAgICAgIHRhcmdldCA6IHRhcmdldCxcbiAgICAgICAgY2FsbGJhY2sgOiBjYWxsYmFjayxcbiAgICAgICAgdHlwZSA6IHR5cGVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWQgaXRvd25zLkdsb2JlVmlldyBhZGRMYXllciBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBUaGUgaXRvd25zIGxheWVyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIC8vIEZJWE1FIDogdG8gZGVsZXRlIHdoZW4gaXRvd25zIGNvbW1pdCAyZTllZDYxZWI0YWEyYTRiYmUwZTE3YzhlMjY1MDk1Mzg0NGIwOTllXG4gICAgLy8gaXMgaW50ZWdyYXRlZCBpbnRvIGFuIGlUb3ducyByZWxlYXNlIFxuICAgIHRyeSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5nZXRHbG9iZVZpZXcoKS5hZGRMYXllcihsYXllcik7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkIGl0b3ducy5HbG9iZVZpZXcgcmVtb3ZlTGF5ZXIgbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBUaGUgbGF5ZXIgaWRcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKGxheWVySWQpIHtcbiAgICB0aGlzLmdldEdsb2JlVmlldygpLnJlbW92ZUxheWVyKGxheWVySWQpO1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xufTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgb3BhY2l0eVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gTGF5ZXIgaWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcGFjaXR5VmFsdWUgLSBvcGFjaXR5IHZhbHVlIGluIFswIDFdXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5zZXRMYXllck9wYWNpdHkgPSBmdW5jdGlvbiAobGF5ZXJJZCwgb3BhY2l0eVZhbHVlKSB7XG4gICAgdGhpcy5nZXRDb2xvckxheWVyQnlJZChsYXllcklkKS5vcGFjaXR5ID0gb3BhY2l0eVZhbHVlO1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xufTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgdmlzaWJpbGl0eVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gTGF5ZXIgaWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIE5ldyB2aXNpYmlsaXR5IG9mIHRoZSBsYXllclxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuc2V0TGF5ZXJWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKGxheWVySWQsIHZpc2libGUpIHtcbiAgICB0aGlzLmdldENvbG9yTGF5ZXJCeUlkKGxheWVySWQpLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xufTtcblxuLyoqXG4gKiBNb3ZlIGxheWVyIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIExheWVyIGlkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluZGV4IC0gbmV3IGluZGV4IG9mIHRoZSBsYXllclxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUubW92ZUxheWVyVG9JbmRleCA9IGZ1bmN0aW9uIChsYXllcklkLCBpbmRleCkge1xuICAgIHRoaXMuX2l0b3ducy5Db2xvckxheWVyc09yZGVyaW5nLm1vdmVMYXllclRvSW5kZXgodGhpcy5nZXRHbG9iZVZpZXcoKSwgbGF5ZXJJZCwgaW5kZXgpO1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgZ2xvYmVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXZlbnQgaGFuZGxlclxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgICAgICB0aGlzLl92aWV3ZXJEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNlbnRlcmNoYW5nZWRcIjpcbiAgICAgICAgICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIERlZmluZXMgaWYgdGhlIGN1cnJlbnQgdmlldyBleHRlbnQgaGF2ZSB0byBiZSBjb21wdXRlZCBvbiBwcmUtcmVuZGVyIGV2ZW50XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBiIC0gdGVsbHMgaWYgdGhlIHZpZXcgZXh0ZW50IGluZm8gc2hvdWxkIGJlIGZldGNoZWQgYnkgdGhlIGV2ZW50IFBSRV9SRU5ERVJcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnByZVJlbmRlckV2ZW50RmV0Y2hWaWV3RXh0ZW50ID0gZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2ZldGNoRXh0ZW50ID0gYjtcbn07XG5cbi8qKlxuICogRGVmaW5lcyBpZiB0aGUgbGlzdCBvZiB0aGUgY29sb3IgbGF5ZXJzIGRpc3BsYXllZCBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uIHByZS1yZW5kZXIgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGIgLSB0ZWxscyBpZiB0aGUgZGlzcGxheWVkIGNvbG9yIGxheWVycyBpbmZvIHNob3VsZCBiZSBmZXRjaGVkIGJ5IHRoZSBldmVudCBQUkVfUkVOREVSXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5wcmVSZW5kZXJFdmVudEZldGNoQ29sb3JMYXllcnNEaXNwbGF5ZWQgPSBmdW5jdGlvbiAoYikge1xuICAgIGlmICh0eXBlb2YgYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBiID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fZmV0Y2hWaXNpYmxlQ29sb3JMYXllcnMgPSBiO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGlmIHRoZSBsaXN0IG9mIHRoZSBlbGV2YXRpb24gbGF5ZXJzIGRpc3BsYXllZCBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uIHByZS1yZW5kZXIgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGIgLSB0ZWxscyBpZiB0aGUgZGlzcGxheWVkIGVsZXZhdGlvbiBsYXllcnMgaW5mbyBzaG91bGQgYmUgZmV0Y2hlZCBieSB0aGUgZXZlbnQgUFJFX1JFTkRFUlxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUucHJlUmVuZGVyRXZlbnRGZXRjaEVsZXZhdGlvbkxheWVyc0Rpc3BsYXllZCA9IGZ1bmN0aW9uIChiKSB7XG4gICAgaWYgKHR5cGVvZiBiID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGIgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9mZXRjaFZpc2libGVFbGV2YXRpb25MYXllcnMgPSBiO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGlmIHRoZSBsaXN0IG9mIHRoZSBsYXllcnMgb2YgYWxsIHR5cGVzIGRpc3BsYXllZCBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uIHByZS1yZW5kZXIgZXZlbnRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGIgLSB0ZWxscyBpZiBib3RoIGRpc3BsYXllZCBjb2xvciBsYXllcnMgYW5kIGRpc3BsYXllZCBlbGV2YXRpb24gbGF5ZXJzIGluZm9zIHNob3VsZCBiZSBmZXRjaGVkIGJ5IHRoZSBldmVudCBQUkVfUkVOREVSXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5wcmVSZW5kZXJFdmVudEZldGNoTGF5ZXJzRGlzcGxheWVkID0gZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2ZldGNoVmlzaWJsZUNvbG9yTGF5ZXJzID0gYjtcbiAgICB0aGlzLl9mZXRjaFZpc2libGVFbGV2YXRpb25MYXllcnMgPSBiO1xufTtcblxuLyoqXG4gKiBHZXQgbGF5ZXIgYnkgaXRzIGlkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBMYXllciBpZFxuICogQHJldHVybiB7T2JqZWN0fSBsYXllciBPYmplY3RcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldExheWVyQnlJZCA9IGZ1bmN0aW9uIChsYXllcklkKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRHbG9iZVZpZXcoKS5nZXRMYXllcnMoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgaWYgKGwuaWQgPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgfSlbMF07XG4gICAgaWYgKCFsYXllcikge1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJbR2xvYmVWaWV3RXh0ZW5kZWRdICA6IG5vIExheWVyIGZvdW5kIGZvciB0aGUgaWQgJ1wiICsgbGF5ZXJJZCArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXI7XG59O1xuXG4vKipcbiAqIEdldCBjb2xvciBsYXllciBieSBpdHMgaWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIENvbG9yIGxheWVyIGlkXG4gKiBAcmV0dXJuIHtPYmplY3R9IGxheWVyIE9iamVjdFxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZ2V0Q29sb3JMYXllckJ5SWQgPSBmdW5jdGlvbiAobGF5ZXJJZCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0R2xvYmVWaWV3KCkuZ2V0TGF5ZXJzKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIGlmIChsLmlkID09PSBsYXllcklkICYmIGwudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIH0pWzBdO1xuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFwiW0dsb2JlVmlld0V4dGVuZGVkXSAgOiBubyBjb2xvckxheWVyIGZvdW5kIGZvciB0aGUgaWQgJ1wiICsgbGF5ZXJJZCArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXI7XG59O1xuXG4vKipcbiAqIEdldCBpbWFnZXJ5IGxheWVyc1xuICpcbiAqIEByZXR1cm4ge0FycmF5fSBpbWFnZXJ5IGxheWVyc1xuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZ2V0Q29sb3JMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuZ2V0TGF5ZXJzKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHZlY3RvciBsYXllcnNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdmVjdG9yIGxheWVyc1xuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZ2V0VmVjdG9yTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEdsb2JlVmlldygpLmdldExheWVycyhmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKGxheWVyLnByb3RvY29sID09PSBcInJhc3Rlcml6ZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBlbGV2YXRpb24gbGF5ZXJzXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGVsZXZhdGlvbiBsYXllcnNcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldEVsZXZhdGlvbkxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHbG9iZVZpZXcoKS5nZXRMYXllcnMoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllci50eXBlID09PSBcImVsZXZhdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZpZXcgZXh0ZW50XG4gKlxuICogQHJldHVybnMge0FycmF5fSBjdXJyZW50IHZpZXcgZXh0ZW50XG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGV4dGVudCA6IG5ldyB0aGlzLl9pdG93bnMuRXh0ZW50KFwiRVBTRzo0MzI2XCIsIDE4MCwgLTE4MCwgOTAsIC05MClcbiAgICB9O1xuXG4gICAgdGhpcy5fZ2V0Q3VycmVudFNjZW5lSW5mb3ModGhpcy5zY2VuZSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gb3B0aW9ucy5leHRlbnQ7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBtZXRob2QgdG8gZmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgdmlldyAoZXh0ZW50LCBsYXllcnMgZGlzcGxheWVkLi4uKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gaXRvd25zIG5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IGNvbnRhaW5pbmcgb2JqZWN0cyB0byBmaWxsIHdpdGggaW5mbyBpZiBzcGVjaWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5fZ2V0Q3VycmVudFNjZW5lSW5mb3MgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUubGV2ZWwpIHtcbiAgICAgICAgaWYgKG5vZGUubWF0ZXJpYWwudmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29sb3JMYXllcnNJZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5tYXRlcmlhbC5jb2xvckxheWVyc0lkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbG9yTGF5ZXJzSWQuaW5kZXhPZihub2RlLm1hdGVyaWFsLmNvbG9yTGF5ZXJzSWRbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvckxheWVyc0lkLnB1c2gobm9kZS5tYXRlcmlhbC5jb2xvckxheWVyc0lkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVsZXZhdGlvbkxheWVyc0lkKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2RlLm1hdGVyaWFsLmVsZXZhdGlvbkxheWVyc0lkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVsZXZhdGlvbkxheWVyc0lkLmluZGV4T2Yobm9kZS5tYXRlcmlhbC5lbGV2YXRpb25MYXllcnNJZFtqXSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVsZXZhdGlvbkxheWVyc0lkLnB1c2gobm9kZS5tYXRlcmlhbC5lbGV2YXRpb25MYXllcnNJZFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5leHRlbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmV4dGVudC51bmlvbihub2RlLmV4dGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgY2hpbGQgaW4gbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Q3VycmVudFNjZW5lSW5mb3Mobm9kZS5jaGlsZHJlbltjaGlsZF0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGdsb2JlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHdpZGdldCAtIFRoZSBXaWRnZXQgb2JqZWN0IHRvIGFkZFxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuYWRkV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgIGlmICghd2lkZ2V0LmdldFRhcmdldCgpKSB7XG4gICAgICAgIHdpZGdldC5zZXRUYXJnZXQodGhpcy5fdmlld2VyRGl2LCBcImFic29sdXRlXCIpO1xuICAgIH1cbiAgICB3aWRnZXQuc2V0R2xvYmUodGhpcyk7XG4gICAgdGhpcy5fd2lkZ2V0cy5wdXNoKHdpZGdldCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHdpZGdldHMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IHdpZGdldHMgLSBUaGUgYXJyYXkgb2Ygd2lkZ2V0cy5cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldFdpZGdldHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZGdldHM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSB3aWRnZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHdpZGdldCAtIFRoZSBXaWRnZXQgb2JqZWN0IHRvIHJlbW92ZVxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUucmVtb3ZlV2lkZ2V0ID0gZnVuY3Rpb24gKHdpZGdldCkge1xuICAgIHdpZGdldC5zZXRHbG9iZSgpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuX3dpZGdldHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5fd2lkZ2V0c1tpZHhdID09PSB3aWRnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZGdldHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBodG1sIHRhcmdldCBlbGVtZW50XG4gKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEdsb2JlIGNvbnRhaW5lciBlbGVtZW50XG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRUYXJnZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3ZXJEaXY7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY3VycmVudCB2aWV3IHNjYWxlXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBTY2FsZVxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuZ2V0U2NhbGUoKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aWx0XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbHQgLSBUaWx0IHZhbHVlXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5zZXRUaWx0ID0gZnVuY3Rpb24gKHRpbHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHbG9iZVZpZXcoKS5jb250cm9scy5zZXRUaWx0KHRpbHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aWx0XG4gKlxuICogQHJldHVybiB7TnVtYmVyfSAtIFRpbHRcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldFRpbHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuZ2V0Q2FtZXJhT3JpZW50YXRpb24oKVswXTtcbn07XG5cbi8qKlxuICogU2V0cyBhemltdXRoXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGF6aW11dGggLSBBemltdXRoIHZhbHVlXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5zZXRBemltdXRoID0gZnVuY3Rpb24gKGF6aW11dGgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHbG9iZVZpZXcoKS5jb250cm9scy5zZXRIZWFkaW5nKGF6aW11dGgsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhemltdXRoXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBhemltdXRoXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRBemltdXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldEdsb2JlVmlldygpLmNvbnRyb2xzLmdldENhbWVyYU9yaWVudGF0aW9uKClbMV07XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGNvb3JkaW5hdGUgaW4gbGF0LGxvbiBmb3IgYSBnaXZlbiBwaXhlbC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBwaXhlbCB4LXBvc2l0aW9uIGluc2lkZSB0aGUgR2xvYmUgZWxlbWVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHBpeGVsIHktcG9zaXRpb24gaW5zaWRlIHRoZSBHbG9iZSBlbGVtZW50LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZXN9IHBvc2l0aW9uXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRDb29yZGluYXRlRnJvbVBpeGVsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHbG9iZVZpZXcoKS5jb250cm9scy5waWNrR2VvUG9zaXRpb24oe1xuICAgICAgICB4IDogeCxcbiAgICAgICAgeSA6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY29vcmRpbmF0ZSBpbiBsYXQsbG9uIGZvciBhIGdpdmVuIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIEEgbW91c2UgZXZlbnQuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlc30gcG9zaXRpb25cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldENvb3JkaW5hdGVGcm9tTW91c2VFdmVudCA9IGZ1bmN0aW9uIChtb3VzZUV2ZW50KSB7XG4gICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0R2xvYmVWaWV3KCkuZXZlbnRUb1ZpZXdDb29yZHMobW91c2VFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMucGlja0dlb1Bvc2l0aW9uKGNvb3Jkcyk7XG59O1xuXG4vKipcbiAqIEdldCBhbGwgdmlzaWJsZSBmZWF0dXJlcyB0aGF0IGludGVyc2VjdCBhIHBpeGVsXG4gKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gQSBtb3VzZSBldmVudC5cbiAqIEByZXR1cm4ge0FycmF5fSB2aXNpYmxlRmVhdHVyZXMgLSBUaGUgYXJyYXkgb2YgdmlzaWJsZSBmZWF0dXJlcy5cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldEZlYXR1cmVzQXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24gKG1vdXNlRXZlbnQpIHtcbiAgICB2YXIgdmVjdG9yTGF5ZXJzID0gdGhpcy5nZXRWZWN0b3JMYXllcnMoKTtcbiAgICBpZiAoIXZlY3RvckxheWVycykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFycmF5IG9mIHRoZSB2aXNpYmxlIGZlYXR1cmVzIG9uIHRoZSBjbGlja2VyIGNvb3JkXG4gICAgdmFyIHZpc2libGVGZWF0dXJlcyA9IFtdO1xuICAgIHZhciBnZW9Db29yZCA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21Nb3VzZUV2ZW50KG1vdXNlRXZlbnQpO1xuICAgIGlmIChnZW9Db29yZCkge1xuICAgICAgICAvLyBidWZmZXIgYXJvdW5kIHRoZSBjbGljayBpbnNpZGUgd2UgcmV0cmlldmUgdGhlIGZlYXR1cmVzXG4gICAgICAgIHZhciBwcmVjaXNpb24gPSB0aGlzLmdldEdsb2JlVmlldygpLmNvbnRyb2xzLnBpeGVsc1RvRGVncmVlcyg1KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZWN0b3JMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZHg7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB2ZWN0b3JMYXllcnNbaV07XG4gICAgICAgICAgICAvLyBpZiB0aGUgbGF5ZXIgaXMgbm90IHZpc2libGUsIHdlIGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKCFsYXllci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faXRvd25zLkZlYXR1cmVzVXRpbHMuZmlsdGVyRmVhdHVyZXNVbmRlckNvb3JkaW5hdGUoZ2VvQ29vcmQsIGxheWVyLmZlYXR1cmUsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAvLyB3ZSBhZGQgdGhlIGZlYXR1cmVzIHRvIHRoZSB2aXNpYmxlIGZlYXR1cmVzIGFycmF5XG4gICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHJlc3VsdC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUZlYXR1cmVzLnB1c2gocmVzdWx0W2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlRmVhdHVyZXM7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdGhlIGNlbnRlciBvZiB0aGUgc2NlbmUgb24gc2NyZWVuIHRvIHRoZSBzcGVjaWZpZWQgaW4gbGF0LCBsb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNlbnRlciAtIENlbnRlciBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXIubG9uZ2l0dWRlIC0gQ29vcmRpbmF0ZSBsb25naXR1ZGUgV0dTODQgaW4gZGVncmVlXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudGVyLmxhdGl0dWRlIC0gQ29vcmRpbmF0ZSBsYXRpdHVkZSBXR1M4NCBpbiBkZWdyZWVcbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG5leHQgJ2dsb2JlIGluaXRpbGF6ZWQnIGV2ZW50IGZpcmVzLlxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuc2V0Q2FtZXJhVGFyZ2V0R2VvUG9zaXRpb24gPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuc2V0Q2FtZXJhVGFyZ2V0R2VvUG9zaXRpb25BZHZhbmNlZChjZW50ZXIsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUmV0dW5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY2VudHJhbCBwb2ludCBvbiBzY3JlZW4gaW4gbGF0LGxvbiBhbmQgYWx0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXJcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FtZXJhQ2VudGVyID0gdGhpcy5nZXRHbG9iZVZpZXcoKS5jb250cm9scy5nZXRDYW1lcmFUYXJnZXRHZW9Qb3NpdGlvbigpO1xuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIGxvbiA6IGNhbWVyYUNlbnRlci5sb25naXR1ZGUoKSxcbiAgICAgICAgbGF0IDogY2FtZXJhQ2VudGVyLmxhdGl0dWRlKCksXG4gICAgICAgIGFsdCA6IGNhbWVyYUNlbnRlci5hbHRpdHVkZSgpXG4gICAgfTtcbiAgICByZXR1cm4gY2VudGVyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3R1YWwgem9vbS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb21cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuZ2V0Wm9vbSgpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHpvb20uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHpvb20gLSBUaGUgem9vbVxuICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZVxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuc2V0Wm9vbSh6b29tLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIFRvIGNvbnZlcnQgdGhlIHByb2plY3Rpb24gaW4gbWV0ZXJzIG9uIHRoZSBnbG9iZSBvZiBhIG51bWJlciBvZiBwaXhlbHMgb2Ygc2NyZWVuXG4gKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxzIC0gY291bnQgcGl4ZWxzIHRvIHByb2plY3RcbiAqIEByZXR1cm4ge051bWJlcn0gcHJvamVjdGlvbiBpbiBtZXRlcnMgb24gZ2xvYmVcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnBpeGVsc1RvTWV0ZXJzID0gZnVuY3Rpb24gKHBpeGVscykge1xuICAgIHJldHVybiB0aGlzLmdldEdsb2JlVmlldygpLmNvbnRyb2xzLnBpeGVsc1RvTWV0ZXJzKHBpeGVscyk7XG59O1xuXG4vKipcbiAqIFByb2plY3Rpb24gb24gc2NyZWVuIGluIHBpeGVscyBvZiBsZW5ndGggaW4gbWV0ZXIgb24gZ2xvYmVcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIExlbmd0aCBpbiBtZXRlciBvbiBnbG9iZVxuICogQHJldHVybiB7TnVtYmVyfSBwcm9qZWN0aW9uIGluIHBpeGVscyBvbiBzY3JlZW5cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLm1ldGVyc1RvUGl4ZWxzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMubWV0ZXJzVG9QaXhlbHModmFsdWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcInJhbmdlXCI6IHRoZSBkaXN0YW5jZSBpbiBtZXRlcnMgYmV0d2VlbiB0aGUgY2FtZXJhIGFuZCB0aGUgY3VycmVudCBjZW50cmFsIHBvaW50IG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG51bWJlclxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMuZ2V0UmFuZ2UoKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7VEhSRUUuVmVjdG9yM30gcG9zaXRpb25cbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLm1vdmVUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY29udHJvbHMubW92ZVRhcmdldCgpO1xufTtcblxuLyoqXG4gKiBUbyBnZXQgdGhlIGxheWVyIGV2ZW50IGluZm9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV2dCAtIGV2ZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBldmVudCBwcm9wZXJ0aWVzXG4gKi9cbkdsb2JlVmlld0V4dGVuZGVkLnByb3RvdHlwZS5nZXRMYXllckV2ZW50SW5mb3MgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IGV2dC50eXBlLnJlcGxhY2UoXCItcHJvcGVydHktY2hhbmdlZFwiLCBcIlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wZXJ0eU5hbWUgOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHByZXZpb3VzVmFsdWUgOiBldnQucHJldmlvdXNbcHJvcGVydHlOYW1lXSxcbiAgICAgICAgbmV3VmFsdWUgOiBldnQubmV3W3Byb3BlcnR5TmFtZV1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBTZXRzIGJhY2tncm91bmQgKHNwZWNpZmljIHRvIG1pbmlnbG9iZSlcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnNldEJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2V0IGEgMCBhbHBoYSBjbGVhciB2YWx1ZSAoaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCAnMScpXG4gICAgLy8gYmVjYXVzZSB3ZSB3YW50IGEgdHJhbnNwYXJlbnQgYmFja2dyb3VuZCBmb3IgdGhlIG1pbmlnbG9iZSB2aWV3IHRvIGJlIGFibGVcbiAgICAvLyB0byBzZWUgdGhlIG1haW4gdmlldyBcImJlaGluZFwiXG4gICAgdGhpcy5nZXRHbG9iZVZpZXcoKS5tYWluTG9vcC5nZnhFbmdpbmUucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDAwMDAwMCwgMCk7XG59O1xuXG4vKipcbiAqIFNldHMgY2FtZXJhIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHRhcmdldCAtIFRhcmdldCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIC0gRGlzdGFuY2UgZnJvbSB0YXJnZXRcbiAqL1xuR2xvYmVWaWV3RXh0ZW5kZWQucHJvdG90eXBlLnNldENhbWVyYVBvc2l0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgZGlzdGFuY2UpIHtcbiAgICB0aGlzLmdldEdsb2JlVmlldygpLmNhbWVyYS5jYW1lcmEzRC5wb3NpdGlvbi5jb3B5KHRhcmdldCkuc2V0TGVuZ3RoKGRpc3RhbmNlKTtcbn07XG5cbi8qKlxuICogU2V0cyBjYW1lcmEgb3JpZW50YXRpb24gdG8gbG9vayBhdCBzcGVjaWZpZWQgdGFyZ2V0XG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHRhcmdldCAtIFRhcmdldCBwb3NpdGlvblxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkuY2FtZXJhLmNhbWVyYTNELmxvb2tBdCh0YXJnZXQpO1xufTtcblxuLyoqXG4gKiBOb3RpZmllcyB0aGUgc2NlbmUgaXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUubm90aWZ5Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ2V0R2xvYmVWaWV3KCkubm90aWZ5Q2hhbmdlKHRydWUpO1xufTtcblxuLyoqXG4qIFJlc2l6ZXMgaXRvd25zXG4qXG4qIEBwYXJhbSB7SW50ZWdlcn0gd2lkdGggLSBjYW52YXMgd2lkdGggaW4gcGl4ZWxzXG4qIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0IC0gY2FudmFzIGhlaWdodCBpbiBwaXhlbHNcbiovXG5HbG9iZVZpZXdFeHRlbmRlZC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmdldEdsb2JlVmlldygpLm1haW5Mb29wLmdmeEVuZ2luZS5vbldpbmRvd1Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmdldEdsb2JlVmlldygpLm5vdGlmeUNoYW5nZSh0cnVlKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdsb2JlVmlld0V4dGVuZGVkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9HbG9iZVZpZXdFeHRlbmRlZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * formalisme d'un tag ID :\n * -> NAME(_ORDER)-1460636385836\n *\n * Ex.\n *   GProutePoints-1460636385836\n *   GProutePoint_10-1460636385836\n */\nvar SelectorID = {\n\n    /**\n     * Construction d'un identifiant statique basé sur le timestamp,\n     * et qui s'incremente de +1 à chaque appel\n     */\n    generate: function () {\n        var timestamp = Math.floor(Date.now());\n        return function () {\n            return timestamp++;\n        };\n    }(),\n\n    /**\n     * nom du tag\n     * @param {String} id - the id\n     *\n     * @returns {String} index\n     */\n    name: function name(id) {\n        var name = null;\n\n        var i = id.lastIndexOf(\"-\");\n        if (i === -1) {\n            name = id;\n        } else {\n            name = id.substring(0, i);\n        }\n\n        return name;\n    },\n\n    /**\n     * numero d'identifiant du tag\n     * @param {String} id - the id\n     *\n     * @returns {String} index\n     */\n    index: function index(id) {\n        var index = null;\n\n        var name = this.name(id);\n        // if (name !== id) {\n        var i = name.lastIndexOf(\"_\");\n        if (i !== -1) {\n            index = name.substring(i + 1);\n        }\n        // }\n\n        return index;\n    },\n\n    /**\n     * uuid du tag\n     * @param {String} id - the id\n     *\n     * @returns {String} uuid\n     */\n    uuid: function uuid(id) {\n        var uuid = null;\n\n        var i = id.lastIndexOf(\"-\");\n        if (i !== -1) {\n            uuid = parseInt(id.substring(i + 1), 10);\n        }\n\n        return uuid;\n    }\n\n};\n\nexports.default = SelectorID;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanM/YzY1OSJdLCJuYW1lcyI6WyJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJ0aW1lc3RhbXAiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwibmFtZSIsImlkIiwiaSIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwiaW5kZXgiLCJ1dWlkIiwicGFyc2VJbnQiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUEsSUFBSUEsYUFBYTs7QUFFYjs7OztBQUlBQyxjQUFZLFlBQVk7QUFDcEIsWUFBSUMsWUFBWUMsS0FBS0MsS0FBTCxDQUFXQyxLQUFLQyxHQUFMLEVBQVgsQ0FBaEI7QUFDQSxlQUFPLFlBQVk7QUFDZixtQkFBT0osV0FBUDtBQUNILFNBRkQ7QUFHSCxLQUxVLEVBTkU7O0FBYWI7Ozs7OztBQU1BSyxVQUFPLGNBQVVDLEVBQVYsRUFBYztBQUNqQixZQUFJRCxPQUFPLElBQVg7O0FBRUEsWUFBSUUsSUFBSUQsR0FBR0UsV0FBSCxDQUFlLEdBQWYsQ0FBUjtBQUNBLFlBQUlELE1BQU0sQ0FBQyxDQUFYLEVBQWM7QUFDVkYsbUJBQU9DLEVBQVA7QUFDSCxTQUZELE1BRU87QUFDSEQsbUJBQU9DLEdBQUdHLFNBQUgsQ0FBYSxDQUFiLEVBQWdCRixDQUFoQixDQUFQO0FBQ0g7O0FBRUQsZUFBT0YsSUFBUDtBQUNILEtBOUJZOztBQWdDYjs7Ozs7O0FBTUFLLFdBQVEsZUFBVUosRUFBVixFQUFjO0FBQ2xCLFlBQUlJLFFBQVEsSUFBWjs7QUFFQSxZQUFJTCxPQUFPLEtBQUtBLElBQUwsQ0FBVUMsRUFBVixDQUFYO0FBQ0E7QUFDQSxZQUFJQyxJQUFJRixLQUFLRyxXQUFMLENBQWlCLEdBQWpCLENBQVI7QUFDQSxZQUFJRCxNQUFNLENBQUMsQ0FBWCxFQUFjO0FBQ1ZHLG9CQUFRTCxLQUFLSSxTQUFMLENBQWVGLElBQUksQ0FBbkIsQ0FBUjtBQUNIO0FBQ0Q7O0FBRUEsZUFBT0csS0FBUDtBQUNILEtBbERZOztBQW9EYjs7Ozs7O0FBTUFDLFVBQU8sY0FBVUwsRUFBVixFQUFjO0FBQ2pCLFlBQUlLLE9BQU8sSUFBWDs7QUFFQSxZQUFJSixJQUFJRCxHQUFHRSxXQUFILENBQWUsR0FBZixDQUFSO0FBQ0EsWUFBSUQsTUFBTSxDQUFDLENBQVgsRUFBYztBQUNWSSxtQkFBT0MsU0FBU04sR0FBR0csU0FBSCxDQUFhRixJQUFJLENBQWpCLENBQVQsRUFBOEIsRUFBOUIsQ0FBUDtBQUNIOztBQUVELGVBQU9JLElBQVA7QUFDSDs7QUFuRVksQ0FBakI7O2tCQXVFZWIsVSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBmb3JtYWxpc21lIGQndW4gdGFnIElEIDpcbiAqIC0+IE5BTUUoX09SREVSKS0xNDYwNjM2Mzg1ODM2XG4gKlxuICogRXguXG4gKiAgIEdQcm91dGVQb2ludHMtMTQ2MDYzNjM4NTgzNlxuICogICBHUHJvdXRlUG9pbnRfMTAtMTQ2MDYzNjM4NTgzNlxuICovXG52YXIgU2VsZWN0b3JJRCA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGlvbiBkJ3VuIGlkZW50aWZpYW50IHN0YXRpcXVlIGJhc8OpIHN1ciBsZSB0aW1lc3RhbXAsXG4gICAgICogZXQgcXVpIHMnaW5jcmVtZW50ZSBkZSArMSDDoCBjaGFxdWUgYXBwZWxcbiAgICAgKi9cbiAgICBnZW5lcmF0ZSA6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcCsrO1xuICAgICAgICB9O1xuICAgIH0pKCksXG5cbiAgICAvKipcbiAgICAgKiBub20gZHUgdGFnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIG5hbWUgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuXG4gICAgICAgIHZhciBpID0gaWQubGFzdEluZGV4T2YoXCItXCIpO1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBpZC5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbnVtZXJvIGQnaWRlbnRpZmlhbnQgZHUgdGFnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBpbmRleFxuICAgICAqL1xuICAgIGluZGV4IDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG51bGw7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUoaWQpO1xuICAgICAgICAvLyBpZiAobmFtZSAhPT0gaWQpIHtcbiAgICAgICAgdmFyIGkgPSBuYW1lLmxhc3RJbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleCA9IG5hbWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1dWlkIGR1IHRhZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHRoZSBpZFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdXVpZFxuICAgICAqL1xuICAgIHV1aWQgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHV1aWQgPSBudWxsO1xuXG4gICAgICAgIHZhciBpID0gaWQubGFzdEluZGV4T2YoXCItXCIpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHV1aWQgPSBwYXJzZUludChpZC5zdWJzdHJpbmcoaSArIDEpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXVpZDtcbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdG9ySUQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tbW9uL1V0aWxzL1NlbGVjdG9ySUQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"Widget\");\n\n/**\n* @classdesc\n* iTowns Widget class.\n* Every geoportal control inherits of this class.\n*\n* @constructor\n* @alias itowns.control.Widget\n* @param {Object} options - options for function call.\n* @param {String}  options.name - Name of the widget.\n* @param {Object}  options.element - HTML element of the widget\n* @param {Object}  options.target - HTML element where to put the widget\n* @param {String}  options.position - \"absolute\" or \"relative\"\n* @example\n* var myWidget = new itowns.control.Widget({\n*      name : \"myWidget\",\n*      element : myWidgetDiv,\n*      target : myWidgetTargetDiv,\n*      position: \"absolute\"\n* });\n*/\nfunction Widget(options) {\n    this.name = null;\n    this._element = null;\n    this._target = null;\n    this._globe = null;\n\n    this.setOptions(options);\n}\n\n/**\n * Constructor (alias)\n */\nWidget.prototype.constructor = Widget;\n\n/**\n * Return the widget's container element.\n *\n * @method\n * @return {HTMLElement} widget's container element.\n */\nWidget.prototype.getElement = function getElement() {\n    return this._element;\n};\n\n/**\n * Associates the widget to a specified target div.\n *\n * @method\n * @param {HTMLElement} targetDiv - widget target div.\n * @param {String} position - html position attribute.\n */\nWidget.prototype.setTarget = function setTarget(targetDiv, position) {\n    if (!targetDiv) {\n        return;\n    }\n\n    if (position && position !== \"absolute\" && position !== \"relative\") {\n        logger.error(\"Widget:setTarget - position value should be 'absolute' or 'relative'\");\n        return;\n    }\n\n    if (this._target && this._element) {\n        this._target.removeChild(this._element);\n    }\n\n    this._target = targetDiv;\n\n    if (!this._element) {\n        logger.error(\"Widget:setTarget - widget element not created\");\n        return;\n    }\n\n    this._element.style.position = position || \"relative\";\n\n    targetDiv.appendChild(this._element);\n};\n\n/**\n * Return the widget's target div.\n *\n * @method\n * @return {HTMLElement} widget's target div.\n */\nWidget.prototype.getTarget = function getTarget() {\n    return this._target;\n};\n\n/**\n * Change the options of the widget.\n *\n * @method\n * @param {Object} options - The new options of the control.\n */\nWidget.prototype.setOptions = function setOptions(options) {\n    this.name = options.name;\n    this._element = options.element;\n    this.setTarget(options.target, options.position);\n};\n\n/**\n * Get the globe associated with the widget. Undefined if the widget is not added to a globe.\n *\n * @method\n * @return {Object} globe\n */\nWidget.prototype.getGlobe = function getGlobe() {\n    return this._globe;\n};\n\n/**\n * Associate a globe to the widget.\n *\n * @method\n * @param {Object} globe - Globe to associate to the widget.\n */\nWidget.prototype.setGlobe = function setGlobe(globe) {\n    this._globe = globe;\n};\n\nexports.default = Widget;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL1dpZGdldC5qcz85YTRlIl0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIldpZGdldCIsIm9wdGlvbnMiLCJuYW1lIiwiX2VsZW1lbnQiLCJfdGFyZ2V0IiwiX2dsb2JlIiwic2V0T3B0aW9ucyIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwiZ2V0RWxlbWVudCIsInNldFRhcmdldCIsInRhcmdldERpdiIsInBvc2l0aW9uIiwiZXJyb3IiLCJyZW1vdmVDaGlsZCIsInN0eWxlIiwiYXBwZW5kQ2hpbGQiLCJnZXRUYXJnZXQiLCJlbGVtZW50IiwidGFyZ2V0IiwiZ2V0R2xvYmUiLCJzZXRHbG9iZSIsImdsb2JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0FBRUEsSUFBSUEsU0FBU0MsMEJBQU9DLFNBQVAsQ0FBaUIsUUFBakIsQ0FBYjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsU0FBU0MsTUFBVCxDQUFpQkMsT0FBakIsRUFBMEI7QUFDdEIsU0FBS0MsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLQyxNQUFMLEdBQWMsSUFBZDs7QUFFQSxTQUFLQyxVQUFMLENBQWdCTCxPQUFoQjtBQUNIOztBQUVEOzs7QUFHQUQsT0FBT08sU0FBUCxDQUFpQkMsV0FBakIsR0FBK0JSLE1BQS9COztBQUVBOzs7Ozs7QUFNQUEsT0FBT08sU0FBUCxDQUFpQkUsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxHQUF1QjtBQUNqRCxXQUFPLEtBQUtOLFFBQVo7QUFDSCxDQUZEOztBQUlBOzs7Ozs7O0FBT0FILE9BQU9PLFNBQVAsQ0FBaUJHLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0JDLFNBQXBCLEVBQStCQyxRQUEvQixFQUF5QztBQUNsRSxRQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDWjtBQUNIOztBQUVELFFBQUlDLFlBQVlBLGFBQWEsVUFBekIsSUFBdUNBLGFBQWEsVUFBeEQsRUFBb0U7QUFDaEVmLGVBQU9nQixLQUFQLENBQWEsc0VBQWI7QUFDQTtBQUNIOztBQUVELFFBQUksS0FBS1QsT0FBTCxJQUFnQixLQUFLRCxRQUF6QixFQUFtQztBQUMvQixhQUFLQyxPQUFMLENBQWFVLFdBQWIsQ0FBeUIsS0FBS1gsUUFBOUI7QUFDSDs7QUFFRCxTQUFLQyxPQUFMLEdBQWVPLFNBQWY7O0FBRUEsUUFBSSxDQUFDLEtBQUtSLFFBQVYsRUFBb0I7QUFDaEJOLGVBQU9nQixLQUFQLENBQWEsK0NBQWI7QUFDQTtBQUNIOztBQUVELFNBQUtWLFFBQUwsQ0FBY1ksS0FBZCxDQUFvQkgsUUFBcEIsR0FBK0JBLFlBQVksVUFBM0M7O0FBRUFELGNBQVVLLFdBQVYsQ0FBc0IsS0FBS2IsUUFBM0I7QUFDSCxDQXhCRDs7QUEwQkE7Ozs7OztBQU1BSCxPQUFPTyxTQUFQLENBQWlCVSxTQUFqQixHQUE2QixTQUFTQSxTQUFULEdBQXNCO0FBQy9DLFdBQU8sS0FBS2IsT0FBWjtBQUNILENBRkQ7O0FBSUE7Ozs7OztBQU1BSixPQUFPTyxTQUFQLENBQWlCRCxVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCTCxPQUFyQixFQUE4QjtBQUN4RCxTQUFLQyxJQUFMLEdBQVlELFFBQVFDLElBQXBCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQkYsUUFBUWlCLE9BQXhCO0FBQ0EsU0FBS1IsU0FBTCxDQUFlVCxRQUFRa0IsTUFBdkIsRUFBK0JsQixRQUFRVyxRQUF2QztBQUNILENBSkQ7O0FBTUE7Ozs7OztBQU1BWixPQUFPTyxTQUFQLENBQWlCYSxRQUFqQixHQUE0QixTQUFTQSxRQUFULEdBQXFCO0FBQzdDLFdBQU8sS0FBS2YsTUFBWjtBQUNILENBRkQ7O0FBSUE7Ozs7OztBQU1BTCxPQUFPTyxTQUFQLENBQWlCYyxRQUFqQixHQUE0QixTQUFTQSxRQUFULENBQW1CQyxLQUFuQixFQUEwQjtBQUNsRCxTQUFLakIsTUFBTCxHQUFjaUIsS0FBZDtBQUNILENBRkQ7O2tCQUlldEIsTSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuXG52YXIgbG9nZ2VyID0gTG9nZ2VyLmdldExvZ2dlcihcIldpZGdldFwiKTtcblxuLyoqXG4qIEBjbGFzc2Rlc2NcbiogaVRvd25zIFdpZGdldCBjbGFzcy5cbiogRXZlcnkgZ2VvcG9ydGFsIGNvbnRyb2wgaW5oZXJpdHMgb2YgdGhpcyBjbGFzcy5cbipcbiogQGNvbnN0cnVjdG9yXG4qIEBhbGlhcyBpdG93bnMuY29udHJvbC5XaWRnZXRcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBmdW5jdGlvbiBjYWxsLlxuKiBAcGFyYW0ge1N0cmluZ30gIG9wdGlvbnMubmFtZSAtIE5hbWUgb2YgdGhlIHdpZGdldC5cbiogQHBhcmFtIHtPYmplY3R9ICBvcHRpb25zLmVsZW1lbnQgLSBIVE1MIGVsZW1lbnQgb2YgdGhlIHdpZGdldFxuKiBAcGFyYW0ge09iamVjdH0gIG9wdGlvbnMudGFyZ2V0IC0gSFRNTCBlbGVtZW50IHdoZXJlIHRvIHB1dCB0aGUgd2lkZ2V0XG4qIEBwYXJhbSB7U3RyaW5nfSAgb3B0aW9ucy5wb3NpdGlvbiAtIFwiYWJzb2x1dGVcIiBvciBcInJlbGF0aXZlXCJcbiogQGV4YW1wbGVcbiogdmFyIG15V2lkZ2V0ID0gbmV3IGl0b3ducy5jb250cm9sLldpZGdldCh7XG4qICAgICAgbmFtZSA6IFwibXlXaWRnZXRcIixcbiogICAgICBlbGVtZW50IDogbXlXaWRnZXREaXYsXG4qICAgICAgdGFyZ2V0IDogbXlXaWRnZXRUYXJnZXREaXYsXG4qICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuKiB9KTtcbiovXG5mdW5jdGlvbiBXaWRnZXQgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fZ2xvYmUgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdG9yIChhbGlhcylcbiAqL1xuV2lkZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdpZGdldDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZGdldCdzIGNvbnRhaW5lciBlbGVtZW50LlxuICpcbiAqIEBtZXRob2RcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB3aWRnZXQncyBjb250YWluZXIgZWxlbWVudC5cbiAqL1xuV2lkZ2V0LnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEFzc29jaWF0ZXMgdGhlIHdpZGdldCB0byBhIHNwZWNpZmllZCB0YXJnZXQgZGl2LlxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldERpdiAtIHdpZGdldCB0YXJnZXQgZGl2LlxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gaHRtbCBwb3NpdGlvbiBhdHRyaWJ1dGUuXG4gKi9cbldpZGdldC5wcm90b3R5cGUuc2V0VGFyZ2V0ID0gZnVuY3Rpb24gc2V0VGFyZ2V0ICh0YXJnZXREaXYsIHBvc2l0aW9uKSB7XG4gICAgaWYgKCF0YXJnZXREaXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIHBvc2l0aW9uICE9PSBcInJlbGF0aXZlXCIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiV2lkZ2V0OnNldFRhcmdldCAtIHBvc2l0aW9uIHZhbHVlIHNob3VsZCBiZSAnYWJzb2x1dGUnIG9yICdyZWxhdGl2ZSdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFyZ2V0ICYmIHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldERpdjtcblxuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJXaWRnZXQ6c2V0VGFyZ2V0IC0gd2lkZ2V0IGVsZW1lbnQgbm90IGNyZWF0ZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb24gfHwgXCJyZWxhdGl2ZVwiO1xuXG4gICAgdGFyZ2V0RGl2LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHdpZGdldCdzIHRhcmdldCBkaXYuXG4gKlxuICogQG1ldGhvZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdpZGdldCdzIHRhcmdldCBkaXYuXG4gKi9cbldpZGdldC5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG9wdGlvbnMgb2YgdGhlIHdpZGdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBuZXcgb3B0aW9ucyBvZiB0aGUgY29udHJvbC5cbiAqL1xuV2lkZ2V0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyAob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLl9lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuICAgIHRoaXMuc2V0VGFyZ2V0KG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLnBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBnbG9iZSBhc3NvY2lhdGVkIHdpdGggdGhlIHdpZGdldC4gVW5kZWZpbmVkIGlmIHRoZSB3aWRnZXQgaXMgbm90IGFkZGVkIHRvIGEgZ2xvYmUuXG4gKlxuICogQG1ldGhvZFxuICogQHJldHVybiB7T2JqZWN0fSBnbG9iZVxuICovXG5XaWRnZXQucHJvdG90eXBlLmdldEdsb2JlID0gZnVuY3Rpb24gZ2V0R2xvYmUgKCkge1xuICAgIHJldHVybiB0aGlzLl9nbG9iZTtcbn07XG5cbi8qKlxuICogQXNzb2NpYXRlIGEgZ2xvYmUgdG8gdGhlIHdpZGdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdH0gZ2xvYmUgLSBHbG9iZSB0byBhc3NvY2lhdGUgdG8gdGhlIHdpZGdldC5cbiAqL1xuV2lkZ2V0LnByb3RvdHlwZS5zZXRHbG9iZSA9IGZ1bmN0aW9uIHNldEdsb2JlIChnbG9iZSkge1xuICAgIHRoaXMuX2dsb2JlID0gZ2xvYmU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSXRvd25zL0NvbnRyb2xzL1dpZGdldC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"config\");\n\nvar Config = {\n\n    /** autoconf */\n    configuration: null,\n\n    /**\n     * Controle du chargement de l'autoconf\n     *\n     * @returns {Boolean} isConfigLoaded - True si l'autoconf a déjà été chargée, False sinon.\n     */\n    isConfigLoaded: function isConfigLoaded() {\n        var scope = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : {};\n        if (scope.Gp && scope.Gp.Config && Object.keys(scope.Gp.Config).length !== 0) {\n            this.configuration = scope.Gp.Config;\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Recuperation de l'identifiant d'une couche donnée\n     *\n     * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n     * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n     * @returns {String} layerId - identifiant de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\")\n     */\n    getLayerId: function getLayerId(layerName, service) {\n        var layerId = null;\n\n        // layer\n        // key : [layerName]$[contexte]:OGC:[service]\n        // ex : \"ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS\"\n\n        // service\n        // key : [layerName]$[contexte];[service]\n        // ex : PositionOfInterest$OGC:OPENLS;ReverseGeocode\n\n        if (this.configuration) {\n            var layers = this.configuration[\"layers\"];\n            for (var key in layers) {\n                if (layers.hasOwnProperty(key)) {\n                    var parts = key.split(\"$\");\n                    if (layerName === parts[0]) {\n                        if (parts[1]) {\n                            var servicePartsLayer = parts[1].split(\":\");\n                            var servicePartsService = parts[1].split(\";\");\n\n                            if (servicePartsService[1] === service) {\n                                layerId = key;\n                                break;\n                            }\n                            if (servicePartsLayer[2] === service) {\n                                layerId = key;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (!layerId) {\n            logger.error(\"ERROR layer id (layer name: \" + layerName + \" / service: \" + service + \") was not found !?\");\n        }\n\n        return layerId;\n    },\n\n    /**\n     * Récupération des paramètres nécessaires à l'affichage d'une couche WMS ou WMTS\n     *\n     * @param {String} layerName - nom de la couche (par ex. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n     * @param {String} service   - nom du service (par ex. \"WMS\" ou \"WMTS\")\n     * @param {String} [apiKey]  - Clé de contrat API\n     * @returns {Object} params  - paramètres du service (WMS ou WMTS) pour la couche donnée\n     * @returns {String} params.url        - Url du service à requêter pour afficher la couche\n     * @returns {String} params.version    - Version du service\n     * @returns {String} params.styles     - Style par défaut de la couche\n     * @returns {String} params.format     - Format par défaut de la couche\n     * @returns {String} params.projection - Projection par défaut de la couche\n     * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n     * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n     * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n     * @returns {Array} params.legends     - Tableau des légendes associées à la couche\n     * @returns {Array} params.metadata    - Tableau des métadonnées associées à la couche\n     * @returns {Array} params.originators - Tableau des originators associés à la couche\n     * @returns {Array} params.title       - Nom de la resource, lisible par un humain.\n     * @returns {Array} params.description - Url de l'image d'aperçu rapide de la ressource.\n     * @returns {Array} params.quicklookUrl- Tableau des originators associés à la couche\n     * @returns {String} params.[TMSLink]          - Identifiant de la pyramide (TMS), dans le cas d'une couche WMTS\n     * @returns {Gp.Point} params.[matrixOrigin]   - Origine de la matrice (top left corner), dans le cas d'une couche WMTS\n     * @returns {Array} params.[nativeResolutions] - Tableau regroupant les résolutions de chaque niveau de la matrice, dans le cas d'une couche WMTS\n     * @returns {Array} params.[matrixIds]         - Tableau regroupant les identifiants de chaque niveau de la matrice, dans le cas d'une couche WMTS\n     */\n    getLayerParams: function getLayerParams(layerName, service, apiKey) {\n        var params = {};\n\n        if (this.configuration) {\n            // récupération de l'identifiant complet de la couche.\n            var layerId = this.getLayerId(layerName, service);\n\n            if (layerId) {\n                // récupération de l'objet de configuration de la couche\n                var layerConf = this.configuration.layers[layerId];\n\n                // controle de la clef\n                var key = layerConf.apiKeys[0];\n                if (apiKey) {\n                    if (apiKey !== key) {\n                        logger.error(\"ERROR different keys (\" + apiKey + \" !== \" + key + \") !?\");\n                        return;\n                    }\n                }\n\n                apiKey = apiKey || key;\n                params.key = apiKey;\n                // récupération des paramètres du service\n                params.url = layerConf.getServerUrl(apiKey);\n                params.version = layerConf.getServiceParams().version;\n                params.styles = layerConf.getDefaultStyle();\n                params.format = layerConf.getDefaultFormat();\n                params.projection = layerConf.getDefaultProjection();\n\n                // récupération des infos de la couche\n                params.minScale = layerConf.getMinScaleDenominator();\n                params.maxScale = layerConf.getMaxScaleDenominator();\n                params.extent = layerConf.getBBOX();\n                params.legends = layerConf.getLegends();\n                params.metadata = layerConf.getMetadata();\n                params.originators = layerConf.getOriginators();\n                params.title = layerConf.getTitle();\n                params.description = layerConf.getDescription();\n                params.quicklookUrl = layerConf.getQuicklookUrl();\n\n                // WMTS : récupération des tileMatrixSetLimits\n                if (layerConf.wmtsOptions) {\n                    params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;\n                }\n\n                // WMTS : récupération des paramètres de la pyramide (TMS)\n                var TMSLink = layerConf.getTMSID();\n                if (TMSLink) {\n                    params.TMSLink = TMSLink;\n                    var tmsConf = this.configuration.getTMSConf(TMSLink);\n                    // Get matrix origin : Gp.Point = Object{x:Float, y:Float}\n                    params.matrixOrigin = tmsConf.getTopLeftCorner();\n                    params.nativeResolutions = tmsConf.nativeResolutions;\n                    params.matrixIds = tmsConf.matrixIds;\n                    params.tileMatrices = tmsConf.tileMatrices;\n                }\n            }\n        }\n\n        return params;\n    },\n\n    /**\n     * Recuperation des parametres d'un service\n     *\n     * @param {String} [resource] - \"PositionOfInterest\", \"StreetAddress\", \"Voiture\", \"Pieton\", ...\n     * @param {String} [service] - Geocode, Itineraire, ...\n     * @param {String} [apiKey]  - Clé de contrat API\n     * @returns {Object} params - paramètres de la ressource\n     * @returns {String} params. -\n     * @returns {String} params. -\n     * @returns {String} params. -\n     */\n    getServiceParams: function getServiceParams(resource, service, apiKey) {\n        var params = {};\n\n        if (this.configuration) {\n            // récupération de l'identifiant complet de la couche.\n            var layerId = this.getLayerId(resource, service);\n\n            if (layerId) {\n                // récupération de l'objet de configuration de la couche\n                var layerConf = this.configuration.layers[layerId];\n\n                // controle de la clef\n                var key = layerConf.apiKeys[0];\n                if (apiKey) {\n                    if (apiKey !== key) {\n                        return;\n                    }\n                }\n\n                apiKey = apiKey || key;\n                params.key = apiKey;\n                // récupération des paramètres du service\n                params.url = layerConf.getServerUrl(apiKey);\n                params.version = layerConf.getServiceParams().version;\n\n                // récupération des infos de la couche\n                params.extent = layerConf.getBBOX();\n                params.title = layerConf.getTitle();\n                params.description = layerConf.getDescription();\n            }\n        }\n\n        return params;\n    },\n\n    /**\n     * Resolution en geographique\n     *\n     * @returns {Array} resolutions\n     */\n    getResolutions: function getResolutions() {\n        var resolutions = [];\n\n        if (this.configuration) {\n            resolutions = this.configuration[\"generalOptions\"][\"wgs84Resolutions\"];\n        }\n\n        return resolutions;\n    },\n\n    /**\n     * Recuperation des parametres TMS de la configuration\n     * @param {String} tmsName - tile matrix set name\n     *\n     * @returns {Object} tile matrix set\n     */\n    getTileMatrix: function getTileMatrix(tmsName) {\n        var tms = {};\n\n        if (this.configuration) {\n            if (tmsName) {\n                tms = this.configuration[\"tileMatrixSets\"][tmsName.toUpperCase()];\n            }\n        }\n\n        return tms;\n    },\n\n    /**\n     * Récupération des contraintes générales d'une couche donnée : extent, minScale, maxScale, projection\n     *\n     * @param {String} layerId - identifiant de la couche\n     * @returns {Object} params - contraintes de la couche\n     * @returns {String} params.projection - Projection par défaut de la couche\n     * @returns {Number} params.minScale   - Dénominateur d'échelle minimum de la couche\n     * @returns {Number} params.maxScale   - Dénominateur d'échelle maximum de la couche\n     * @returns {Gp.BBox} params.extent    - Etendue de la couche, dans la projection de la couche\n     */\n    getGlobalConstraints: function getGlobalConstraints(layerId) {\n        var params = {};\n\n        if (layerId) {\n            // récupération de l'objet de configuration de la couche\n            var layerConf = this.configuration.layers[layerId];\n            params.projection = layerConf.getDefaultProjection();\n            params.minScale = layerConf.getMinScaleDenominator();\n            params.maxScale = layerConf.getMaxScaleDenominator();\n            params.extent = layerConf.getBBOX();\n        }\n\n        return params;\n    }\n};\n\nexports.default = Config;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL0NvbmZpZy5qcz8wZWFkIl0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJpc0NvbmZpZ0xvYWRlZCIsInNjb3BlIiwid2luZG93Iiwic2VsZiIsImdsb2JhbCIsIkdwIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImdldExheWVySWQiLCJsYXllck5hbWUiLCJzZXJ2aWNlIiwibGF5ZXJJZCIsImxheWVycyIsImtleSIsImhhc093blByb3BlcnR5IiwicGFydHMiLCJzcGxpdCIsInNlcnZpY2VQYXJ0c0xheWVyIiwic2VydmljZVBhcnRzU2VydmljZSIsImVycm9yIiwiZ2V0TGF5ZXJQYXJhbXMiLCJhcGlLZXkiLCJwYXJhbXMiLCJsYXllckNvbmYiLCJhcGlLZXlzIiwidXJsIiwiZ2V0U2VydmVyVXJsIiwidmVyc2lvbiIsImdldFNlcnZpY2VQYXJhbXMiLCJzdHlsZXMiLCJnZXREZWZhdWx0U3R5bGUiLCJmb3JtYXQiLCJnZXREZWZhdWx0Rm9ybWF0IiwicHJvamVjdGlvbiIsImdldERlZmF1bHRQcm9qZWN0aW9uIiwibWluU2NhbGUiLCJnZXRNaW5TY2FsZURlbm9taW5hdG9yIiwibWF4U2NhbGUiLCJnZXRNYXhTY2FsZURlbm9taW5hdG9yIiwiZXh0ZW50IiwiZ2V0QkJPWCIsImxlZ2VuZHMiLCJnZXRMZWdlbmRzIiwibWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsIm9yaWdpbmF0b3JzIiwiZ2V0T3JpZ2luYXRvcnMiLCJ0aXRsZSIsImdldFRpdGxlIiwiZGVzY3JpcHRpb24iLCJnZXREZXNjcmlwdGlvbiIsInF1aWNrbG9va1VybCIsImdldFF1aWNrbG9va1VybCIsIndtdHNPcHRpb25zIiwidGlsZU1hdHJpeFNldExpbWl0cyIsIlRNU0xpbmsiLCJnZXRUTVNJRCIsInRtc0NvbmYiLCJnZXRUTVNDb25mIiwibWF0cml4T3JpZ2luIiwiZ2V0VG9wTGVmdENvcm5lciIsIm5hdGl2ZVJlc29sdXRpb25zIiwibWF0cml4SWRzIiwidGlsZU1hdHJpY2VzIiwicmVzb3VyY2UiLCJnZXRSZXNvbHV0aW9ucyIsInJlc29sdXRpb25zIiwiZ2V0VGlsZU1hdHJpeCIsInRtc05hbWUiLCJ0bXMiLCJ0b1VwcGVyQ2FzZSIsImdldEdsb2JhbENvbnN0cmFpbnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0FBRUEsSUFBSUEsU0FBU0MsMEJBQU9DLFNBQVAsQ0FBaUIsUUFBakIsQ0FBYjs7QUFFQSxJQUFJQyxTQUFTOztBQUVUO0FBQ0FDLG1CQUFnQixJQUhQOztBQUtUOzs7OztBQUtBQyxvQkFBaUIsMEJBQVk7QUFDekIsWUFBSUMsUUFBUSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5QyxFQUFuSTtBQUNBLFlBQUlILE1BQU1JLEVBQU4sSUFBWUosTUFBTUksRUFBTixDQUFTUCxNQUFyQixJQUErQlEsT0FBT0MsSUFBUCxDQUFZTixNQUFNSSxFQUFOLENBQVNQLE1BQXJCLEVBQTZCVSxNQUE3QixLQUF3QyxDQUEzRSxFQUE4RTtBQUMxRSxpQkFBS1QsYUFBTCxHQUFxQkUsTUFBTUksRUFBTixDQUFTUCxNQUE5QjtBQUNBLG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNILEtBakJROztBQW1CVDs7Ozs7OztBQU9BVyxnQkFBYSxvQkFBVUMsU0FBVixFQUFxQkMsT0FBckIsRUFBOEI7QUFDdkMsWUFBSUMsVUFBVSxJQUFkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBSSxLQUFLYixhQUFULEVBQXdCO0FBQ3BCLGdCQUFJYyxTQUFTLEtBQUtkLGFBQUwsQ0FBbUIsUUFBbkIsQ0FBYjtBQUNBLGlCQUFLLElBQUll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VUFBVVcsb0JBQVYsRUFBcEI7QUFDQVosbUJBQU9hLFFBQVAsR0FBa0JaLFVBQVVhLHNCQUFWLEVBQWxCO0FBQ0FkLG1CQUFPZSxRQUFQLEdBQWtCZCxVQUFVZSxzQkFBVixFQUFsQjtBQUNBaEIsbUJBQU9pQixNQUFQLEdBQWdCaEIsVUFBVWlCLE9BQVYsRUFBaEI7QUFDSDs7QUFFRCxlQUFPbEIsTUFBUDtBQUNIO0FBalFRLENBQWI7O2tCQW9RZXpCLE0iLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJjb25maWdcIik7XG5cbnZhciBDb25maWcgPSB7XG5cbiAgICAvKiogYXV0b2NvbmYgKi9cbiAgICBjb25maWd1cmF0aW9uIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnRyb2xlIGR1IGNoYXJnZW1lbnQgZGUgbCdhdXRvY29uZlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGlzQ29uZmlnTG9hZGVkIC0gVHJ1ZSBzaSBsJ2F1dG9jb25mIGEgZMOpasOgIMOpdMOpIGNoYXJnw6llLCBGYWxzZSBzaW5vbi5cbiAgICAgKi9cbiAgICBpc0NvbmZpZ0xvYWRlZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjb3BlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fTtcbiAgICAgICAgaWYgKHNjb3BlLkdwICYmIHNjb3BlLkdwLkNvbmZpZyAmJiBPYmplY3Qua2V5cyhzY29wZS5HcC5Db25maWcpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gc2NvcGUuR3AuQ29uZmlnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cGVyYXRpb24gZGUgbCdpZGVudGlmaWFudCBkJ3VuZSBjb3VjaGUgZG9ubsOpZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBsYXllcklkIC0gaWRlbnRpZmlhbnQgZGUgbGEgY291Y2hlIChwYXIgZXguIFwiT1JUSE9JTUFHRVJZLk9SVEhPUEhPVE9TJEdFT1BPUlRBSUw6T0dDOldNVFNcIilcbiAgICAgKi9cbiAgICBnZXRMYXllcklkIDogZnVuY3Rpb24gKGxheWVyTmFtZSwgc2VydmljZSkge1xuICAgICAgICB2YXIgbGF5ZXJJZCA9IG51bGw7XG5cbiAgICAgICAgLy8gbGF5ZXJcbiAgICAgICAgLy8ga2V5IDogW2xheWVyTmFtZV0kW2NvbnRleHRlXTpPR0M6W3NlcnZpY2VdXG4gICAgICAgIC8vIGV4IDogXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1MkR0VPUE9SVEFJTDpPR0M6V01UU1wiXG5cbiAgICAgICAgLy8gc2VydmljZVxuICAgICAgICAvLyBrZXkgOiBbbGF5ZXJOYW1lXSRbY29udGV4dGVdO1tzZXJ2aWNlXVxuICAgICAgICAvLyBleCA6IFBvc2l0aW9uT2ZJbnRlcmVzdCRPR0M6T1BFTkxTO1JldmVyc2VHZW9jb2RlXG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuY29uZmlndXJhdGlvbltcImxheWVyc1wiXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KFwiJFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyTmFtZSA9PT0gcGFydHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2aWNlUGFydHNMYXllciA9IHBhcnRzWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmljZVBhcnRzU2VydmljZSA9IHBhcnRzWzFdLnNwbGl0KFwiO1wiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUGFydHNTZXJ2aWNlWzFdID09PSBzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVySWQgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmljZVBhcnRzTGF5ZXJbMl0gPT09IHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGF5ZXJJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRVJST1IgbGF5ZXIgaWQgKGxheWVyIG5hbWU6IFwiICsgbGF5ZXJOYW1lICsgXCIgLyBzZXJ2aWNlOiBcIiArIHNlcnZpY2UgKyBcIikgd2FzIG5vdCBmb3VuZCAhP1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXllcklkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSw6ljdXDDqXJhdGlvbiBkZXMgcGFyYW3DqHRyZXMgbsOpY2Vzc2FpcmVzIMOgIGwnYWZmaWNoYWdlIGQndW5lIGNvdWNoZSBXTVMgb3UgV01UU1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAtIG5vbSBkZSBsYSBjb3VjaGUgKHBhciBleC4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZSAgIC0gbm9tIGR1IHNlcnZpY2UgKHBhciBleC4gXCJXTVNcIiBvdSBcIldNVFNcIilcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwaUtleV0gIC0gQ2zDqSBkZSBjb250cmF0IEFQSVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhcmFtcyAgLSBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlIChXTVMgb3UgV01UUykgcG91ciBsYSBjb3VjaGUgZG9ubsOpZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy51cmwgICAgICAgIC0gVXJsIGR1IHNlcnZpY2Ugw6AgcmVxdcOqdGVyIHBvdXIgYWZmaWNoZXIgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcGFyYW1zLnZlcnNpb24gICAgLSBWZXJzaW9uIGR1IHNlcnZpY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuc3R5bGVzICAgICAtIFN0eWxlIHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5mb3JtYXQgICAgIC0gRm9ybWF0IHBhciBkw6lmYXV0IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5wcm9qZWN0aW9uIC0gUHJvamVjdGlvbiBwYXIgZMOpZmF1dCBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwYXJhbXMubWluU2NhbGUgICAtIETDqW5vbWluYXRldXIgZCfDqWNoZWxsZSBtaW5pbXVtIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5tYXhTY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1heGltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0dwLkJCb3h9IHBhcmFtcy5leHRlbnQgICAgLSBFdGVuZHVlIGRlIGxhIGNvdWNoZSwgZGFucyBsYSBwcm9qZWN0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLmxlZ2VuZHMgICAgIC0gVGFibGVhdSBkZXMgbMOpZ2VuZGVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMubWV0YWRhdGEgICAgLSBUYWJsZWF1IGRlcyBtw6l0YWRvbm7DqWVzIGFzc29jacOpZXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMub3JpZ2luYXRvcnMgLSBUYWJsZWF1IGRlcyBvcmlnaW5hdG9ycyBhc3NvY2nDqXMgw6AgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMudGl0bGUgICAgICAgLSBOb20gZGUgbGEgcmVzb3VyY2UsIGxpc2libGUgcGFyIHVuIGh1bWFpbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhcmFtcy5kZXNjcmlwdGlvbiAtIFVybCBkZSBsJ2ltYWdlIGQnYXBlcsOndSByYXBpZGUgZGUgbGEgcmVzc291cmNlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLnF1aWNrbG9va1VybC0gVGFibGVhdSBkZXMgb3JpZ2luYXRvcnMgYXNzb2Npw6lzIMOgIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5bVE1TTGlua10gICAgICAgICAgLSBJZGVudGlmaWFudCBkZSBsYSBweXJhbWlkZSAoVE1TKSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKiBAcmV0dXJucyB7R3AuUG9pbnR9IHBhcmFtcy5bbWF0cml4T3JpZ2luXSAgIC0gT3JpZ2luZSBkZSBsYSBtYXRyaWNlICh0b3AgbGVmdCBjb3JuZXIpLCBkYW5zIGxlIGNhcyBkJ3VuZSBjb3VjaGUgV01UU1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcGFyYW1zLltuYXRpdmVSZXNvbHV0aW9uc10gLSBUYWJsZWF1IHJlZ3JvdXBhbnQgbGVzIHLDqXNvbHV0aW9ucyBkZSBjaGFxdWUgbml2ZWF1IGRlIGxhIG1hdHJpY2UsIGRhbnMgbGUgY2FzIGQndW5lIGNvdWNoZSBXTVRTXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXJhbXMuW21hdHJpeElkc10gICAgICAgICAtIFRhYmxlYXUgcmVncm91cGFudCBsZXMgaWRlbnRpZmlhbnRzIGRlIGNoYXF1ZSBuaXZlYXUgZGUgbGEgbWF0cmljZSwgZGFucyBsZSBjYXMgZCd1bmUgY291Y2hlIFdNVFNcbiAgICAgKi9cbiAgICBnZXRMYXllclBhcmFtcyA6IGZ1bmN0aW9uIChsYXllck5hbWUsIHNlcnZpY2UsIGFwaUtleSkge1xuICAgICAgICB2YXIgcGFyYW1zID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdpZGVudGlmaWFudCBjb21wbGV0IGRlIGxhIGNvdWNoZS5cbiAgICAgICAgICAgIHZhciBsYXllcklkID0gdGhpcy5nZXRMYXllcklkKGxheWVyTmFtZSwgc2VydmljZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdvYmpldCBkZSBjb25maWd1cmF0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGUgZGUgbGEgY2xlZlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsYXllckNvbmYuYXBpS2V5c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRVJST1IgZGlmZmVyZW50IGtleXMgKFwiICsgYXBpS2V5ICsgXCIgIT09IFwiICsga2V5ICsgXCIpICE/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBpS2V5ID0gYXBpS2V5IHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3R5bGVzID0gbGF5ZXJDb25mLmdldERlZmF1bHRTdHlsZSgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSBsYXllckNvbmYuZ2V0RGVmYXVsdEZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wcm9qZWN0aW9uID0gbGF5ZXJDb25mLmdldERlZmF1bHRQcm9qZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgaW5mb3MgZGUgbGEgY291Y2hlXG4gICAgICAgICAgICAgICAgcGFyYW1zLm1pblNjYWxlID0gbGF5ZXJDb25mLmdldE1pblNjYWxlRGVub21pbmF0b3IoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWF4U2NhbGUgPSBsYXllckNvbmYuZ2V0TWF4U2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5leHRlbnQgPSBsYXllckNvbmYuZ2V0QkJPWCgpO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sZWdlbmRzID0gbGF5ZXJDb25mLmdldExlZ2VuZHMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMubWV0YWRhdGEgPSBsYXllckNvbmYuZ2V0TWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMub3JpZ2luYXRvcnMgPSBsYXllckNvbmYuZ2V0T3JpZ2luYXRvcnMoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMucXVpY2tsb29rVXJsID0gbGF5ZXJDb25mLmdldFF1aWNrbG9va1VybCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gV01UUyA6IHLDqWN1cMOpcmF0aW9uIGRlcyB0aWxlTWF0cml4U2V0TGltaXRzXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZi53bXRzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMudGlsZU1hdHJpeFNldExpbWl0cyA9IGxheWVyQ29uZi53bXRzT3B0aW9ucy50aWxlTWF0cml4U2V0TGltaXRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdNVFMgOiByw6ljdXDDqXJhdGlvbiBkZXMgcGFyYW3DqHRyZXMgZGUgbGEgcHlyYW1pZGUgKFRNUylcbiAgICAgICAgICAgICAgICB2YXIgVE1TTGluayA9IGxheWVyQ29uZi5nZXRUTVNJRCgpO1xuICAgICAgICAgICAgICAgIGlmIChUTVNMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5UTVNMaW5rID0gVE1TTGluaztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtc0NvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZ2V0VE1TQ29uZihUTVNMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG1hdHJpeCBvcmlnaW4gOiBHcC5Qb2ludCA9IE9iamVjdHt4OkZsb2F0LCB5OkZsb2F0fVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMubWF0cml4T3JpZ2luID0gdG1zQ29uZi5nZXRUb3BMZWZ0Q29ybmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5uYXRpdmVSZXNvbHV0aW9ucyA9IHRtc0NvbmYubmF0aXZlUmVzb2x1dGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5tYXRyaXhJZHMgPSB0bXNDb25mLm1hdHJpeElkcztcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRpbGVNYXRyaWNlcyA9IHRtc0NvbmYudGlsZU1hdHJpY2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY3VwZXJhdGlvbiBkZXMgcGFyYW1ldHJlcyBkJ3VuIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVzb3VyY2VdIC0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJTdHJlZXRBZGRyZXNzXCIsIFwiVm9pdHVyZVwiLCBcIlBpZXRvblwiLCAuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlcnZpY2VdIC0gR2VvY29kZSwgSXRpbmVyYWlyZSwgLi4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFthcGlLZXldICAtIENsw6kgZGUgY29udHJhdCBBUElcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbcOodHJlcyBkZSBsYSByZXNzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwYXJhbXMuIC1cbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlUGFyYW1zIDogZnVuY3Rpb24gKHJlc291cmNlLCBzZXJ2aWNlLCBhcGlLZXkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwnaWRlbnRpZmlhbnQgY29tcGxldCBkZSBsYSBjb3VjaGUuXG4gICAgICAgICAgICB2YXIgbGF5ZXJJZCA9IHRoaXMuZ2V0TGF5ZXJJZChyZXNvdXJjZSwgc2VydmljZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCdvYmpldCBkZSBjb25maWd1cmF0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLmNvbmZpZ3VyYXRpb24ubGF5ZXJzW2xheWVySWRdO1xuXG4gICAgICAgICAgICAgICAgLy8gY29udHJvbGUgZGUgbGEgY2xlZlxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBsYXllckNvbmYuYXBpS2V5c1swXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXBpS2V5ID0gYXBpS2V5IHx8IGtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXMua2V5ID0gYXBpS2V5O1xuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBwYXJhbcOodHJlcyBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IGxheWVyQ29uZi5nZXRTZXJ2ZXJVcmwoYXBpS2V5KTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudmVyc2lvbiA9IGxheWVyQ29uZi5nZXRTZXJ2aWNlUGFyYW1zKCkudmVyc2lvbjtcblxuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBpbmZvcyBkZSBsYSBjb3VjaGVcbiAgICAgICAgICAgICAgICBwYXJhbXMuZXh0ZW50ID0gbGF5ZXJDb25mLmdldEJCT1goKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMudGl0bGUgPSBsYXllckNvbmYuZ2V0VGl0bGUoKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZGVzY3JpcHRpb24gPSBsYXllckNvbmYuZ2V0RGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc29sdXRpb24gZW4gZ2VvZ3JhcGhpcXVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHJlc29sdXRpb25zXG4gICAgICovXG4gICAgZ2V0UmVzb2x1dGlvbnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXNvbHV0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHJlc29sdXRpb25zID0gdGhpcy5jb25maWd1cmF0aW9uW1wiZ2VuZXJhbE9wdGlvbnNcIl1bXCJ3Z3M4NFJlc29sdXRpb25zXCJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cGVyYXRpb24gZGVzIHBhcmFtZXRyZXMgVE1TIGRlIGxhIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG1zTmFtZSAtIHRpbGUgbWF0cml4IHNldCBuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aWxlIG1hdHJpeCBzZXRcbiAgICAgKi9cbiAgICBnZXRUaWxlTWF0cml4IDogZnVuY3Rpb24gKHRtc05hbWUpIHtcbiAgICAgICAgdmFyIHRtcyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0bXNOYW1lKSB7XG4gICAgICAgICAgICAgICAgdG1zID0gdGhpcy5jb25maWd1cmF0aW9uW1widGlsZU1hdHJpeFNldHNcIl1bdG1zTmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFLDqWN1cMOpcmF0aW9uIGRlcyBjb250cmFpbnRlcyBnw6luw6lyYWxlcyBkJ3VuZSBjb3VjaGUgZG9ubsOpZSA6IGV4dGVudCwgbWluU2NhbGUsIG1heFNjYWxlLCBwcm9qZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIGlkZW50aWZpYW50IGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHBhcmFtcyAtIGNvbnRyYWludGVzIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHBhcmFtcy5wcm9qZWN0aW9uIC0gUHJvamVjdGlvbiBwYXIgZMOpZmF1dCBkZSBsYSBjb3VjaGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwYXJhbXMubWluU2NhbGUgICAtIETDqW5vbWluYXRldXIgZCfDqWNoZWxsZSBtaW5pbXVtIGRlIGxhIGNvdWNoZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhcmFtcy5tYXhTY2FsZSAgIC0gRMOpbm9taW5hdGV1ciBkJ8OpY2hlbGxlIG1heGltdW0gZGUgbGEgY291Y2hlXG4gICAgICogQHJldHVybnMge0dwLkJCb3h9IHBhcmFtcy5leHRlbnQgICAgLSBFdGVuZHVlIGRlIGxhIGNvdWNoZSwgZGFucyBsYSBwcm9qZWN0aW9uIGRlIGxhIGNvdWNoZVxuICAgICAqL1xuICAgIGdldEdsb2JhbENvbnN0cmFpbnRzIDogZnVuY3Rpb24gKGxheWVySWQpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZSBsJ29iamV0IGRlIGNvbmZpZ3VyYXRpb24gZGUgbGEgY291Y2hlXG4gICAgICAgICAgICB2YXIgbGF5ZXJDb25mID0gdGhpcy5jb25maWd1cmF0aW9uLmxheWVyc1tsYXllcklkXTtcbiAgICAgICAgICAgIHBhcmFtcy5wcm9qZWN0aW9uID0gbGF5ZXJDb25mLmdldERlZmF1bHRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICBwYXJhbXMubWluU2NhbGUgPSBsYXllckNvbmYuZ2V0TWluU2NhbGVEZW5vbWluYXRvcigpO1xuICAgICAgICAgICAgcGFyYW1zLm1heFNjYWxlID0gbGF5ZXJDb25mLmdldE1heFNjYWxlRGVub21pbmF0b3IoKTtcbiAgICAgICAgICAgIHBhcmFtcy5leHRlbnQgPSBsYXllckNvbmYuZ2V0QkJPWCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb25maWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tbW9uL1V0aWxzL0NvbmZpZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * @brief Geoportal resources access library\n *\n * This software is released under the licence CeCILL-B (Free BSD compatible)\n * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt\n * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt\n * @see http://www.cecill.info/\n *\n * copyright CeCILL-B\n * copyright IGN\n * @author IGN\n * @version 2.0.0\n * @date 2018-04-05\n *\n */\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.4\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(10), __webpack_require__(11));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Gp\", [\"require\", \"require\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Gp\"] = factory(require(\"xmldom\"), require(\"request\"));\n\telse\n\t\troot[\"Gp\"] = factory(root[undefined], root[undefined]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_20__, __WEBPACK_EXTERNAL_MODULE_52__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 43);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_loglevel__ = __webpack_require__(47);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_loglevel___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_loglevel__);\n/* global __PRODUCTION__ */\n\n\nvar LoggerByDefault = {\n    /**\n     * logger statique\n     *\n     * @static\n     * @param {String} name - nom du logger\n     * @returns {Object} retourne un logger\n     */\n    getLogger : function (name) {\n        // Substitute global constants configured at compile time\n        // cf. webpack.config.js\n        ( false) ? Log.disableAll() : __WEBPACK_IMPORTED_MODULE_0_loglevel__[\"enableAll\"]();\n        var logname = name || \"default\";\n        return __WEBPACK_IMPORTED_MODULE_0_loglevel__[\"getLogger\"](logname);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LoggerByDefault);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Classe de gestion des erreurs qui permer d'associer un message d'erreur à l'exception lancée.\n *\n * @example\n * MessagesResources.getMessage(\"ERROR_PARAM_MISSING\", \"x\", \"y\", \"z\")));\n * // --> output : Parameter(s) 'x - y - z' missing\n *\n * @module MessagesResources\n * @alias Gp.Utils.MessagesResources\n * @private\n */\nvar MessagesResources = {\n\n    // Paramètres\n    PARAM_MISSING : \"Parameter(s) '%var%' missing\",\n    PARAM_EMPTY : \"Parameter(s) '%var%' empty\",\n    PARAM_TYPE : \"Wrong type(s) for parameter(s) '%var%'\",\n    PARAM_FORMAT : \"Parameter(s) '%var%' not correctly formatted\",\n    PARAM_NOT_SUPPORT : \"Value(s) for parameter(s) '%var%' not supported\",\n    PARAM_NOT_SUPPORT_NODEJS : \"Value(s) for parameter(s) '%var%' not supported to NodeJS\",\n    PARAM_UNKNOWN : \"Value(s) for parameter(s) '%var%' unknown\",\n\n    // Services\n    // Requête\n    SERVICE_REQUEST_BUILD : \"An error occurred during the request building of the service\",\n    SERVICE_REQUEST_EMPTY : \"The request sent to the service is empty\",\n\n    // Réponse\n    SERVICE_RESPONSE_EXCEPTION : \"The service returned an exception : '%var%'\",\n    SERVICE_RESPONSE_EXCEPTION_2 : \"The service returned an exception\",\n    SERVICE_RESPONSE_ANALYSE : \"An error occurred while parsing the response '%var%' of the service\",\n    SERVICE_RESPONSE_ANALYSE_2 : \"An unknown error occurred while parsing the response\",\n    SERVICE_RESPONSE_EMPTY : \"The response of the service is empty\",\n    SERVICE_RESPONSE_EMPTY_2 : \"The response from the service could not be analyzed or is empty\",\n    SERVICE_RESPONSE_FORMAT : \"The format of the service response is not supported (handled format(s) : '%var%')\",\n    SERVICE_RESPONSE_FORMAT_2 : \"The format of the service response is not supported\",\n    SERVICE_RESPONSE_FORMAT_3 : \"No suggestion matching the search\",\n\n    // Classes\n    CLASS_CONSTRUCTOR : \"'%var%' constructor cannot be called as a function.\",\n\n    /**\n     * Fonction qui va retourner le message d'erreur associé à la clé donnée\n     *\n     * @method getMessage\n     * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)\n     * @param {String[]} parametres - Paramètres/variables concernés par le message d'erreur associé à la clef donnée\n     * @return {String} message - String contenant le message de l'exception\n     */\n    getMessage : function (clef, parametres) {\n        // param de la fonction uniquement pour la documentation...\n\n        if (Object.keys(arguments).length === 0) {\n            return \"Message indefined !\";\n        }\n\n        var params = Array.prototype.slice.call(arguments);\n        var key = params.shift();\n        var args = params;\n\n        var message = this[key];\n\n        try {\n            if (Array.isArray(args) && args.length > 0) {\n                message = message.replace(\"%var%\", args.join(\" - \"));\n            } else {\n                message = message.replace(\"%var%\", \"%var% (not specified)\");\n            }\n        } catch (e) {\n            // error de string.replace()\n\n        }\n\n        return message;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MessagesResources);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Errors raised by API for one among three reasons : wrong API usage, underlying service error or unknown reason.\n *\n * @property {String} message - Error message\n * @property {Number} status - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} ; -1 otherwise.\n * @property {String} type - Error type ({@link Gp.Error.TYPE_SRVERR}, {@link Gp.Error.TYPE_USEERR} or {@link Gp.Error.TYPE_UNKERR}).\n *\n * @namespace\n * @alias Gp.Error\n * @param {Object|String} error - Options for creating error object. Can be a String (message) or an Object.\n * @param {String} error.message - Error message to return to user.\n * @param {enum} [error.type=TYPE_UNKERR] - Error type\n * @param {status} [error.status=-1] - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}.\n *\n */\nfunction ErrorService (error) {\n    if (!(this instanceof ErrorService)) {\n        throw new TypeError(\"ErrorService constructor cannot be called as a function.\");\n    }\n\n    var e = error;\n    if (typeof error === \"string\" || error instanceof String) {\n        this.message = error;\n        this.status = -1;\n        this.type = ErrorService.TYPE_UNKERR;\n    } else {\n        this.message = e.message || \"undefined!?\";\n        this.type = e.type;\n        this.status = e.status || -1;\n    }\n\n    this.name = \"ErrorService\";\n    this.stack = (new Error()).stack;\n}\n\n/**\n * Error raised when underlying geoportal service answers on error.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_SRVERR = \"SERVICE_ERROR\";\n/**\n * Error raised when funcion use is inappropriate\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_USEERR = \"USAGE_ERROR\";\n/**\n * Error raised when API can't perform the job for a reason other than the two other ones.\n *\n * @type {String}\n * @constant\n * @static\n */\nErrorService.TYPE_UNKERR = \"UNKNOWN_ERROR\";\n\n/**\n * @lends module:ErrorService\n */\nErrorService.prototype = Object.create(Error.prototype, {\n    constructor : {\n        value : ErrorService,\n        writable : true,\n        configurable : true\n    }\n});\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ErrorService);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Protocols_Protocol__ = __webpack_require__(48);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DefaultUrlService__ = __webpack_require__(5);\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Composant Service\n *\n * @constructor\n * @alias Gp.Services.CommonService\n * @param {Object} options - options communes à tous les services\n *\n * @param {String} options.apiKey - Clef d'accès à la plateforme Géoportail,\n *      nécessaire pour franchir la couche de contrôle des accès pour avoir une réponse du service invoqué.\n *      Plusieurs clefs peuvent être passées dans le cas de l'invocation du service d'autoconfiguration.\n *      Si ce paramètre n'est pas renseigné, alors le paramètre serverUrl doit être renseigné (comprenant alors, si nécessaire la clef API).\n *\n * @param {String} options.serverUrl - URL d'accès au service.\n *      Permet de forcer l'utilisation d'un service équivalent déployé derrière une éventuelle autre URL d'accès.\n *      Si ce paramètre est renseigné alors, le paramètre apiKey est ignoré.\n *\n * @param {String} [options.protocol] - Le protocole à utiliser pour récupérer les informations du service :\n *      peut valoir 'JSONP' ou 'XHR'.\n *      Par défaut, c'est le protocole XHR qui sera utilisé.\n *      Attention, le protocole JSONP n'est pas valide dans un environnement NodeJS (Utilisation du mode XHR).\n *\n * @param {Boolean} [options.ssl] - Indique si l'on souhaite intérroger les services en https.\n *      Ce paramètre ne fonctionne que pour une utilisation hors navigateur (ex. NodeJS).\n *      Sur un navigateur, le protocole est automatiquement extrait de l'url du site...\n *      Par défaut, on utilise le protocole http (ssl=false).\n *\n * @param {String} [options.proxyURL] - Le proxy à utiliser pour pallier au problème de cross-domain dans le cas d'une requête XHR.\n *      Utile si le paramètre 'protocol' vaut 'XHR', il ne sera pas pris en compte si protocol vaut JSONP.\n *\n * @param {String} [options.callbackSuffix] - Suffixe de la fonction de callback à utiliser, dans le cas du protocole JSONP.\n *      Par défaut, la fonction de callback portera un nom du type \"callback\"+ID, où ID est soit un identifiant unique généré à chaque requête,\n *      soit le paramètre callbackSuffix s'il est spécifié. Par exemple, si callbackSuffix=\"_2\", la fonction sera \"callback_2 ()\".\n *      Utile pour utiliser une réponse déjà encapsulée dans une fonction de callback, dont le nom est connu (ex : chargement de l'autoconfiguration en local)\n *      Utile seulement si le paramètre 'protocol' vaut 'JSONP', il ne sera pas pris en compte si protocol vaut 'XHR'.\n *\n * @param {String} [options.httpMethod] - La méthode HTTP\n *      à utiliser dans le cas d'une requête XHR : peut valoir 'GET' ou 'POST'.\n *      Non pris en compte si 'protocol' vaut JSONP qui fonctionne obligatoirement en GET.\n *      Par défaut, c'est la méthode GET qui est utilisée.\n *\n * @param {String} [options.contentType] - Content-Type de la requete\n *      à utiliser dans le cas d'une requête XHR en mode POST.\n *      Non pris en compte si 'protocol' vaut JSONP et/ou la méthode HTTP vaut GET.\n *      Par défaut, c'est la méthode GET qui est utilisée donc on n'utilise pas de Content-Type.\n *\n * @param {Number} [options.timeOut] - Délai d'attente maximal (en ms) de la réponse du service (à partir de l'envoi de la requête).\n *      Par défaut, aucun timeOut n'est pris en compte (timeoutDelay= 0).\n *\n * @param {Boolean} [options.rawResponse] - Indique si l'on souhaite que la réponse du service ne soit pas parsée par l'API avant d'être restituée.\n *      (Cf. paramètre « onSuccess » pour plus de détails).\n *\n * @param {Function} [options.onSuccess] - Fonction appelée lorsque le service répond correctement à la requête\n *      (code HTTP 200, sans message d'erreur).\n *      Cette fonction prend en paramètre la réponse du service,\n *      soit sous la forme d'un Object Javascript formaté par le parseur dédié à la syntaxe du service (comportement par défaut) ;\n *      soit brute au format String non prétraité si le paramètre « rawResponse » a été précisé avec la valeur « true ».\n *\n * @param {Function} [options.onFailure] - Fonction appelée lorsque le service ne répond pas correctement\n *      (code HTTP de retour différent de 200 ou pas de réponse).\n *\n * @param {Function} [options.onBeforeParse] - Fonction appelée avant le parsing de la réponse\n *      Permet de modifier la réponse avant parsing si la fonction retourne une String.\n *      Cette fonction prend en paramètre la réponse XML telle que renvoyée par le service,\n *      sous la forme d'une chaîne de caractères (comportement par défaut).\n *      Si le paramètre \"rawResponse\" a été précisé avec la valeur \"true\",\n *      la fonction prend en paramètre un Object JavaScript contenant la réponse XML.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      ssl : false,\n *      proxyURL : null,\n *      callbackName : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      onBeforeParse : function (rawResponse) {}\n *   };\n * @private\n */\nfunction CommonService (options) {\n    if (!(this instanceof CommonService)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\"));\n    }\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"CommonService\");\n    this.logger.trace(\"[Constructeur CommonService (options)]\");\n\n    // #####################\n    // récupération des options par défaut pour les paramètres optionnels\n    // #####################\n\n    /**\n     * Options du service\n     * @type {Object}\n     */\n    this.options = {\n        // protocol : \"JSONP\",\n        protocol : \"XHR\",\n        ssl : false,\n        proxyURL : \"\",\n        // callbackName : \"\",\n        callbackSuffix : null,\n        httpMethod : \"GET\",\n        timeOut : 0,\n        rawResponse : false,\n        scope : this,\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        onSuccess : function (response) {\n            console.log(\"onSuccess - la reponse est la suivante : \", response);\n        },\n        /**\n        * callback par defaut pour les erreurs\n        * @param {Object} error - error\n        * @private\n        */\n        onFailure : function (error) {\n            if (error.status === 200 || !error.status) {\n                console.log(\"onFailure : \", error.message);\n            } else {\n                console.log(\"onFailure - Erreur (\", error.status, \") : \", error.message);\n            }\n        }\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    // gestion des clefs API\n    if (!this.options.apiKey && !this.options.serverUrl) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"apiKey\", \"serverUrl\"));\n    }\n\n    // modification de la fonction de callback onSuccess dans le cas où la réponse brute est demandée\n    if (this.options.rawResponse && !this.options.onSuccess) {\n        /**\n        * callback par defaut pour la reponse\n        * @param {Object} response - response\n        * @private\n        */\n        this.options.onSuccess = function (response) {\n            console.log(\"onSuccess - la réponse brute du service est la suivante : \", response);\n        };\n    }\n\n    // gestion du callback onSuccess\n    var bOnSuccess = !!((this.options.onSuccess !== null && typeof this.options.onSuccess === \"function\"));\n    if (!bOnSuccess) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"onSuccess()\"));\n    }\n\n    // gestion de l'url du service par defaut\n    if (!this.options.serverUrl) {\n        // INFO\n        // gestion de l'url du service par defaut pour les services qui ne possèdent qu'une seul url par defaut\n        // les cas particuliers des services avec plusieurs urls (ex. Alti) devront être traité dans la classe du composant\n        // donc si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n        __WEBPACK_IMPORTED_MODULE_5__DefaultUrlService__[\"a\" /* default */].ssl = this.options.ssl;\n        var urlByDefault = __WEBPACK_IMPORTED_MODULE_5__DefaultUrlService__[\"a\" /* default */][this.CLASSNAME].url(this.options.apiKey);\n        if (typeof urlByDefault === \"string\") {\n            this.options.serverUrl = urlByDefault;\n        } else {\n            this.logger.trace(\"URL par defaut à determiner au niveau du composant...\");\n        }\n    }\n\n    // FIXME nettoyage des KVP dans l'url du service\n    // if (this.options.serverUrl) {\n    //     // INFO\n    //     // si l'url est renseignée, il faut la nettoyer de tous ses KVP\n    //     // ex. on ne veut pas de params. 'callback' ou 'output' car ceci declencherait\n    //     // des opérations d'encapsulations des reponses légèrement farfelues ...\n    //     var urlsource = this.options.serverUrl;\n    //     var urlparts = urlsource.split(\"?\");\n    //     this.options.serverUrl = urlparts[0];\n    // }\n\n    // gestion de la methode HTTP\n    this.options.httpMethod = (typeof options.httpMethod === \"string\") ? options.httpMethod.toUpperCase() : \"GET\";\n\n    switch (this.options.httpMethod) {\n        case \"POST\":\n        case \"GET\":\n            break;\n        case \"PUT\":\n        case \"DELETE\":\n        case \"HEAD\":\n        case \"OPTIONS\":\n            throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_NOT_SUPPORT\", \"httpMethod\"));\n        default:\n            throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_UNKNOWN\", \"httpMethod\"));\n    }\n\n    // gestion du protocole\n    // this.options.protocol = (typeof options.protocol === \"string\" ) ? options.protocol.toUpperCase() : \"JSONP\";\n    this.options.protocol = (typeof options.protocol === \"string\") ? options.protocol.toUpperCase() : \"XHR\";\n\n    switch (this.options.protocol) {\n        case \"JSONP\":\n        case \"XHR\":\n            break;\n        default:\n            throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_UNKNOWN\", \"protocol\"));\n    }\n\n    // on determine l'environnement d'execution : browser ou non ?\n    // et on lance une exception sur l'utilisation du protocole JSONP pour nodeJS...\n    if (typeof window === \"undefined\" && this.options.protocol === \"JSONP\") {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_2__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_NOT_SUPPORT_NODEJS\", \"protocol=JSONP (instead use XHR)\"));\n    }\n\n    // le protocole JSONP ne fonctionne qu'en GET.\n    if (this.options.protocol === \"JSONP\") {\n        this.options.httpMethod = \"GET\";\n    }\n\n    // gestion du cache\n    this.options.nocache = options.nocache || false;\n\n    // #####################\n    // attributs d'instances\n    // #####################\n\n    /**\n     * Format de réponse du service\n     */\n    this.options.outputFormat = null;\n    /**\n     * Requête envoyée au service\n     */\n    this.request = null;\n    /**\n     * Reponse du service\n     */\n    this.response = null;\n}\n\n/**\n * @lends module:CommonService\n */\nCommonService.prototype = {\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : CommonService,\n\n    /**\n     * Appel du service Géoportail\n     */\n    call : function () {\n        /* jshint validthis : true */\n        this.logger.trace(\"CommonService::call ()\");\n\n        var context = this;\n        /** fonction d'execution */\n        function run () {\n            this.logger.trace(\"CommonService::run ()\");\n            this.buildRequest.call(context, onError, onBuildRequest);\n        }\n\n        run.call(context);\n\n        /** callback de fin de construction de la requête */\n        function onBuildRequest (result) {\n            this.logger.trace(\"CommonService::onBuildRequest : \", result);\n            this.callService.call(context, onError, onCallService);\n        }\n\n        /** callback de fin d'appel au service */\n        function onCallService (result) {\n            this.logger.trace(\"CommonService::onCallService : \", result);\n            this.analyzeResponse.call(context, onError, onAnalyzeResponse);\n        }\n\n        /** callback de fin de lecture de la reponse */\n        function onAnalyzeResponse (result) {\n            this.logger.trace(\"CommonService::onAnalyzeResponse : \", result);\n            if (result) {\n                this.options.onSuccess.call(this, result);\n            } else {\n                return onError.call(this, new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */](\"Analyse de la reponse en échec !?\"));\n            }\n        }\n\n        /** callback de gestion des erreurs : renvoit un objet de type ErrorService */\n        function onError (error) {\n            this.logger.trace(\"CommonService::onError()\");\n            // error : l'objet est du type ErrorService ou Error\n            var e = error;\n            if (!(e instanceof __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */])) {\n                e = new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */](error.message);\n            }\n            this.options.onFailure.call(this, e);\n        }\n    },\n\n    /**\n     * Création de la requête\n     */\n    buildRequest : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet 'this.request'\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    },\n\n    /**\n     * Appel du service\n     */\n    callService : function (error, success) {\n        // INFO\n        // retourne l'objet 'this.response'\n\n        // NOTES\n        //  Pour le mode XHR, on recupère une reponse sous forme d'une string. Le content\n        //  est donc du JSON natif ou du XML en fonction du service demandé (pas d'encapsulation !).\n        //  Pour le mode JSONP, on a toujours un objet JSON mais sous 2 formats :\n        //      - natif\n        //      - XML encapsulé :\n        //          {http : {status:200, error:null},xml :'réponse du service'}\n        //          {http : {status:400, error:'reponse du service'},xml :null}\n        //  En XHR, la reponse est directement sauvegardée dans 'this.response'.\n        //  Par contre, en JSONP, on doit analyser la reponse (status ou non vide),\n        //  et ne renvoyer que le contenu (xml ou l'objet)\n\n        // gestion de la proxification du service\n        var strUrlProxified = null;\n        var strData = this.request;\n\n        // a t on mis en place un proxy ?\n        // la proxyfication est valable uniquement en mode XHR !\n        var bUrlProxified = !!((this.options.proxyURL && this.options.protocol === \"XHR\"));\n\n        // rajout de l'option gpbibaccess\n        // FIXME : acces au numero de version de package.conf\n        /*\n        var scope = typeof window !== \"undefined\" ? window : {};\n        var servicesVersion = scope.Gp ? scope.Gp.servicesVersion : \"2.0.0\";\n        */\n        this.options.serverUrl = __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__[\"a\" /* default */].normalyzeUrl(this.options.serverUrl, {\n            \"gp-access-lib\" : \"2.0.0\"\n        }, false);\n\n        // si le proxy est renseigné, on proxifie l'url du service\n        if (bUrlProxified) {\n            if (this.options.httpMethod === \"GET\") {\n                strUrlProxified = this.options.proxyURL + __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__[\"a\" /* default */].normalyzeUrl(this.options.serverUrl, this.request, true);\n                strData = null;\n            }\n\n            if (this.options.httpMethod === \"POST\") {\n                strUrlProxified = this.options.proxyURL + __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__[\"a\" /* default */].normalyzeUrl(this.options.serverUrl, null, true);\n                strData = this.request;\n            }\n        }\n\n        // contexte du composant spécifique !\n        var self = this;\n\n        var options = {\n            url : strUrlProxified || this.options.serverUrl,\n            method : this.options.httpMethod,\n            protocol : this.options.protocol,\n            timeOut : this.options.timeOut || 0,\n            format : this.options.outputFormat, // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !\n            nocache : this.options.nocache || false, // ceci permet d'ajouter un timestamp dans la requête\n            wrap : this.options.protocol !== \"XHR\", // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !\n            callbackSuffix : this.options.callbackSuffix,\n            // callbackName : this.options.callbackName || null,\n            data : strData,\n            headers : null, // TODO...\n            content : this.options.contentType || \"application/xml\",\n            scope : this.options.scope || this,\n            /** callback de reponse */\n            onResponse : function (response) {\n                self.logger.trace(\"callService::onResponse()\");\n\n                // le contenu de la reponse à renvoyer !\n                var content = null;\n\n                // XHR : on renvoie la reponse brute (string)\n                if (self.options.protocol === \"XHR\") {\n                    // on ne peut pas savoir si la reponse est en XML ou JSON\n                    // donc on laisse le boulot à l'analyse de la reponse !\n                    content = response;\n                }\n\n                // JSONP : on doit analyser le contenu (json)\n                if (self.options.protocol === \"JSONP\") {\n                    self.logger.trace(\"Response JSON\", response);\n                    if (response) {\n                        // reponse encapsulée : {http : {status:200, error:null},xml :'réponse du service'}\n                        if (response.http) {\n                            if (response.http.status !== 200) {\n                                error.call(self, new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */]({\n                                    status : response.http.status,\n                                    message : response.http.error,\n                                    type : __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                                }));\n                                return;\n                            } else {\n                                content = response.xml; // par defaut !\n                                if (self.options.rawResponse) {\n                                    content = response;\n                                }\n                                if (typeof self.options.onBeforeParse === \"function\") {\n                                    var newResponse = self.options.onBeforeParse(content);\n                                    if (typeof newResponse === \"string\") {\n                                        content = newResponse;\n                                    }\n                                }\n                            }\n                        } else {\n                            content = response;\n                        }\n                    } else {\n                        error.call(self, new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */](\"Le contenu de la reponse est vide !?\"));\n                        return;\n                    }\n                }\n\n                // sauvegarde de la reponse dans l'objet parent (CommonService)\n                self.response = content;\n\n                // on renvoie la reponse...\n                success.call(self, content);\n            },\n            /** callback des erreurs */\n            onFailure : function (e) {\n                self.logger.trace(\"callService::onFailure()\");\n                // on est forcement sur une erreur levée par un service !\n                e.type = __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR;\n                error.call(self, new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */](e));\n            },\n            /** callback de timeOut */\n            onTimeOut : function () {\n                self.logger.trace(\"callService::onTimeOut()\");\n                error.call(self, new __WEBPACK_IMPORTED_MODULE_4__Exceptions_ErrorService__[\"a\" /* default */](\"TimeOut!\"));\n            }\n        };\n\n        __WEBPACK_IMPORTED_MODULE_3__Protocols_Protocol__[\"a\" /* default */].send(options);\n    },\n\n    /**\n     * Analyse de la réponse\n     */\n    analyzeResponse : function (error, success) {\n        // INFO\n        this.logger.error(\"overwritten method !\");\n        // retourne l'objet spécifique au type de composant (json)\n        if (error) {\n            error.call(this, \"This method must be overwritten !\");\n        }\n        success.call(this, \"This method must be overwritten !\");\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CommonService);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Classe utilitaire\n *\n * @module Helper\n * @private\n * @alias Gp.Utils.Helper\n */\nvar Helper = {\n\n    /**\n     * concatenation des parametres key/value dans les urls\n     *\n     * @method normalyzeParameters\n     * @static\n     * @param {Object} params - tableau de clef/valeur\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeParameters ({\n     *         key1:value1,\n     *         key2:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne les paramètres concaténés\n     */\n    normalyzeParameters : function (params) {\n        var myParams = null;\n\n        if (params) {\n            var tabParams = [];\n            for (var key in params) {\n                if (params.hasOwnProperty(key)) {\n                    var value = params[key];\n                    if (!value) {\n                        value = \"\";\n                    }\n                    tabParams.push(key + \"=\" + value);\n                }\n            }\n\n            myParams = tabParams.join(\"&\");\n        }\n\n        return myParams;\n    },\n\n    /**\n     * Concaténation et encodage des urls.\n     *\n     * @method normalyzeUrl\n     * @static\n     * @param {String} url - url\n     * @param {Object|String} params - tableau de clef/valeur ou string\n     * @param {Boolean} encode - true|false, false par defaut\n     *\n     * @example\n     *  Gp.Utils.Helper.normalyzeUrl (url, {\n     *         key1:value1,\n     *         key2=:value2,\n     *         key3:value3\n     *  });\n     *  // out : \"url?key1=value1&key2=value2&key3=value3\"\n     *\n     * @returns {String} retourne une url normalisée\n     */\n    normalyzeUrl : function (url, params, encode) {\n        var myUrl = url;\n\n        if (url) {\n            var k = url.indexOf(\"?\");\n            if (k === -1) { // pas de ? et KVP\n                myUrl += \"?\";\n            }\n\n            if (k !== -1 && k !== url.length - 1) { // KVP\n                myUrl += \"&\";\n            }\n        }\n\n        if (params) {\n            if (typeof params === \"string\") {\n                myUrl += params;\n            } else {\n                myUrl += this.normalyzeParameters(params);\n            }\n        }\n\n        if (encode) {\n            // FIXME bonne idée ?\n            myUrl = encodeURIComponent(myUrl);\n        }\n\n        return myUrl;\n    },\n\n    /**\n     * Indentation d'une chaine\n     *\n     * @param {Number} n - nombre de tabulation\n     * @param {String} msg - chaine\n     *\n     * @example\n     * Gp.Utils.Helper.indent (2, \"message à indenter\")\n     * // out\n     * // ........message à indenter\n     *\n     * @returns {String} retourne une chaine indentée\n     */\n    indent : function (n, msg) {\n        var num = n || 0;\n        return new Array(num + 1).join(\"\\t\") + msg;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Helper);\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// cette classe contient les URLs par defaut des services.\n//  DefaultUrlService.Alti.url(key)[elevation-json]\n//  DefaultUrlService.Alti.url(key)[elevation-xml]\n//  DefaultUrlService.Alti.url(key)[profil-json]\n//  DefaultUrlService.Alti.url(key)[profil-xml]\n//  DefaultUrlService.Alti.url(key)[wps]\n//  DefaultUrlService.ProcessIsoCurve.url(key)\n//  DefaultUrlService.AutoComplete.url(key)\n//  DefaultUrlService.ReverseGeocode.url(key)\n//  DefaultUrlService.AutoConf.url(key)[apiKey]\n//  DefaultUrlService.AutoConf.url(key)[apiKeys]\n//  DefaultUrlService.AutoConf.url(key)[aggregate]\n//  DefaultUrlService.Geocode.url(key)\n//  DefaultUrlService.Route.url(key)\n\n// Example :\n//\n// DefaultUrlService.Alti.url('efe4r54tj4uy5i78o7545eaz7e87a')[elevation-json]\n//  output {String} -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/rest/elevation.json\n//\n// DefaultUrlService.Alti.url('efe4r54tj4uy5i78o7545eaz7e87a')\n// output {Object|String}\n// -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/rest/elevation.json\n// -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/rest/elevation.xml\n// -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/rest/elevationLine.json\n// -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/rest/elevationLine.xml\n// -> http://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/alti/wps\n//\n// Force ssl :\n//\n// DefaultUrlService.ssl = true;\n// DefaultUrlService.AutoComplete.url('efe4r54tj4uy5i78o7545eaz7e87a')\n// output {Object|String}\n// -> https://wxs.ign.fr/efe4r54tj4uy5i78o7545eaz7e87a/ols/apis/completion\n\n// constantes internes\nvar ISBROWSER = typeof window !== \"undefined\" ? 1 : 0;\nvar HOSTNAME = \"wxs.ign.fr\";\n\n/**\n * Default Geoportal web services URLs access.\n *\n * @namespace\n * @alias Gp.Services.DefaultUrl\n */\nvar DefaultUrlService = {\n\n    /** if set true, require the use of https protocol (except browser) */\n    ssl : false,\n\n    /**\n    * base url of services (ssl protocol management)\n    * @param {String} key - key\n    * @param {String} path - path\n    * @returns {String} url\n    */\n    url : function (key, path) {\n        // en mode browser, c'est le protocole du navigateur,\n        // sinon, il est fixé par l'option 'ssl' (par défaut à false, cad en http)\n        var _protocol = (ISBROWSER) ? (location && location.protocol && location.protocol.indexOf(\"https:\") === 0 ? \"https://\" : \"http://\") : (DefaultUrlService.ssl ? \"https://\" : \"http://\");\n        return _protocol + HOSTNAME.concat(\"/\", key, path);\n    },\n\n    /**\n     * Elevation web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"elevation-json\", \"elevation-xml\", \"profil-json\" or \"profil-xml\").\n     */\n    Alti : {\n        _key : {\n            // rest\n            \"elevation-json\" : \"/alti/rest/elevation.json\",\n            \"elevation-xml\" : \"/alti/rest/elevation.xml\",\n            \"profil-json\" : \"/alti/rest/elevationLine.json\",\n            \"profil-xml\" : \"/alti/rest/elevationLine.xml\",\n            // other\n            wps : \"/alti/wps\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return {\n                // rest\n                \"elevation-json\" : DefaultUrlService.url(key, this._key[\"elevation-json\"]),\n                \"elevation-xml\" : DefaultUrlService.url(key, this._key[\"elevation-xml\"]),\n                \"profil-json\" : DefaultUrlService.url(key, this._key[\"profil-json\"]),\n                \"profil-xml\" : DefaultUrlService.url(key, this._key[\"profil-xml\"]),\n                // other\n                wps : DefaultUrlService.url(key, this._key[\"wps\"])\n            };\n        }\n    },\n    /**\n     * IsoCurve web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"iso-json\" or \"iso-xml\").\n     */\n    ProcessIsoCurve : {\n        _key : {\n            \"iso-json\" : \"/isochrone/isochrone.json\", // rest (geoconcept)\n            \"iso-xml\" : \"/isochrone/isochrone.xml\" // rest (geoconcept)\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return {\n                \"iso-json\" : DefaultUrlService.url(key, this._key[\"iso-json\"]),\n                \"iso-xml\" : DefaultUrlService.url(key, this._key[\"iso-xml\"])\n            };\n        }\n    },\n    /**\n     * Autocompletion web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    AutoComplete : {\n        _key : \"/ols/apis/completion\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Reverse geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    ReverseGeocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Autoconfiguration web service access\n     *\n     * @member {Object}\n     * @property {Function} url ([key1,...]) - Returns autoconfiguration service default urls with geoportal access key (s) given as a String array parameter. The result is a javascript object with different urls given the access mode (\"apiKey\", \"apiKeys\" or \"aggregate\").\n     */\n    AutoConf : {\n        _key : {\n            apiKey : \"/autoconf\",\n            apiKeys : \"/autoconf?keys=%KEYS%\",\n            aggregate : \"/autoconf/id/\"\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            var keys = \"\";\n            if (Array.isArray(key) && key.length > 0) {\n                keys = key[0];\n                for (var i = 1; i < key.length; i++) {\n                    keys += \",\" + key[i];\n                }\n            }\n            return {\n                apiKey : DefaultUrlService.url(key, this._key[\"apiKey\"]), // une seule clé\n                apiKeys : DefaultUrlService.url(key[0], this._key[\"apiKeys\"]).replace(\"%KEYS%\", keys), // autoconf de plusieurs clés\n                aggregate : DefaultUrlService.url(key, this._key[\"aggregate\"])\n            };\n        }\n    },\n    /**\n     * Geocoding web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.\n     */\n    Geocode : {\n        _key : \"/geoportail/ols\",\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return DefaultUrlService.url(key, this._key);\n        }\n    },\n    /**\n     * Routing web service access\n     *\n     * @member {Object}\n     * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols (\"route-json\" or \"route-xml\").\n     */\n    Route : {\n        _key : {\n            ols : \"/itineraire/ols\", // openLS\n            \"route-json\" : \"/itineraire/rest/route.json\", // rest (geoconcept)\n            \"route-xml\" : \"/itineraire/rest/route.xml\" // rest (geoconcept)\n        },\n        /**\n        * url\n        * @param {String} key - key\n        * @returns {String} url\n        */\n        url : function (key) {\n            return {\n                ols : DefaultUrlService.url(key, this._key[\"ols\"]),\n                \"route-json\" : DefaultUrlService.url(key, this._key[\"route-json\"]),\n                \"route-xml\" : DefaultUrlService.url(key, this._key[\"route-xml\"])\n            };\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefaultUrlService);\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* global require */\n\n\n// import __xmldom from \"xmldom\";\n\n/**\n * @classdesc\n *\n * Classe permettant d'écrire ou de lire du XML, sous forme de document DOM,\n * éventuellement selon des clés de lecture (readers) ou d'écriture (writers) spécifiques.\n *\n * @constructor\n * @alias Gp.Formats.XML\n *\n * @param {Object} [options] - options du format XML\n *\n * @param {Object} [options.reader] - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)\n *      utile pour interpréter le XML lorsque sa structure est connue.\n *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.\n *\n * @param {Object} [options.writers] - writers\n *\n * @param {String} [options.xmlString] - chaîne de caractère contenant du XML à interpréter.\n *\n * @private\n */\nfunction XML (options) {\n    if (!(this instanceof XML)) {\n        throw new TypeError(\"XML constructor cannot be called as a function.\");\n    }\n\n    // FIXME : notion de singleton\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur XML ()]\");\n\n    /**\n     * Chaîne de caractères contenant le texte XML\n     * @type {String}\n     */\n    this.xmlString = null;\n\n    /**\n     * DOM Element correspondant à la structure du XML.\n     * @type {DOMElement}\n     */\n    this.xmlDoc = null;\n\n    /**\n     * Objet contenant des fonctions de lecture des différentes balises XML.\n     * @type {Object}\n     */\n    this.reader = null;\n\n    // traitement des paramètres d'options s'il y en a\n    if (options) {\n        if (options.xmlString && typeof options.xmlString === \"string\") {\n            this.xmlString = options.xmlString;\n            // Si une chaine de caractère a été passée en entrée : on la transforme aussi en XML document\n            this.xmlDoc = __getXMLDOC(options.xmlString);\n        }\n        if (options.reader) {\n            this.setReader(options.reader);\n        }\n    }\n}\n\nXML.prototype = {\n\n    /**\n     * @lends module:XML\n     */\n\n    /*\n     * Constructeur (alias)\n     */\n    constructor : XML,\n\n    /**\n     * Méthode permettant de récupérer la chaîne de caractères associée au format XML\n     *\n     * @returns {String} xmlString - la chaîne de caractères correspondant au format XML\n     */\n    getXMLString : function () {\n        return this.xmlString;\n    },\n\n    /**\n     * Méthode permettant d'attribuer une chaîne de caractères au format XML (attribut xmlString).\n     * La méthode va aussi transformer cette chaîne de caractères en document XML,\n     * afin de remplir l'attribut xmlDoc.\n     *\n     * @param {String} xmlString - la chaîne de caractères correspondant au format XML\n     */\n    setXMLString : function (xmlString) {\n        if (xmlString && typeof xmlString === \"string\") {\n            this.xmlString = xmlString;\n            this.xmlDoc = __getXMLDOC(xmlString);\n        }\n    },\n\n    /**\n     * Méthode permettant de récupérer les readers associés au format XML, s'ils ont été définis\n     *\n     * @return {Object} readers - les readers associés au format XML, s'ils existent,\n     *      sous forme d'une collection de fonctions\n     */\n    getReader : function () {\n        return this.reader;\n    },\n\n    /**\n     * Méthode permettant d'attribuer des readers, sous la forme d'un objet de fonctions (node, data),\n     *      lorsqu'ils n'ont pas été définis lors de l'instanciation par exemple (new XML (options)).\n     *\n     * @param {Object} reader - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)\n     *      utile pour interpréter le XML lorsque sa structure est connue.\n     *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.\n     */\n    setReader : function (reader) {\n        if (reader && reader.read && typeof reader.read === \"function\") {\n            this.reader = reader;\n        }\n    },\n\n    /**\n     * Méthode permettant de récupérer le document XML associé au format, s'il existe.\n     *\n     * @return {DOMElement} xmlDoc - le document XML (DOM document node) s'il existe\n     */\n    getXMLDoc : function () {\n        return this.xmlDoc;\n    },\n\n    /**\n     * Setter\n     */\n    setXMLDoc : function (doc) {\n        this.xmlDoc = doc;\n    },\n    /**\n     * Méthode initialisant la lecture du XML, à partir d'un XML Document :\n     *      création d'un objet JavaScript contenant les informations du XML,\n     *      sauf dans le cas où il n'existe pas de XML Document à interpréter (retourne un objet vide).\n     *\n     * @return {Object} [parserOutput] - un objet JavaScript contenant les informations du XML :\n     * - soit toutes les informations si aucun reader n'a été spécifié à la création du format\n     * - soit les informations spécifiées dans le reader.\n     */\n    parse : function () {\n        // build xml document from xmlString\n        if (!this.xmlDoc && this.xmlString) {\n            this.xmlDoc = __getXMLDOC(this.xmlString);\n        }\n        if (this.xmlDoc) {\n            var root = __getRootNode(this.xmlDoc);\n            if (root) {\n                var parserOutput;\n                // call reader if exists\n                if (this.reader && this.reader.read) {\n                    parserOutput = this.reader.read(root);\n                } else {\n                    parserOutput = {};\n                    parserOutput[root.nodeName] = __readDefault(root);\n                }\n                return parserOutput;\n            } else {\n                return {};\n            }\n        }\n    }\n\n};\n\n/**\n * Méthode de la classe (privée) permettant de créer un XML Document à partir d'une chaîne de caractères XML,\n *      en utilisant DOMParser () lorsque c'est possible.\n *      For more information, see: https://dvcs.w3.org/hg/innerhtml/raw-file/tip/index.html#the-domparser-interface\n *\n * @private\n * @memberof XML\n * @method __getXMLDOC\n * @param {String} xmlString - xml string to be converted into DOM element\n * @return {DOMElement} - the corresponding XML Document\n */\nfunction __getXMLDOC (xmlString) {\n    if (typeof window === \"undefined\") {\n        // env. nodejs\n        var DOMParser = __webpack_require__(20).DOMParser; // __xmldom.DOMParser;\n        return new DOMParser().parseFromString(xmlString, \"text/xml\");\n    } else {\n        // env. browser\n\n        var parser;\n        var xmlDoc;\n        var errorMsg = \"Erreur lors du parsing de la réponse du service : XML non conforme\";\n\n        if (window.ActiveXObject) {\n            // Internet Explorer < 9\n            xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.loadXML(xmlString);\n            var parseError = xmlDoc.parseError;\n            if (parseError.errorCode) {\n                if (parseError.line && parseError.linepos) {\n                    errorMsg += \"( ligne \" + parseError.line + \", colonne \" + parseError.linepos;\n                }\n                if (parseError.reason) {\n                    errorMsg += \":  \" + parseError.reason + \")\";\n                }\n                throw new Error(errorMsg);\n            }\n            return xmlDoc;\n        } else if (window.DOMParser) {\n            // les autres (Chrome, Mozilla, IE >= 9)\n            parser = new window.DOMParser();\n            try {\n                xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n            } catch (e) {\n                // Internet Explorer browser raises exception if xmlString is not valid XML\n                if (e.message === \"SyntaxError\") {\n                    throw new Error(errorMsg);\n                } else {\n                    throw new Error(\"Erreur lors du parsing de la réponse du service : \" + e.message);\n                }\n            }\n            // look for parsing error in case no exception was raised\n            if (xmlDoc.getElementsByTagName(\"parsererror\").length > 0) {\n                var parsererror = xmlDoc.getElementsByTagName(\"parsererror\");\n                for (var i = 0; i < parsererror.length; i++) {\n                    var content = parsererror[i].innerHTML;\n                    // except in case parsererror is just because of huge xml, but parsing is done.\n                    if (content.indexOf(\"Huge input lookup\") === -1) {\n                        errorMsg += \"(\" + content + \")\";\n                        throw new Error(errorMsg);\n                    }\n                }\n            } else if (!xmlDoc.documentElement) { // may happen in chrome browser\n                throw new Error(errorMsg);\n            }\n            return xmlDoc;\n        } else {\n            // FIXME\n            throw new Error(\"Incompatible DOM Parser pour ce navigateur !\");\n        }\n    }\n}\n\n/**\n * Méthode de la classe (privée) permettant de récupérer le noeud racine du document,\n *      à partir d'un document node (nodeType=9), puis lecture de ce noeud (readNode)\n *\n * @private\n * @memberof XML\n * @method __getRootNode\n * @param {DOMElement} [xmlDoc] - a Document Node\n * @return {DOMElement} root - the document root node\n */\nfunction __getRootNode (xmlDoc) {\n    var root;\n    if (xmlDoc.nodeType === 9) {\n        // INFO : nodeType 9 represents the entire document (the root-node of the DOM tree)\n        root = xmlDoc.documentElement;\n    } else if (xmlDoc.nodeType === 1) {\n        root = xmlDoc;\n    }\n    return root;\n}\n\n/**\n * Méthode de la classe (privée) permettant de lire automatiquement un noeud XML,\n *      lorsqu'aucun reader spécifique n'a été spécifié (parser brut)\n *\n * @private\n * @memberof XML\n * @method readDefault\n * @param {DOMElement} node - a DOM element node\n * @example final data object looks like :\n *          data = {\n *              attributeName: attributeValue,\n *              childName: {\n *                  attributeName: attributeValue,\n *                  attributeName: attributeValue,\n *                  childName: {\n *                      \"textContent\": textContent\n *                  },\n *                  childName: {\n *                      childName: {\n *                          attributeName:attributeValue\n *                      }\n *                  }\n *              }\n *          }\n */\nfunction __readDefault (node) {\n    var data = {};\n\n    // if element node has attributes, set their values to data\n    if (node.attributes.length > 0) {\n        var dataAttributes = __getAttributes(node);\n        data[\"attributes\"] = dataAttributes;\n    }\n\n    // if element node has childNodes, read them and set them to data\n    if (node.hasChildNodes()) {\n        var childData = {};\n        var child;\n        var children = node.childNodes;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 3) { // TEXT_NODE\n                data[\"textContent\"] = child.nodeValue;\n            } else if (child.nodeType === 1) {\n                childData = __readDefault(child);\n\n                if (!data[child.nodeName]) {\n                    // store childData in an object\n                    data[child.nodeName] = childData;\n                } else {\n                    // in case several childNodes has the same name : store them in an array.\n                    // if data[nodeName] already exists but is not an array\n                    if (!Array.isArray(data[child.nodeName])) {\n                        var old = data[child.nodeName];\n                        data[child.nodeName] = [];\n                        data[child.nodeName].push(old);\n                    }\n                    data[child.nodeName].push(childData);\n                }\n            }\n            // TODO : manage other node types (4=CDATA, etc)\n        }\n    }\n\n    return data;\n}\n\n/**\n * Méthode de la classe (privée) permettant de récupérer les attributs d'un noeud élément\n *\n * @private\n * @memberof XML\n * @method __getAttributes\n * @param {DOMElement} node - noeud contenant l'attribut recherché\n * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs\n */\nfunction __getAttributes (node) {\n    if (node.attributes.length > 0) {\n        var nodeAttributes = {};\n        var attributes = node.attributes;\n        for (var i = 0; i < attributes.length; i++) {\n            var attribute = attributes[i];\n            nodeAttributes[attribute.nodeName] = attribute.nodeValue;\n        }\n        return nodeAttributes;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XML);\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @classdesc\n *\n * Liste des attributs des tables de geocodage\n * @constructor\n * @alias Gp.Services.Geocode.Request.GeocodeLocation\n * @private\n */\nfunction GeocodeLocation () {\n    if (!(this instanceof GeocodeLocation)) {\n        throw new TypeError(\"GeocodeLocation constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Objet qui peut prendre comme propriétés les valeurs du tableau serviceAttributes\n     * @type {Object}\n     */\n    this.placeAttributes = {};\n\n    /**\n     * Tableau qui liste les attributs spécifiques selon le type de la GeocodeLocation.\n     * Ces attributs correspondent à ceux saisis par l'utilisateur (légèrement différents de ceux du service)\n     * @type {String[]}\n     */\n    this.attributesList = [];\n\n    /**\n     * Tableau qui liste les attributs spécifiques selon le type de la GeocodeLocation\n     * Ces attributs correspondent à ceux interprétés par le service (balises Place).\n     * @type {String[]}\n     */\n    this.serviceAttributes = [];\n}\n\n/**\n * @lends module:GeocodeLocation\n */\nGeocodeLocation.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : GeocodeLocation\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GeocodeLocation);\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * Lecture / Ecriture du format WKT\n *\n * Les besoins sont assez simples :\n * 1. lecture des types suivants :\n *  - LINESTRING\n *  - POLYGON\n *  - (TODO)\n * 2. convertir aux formats suivants :\n *  - json\n *  - (TODO)\n *\n *\n * @example\n *  var strWKT = \"LINESTRING (2.416907 48.846577, 2.416916 48.846613)\";\n *  WKT.toJson (strWKT,\n *      function onSuccess (json) {\n *          // {\n *          //      type : 'LINESTRING',\n *          //      coordinates : [\n *          //          [2.416907, 48.846577],\n *          //          [2.416916, 48.846613]\n *          //      ]\n *          // }\n *      },\n *      function onError (error) {\n *          console.log(error);\n *      }\n *  );\n *\n * @module WKT\n * @alias Gp.Formats.WKT\n * @private\n */\n\nvar WKT = {\n\n    /**\n     * Parsing d'une chaine WKT\n     *\n     * @method toJson\n     * @param {String} strWkt - chaine de type WKT\n     * @param {Function} success - fonction callback\n     * @param {Function} error   - fonction callback\n     */\n    toJson : function (strWkt, success, error) {\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n\n        var json = null;\n\n        try {\n            if (!strWkt) {\n                throw new Error(\"La chaine WKT n'est pas renseignée !\");\n            }\n\n            if (!success) {\n                /** callback success par defaut */\n                success = function (json) {\n                    console.log(json);\n                };\n            }\n\n            if (!error) {\n                /** callback error par defaut */\n                error = function (e) {\n                    console.log(e);\n                };\n            }\n\n            var regex;\n            var subst;\n\n            // regex coordinates\n            regex = /(-?\\d+\\.?[0-9]*)\\s(-?\\d+\\.?[0-9]+)/g;\n            subst = \"[$1,$2]\";\n            strWkt = strWkt.replace(regex, subst);\n\n            // regex type\n            regex = /^(\\w+)/;\n            regex.exec(strWkt);\n            if (RegExp.$1 === \"POLYGON\") {\n                subst = \"{\\\"type\\\" : \\\"Polygon\\\",\";\n                strWkt = strWkt.replace(RegExp.$1, subst);\n                // clean\n                // (( --> coordinates : [[\n                regex = /(\\({2}?)/;\n                subst = \"\\\"coordinates\\\" : [[\";\n                strWkt = strWkt.replace(regex, subst);\n                // )) --> ]]}\n                regex = /(\\){2}?)/;\n                subst = \"]]}\";\n                strWkt = strWkt.replace(regex, subst);\n                // all ( --> [\n                regex = /(\\()/g;\n                subst = \"[\";\n                strWkt = strWkt.replace(regex, subst);\n                // all ) --> ]\n                regex = /(\\))/g;\n                subst = \"]\";\n                strWkt = strWkt.replace(regex, subst);\n            } else if (RegExp.$1 === \"LINESTRING\") {\n                subst = \"{\\\"type\\\" : \\\"LineString\\\",\";\n                strWkt = strWkt.replace(RegExp.$1, subst);\n                // clean\n                regex = /(\\(\\(?)/;\n                subst = \"\\\"coordinates\\\" : [\";\n                strWkt = strWkt.replace(regex, subst);\n                regex = /(\\)\\)?)/;\n                subst = \"]}\";\n                strWkt = strWkt.replace(regex, subst);\n            }\n\n            logger.trace(strWkt);\n\n            json = JSON.parse(strWkt);\n\n            if (!json) {\n                throw new Error(\"Le JSON est vide !\");\n            }\n\n            if (!json.type) {\n                throw new Error(\"Le type de geometrie n'est pas connu !\");\n            }\n\n            if (!json.coordinates) {\n                throw new Error(\"La liste des points est vide !\");\n            }\n\n            success.call(this, json);\n        } catch (e) {\n            if (e.name === \"SyntaxError\") {\n                error.call(this, \"Erreur de parsing JSON !\");\n                return;\n            }\n            error.call(this, e);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (WKT);\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Response object for {@link module:Services~getAltitude Gp.Services.getAltitude ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Array.<Gp.Services.Alti.Elevation>} elevations - Elevations array.\n *\n * @namespace\n * @alias Gp.Services.AltiResponse\n */\nfunction AltiResponse () {\n    if (!(this instanceof AltiResponse)) {\n        throw new TypeError(\"AltiResponse constructor cannot be called as a function.\");\n    }\n\n    this.elevations = [];\n}\n\nAltiResponse.prototype = {\n\n    constructor : AltiResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiResponse);\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Single elevation object returned by underlying web service. Contains at least, one elevation (z). May also contain point coordinates and elevation accuracy if \"zonly\" parameter wasn't set to true.\n *\n * @property {Float} lat - Point latitude. (only if zonly=false)\n * @property {Float} lon - Point longitude. (only if zonly=false)\n * @property {Float} z - Point elevation.\n * @property {Float} acc - Accuracy of elevation for this point. (only if zonly=false)\n *\n * @namespace\n * @alias Gp.Services.Alti.Elevation\n */\nfunction Elevation () {\n    if (!(this instanceof Elevation)) {\n        throw new TypeError(\"Elevation constructor cannot be called as a function.\");\n    }\n\n    this.z = null;\n}\n\nElevation.prototype = {\n\n    constructor : Elevation\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Elevation);\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__XLS_RequestHeader__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__XLS_Request__ = __webpack_require__(66);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__XLS_AbstractService__ = __webpack_require__(12);\n\n\n\n\n\n/**\n * @classdesc\n *\n * standard OpenLS\n * standard XLS\n * (version 1.2)\n *\n * Réfs :\n *     - {@link http://schemas.opengis.net/ols/1.2/}\n *     - {@link http://www.opengeospatial.org/standards/ols}\n *     - {@link http://wxs.ign.fr/schemas/}\n *\n *\n * Création du template XLS (avec gestion des namespaces)\n * ------------------------\n * ```\n *   balise xsd : element name=\"XLS\" attribute name=\"version\" [(attribute ref=\"lang\")]\n * ```\n *\n * Exemple :\n * ```\n * <XLS xmlns=\"http://www.opengis.net/xls\" version=\"1.2\">\n *   < (ref. OLS) />\n * </XLS>\n * ```\n * ```\n * <xls:XLS xmlns:xls=\"http://www.opengis.net/xls\" version=\"1.2\">\n *   <xls: (ref. OLS) />\n * </xls:XLS>\n * ```\n *\n * Création des templates OLS pour LocationUtilityService\n * ------------------------------------------------------\n *\n * Exemple :\n *\n * ```\n * <RequestHeader srsName=\"epsg:4326\"/>\n * <Request maximumResponses=\"26\" methodName=\"GeocodeRequest\" requestID=\"uid1349081498314_388\" version=\"1.2\">\n *      <GeocodeRequest>\n *          <Address countryCode=\"PositionOfInterest\">\n *              <freeFormAddress>saint mandé</freeFormAddress>\n *          </Address>\n *      </GeocodeRequest>\n *  </Request>\n * ```\n * ```\n * <RequestHeader sessionID=\"\" />\n * <Request methodName=\"ReverseGeocodeRequest\" version=\"1.2\" requestID=\"\" maximumResponses=\"10\">\n *   <ReverseGeocodeRequest>\n *     <Position>\n *       <gml:Point xmlns:gml=\"http://www.opengis.net/gml\">\n *           <gml:pos>50.347775 3.205098</gml:pos>\n *       </gml:Point>\n *     </Position>\n *     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>\n *  </ReverseGeocodeRequest>\n * </Request>\n * ```\n * ```\n * Geocodage direct (balise xsd) :\n *   element ref=\"RequestHeader\" [ (attribute name=\"clientName\" attribute name=\"clientPassword\" attribute name=\"sessionID\" attribute name=\"srsName\" attribute name=\"MSID\") ]\n *     element name=\"Request\" attribute name=\"methodName\" attribute name=\"version\" attribute name=\"requestID\" [ attribute name=\"maximumResponses\" ]\n *       element name=\"GeocodeRequest\" attribute name=\"returnFreeForm\"\n *         element ref=\"xls:Address\"\n * ```\n * ```\n * Geocodage inverse (balise xsd) :\n *   element ref=\"RequestHeader\" [ (attribute name=\"clientName\" attribute name=\"clientPassword\" attribute name=\"sessionID\" attribute name=\"srsName\" attribute name=\"MSID\") ]\n *     element name=\"Request\" attribute name=\"methodName\" attribute name=\"version\" attribute name=\"requestID\" [ attribute name=\"maximumResponses\" ]\n *       element name=\"ReverseGeocodeRequest\"\n *         element ref=\"xls:Position\"\n *         element name=\"ReverseGeocodePreference\" (enumeration)\n * ```\n *\n * Il existe 3 sous ensembles d'objets :\n *     - RequestHeader\n *     - Request\n *     - ReverseGeocodeRequest, GeocodeRequest\n *\n * GeocodeRequest est composé d'un objet {@link Gp.Services.Geocode.Response.GeocodeLocation}.\n * ReverseGeocodeRequest est composé d'un objet {@link Gp.Services.ReverseGeocode.Response.ReverseGeocodeLocation}.\n *\n * Les locations font appels aux objets suivants qui possèdent des attributs spécifiques\n * en fonction du type de table de geocodage interrogé :\n *     - StreetAddress\n *     - CadastralParcel\n *     - PositionOfInterest\n *     - Administratif\n *\n *\n * et des élements sous jacents tels que :\n *     - ReverseGeocodePreference -> tables de geocodages :\n *         - StreetAddress\n *         - CadastralParcel\n *         - PositionOfInterest\n *         - Administratif (une balise par table)\n *     - Position -> standard GML 3.2.1\n *     - Address  -> cf. ci-dessous\n *\n * ```\n * Position (balise xsd) :\n *   ex. <Position><gml:Point xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>50.347775 3.205098</gml:pos></gml:Point></Position>\n *   ex. <Position><gml:CircleByCenterPoint xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>48.85978570614691 2.2913572761128878</gml:pos><gml:radius>1000</gml:radius></gml:CircleByCenterPoint></Position>\n *   (au choix)\n *   element ref=\"gml:Point\"\n *   element ref=\"gml:CircleByCenterPoint\"\n *   element ref=\"gml:Polygon\"\n *   element ref=\"gml:MultiPolygon\"\n *   les autres elemennts ne sont pas implémentés (QoP, Speed, Direction, Time, ...)\n *\n * Address (balise xsd) :\n *   ex. <Address countryCode=\"StreetAddress\"><freeFormAddress>1 r de paris saint denis</freeFormAddress></Address>\n *   attribute name=\"countryCode\"\n *     element name=\"freeFormAddress\"\n *     element ref=\"xls:Place\"\n *     element ref=\"gml:Envelope\"\n *  ou\n *   ex. <Address countryCode=\"StreetAddress\"><StreetAddress><Street>1 rue Marconi</Street></StreetAddress><Place type=\"Municipality\">Metz</Place><PostalCode>57000</PostalCode></Address>\n *   attribute name=\"countryCode\"\n *     element ref=\"xls:StreetAddress\"\n *     element ref=\"xls:PostalCode\"\n *     element ref=\"xls:Place\"\n *     element ref=\"gml:Envelope\"\n *\n * Place  (balise xsd) :\n *  ex. <Place type=\"Municipality\">Metz</Place>\n *  attribute name=\"type\"\n *   enumeration value=\"CountrySubdivision\"\n *   enumeration value=\"CountrySecondarySubdivision\"\n *   enumeration value=\"Municipality\"\n *   enumeration value=\"MunicipalitySubdivision\"\n *   enumeration value=\"choume-banchi-go\"\n *   enumeration value=\"Qualite\"\n *   enumeration value=\"Departement\"\n *   enumeration value=\"Bbox\"\n *   enumeration value=\"Commune\"\n *   enumeration value=\"Territoire\"\n *   enumeration value=\"Importance\"\n *   enumeration value=\"Nature\"\n *   (la liste n'est pas exhaustives...)\n *\n * StreetAddress (balise xsd) :\n *   ex. <StreetAddress><Street>1 rue Marconi</Street></StreetAddress>\n *   attribute name=\"locator\"\n *    element name=\"xls:Building\"\n *    element ref=\"xls:Street\"\n *\n * Street (balise xsd) :\n *   ex. <Street>1 rue Marconi</Street>\n *   attribute name=\"officialName\" (...)\n *\n * Building (balise xsd) :\n *   ex. <Building number=\"800\"/>\n *   attribute name=\"number\" attribute name=\"subdivision\" attribute name=\"buildingName\"\n *\n * PostalCode (balise xsd) :\n *   ex. <PostalCode>77182</PostalCode>\n *\n * ```\n *\n * Requête\n * -------\n *\n * 2 modes de requête sur les services : GET ou POST.\n *\n * Le mode GET n'est que l'encodage du XML en param (qxml) de la requête (donc pas d'implementation particulière ?)\n *\n * Modèle de classes\n * -----------------\n *\n * ```\n *                 ________  XLS ____________\n *               /            |               \\\n *   RequestHeader      AbstractService    Request\n *                            ^\n *                      ______|________________________\n *           (extends) /                               \\ (extends)\n *          LocationUtilityService                    RouteService\n *                    |                                    |\n *         ___________|___________                       (...)\n *       /                        \\\n * GeocodeRequest          ReverseGeocodeRequest\n *      |                          |\n *      |                     _____|______\n *      |                    /            \\\n *   Address              Preference  Position\n *      |\n *    /   \\\n * Place   StreetAddress\n *               |\n *             /   \\\n *       Street   Building\n * ```\n *\n * @example\n * // encapsule un objet 'LocationUtilityService'\n * // dans une coquille XSL (avec/sans namespace)\n * xsl = new XSL ();\n * xsl.namespace = false;\n * xsl.srsName = \"epsg:4326\";\n * xsl.maximumResponses = 26;\n * //   methodName fournit par l'objet 'lus'\n * //   requestID est calculé\n * xsl.setService (lus);\n * xsl.build ();\n * // out ->\n * // <XLS xmlns=\"http://www.opengis.net/xls\" version=\"1.2\">\n * // <RequestHeader srsName=\"epsg:4326\"/>\n * // <Request maximumResponses=\"26\" methodName=\"GeocodeRequest\" requestID=\"uid1349081498314_388\" version=\"1.2\">\n * //   < (ref. LocationUtilityService ou vide) />\n * //  </Request>\n * // </XLS>\n *\n *\n * @constructor\n * @alias Gp.Formats.XLS\n * @param {Object} options - options du constructeur\n * @param {Object} options.srsName - identifiant du Systeme de Coordonnees\n * @param {String}   options.maximumResponses - nombre de reponses max d'une requete\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction XLS (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur XLS()]\");\n\n    if (!(this instanceof XLS)) {\n        throw new TypeError(\"XLS constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = {\n        srsName : \"EPSG:4326\",\n        maximumResponses : 25\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            if (options[opt]) {\n                this.options[opt] = options[opt];\n            }\n        }\n    }\n}\n\n/**\n * Version\n */\nXLS.VERSION = \"1.2\";\n\nXLS.prototype = {\n\n    /**\n     * @lends module:XLS#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * namespace\n     * Surcharge les balises XLS d'un prefixe.\n     * Par defaut, false\n     * @type {Boolean}\n     */\n    namespace : false,\n\n    /**\n     * Objet Service\n     * LocationUtilityService ou RouteService\n     * @type {AbstractService}\n     */\n    oService : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : XLS,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __VERSION__, __NAMESPACE__, __SCHEMALOCATION__\n     * __REQUESTHEADER__, __REQUEST__\n     */\n    template : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n        \"<XLS version=\\\"__VERSION__\\\"\\n\" +\n        \"__NAMESPACE__ \\n\" +\n        \"__SCHEMALOCATION__>\\n\" +\n        \"__REQUESTHEADER__\\n\" +\n        \"__REQUEST__\\n\" +\n        \"</XLS>\\n\",\n\n    /**\n     * Namespace par defaut.\n     *\n     * @returns {String}\n     */\n    namespaceByDefault : function () {\n        var ns = [\n            \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\",\n            \"xmlns:xls=\\\"http://www.opengis.net/xls\\\"\",\n            \"xmlns:gml=\\\"http://www.opengis.net/gml\\\"\"\n        ];\n\n        return ns.join(\" \");\n    },\n\n    /**\n     * Schemalocation par defaut\n     *\n     * @returns {String}\n     */\n    schemaLocationByDefault : function () {\n        return \"xsi:schemaLocation=\\\"http://www.opengis.net/xls http://schemas.opengis.net/ols/1.2/olsAll.xsd\\\"\";\n    },\n\n    /**\n     * Setter Service\n     * Ajout d'un objet de type LocationUtilityService (LUS) ou RouteService\n     *\n     * @param {Object} oService - GeoceodeRequest / ReverseGeocodeRequest ou RouteRequest\n     */\n    setService : function (oService) {\n        if (!oService) {\n            this.logger.trace(\"L'objet de type Service XSL n'est pas encore defini !?\");\n            return;\n        }\n\n        if (oService instanceof __WEBPACK_IMPORTED_MODULE_3__XLS_AbstractService__[\"a\" /* default */]) {\n            this.oService = oService;\n        } else {\n            this.logger.error(\"L'objet n'est pas du type 'LocationUtilityService' ou 'RouteService' !?\");\n        }\n    },\n\n    /**\n     * Getter Service\n     * Retourne un objet de type LocationUtilityService (LUS) ou RouteService\n     * ex. GeoceodeRequest / ReverseGeocodeRequest ou RouteRequest\n     *\n     * @returns {Object}\n     */\n    getService : function () {\n        return this.oService;\n    }\n};\n\n/**\n * Ajout d'un prefixe de namespace\n *\n * @todo impl. l'ajout de namespace\n * @param {Object} ns - ex. {key:xls, url:http://www.opengis.net/xls}\n */\nXLS.prototype.addNamespace = function (ns, request) {\n    // INFO\n    // on recherche la clef dans les namespaces par defaut.\n    // si la clef n'existe pas dans les namespaceByDefault (), on l'ajoute.\n    // on surcharge toutes les balises, ex. XLS -> xls:XLS\n    // sauf celles qui sont déjà prefixées !\n\n    var keyNS = ns.key;\n    // var urlNS = ns.url; // TODO not yet implemented !\n\n    // recherche la clef dans les namespaces par defaut\n    var bFound = false;\n    var allNS = this.namespaceByDefault().split(\" \");\n    for (var index = 0; index < allNS.length; index++) {\n        var element = allNS[index];\n        var map = element.split(\"=\");\n        var key = map[0];\n        // var url = map[1]; // TODO not yet implemented !\n\n        if (key === \"xmlns:\" + keyNS) {\n            bFound = true;\n            break;\n        }\n    }\n\n    // TODO\n    // si on a une nouvelle clef, on l'ajoute...\n    if (!bFound) {\n        this.logger.warn(\"L'ajout d'un nouvel namespace n'est pas encore implémenté !\");\n        return request;\n    }\n\n    // surcharge toutes les balises\n    var regex;\n    var subst;\n\n    // regex balise ouvrante\n    regex = /<(\\w+[\\s>])/g;\n    subst = \"<\" + keyNS + \":$1\";\n    request = request.replace(regex, subst);\n\n    // regex balise fermante\n    regex = /<\\/(\\w+[\\s>])/g;\n    subst = \"</\" + keyNS + \":$1\";\n    request = request.replace(regex, subst);\n\n    this.logger.trace(\"namespace\", request);\n\n    return request;\n};\n\n/**\n * Construction de la requête\n */\nXLS.prototype.build = function () {\n    // out ->\n    // <XLS xmlns=\"http://www.opengis.net/xls\" version=\"1.2\">\n    // <RequestHeader srsName=\"epsg:4326\"/>\n    // <Request maximumResponses=\"26\" methodName=\"GeocodeRequest\" requestID=\"uid1349081498314_388\" version=\"1.2\">\n    //   < (ref. LocationUtilityService ou vide) />\n    //  </Request>\n    // </XLS>\n\n    // as t on un objet de type Service XLS à disposition ?\n    var bService = !!this.getService();\n\n    var template = \"\";\n    template = this.template;\n    template = template.replace(/__VERSION__/g, XLS.VERSION);\n    template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);\n    template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);\n\n    // header\n    var oHeader = new __WEBPACK_IMPORTED_MODULE_1__XLS_RequestHeader__[\"a\" /* default */]({\n        srsName : this.options.srsName\n    });\n    template = template.replace(/__REQUESTHEADER__/g, oHeader.toString());\n\n    // request\n    var oRequest = new __WEBPACK_IMPORTED_MODULE_2__XLS_Request__[\"a\" /* default */]({\n        maximumResponses : this.options.maximumResponses,\n        version : XLS.VERSION, // FIXME même version ?\n        methodName : bService ? this.getService().CLASSTYPE : null\n    });\n    template = template.replace(/__REQUEST__/g, oRequest.toString());\n\n    // objet lus ou route\n    if (bService) { // INFO : clef __REQUESTSERVICE__ dispo dans l'objet 'Request'\n        template = template.replace(/<!-- __REQUESTSERVICE__ -->/g, this.getService().toString());\n    }\n\n    if (!template) {\n        this.logger.warn(\"traduction tmpl : empty request !?\");\n        return;\n    }\n\n    // ajout d'un namespace\n    if (this.namespace) {\n        // ajout de xls par defaut\n        template = this.addNamespace({\n            key : \"xls\",\n            url : \"http://www.opengis.net/xls\"\n        }, template);\n    }\n\n    this.requestString = template;\n    this.logger.trace(\"traduction tmpl\", template);\n\n    // on retourne qqchose !\n    return this.requestString;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XLS);\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n * @private\n *\n * @constructor\n * @alias Gp.Formats.XLS.AbstractService\n *\n * @param {Object} [options] - options\n */\nfunction AbstractService (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur AbstractService ()]\");\n\n    if (!(this instanceof AbstractService)) {\n        throw new TypeError(\"AbstractService constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {};\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\n/**\n * @lends module:AbstractService#\n */\nAbstractService.prototype = {\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    strRequest : null,\n\n    /**\n     * objet Request\n     * @type {Request}\n     */\n    oRequest : null,\n\n    /**\n     * Filter\n     * @type {FilterExtension}\n     */\n    oFilter : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : AbstractService,\n\n    /**\n     * Ajout d'un objet de type Request : GeocodeRequest / ReverseGeocodeRequest / RouteRequest\n     *\n     * @param {Object} oRequest - GeocodeRequest / ReverseGeocodeRequest / RouteRequest\n     */\n    addRequest : function (oRequest) {\n        this.logger.error(\"overwritten method !\");\n    },\n\n    /**\n     * Ajout d'un objet de type FilterExtension : GeocodeFilterExtension ou RouteRequestExtension\n     *\n     * @param {Object} oFilter - GeocodeFilterExtension ou RouteRequestExtension\n     */\n    addFilter : function (oFilter) {\n        this.logger.error(\"overwritten method !\");\n    },\n\n    /**\n     * toString\n     */\n    toString : function () {\n        this.logger.error(\"overwritten method !\");\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AbstractService);\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n\n/**\n * @classdesc\n *\n * Ajouter des extensions de filtres spécifiques au service de geocodage de l'IGN.\n * Ceci permet de contrôler les options spécifiques de la table de geocodage intérrogées.\n *\n * @example\n * var ext =  new GeocodeFiltersExtension ();\n *     ext.add (new Administratif ());\n *     ext.add (new StreetAddress ());\n *     ext.add (new PositionOfInterest ());\n *     ext.add (new CadastralParcel ());\n *\n * ext.getNames ()\n * // --> out\n * // [Administratif, StreetAddress, PositionOfInterest, CadastralParcel]\n *\n * ext.getFilters ()\n * // --> out\n * // [Object, Object, Object, Object] = tableau d'objet GeocodeLocation\n *\n * ext.getFilter ('StreetAddress')\n * // --> out\n * // {Object} = objet GeocodeLocation\n *\n * ext.getAttributs ('StreetAddress')\n * // --> out\n * // [\"bbox\", \"number\", \"ID\", \"IDTR\", \"postalCode\", \"quality\", \"street\", \"territoire\", \"commune\", \"department\", \"insee\", \"municipality\"]\n *\n * ext.setPlaceAttributs ('StreetAddress', {number:'', territoire:'', quality:'', fake:''})\n * // --> out\n * // (fake est écarté car il n'appartient pas à la liste !)\n *\n * ext.getPlaceAttributs ('StreetAddress')\n * // --> out\n * // {number : '', territoire : '', quality : ''}\n *\n * // Comment ajouter des filtres spécifiques au service de geocodage ?\n * var req = new GeocodeRequest ({\n *      location : \"saint mandé\",\n *      returnFreeForm : true,\n *      filterOptions : {\n *          type : ['PositionOfInterest'], <-- ajouter une extension afin de gerer les attributs de cette table de geocodage !\n *          (...)\n *      }\n *  })\n *  req.addFilter (new PositionOfInterest ());\n * @constructor\n * @alias Gp.Formats.XLS.LocationUtilityService.GeocodeFilterExtension\n *\n * @private\n */\nfunction GeocodeFilterExtension () {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"GeocodeFilterExtension\");\n    this.logger.trace(\"[Constructeur GeocodeFilterExtension ()]\");\n\n    if (!(this instanceof GeocodeFilterExtension)) {\n        throw new TypeError(\"GeocodeFilterExtension constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Tableau de filtres (table de geocodage)\n     */\n    this.filters = [];\n}\n\n/**\n * @lends module:GeocodeFilterExtension#\n */\nGeocodeFilterExtension.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : GeocodeFilterExtension,\n\n    /**\n     * Ajout d'un filtre\n     *\n     * @param {Object} oGeocodeLocation - objet de type 'GeocodeLocation'\n     */\n    addFilterExtensions : function (oGeocodeLocation) {\n        // FIXME test sur le type d'objet !\n        if (oGeocodeLocation) {\n            // FIXME ou test sur ses propriétés !\n            this.filters.push(oGeocodeLocation);\n        }\n    },\n\n    // getter\n\n    /**\n     * Tableau de noms (tables de geocodage)\n     *\n     * @returns {Array.<String>}\n     */\n    getNames : function () {\n        var names = [];\n        for (var idx in this.filters) {\n            names.push(this.filters[idx].CLASSNAME);\n        }\n        this.logger.trace(names);\n        return names;\n    },\n\n    /**\n     * Retourne une table de geocodage\n     *\n     * @param {String} name - nom de la table de geocodage\n     * @returns {Object}\n     */\n    getFilter : function (name) {\n        var filter = null;\n        for (var idx in this.filters) {\n            if (this.filters[idx].CLASSNAME === name) {\n                filter = this.filters[idx];\n            }\n        }\n        this.logger.trace(filter);\n        return filter;\n    },\n\n    /**\n     * Tableau d'objects (tables de geocodage)\n     *\n     * @returns {Array.<Object>}\n     */\n    getFilters : function () {\n        this.logger.trace(this.filters);\n        return this.filters;\n    },\n\n    /**\n     * Récupère la liste des attributs (filtres) sur une table de geocodage\n     *\n     * @param {String} name - nom de la table de geocodage\n     * @returns {Array}\n     */\n    getAttributs : function (name) {\n        var attributs = [];\n        for (var idx in this.filters) {\n            if (this.filters[idx].CLASSNAME === name) {\n                attributs = this.filters[idx].attributesList;\n            }\n        }\n        this.logger.trace(attributs);\n        return attributs;\n    },\n\n    /**\n     * Ajout des attributs (filtres) sur une table de geocodage\n     *\n     * @param {String} name - nom de la table de geocodage\n     * @param {Object} options - options de la table de geocodage\n     */\n    setPlaceAttributs : function (name, options) {\n        var filter = this.getFilter(name);\n        var attributs = this.getAttributs(name);\n        for (var idx in attributs) {\n            var value = attributs[idx];\n            if (options[value]) {\n                filter.placeAttributes[value] = options[value];\n            }\n        }\n    },\n\n    /**\n     * Retourne les attributs (filtres) sur une table de geocodage\n     *\n     * @param {String} name - nom de la table de geocodage\n     */\n    getPlaceAttributs : function (name) {\n        var places = {};\n        for (var idx in this.filters) {\n            if (this.filters[idx].CLASSNAME === name) {\n                places = this.filters[idx].placeAttributes;\n            }\n        }\n        this.logger.trace(places);\n        return places;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GeocodeFilterExtension);\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Response object for {@link module:Services~geocode Gp.Services.geocode ()} or {@link module:Services~reverseGeocode Gp.Services.reverseGeocode ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Array.<Gp.Services.Geocode.DirectGeocodedLocation|Gp.Services.Geocode.ReverseGeocodedLocation>} locations - locations array.\n *\n * @namespace\n * @alias Gp.Services.GeocodeResponse\n */\nfunction GeocodeResponse () {\n    if (!(this instanceof GeocodeResponse)) {\n        throw new TypeError(\"GeocodeResponse constructor cannot be called as a function.\");\n    }\n\n    this.locations = [];\n}\n\nGeocodeResponse.prototype = {\n\n    constructor : GeocodeResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GeocodeResponse);\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Location object holding common properties returned by the underlying geocoding and reverse geocoding web service.\n *\n * @property {Gp.Point} position - Position of the location given in the requested coordinates system.\n * @property {String} type - location type \"StreetAddress\" (for an address), \"PositionOfInterest\" (for a place name) or \"CadastralParcel\" (for cadastral parcel).\n * @property {String} matchType - how geocoding is performed : \"street number\" (exact address), \"street enhanced\" (street number calculated by interpolation), \"street\" (only the street), \"city\" (only the city).\n * @property {Object} placeAttributes - Associative array matching the following attributes with their values given by the underlying web service :\n *\n * *Common attributes : *\n *\n * - **freeform** - freeform complete Address.\n * - **bbox** - Bounding Box *{@link Gp.BBox}*.\n * - **municipality** - Municipality\n *\n * *if type === \"StreetAddress\" : *\n *\n * - **number** - Street number.\n * - **ID** - Identifier of the address in the [BD ADRESSE Database]{@link http://professionnels.ign.fr/bdadresse}.\n * - **IDTR** - Identifier of the lineString in the [BD ADRESSE Database]{@link http://professionnels.ign.fr/bdadresse}.\n * - **postalCode** - PostCode\n * - **quality** - Geocoding quality ([see]{@link http://api.ign.fr/tech-docs-js/developpeur/search.html})\n * - **street** - Street name\n * - **territory** - French Territory code\n * - **commune** - City\n * - **department** - Department\n * - **insee** - INSEE Code\n *\n *\n * *if type === \"PositionOfInterest\" :*\n *\n * - **importance** - Place name importance\n * - **nature** - Place name nature\n * - **postalCode** - PostCode\n * - **territory** - French Territory code\n * - **commune** - City\n * - **department** - Department\n * - **insee** - INSEE Code\n *\n *\n * *si type = \"CadastralParcel\" :*\n *\n * - **absorbedCity** - when a parcel comes from a city that was absorbed by another, code of that old city. \"000\" otherwise.\n * - **arrondissement** - arrondissement\n * - **cadastralParcel** - cadastral parcel code\n * - **district** - district\n * - **sheet** - Parcel Sheet (eg. \"1\").\n * - **number** - Parcel Number (eg. \"0041\")\n * - **section** - Parcel Section (eg. \"0D\").\n * - **commune** - Parcel municipality.\n * - **department** - Parcel Department.\n * - **insee** - INSEE Code.\n * - **origin** - Parcel origin (see \"type\" attribute in the [underlying web service response]{@link http://api.ign.fr/tech-docs-js/developpeur/search.html#Cadastral_parcels_search})\n *\n * @namespace\n * @alias Gp.Services.Geocode.GeocodedLocation\n */\nfunction GeocodedLocation () {\n    if (!(this instanceof GeocodedLocation)) {\n        throw new TypeError(\"GeocodedLocation constructor cannot be called as a function.\");\n    }\n\n    this.position = {\n        x : null,\n        y : null\n    };\n\n    this.matchType = null;\n\n    this.placeAttributes = {};\n\n    this.type = null;\n}\n\nGeocodedLocation.prototype = {\n\n    constructor : GeocodedLocation\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GeocodedLocation);\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Response object for {@link module:Services~route Gp.Services.route ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Gp.BBox} bbox - Bounding Box of the route. Given when provideBBox parameter is used in function call.\n * @property {Object} routeGeometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the route.\n * @property {Array.<Gp.Services.Route.RouteInstruction>} routeInstructions - Instructions of the route.\n * @property {String} totalDistance - Length of the route. If distanceUnit parameter was set to \"km\" (default), totalDistance is a string containing the total distance expressed in kilometers, followed by \" Km\" (e.g. : \"19.6 Km\"). If distanceUnit parameter was set to \"m\", totalDistance is a string containing the total distance expressed in meters (e.g. : \"19599.14\").\n * @property {Float} totalTime - Route duration in seconds.\n *\n * @namespace\n * @alias Gp.Services.RouteResponse\n */\nfunction RouteResponse () {\n    if (!(this instanceof RouteResponse)) {\n        throw new TypeError(\"RouteResponse constructor cannot be called as a function.\");\n    }\n\n    this.totalTime = null;\n\n    this.totalDistance = null;\n\n    this.bbox = {\n        left : null,\n        right : null,\n        top : null,\n        bottom : null\n    };\n\n    this.routeGeometry = null; // FIXME can be null if option 'geometryInInstructions' is true !\n\n    this.routeInstructions = [];\n}\n\nRouteResponse.prototype = {\n\n    constructor : RouteResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteResponse);\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Single Route Instruction object.\n *\n * @property {String} code - Instruction code :\n *\n * - \"F\" : Straight forward\n * - \"B\" : U-turn\n * - \"L\" : turn left\n * - \"R\" : turn right\n * - \"BL\" : turn left strongly\n * - \"BR\" : turn right strongly\n * - \"FL\" : turn lightly to the left\n * - \"FR\" : turn lightly to the right\n * - \"round_about_entry\" : round about entry\n * - \"round_about_exit\" : round about exit\n *\n * @property {String} instruction - Instruction text : translated code + street name\n * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the street.\n * @property {Float} distance - Length of the instruction. Expressed in km or m, depending on distanceUnit parameter.\n * @property {Float} duration - Instruction duration in seconds.\n *\n * @namespace\n * @alias Gp.Services.Route.RouteInstruction\n */\nfunction RouteInstruction () {\n    if (!(this instanceof RouteInstruction)) {\n        throw new TypeError(\"RouteInstruction constructor cannot be called as a function.\");\n    }\n\n    this.duration = null;\n\n    this.distance = null;\n\n    this.code = null;\n\n    this.instruction = null;\n\n    this.geometry = null; // FIXME can be null if option 'geometryInInstructions' is false !\n}\n\nRouteInstruction.prototype = {\n\n    constructor : RouteInstruction\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteInstruction);\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Response object for {@link module:Services~isoCurve Gp.Services.isoCurve ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Float} distance - distance (expressed in meters) used for the request.\n * @property {Float} time - time (expressed in seconds) used for the request.\n * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the isocurve.\n * @property {String} id - request id (used by underlying webservice).\n * @property {Gp.Point} location - Position of the start or end point used for the request (expressed in \"srs\" coordinates system).\n * @property {String} message - message\n * @property {String} srs - Identifier of the coordinates system used for the isocurve.\n *\n * @namespace\n * @alias Gp.Services.IsoCurveResponse\n *\n */\nfunction ProcessIsoCurveResponse () {\n    if (!(this instanceof ProcessIsoCurveResponse)) {\n        throw new TypeError(\"ProcessIsoCurveResponse constructor cannot be called as a function.\");\n    }\n\n    this.message = null;\n\n    this.id = null;\n\n    this.location = {};\n    this.location.x = null;\n    this.location.y = null;\n\n    this.srs = null;\n\n    this.geometry = null;\n\n    this.time = null;\n\n    this.distance = null;\n}\n\nProcessIsoCurveResponse.prototype = {\n\n    constructor : ProcessIsoCurveResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurveResponse);\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_es6_promise__ = __webpack_require__(49);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_es6_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_es6_promise__);\n/* global Promise, require */\n\n\n\n\n// import __request from \"request\";\n// import __xmldom from \"xmldom\";\n\n/**\n * Requêtes Ajax (utilisation des Promises)\n * cf. https://xhr.spec.whatwg.org/\n * cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n *\n * @module XHR\n * @private\n * @alias Gp.Protocols.XHR\n * @see dependance 'promise'\n */\n\nvar XHR = {\n\n    /**\n     * Interface unique d'envoi d'une requête.\n     *\n     * @method call\n     * @static\n     * @param {Object} settings - options generales\n     * @param {String} settings.url    - url du service\n     * @param {String} settings.method - GET, POST, PUT, DELETE\n     * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)\n     * @param {String} settings.data   - content (post) ou param (get)\n     * @param {String} settings.proxy  - proxy url\n     * @param {Object|String} settings.headers - (post) ex. referer\n     * @param {Object|String} settings.content - (post) ex. 'application/json'\n     * @param {String} settings.timeOut - timeout = 0 par defaut\n     * @param {String} settings.scope - this\n     * @param {Function} settings.onResponse - callback\n     * @param {Function} settings.onFailure  - callback\n     */\n    call : function (settings) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"XHR\");\n        logger.trace(\"[XHR::call()]\");\n\n        // FIXME\n        // To polyfill the global environment\n        __WEBPACK_IMPORTED_MODULE_2_es6_promise___default.a.polyfill();\n\n        // test sur les settings obligatoires\n        if (!settings.url) {\n            throw new Error(\"missing parameter : url is not defined !\");\n        }\n\n        if (!settings.method) {\n            throw new Error(\"missing parameter : method is not defined !\");\n        }\n\n        if (!settings.format) {\n            settings.format = \"text\"; // reponse brute !\n        }\n\n        var options = {};\n        options.url = settings.url;\n        options.data = settings.data ? settings.data : null;\n        options.method = settings.method;\n        options.timeOut = settings.timeOut || 0;\n        options.scope = settings.scope || this;\n        options.proxy = settings.proxy || null;\n        options.content = settings.content || null;\n        options.headers = settings.headers || {\n            referer : \"http://localhost\"\n        };\n\n        // test sur les valeurs de 'settings.method'\n        switch (settings.method) {\n            case \"DELETE\":\n            case \"GET\":\n                break;\n            case \"PUT\":\n            case \"POST\":\n                // on force sur ces params spécifiques au mode POST\n                options.content = settings.content ? settings.content : \"application/x-www-form-urlencoded\"; // FIXME en attente des services : bascule en \"application/xml\" ou \"application/json\"\n                options.headers = settings.headers ? settings.headers : {\n                    referer : \"http://localhost\" // todo ...\n                };\n                break;\n            case \"HEAD\":\n            case \"OPTIONS\":\n                throw new Error(\"HTTP method not yet supported !\");\n            default:\n                throw new Error(\"HTTP method unknown !\");\n        }\n\n        // test sur les valeurs de 'settings.format'\n        switch (settings.format) {\n            case \"text\":\n                this.__call(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"json\":\n                this.__callJSON(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            case \"xml\":\n                this.__callXML(options)\n                    .then(function (response) {\n                        logger.trace(response);\n                        settings.onResponse.call(this, response);\n                    })\n                    .catch(function (error) {\n                        settings.onFailure.call(this, error);\n                    });\n                break;\n            default:\n                throw new Error(\"This output Format is not yet supported !\");\n        }\n    },\n\n    /**\n     * Requete\n     *\n     * @method __call\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __call : function (options) {\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"XHR\");\n        logger.trace(\"[XHR::__call()]\");\n\n        var promise = new Promise(\n            function (resolve, reject) {\n                // traitement du corps de la requête\n                var corps = (options.method === \"POST\" || options.method === \"PUT\") ? 1 : 0;\n\n                // seulement si options.data n'est pas vide (peut être un objet ou une chaine de caractères)\n                if (options.data && ((typeof options.data === \"object\" && Object.keys(options.data).length) || (typeof options.data === \"string\" && options.data.length)) && !corps) {\n                    options.url = __WEBPACK_IMPORTED_MODULE_1__Utils_Helper__[\"a\" /* default */].normalyzeUrl(options.url, options.data);\n                }\n\n                logger.trace(\"URL = \", options.url);\n\n                var hXHR = null;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    // Utilisation du module :\n                    // cf. http://blog.modulus.io/node.js-tutorial-how-to-use-request-module\n\n                    var req = __webpack_require__(52);// __request\n\n                    // mapping data avec body param. pour le mode POST ou PUT (?)\n                    if (options.data && typeof options.data === \"string\" && corps) {\n                        options.body = options.data;\n                    }\n\n                    // FIXME ERROR : self signed certificate in certificate chain\n                    options.rejectUnauthorized = false;\n\n                    req(options, function (error, response, body) {\n                        if (!error && response.statusCode === 200 && body) {\n                            resolve(body);\n                        } else {\n                            reject(\"Errors Occured on Http Request (nodejs) : \" + error);\n                        }\n                    });\n                } else {\n                    if (window.XMLHttpRequest) {\n                        logger.trace(\"XMLHttpRequest\");\n\n                        hXHR = new XMLHttpRequest();\n                        hXHR.open(options.method, options.url, true); // async\n                        hXHR.overrideMimeType = options.content;\n\n                        // gestion du timeout\n                        var onTimeOutTrigger = null;\n                        if (options.timeOut > 0) {\n                            // FIXME le timeout interne ne me permet pas de declencher le bon message...\n                            // hXHR.timeout = options.timeOut;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                            /**\n                             * Description\n                             *\n                             * @method onTimeOutTrigger\n                             * @private\n                             */\n                            onTimeOutTrigger = window.setTimeout(\n                                function () {\n                                    var message = \"TimeOut Occured on Http Request with XMLHttpRequest !\";\n                                    reject({\n                                        message : message,\n                                        status : -1\n                                    });\n                                }, options.timeOut);\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            logger.trace(\"data = \", options.data);\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * On Error\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function (e) {\n                            console.log(e);\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Timeout\n                         * FIXME ne se declenche pas !?\n                         *\n                         * @param {Object} e - Event\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function () {\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method onreadystatechange\n                         * @private\n                         */\n                        hXHR.onreadystatechange = function () {\n                            if (hXHR.readyState === 4) { // DONE\n                                if (hXHR.status === 200) {\n                                    window.clearTimeout(onTimeOutTrigger);\n                                    resolve(hXHR.response);\n                                } else {\n                                    var message = \"Errors Occured on Http Request (status : '\" + hXHR.status + \"' | response : '\" + hXHR.response + \"')\";\n                                    var status = hXHR.status;\n                                    reject({\n                                        message : message,\n                                        status : status\n                                    });\n                                }\n                            }\n                        };\n\n                        // gestion du content data\n                        var data4xhr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xhr);\n                    } else if (window.XDomainRequest) {\n                        // worked in Internet Explorer 8–10 only !\n                        logger.trace(\"XDomainRequest\");\n\n                        hXHR = new XDomainRequest();\n                        hXHR.open(options.method, options.url);\n\n                        hXHR.overrideMimeType = options.content;\n\n                        if (options.timeOut > 0) {\n                            hXHR.timeout = options.timeout;\n                            logger.trace(\"XHR - TimeOut actif !\");\n                        }\n\n                        if (corps) {\n                            // headers, data, content of data\n                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader\n                            hXHR.setRequestHeader(\"Content-type\", options.content);\n                            // FIXME refused to set unsafe header content-length javascript\n                            // hXHR.setRequestHeader (\"Content-length\", options.data.length);\n                            // hXHR.setRequestHeader (\"Referer\", options.headers.referer);\n                        }\n\n                        /**\n                         * Description\n                         *\n                         * @method onerror\n                         * @private\n                         */\n                        hXHR.onerror = function () {\n                            reject(new Error(\"Errors Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * Description\n                         *\n                         * @method ontimeout\n                         * @private\n                         */\n                        hXHR.ontimeout = function () {\n                            reject(new Error(\"TimeOut Occured on Http Request with XMLHttpRequest !\"));\n                        };\n\n                        /**\n                         * On Load\n                         *\n                         * @method onload\n                         * @private\n                         */\n                        hXHR.onload = function () {\n                            if (hXHR.status === 200) {\n                                resolve(hXHR.responseText);\n                            } else {\n                                var message = \"Errors Occured on Http Request (status : '\" + hXHR.status + \"' | response : '\" + hXHR.responseText + \"')\";\n                                var status = hXHR.status;\n                                reject({\n                                    message : message,\n                                    status : status\n                                });\n                            }\n                        };\n\n                        var data4xdr = (options.data && corps) ? options.data : null;\n\n                        hXHR.send(data4xdr);\n                    } else {\n                        throw new Error(\"CORS not supported\");\n                    }\n                }\n            }\n        );\n\n        return promise;\n    },\n\n    /**\n     * Requete avec parser JSON\n     *\n     * @method __callJSON\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callJSON : function (options) {\n        return this.__call(options)\n            .then(JSON.parse)\n            .catch(function (error) {\n                console.log(\"_callJSON failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    },\n\n    /**\n     * Requete avec parser XML\n     *\n     * @method __callXML\n     * @private\n     * @param  {Object} options - options\n     * @return {Object} promise\n     */\n    __callXML : function (options) {\n        return this.__call(options)\n            .then(function (response) {\n                var xmlDoc;\n\n                // test on env. nodejs or browser\n                if (typeof window === \"undefined\") {\n                    var DOMParser = __webpack_require__(20).DOMParser; // __xmldom.DOMParser\n                    xmlDoc = new DOMParser().parseFromString(response, \"text/xml\");\n                } else {\n                    if (window.DOMParser) {\n                        var parser = new window.DOMParser();\n                        xmlDoc = parser.parseFromString(response, \"text/xml\");\n                    } else { // IE\n                        xmlDoc = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n                        xmlDoc.async = false;\n                        xmlDoc.loadXML(response);\n                    }\n                }\n\n                return xmlDoc;\n            })\n            .catch(function (error) {\n                console.log(\"__callXML failed on : \", options.url, error);\n                // FIXME pas d'exception, laissons le fil se derouler...\n                // throw error;\n            });\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (XHR);\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_20__;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AltiRequest__ = __webpack_require__(22);\n\n\n\n\n/**\n * @classdesc\n *\n * Classe de gestion des param. des requêtes de type POINT du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiElevationRequest\n * @param {Object} options - options\n * @param {Boolean}  options.zonly - false|true\n *\n * @private\n */\nfunction AltiElevationRequest (options) {\n    if (!(this instanceof AltiElevationRequest)) {\n        throw new TypeError(\"AltiElevationRequest constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"AltiElevationRequest\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_1__AltiRequest__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur AltiElevationRequest ()]\");\n\n    /**\n     * Z uniquement.\n     * true|false\n     */\n    this.zonly = this.options.zonly || false; // test des options héritées !\n}\n\n/**\n * @lends module:AltiElevationRequest#\n */\n\nAltiElevationRequest.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__AltiRequest__[\"a\" /* default */].prototype, {\n\n    /**\n     * Setter/getter pour \"zonly\"\n     */\n    zonly : {\n        /** getter */\n        get : function () {\n            return this._zonly;\n        },\n        /** setter */\n        set : function (z) {\n            this._zonly = z;\n        }\n    }\n\n});\n\n/**\n * Constructeur (alias)\n */\nAltiElevationRequest.prototype.constructor = AltiElevationRequest;\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Array}\n */\nAltiElevationRequest.prototype.getData = function () {\n    // par glop..., appel de AltiRequest::getData () !\n    var map = [];\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    // map.push({k : \"delimiter\", v : this.delimiter}); // FIXME on retire le param \"delimiter\"\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"zonly\",\n        v : this.zonly\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiElevationRequest);\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiRequest\n * @param {Object} options - options\n * @param {Object}   options.positions - tableau de coordonnées lon/lat\n * @param {String}   options.delimiter - \"|\"\n * @param {Boolean}  options.indent - false|true\n * @param {String}   options.crs - \"CRS:84\"\n * @param {String}   options.format - \"JSON|XML\"\n *\n * @private\n */\nfunction AltiRequest (options) {\n    if (!(this instanceof AltiRequest)) {\n        throw new TypeError(\"AltiRequest constructor cannot be called as a function.\");\n    }\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur AltiRequest ()]\");\n\n    /**\n     * Options en paramêtres du constructeur.\n     */\n    this.options = options || {};\n\n    /**\n     * Liste des coordonnées.\n     * @example\n     * var c = [{lon : \"\", lat : \"\"}, {lon : \"\", lat : \"\"}];\n     */\n    this.positions = this.options.positions || [];\n\n    /**\n     * Caractère de séparation.\n     * Par defaut, \"|\".\n     */\n    this.delimiter = this.options.delimiter || \"|\";\n\n    /**\n     * Indentation.\n     * true|false\n     */\n    this.indent = this.options.indent || false;\n\n    /**\n     * Projection.\n     * Par defaut, CRS:84.\n     */\n    this.crs = this.options.crs || \"CRS:84\";\n\n    /**\n     * format de sortie.\n     * Par defaut, \"json\".\n     */\n    this.format = this.options.format || \"json\";\n}\n\n/**\n * CLASSNAME\n */\nAltiRequest.CLASSNAME = \"AltiRequest\";\n\nAltiRequest.prototype = {\n\n    /**\n     * @lends module:AltiRequest#\n     */\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : AltiRequest,\n\n    /**\n     * Ajout d\"une liste de coordonnées.\n     *\n     * @param {Object[]} lstPosition - liste de positions\n     * @example\n     * obj.setPositions ([{lon : \"0.15\", lat : \"0.15\"}, {lon : \"1.15\", lat : \"1.15\"}]);\n     */\n    setPositions : function (lstPosition) {\n        var positions = [];\n        for (var i = 0; i < lstPosition.length; i++) {\n            var o = lstPosition[i];\n            if (o.lon && o.lat) {\n                positions.push(o);\n            }\n        }\n\n        this.positions = positions;\n    },\n\n    /**\n     * Liste des coordonnées.\n     *\n     * @param {Int} pos - position\n     * @returns {positions}\n     * @example\n     * obj.getPositions ();  // [{lon : \"\", lat : \"\"}, {lon : \"\", lat : \"\"}]\n     * obj.getPositions (0); // [{lon : \"\", lat : \"\"}]\n     */\n    getPositions : function (pos) {\n        // FIXME test if not a number !?\n        if (!pos) {\n            return this.positions;\n        }\n\n        var index = this.positions.length - 1;\n        if (pos > index || pos < index) {\n            this.logger.warn(\"index out of range !\");\n            return this.positions;\n        }\n\n        return this.positions[pos];\n    },\n\n    /**\n     * Ajout d\"une liste de coordonnées.\n     *\n     * @param {Object[]} lstPosition - liste de positions\n     * @example\n     * obj.addPositions ([{lon : \"0.15\", lat : \"0.15\"}, {lon : \"1.15\", lat : \"1.15\"}]);\n     */\n    addPositions : function (lstPosition) {\n        for (var i = 0; i < lstPosition.length; i++) {\n            var o = lstPosition[i];\n            if (o.lon && o.lat) {\n                this.positions.push(lstPosition[i]);\n            }\n        }\n    },\n\n    /**\n     * Retourne la liste des longitudes avec un caractère de séparation.\n     *\n     * @returns {String} - une liste de longitudes\n     * @example\n     * // out : 0.2367|2.1570|43.789|...\n     */\n    getLon : function () {\n        var lstLon = [];\n        for (var i = 0; i < this.positions.length; i++) {\n            lstLon.push(this.positions[i].lon);\n        }\n        this.logger.trace(lstLon);\n        return lstLon.join(this.delimiter);\n    },\n\n    /**\n     * Retourne la liste des lattitudes avec un caractère de séparation.\n     *\n     * @returns {String} - une liste de lattitudes\n     * @example\n     * // out : 0.2367|2.1570|43.789|...\n     */\n    getLat : function () {\n        var lstLat = [];\n        for (var i = 0; i < this.positions.length; i++) {\n            lstLat.push(this.positions[i].lat);\n        }\n        this.logger.trace(lstLat);\n        return lstLat.join(this.delimiter);\n    }\n\n};\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Object[]}\n */\nAltiRequest.prototype.getData = function () {\n    var map = [];\n\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    map.push({\n        k : \"delimiter\",\n        v : this.delimiter\n    });\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiRequest);\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AltiRequest__ = __webpack_require__(22);\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes de type PROFIL du service altimetrique.\n *\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiProfilRequest\n * @param {Object}   options - options\n * @param {String}   options.sampling - 3\n *\n * @private\n */\nfunction AltiProfilRequest (options) {\n    if (!(this instanceof AltiProfilRequest)) {\n        throw new TypeError(\"AltiProfilRequest constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"AltiProfilRequest\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_1__AltiRequest__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur AltiProfilRequest ()]\");\n\n    /**\n     * Sampling\n     * Par defaut, 3\n     */\n    this.sampling = this.options.sampling || 3; // test des options héritées !\n}\n\n/**\n * @lends module:AltiProfilRequest#\n */\n\nAltiProfilRequest.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__AltiRequest__[\"a\" /* default */].prototype, {\n\n    /**\n     * Setter/getter pour \"sampling\"\n     */\n    sampling : {\n        /** getter */\n        get : function () {\n            return this._sampling;\n        },\n        /** setter */\n        set : function (value) {\n            this._sampling = value;\n        }\n    }\n});\n\n/**\n * Constructeur (alias)\n */\nAltiProfilRequest.prototype.constructor = AltiProfilRequest;\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Object[]}\n */\nAltiProfilRequest.prototype.getData = function () {\n    // par glop..., appel de AltiRequest::getData () !\n    var map = [];\n    map.push({\n        k : \"lon\",\n        v : this.getLon()\n    });\n    map.push({\n        k : \"lat\",\n        v : this.getLat()\n    });\n    // map.push({k : \"delimiter\", v : this.delimiter}); // FIXME on retire le param \"delimiter\"\n    map.push({\n        k : \"indent\",\n        v : this.indent\n    });\n    map.push({\n        k : \"crs\",\n        v : this.crs\n    });\n    map.push({\n        k : \"sampling\",\n        v : this.sampling\n    });\n    map.push({\n        k : \"format\",\n        v : this.format\n    });\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiProfilRequest);\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Response object for {@link module:Services~getConfig Gp.Services.getConfig ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Object} generalOptions - General properties for default map configuration resources.\n * @property {Object} generalOptions.apiKeys - Object that associates apiKey (s) with an array of resources IDs availables with that key.\n * @property {String} generalOptions.title - Underlying web service Title.\n * @property {String} generalOptions.defaultGMLGFIStyle - XSL URL used by default to translate an XML GetFeatureInfo response into an HTML array.\n * @property {String} generalOptions.theme - default theme (FIXME : for what ?)\n * @property {Array.<Float>} generalOptions.wgs84Resolutions - geographical resolutions Array for each [zoom level of the Geoportal platform]{@link http://api.ign.fr/tech-docs-js/webmaster/layers.html#Geoportal_resolutions} from 0 to 21. Expressed in degrees/pixel.\n * @property {Object} layers - Associative array mapping resources availables IDs (keys) with their properties (values given as {@link Gp.Services.Config.Layer}).\n * @property {Object} territories - Associative array mapping french territories IDs (keys) with their properties (values given as {@link Gp.Services.Config.Territory}).\n * @property {Object} tileMatrixSets - Associative Array mapping TileMatrixSets IDs (keys) availables with their properties (values given as {@link Gp.Services.Config.TileMatrixSet}).\n * @property {Object} services - Associative Array mapping Geoportal web services IDs (keys) availables with their properties (values given as {@link Gp.Services.Config.Service}).\n *\n * @namespace\n * @alias Gp.Services.GetConfigResponse\n */\nfunction AutoConfResponse () {\n    if (!(this instanceof AutoConfResponse)) {\n        throw new TypeError(\"AutoConfResponse constructor cannot be called as a function.\");\n    }\n\n    this.generalOptions = {\n        apiKeys : {},\n        title : null,\n        defaultGMLGFIStyle : null,\n        theme : null,\n        wgs84Resolutions : []\n    };\n\n    this.layers = {};\n\n    this.territories = {};\n\n    this.tileMatrixSets = {};\n\n    this.services = {};\n}\n\nAutoConfResponse.prototype = {\n\n    /*\n     * Constructor (alias)\n     */\n    constructor : AutoConfResponse,\n\n    /**\n     * Check if config is loaded for a given key\n     *\n     * @param {String} apiKey - Access key to Geoportal platform\n     * @returns {Boolean} isConfLoaded - true if config is already loaded, false otherwise\n     */\n    isConfLoaded : function (apiKey) {\n        if (!apiKey) {\n            return;\n        }\n        if (this.generalOptions.apiKeys[apiKey]) {\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Returns an array of Geoportal layers identifiers, corresponding to an API contract key.\n     *\n     * @param {String} apiKey - Access key to Geoportal platform\n     * @returns {Array} apiKeys - Array of geoportal layers identifiers\n     */\n    getLayersId : function (apiKey) {\n        return this.generalOptions.apiKeys[apiKey];\n    },\n\n    /**\n     * Returns an associative array of Geoportal layers configurations, corresponding to an API contract key.\n     * If no key is specified, all layers from configuration are returned.\n     *\n     * @param {String} apiKey - Access key to Geoportal platform\n     * @returns {Object} layers - Object which properties are layers identifiers, and corresponding\n     *      values are instances of <Gp.Services.Config.Layer>.\n     */\n    getLayersConf : function (apiKey) {\n        var layers = {};\n        var layersIdArray = this.getLayersId(apiKey);\n        if (layersIdArray) {\n            for (var i = 0; i < layersIdArray.length; i++) {\n                var lyrId = layersIdArray[i];\n                layers[lyrId] = this.layers[lyrId];\n            }\n        }\n        return layers;\n    },\n\n    /**\n     * Returns a geoportal layer configuration, given its identifier\n     *\n     * @param {String} layerId - Geoportal layer identifier (e.g. \"GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS\")\n     * @return {Object} layer - Layer configuration : instance of {@link Gp.Services.Config.Layer}\n     */\n    getLayerConf : function (layerId) {\n        if (!this.layers) {\n            return;\n        }\n        return this.layers[layerId];\n    },\n\n    /**\n     * Returns an associative array of Tile Matrix Sets configurations.\n     *\n     * @return {Object} tileMatrixSets - Object which properties are TMS identifiers,\n     *      and corresponding values are instances of {@link Gp.Services.Config.TileMatrixSet}.\n     */\n    getTileMatrixSets : function () {\n        return this.tileMatrixSets;\n    },\n\n    /**\n     * Returns a Tile Matrix Sets configuration, given its identifier.\n     *\n     * @param {String} tmsID - Tile Matrix Set identifier (e.g. : \"PM\")\n     * @return {Object} tileMatrixSet - Tile Matrix Set configuration, instance of {@link Gp.Services.Config.TileMatrixSet}\n     */\n    getTMSConf : function (tmsID) {\n        if (!this.tileMatrixSets) {\n            return;\n        }\n        return this.tileMatrixSets[tmsID];\n    },\n\n    /**\n     * Returns an associative array of territories configurations.\n     *\n     * @return {Object} territories - Object which properties are territory identifiers,\n     *      and corresponding values are instances of {@link Gp.Services.Config.Territory}.\n     */\n    getTerritories : function () {\n        return this.territories;\n    },\n\n    /**\n     * Returns a territory configuration, given its identifier.\n     *\n     * @param {String} territoryID - territory identifier (e.g. \"FXX\")\n     * @return {Object} territory - Territory configuration, instance of {@link Gp.Services.Config.Territory}\n     */\n    getTerritoryConf : function (territoryID) {\n        if (!this.territories) {\n            return;\n        }\n        return this.territories[territoryID];\n    },\n\n    /**\n     * Returns an associative array of services configurations.\n     *\n     * @return {Object} services - Object which properties are services identifiers,\n     *      and corresponding values are instances of {@link Gp.Services.Config.Service}.\n     */\n    getServices : function () {\n        return this.services;\n    },\n\n    /**\n     * Returns a service configuration, given its identifier.\n     *\n     * @param {String} serviceID - service identifier (e.g. \"OGC:WMTS\")\n     * @return {Object} service - service configuration, instance of {@link Gp.Services.Config.Service}\n     */\n    getServiceConf : function (serviceID) {\n        if (!this.services) {\n            return;\n        }\n        return this.services[serviceID];\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoConfResponse);\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n *\n * Object used to express a geographical (BBOX, scale) and temporal constraint.\n *\n * @property {String} crs - Coordinates System ID used to express coordinates contraints.\n * @property {Gp.BBox} bbox - Constraint Bounding Box.\n * @property {Number} minScaleDenominator - Minimum scale denominator where constraint applies.\n * @property {Number} maxScaleDenominator - Maximum scale denominator where constraint applies.\n * @property {Array.<String>} temporalExtent - Array expressing the time interval of the constraint [minT, maxT]. Dates are expressed in the [ISO-8601]{@link https://en.wikipedia.org/wiki/ISO_8601} way.\n *\n * @namespace\n * @alias Gp.Services.Config.Constraint\n */\n\nfunction Constraint () {\n    if (!(this instanceof Constraint)) {\n        throw new TypeError(\"Constraint constructor cannot be called as a function.\");\n    }\n\n    this.crs = null;\n\n    this.bbox = {\n        left : null,\n        right : null,\n        top : null,\n        bottom : null\n    };\n\n    this.minScaleDenominator = null;\n\n    this.maxScaleDenominator = null;\n\n    this.temporalExtent = [null, null];\n}\n\nConstraint.prototype = {\n\n    constructor : Constraint\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Constraint);\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a format to use with Geoportal resources.\n *\n * @property {Boolean} current - If true, then this format is used by default.\n * @property {String} name - Format mime-type.\n *\n * @namespace\n * @alias Gp.Services.Config.Format\n */\n\nfunction Format () {\n    if (!(this instanceof Format)) {\n        throw new TypeError(\"Format constructor cannot be called as a function.\");\n    }\n\n    this.current = null;\n\n    this.name = null;\n}\n\nFormat.prototype = {\n\n    constructor : Format\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Format);\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe geoportal resource (WMTS, WMS, WFS layers, geocoding resources or elevation service) parameters. Properties may be used or not depending on the resource type.\n *\n * @property {String} name - name of the resource to use with the webservice that serves it (eg : \"GEOGRAPHICALGRIDSYSTEMS.MAPS\").\n * @property {String} title - Human readable name for the resource.\n * @property {String} description - Resource description.\n * @property {String} layerId - Unique resource Identifier (eg : \"GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS\")\n * @property {String} quicklookUrl - Image URL for the resource.\n * @property {Object} serviceParams - Informations about the webservice that serves the resource (OpenLS, WFS, WMTS)\n * @property {String} serviceParams.id - Web Service identifier (\"OGC:WMTS\", \"OGC:OPENLS;ReverseGeocode\", etc...)\n * @property {Object} serviceParams.serverUrl - Associative array mapping geoportal access key (keys) with their properties (URLs of the web service, with the geoportal access key).\n * @property {String} serviceParams.version - webservice version.\n * @property {String} defaultProjection - coordinates system ID used by default for the resource (WMS or WFS layer) or of the TileMatrixSet used by the WMTS layer.\n * @property {Array.<String>} additionalProjections - additional coordinates systems IDs availables for the resource, others than the default one (see defaultProjection) (WMS and WFS layers only).\n * @property {Array.<Gp.Services.Config.Format>} formats - Formats availables for the resource.\n * @property {Array.<Gp.Services.Config.Legend>} legends - Informations about legends associated to the resource.\n * @property {Array.<Gp.Services.Config.Metadata>} metadata - Informations about metadata associated to the resource.\n * @property {Array.<Gp.Services.Config.Style>} styles - Informations about styles availables for the resources (WMS, WFS and WMTS only).\n * @property {Array.<Gp.Services.Config.Thematic>} thematics - Informations about thematics associated to the resource.\n * @property {Gp.Services.Config.Constraint} globalConstraint - geographical constraint for the resource.\n * @property {Array.<Gp.Services.Config.Constraint>} constraints - additionnal geographical constraints for the resource.\n * @property {Array.<Gp.Services.Config.Originator>} originators - Informations about originator of the resource.\n * @property {Object} wmtsOptions - Informations associated to WMTS resources.\n * @property {String} wmtsOptions.tileMatrixSetLink - TileMatrixSet identifier used by the resource (see {@link Gp.Services.Config.TileMatrixSet})\n * @property {Gp.Services.Config.TileMatrixLimit} wmtsOptions.tileMatrixSetLimits - limits of the resource for that TileMAtrixSet.\n * @property {Boolean} queryable - true if a getFeatureInfo request may be done for the resource (WMS or WMTS only).\n * @property {Boolean} hidden - true if the resource is not visible.\n * @property {Boolean} isAggregate - true if the resource is an aggregate of other resources (@see aggregatedLayers).\n * @property {Array.<String>} aggregatedLayers - Layers IDs composing the being described aggregated layer.\n * @property {Array.<String>} apiKeys - Array of access keys that grant access to that resource.\n * @property {Object} dimensions - Dimensions informations associated with the resource.\n * @property {String} dimensions.type\n * @property {String} dimensions.visibilityRange\n * @property {String} dimensions.visibilityMode\n * @property {String} dimensions.noDataValue\n * @property {String} dimensions.geometricType\n *\n * @namespace\n * @alias Gp.Services.Config.Layer\n */\nfunction Layer () {\n    if (!(this instanceof Layer)) {\n        throw new TypeError(\"Layer constructor cannot be called as a function.\");\n    }\n\n    // info : une instance de la classe Layer n'a aucune propriété au départ,.\n    // les attributs possibles sont documentés ci-dessus,\n    // et seront implémentés au fur et à mesure de la lecture de la réponse de l'autoconf, lorsque l'information est rencontrée.\n}\n\nLayer.prototype = {\n\n    constructor : Layer,\n\n    /**\n     * Returns the layer name\n     *\n     * @returns {String} name - name of the resource to use with the webservice that serves it (eg : \"GEOGRAPHICALGRIDSYSTEMS.MAPS\").\n     */\n    getName : function () {\n        return this.name;\n    },\n\n    /**\n     * Returns the layer title\n     *\n     * @returns {String} title - Human readable name for the resource.\n     */\n    getTitle : function () {\n        return this.title;\n    },\n\n    /**\n     * Returns the layer description\n     *\n     * @returns {String} description - Resource description.\n     */\n    getDescription : function () {\n        return this.description;\n    },\n\n    /**\n     * Returns the layer identifier\n     *\n     * @returns {String} layerId - Unique resource Identifier (eg : \"GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS\")\n     */\n    getLayerId : function () {\n        return this.layerId;\n    },\n\n    /**\n     * Returns the layer quicklookUrl\n     *\n     * @returns {String} quicklookUrl - Image URL for the resource.\n     */\n    getQuicklookUrl : function () {\n        return this.quicklookUrl;\n    },\n\n    /**\n     * Returns the layer default projection\n     *\n     * @returns {String} defaultProjection - coordinates system ID used by default for the resource (WMS or WFS layer) or of the TileMatrixSet used by the WMTS layer.\n     */\n    getDefaultProjection : function () {\n        return this.defaultProjection;\n    },\n\n    /**\n     * Returns the layer projections\n     *\n     * @returns {Array.<String>} projections - coordinates systems IDs availables for the resource, including the default one.\n     */\n    getProjections : function () {\n        var projections = [];\n        projections.push(this.defaultProjection);\n        var proj = projections.concat(this.additionalProjections);\n        return proj;\n    },\n\n    /**\n     * Returns the global BBOX\n     *\n     * @returns {Gp.BBox} bbox - the layer global bounding box, expressed in CRS system.\n     */\n    getBBOX : function () {\n        if (!this.globalConstraint) {\n            return;\n        }\n        return this.globalConstraint.bbox;\n    },\n\n    /**\n     * Returns the layer minimum scale denominator\n     *\n     * @returns {Number} minScaleDenominator - minimum scale denominator for this layer\n     */\n    getMinScaleDenominator : function () {\n        if (!this.globalConstraint) {\n            return;\n        }\n        return this.globalConstraint.minScaleDenominator;\n    },\n\n    /**\n     * Returns the layer maximum scale denominator\n     *\n     * @returns {Number} maxScaleDenominator - maximum scale denominator for this layer\n     */\n    getMaxScaleDenominator : function () {\n        if (!this.globalConstraint) {\n            return;\n        }\n        return this.globalConstraint.maxScaleDenominator;\n    },\n\n    /**\n     * Returns layer Tile Matrix Set identifier if exists\n     *\n     * @returns {String} tileMatrixSetLink - Tile Matrix Set identifier (for instance : \"PM\")\n     */\n    getTMSID : function () {\n        if (this.wmtsOptions) {\n            return this.wmtsOptions.tileMatrixSetLink;\n        }\n    },\n\n    /**\n     * Returns information about the webservice that serves the resource\n     *\n     * @returns {Object} serviceParams - Information about the webservice that serves the resource (OpenLS, WFS, WMTS)\n     */\n    getServiceParams : function () {\n        return this.serviceParams;\n    },\n\n    /**\n     * Returns Geoportal server url for a given key\n     *\n     * @param {String} apiKey - Access key to Geoportal platform\n     * @returns {String} serverUrl - general URL of the web service (with the geoportal access key)\n     */\n    getServerUrl : function (apiKey) {\n        if (!apiKey || !this.serviceParams || !this.serviceParams.serverUrl) {\n            return;\n        }\n        return this.serviceParams.serverUrl[apiKey];\n    },\n\n    /**\n     * Returns information about legends associated to the resource.\n     *\n     * @returns {Array.<Gp.Services.Config.Legend>} legends - Informations about legends associated to the resource.\n     */\n    getLegends : function () {\n        return this.legends;\n    },\n\n    /**\n     * Returns information about metadata associated to the resource.\n     *\n     * @returns {Array.<Gp.Services.Config.Metadata>} metadata - Informations about metadata associated to the resource.\n     */\n    getMetadata : function () {\n        return this.metadata;\n    },\n\n    /**\n     * Returns information about styles availables for the resources (WMS, WFS and WMTS only).\n     *\n     * @returns {Array.<Gp.Services.Config.Style>} styles - Informations about styles availables for the resources (WMS, WFS and WMTS only).\n     */\n    getStyles : function () {\n        return this.styles;\n    },\n\n    /**\n     * Returns layer default style\n     *\n     * @returns {String} styleName - style identifier (eg : \"normal\", \"bdparcellaire\", ...)\n     */\n    getDefaultStyle : function () {\n        if (!this.styles) {\n            return;\n        }\n        var style;\n        var s = this.styles;\n        for (var i = 0; i < s.length; i++) {\n            if (s[i].current === true) {\n                style = s[i].name;\n                break;\n            }\n        }\n        return style;\n    },\n\n    /**\n     * Returns information about thematics associated to the resource.\n     *\n     * @returns {Array.<Gp.Services.Config.Thematic>} thematics - Informations about thematics associated to the resource.\n     */\n    getThematics : function () {\n        return this.thematics;\n    },\n\n    /**\n     * Returns layer default format\n     *\n     * @returns {String} formatName - Format mime-type. (eg. \"image/jpeg\")\n     */\n    getDefaultFormat : function () {\n        if (!this.formats) {\n            return;\n        }\n        var format;\n        var f = this.formats;\n        for (var i = 0; i < f.length; i++) {\n            if (f[i].current === true) {\n                format = f[i].name;\n                break;\n            }\n        }\n        return format;\n    },\n\n    /**\n     * Returns information about geographical or temporal constraints for the resource\n     *\n     * @returns {Array.<Gp.Services.Config.Constraint>} constraints - Informations about geographical or temporal constraints for the resource\n     */\n    getConstraints : function () {\n        return this.constraints;\n    },\n\n    /**\n     * Returns information about originators of this resource\n     *\n     * @returns {Array.<Gp.Services.Config.Originator>} originators - Informations about originators of this resource\n     */\n    getOriginators : function () {\n        return this.originators;\n    },\n\n    /**\n     * Returns information about dimensions associated with this resource\n     *\n     * @returns {Object} dimensions - Dimensions informations associated with the resource.\n     */\n    getDimensions : function () {\n        return this.dimensions;\n    },\n\n    /**\n     * Returns information about aggregated layers composing the being described layer, in case the resource is an aggregate of other resources.\n     *\n     * @returns {Object} aggregatedLayers - Layers IDs composing the being described aggregated layer.\n     */\n    getAggregatedLayers : function () {\n        if (this.isAggregate) {\n            return this.aggregatedLayers;\n        } else {\n\n        }\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Layer);\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a legend file associated with a geoportal resource (WMTS, WMS, WFS layers).\n *\n * @property {String} format - mime-type of the legend file.\n * @property {String} url - legend file URL\n * @property {Number} minScaleDenominator - minimum scale denominator where this legend applies.\n *\n * @namespace\n * @alias Gp.Services.Config.Legend\n */\n\nfunction Legend () {\n    if (!(this instanceof Legend)) {\n        throw new TypeError(\"Legend constructor cannot be called as a function.\");\n    }\n\n    this.format = null;\n\n    this.url = null;\n\n    this.minScaleDenominator = null;\n}\n\nLegend.prototype = {\n\n    constructor : Legend\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Legend);\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a metadata file associated with a geoportal resource.\n *\n * @property {String} format - mime-type of the metadata file.\n * @property {String} url - metadata file URL\n *\n * @namespace\n * @alias Gp.Services.Config.Metadata\n */\n\nfunction Metadata () {\n    if (!(this instanceof Metadata)) {\n        throw new TypeError(\"Metadata constructor cannot be called as a function.\");\n    }\n\n    this.format = null;\n\n    this.url = null;\n}\n\nMetadata.prototype = {\n\n    constructor : Metadata\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Metadata);\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe an Originator of geoportal resource.\n *\n * @property {String} name - originator name\n * @property {String} attribution - originator full name\n * @property {String} logo - originator logo file URL\n * @property {String} url - originator web site URL\n * @property {Array.<Gp.Services.Config.Constraint>} constraints - where and when the originator applies for the ressource.\n *\n * @namespace\n * @alias Gp.Services.Config.Originator\n */\n\nfunction Originator () {\n    if (!(this instanceof Originator)) {\n        throw new TypeError(\"Originator constructor cannot be called as a function.\");\n    }\n\n    this.name = null;\n\n    this.attribution = null;\n\n    this.logo = null;\n\n    this.url = null;\n\n    this.constraints = [];\n}\n\nOriginator.prototype = {\n\n    constructor : Originator\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Originator);\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a web service of the geoportal platform.\n *\n * @property {String} title - Web service name\n * @property {Object} serverUrl - Associative array mapping geoportal access key (keys) with their properties (URLs of the web service, with the geoportal access key).\n * @property {String} version - web service version.\n *\n * @namespace\n * @alias Gp.Services.Config.Service\n */\nfunction Service () {\n    if (!(this instanceof Service)) {\n        throw new TypeError(\"Service constructor cannot be called as a function.\");\n    }\n\n    this.title = null;\n\n    this.serverUrl = null;\n\n    this.version = null;\n}\n\nService.prototype = {\n\n    constructor : Service\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Service);\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a style that may be used for a geoportal resource.\n *\n * @property {String} name - Style identifier (eg : \"normal\", \"bdparcellaire\", ...)\n * @property {String} title - human readable name of the style.\n * @property {Boolean} current - true if this is the default style.\n *\n * @namespace\n * @alias Gp.Services.Config.Style\n */\n\nfunction Style () {\n    if (!(this instanceof Style)) {\n        throw new TypeError(\"Style constructor cannot be called as a function.\");\n    }\n\n    this.name = null;\n\n    this.title = null;\n\n    this.current = null;\n}\n\nStyle.prototype = {\n\n    constructor : Style\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Style);\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe properties of a french territory covered by geoportal resources.\n *\n * @property {Boolean} isDefault - if this territory is to use by default.\n * @property {String} defaultCRS - Identifier of the coordinates system to use by default for that territory.\n * @property {Array.<String>} additionalCRS - Identifiers of additional coordinates systems availables for that territory.\n * @property {Array.<String>} defaultLayers - Identifiers of layers to load by default for that territory.\n * @property {Object} defaultOptions - options to use by default for that territory.\n * @property {Number} defaultOptions.resolution - resolution to use by default for that territory (in meter per pixel).\n * @property {Number} defaultOptions.minScaleDenominator - minimum scaleDenominator accessible for that territory.\n * @property {Number} defaultOptions.maxScaleDenominator - maximum scaleDenominator accessible for that territory.\n * @property {Gp.BBox} geoBBox - Bounding Box of the territory (expressed in geographical coordinates)\n * @property {Object} geoCenter - center of the territory (expressed in geographical coordinates)\n * @property {Float} geoCenter.lon - center longitude\n * @property {Float} geoCenter.lat - center latitude\n *\n * @namespace\n * @alias Gp.Services.Config.Territory\n */\nfunction Territory () {\n    if (!(this instanceof Territory)) {\n        throw new TypeError(\"Territory constructor cannot be called as a function.\");\n    }\n\n    this.isDefault = null;\n\n    this.defaultCRS = null;\n\n    this.additionalCRS = [];\n\n    this.geoBBOX = {\n        left : null,\n        right : null,\n        top : null,\n        bottom : null\n    };\n\n    this.geoCenter = {\n        lon : null,\n        lat : null\n    };\n\n    this.defaultOptions = {\n        resolution : null,\n        minScaleDenominator : null,\n        maxScaleDenominator : null\n    };\n\n    this.defaultLayers = [];\n}\n\nTerritory.prototype = {\n\n    constructor : Territory\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Territory);\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a thematic\n *\n * @property {String} name - Thematic name\n * @property {Boolean} inspire - true if the thematic name is an [INSPIRE one]{@link http://inspire.ec.europa.eu/index.cfm/pageid/2/list/7}.\n *\n * @namespace\n * @alias Gp.Services.Config.Thematic\n */\n\nfunction Thematic () {\n    if (!(this instanceof Thematic)) {\n        throw new TypeError(\"Thematic constructor cannot be called as a function.\");\n    }\n\n    this.inspire = null;\n\n    this.name = null;\n}\n\nThematic.prototype = {\n\n    constructor : Thematic\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Thematic);\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n *\n * Object used to describe a TileMatrix set (for WMTS use).\n *\n * @property {Array.<String>} matrixIds - Array of IDs for each TileMatrix of the set.\n * @property {Array.<Gp.Services.Config.TileMatrix>} tileMatrices - Array of TileMatrix descriptions.\n * @property {Array.<Float>} nativeResolutions - Array of resolutions (in meter per pixel) applying for each TileMatrix of the set.\n * @property {String} projection - Identifier of the Cordinates System used for the tileMatrixSet.\n *\n * @namespace\n * @alias Gp.Services.Config.TileMatrixSet\n */\nfunction TileMatrixSet () {\n    if (!(this instanceof TileMatrixSet)) {\n        throw new TypeError(\"TileMatrixSet constructor cannot be called as a function.\");\n    }\n\n    this.projection = null;\n\n    this.nativeResolutions = [];\n\n    this.matrixIds = [];\n\n    this.tileMatrices = {};\n}\n\nTileMatrixSet.prototype = {\n\n    constructor : TileMatrixSet,\n\n    /**\n     * Returns Tile Matrix Set resolutions\n     *\n     * @returns {Array} nativeResolutions - Array of resolutions (in meter per pixel) applying for each TileMatrix of the set.\n     */\n    getResolutions : function () {\n        return this.nativeResolutions;\n    },\n\n    /**\n     * Returns Tile Matrix Set identifiers\n     *\n     * @returns {Array} matrixIds - Array of IDs for each TileMatrix of the set.\n     */\n    getMatrixIds : function () {\n        return this.matrixIds;\n    },\n\n    /**\n     * Returns Tile Matrix Set projection\n     *\n     * @returns {String} projection - Identifier of the Cordinates System used for the tileMatrixSet.\n     */\n    getProjection : function () {\n        return this.projection;\n    },\n\n    /**\n     * Returns Tile Matrices descriptions.\n     *\n     * @returns {Array.<Gp.Services.Config.TileMatrix>} tileMatrices - Array of TileMatrix descriptions.\n     */\n    getTileMatrices : function () {\n        return this.tileMatrices;\n    },\n\n    /**\n     * Returns top left corner point of matrices\n     *\n     * @returns {Gp.Point} topLeftCorner - Top Left Corner Point of TMS matrices, expressed in the tileMatrixSet coordinates system.\n     */\n    getTopLeftCorner : function () {\n        var topLeftCorner;\n        var matrices = this.getTileMatrices();\n        if (matrices) {\n            for (var id in matrices) {\n                if (matrices.hasOwnProperty(id)) {\n                    topLeftCorner = matrices[id].topLeftCorner;\n                    break;\n                }\n            }\n        }\n        return topLeftCorner;\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TileMatrixSet);\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a TileMatrix.\n *\n * @property {String} matrixId - matrix Identifier\n * @property {Number} matrixHeight - Number of tiles from the top to the bottom of the matrix.\n * @property {Number} matrixWidth - Number of tiles from the left to the right of the matrix.\n * @property {Number} scaleDenominator - Scale denominator associated to that matrix.\n * @property {Number} tileHeight - tile height in number of pixels\n * @property {Number} tileWidth - tile width in number of pixels\n * @property {Gp.Point} topLeftCorner - Top Left Corner Point of the matrix expressed in the tileMatrixSet coordinates system.\n *\n * @namespace\n * @alias Gp.Services.Config.TileMatrix\n */\n\nfunction TileMatrix () {\n    if (!(this instanceof TileMatrix)) {\n        throw new TypeError(\"TileMatrix constructor cannot be called as a function.\");\n    }\n\n    this.matrixId = null;\n\n    this.matrixHeight = null;\n\n    this.matrixWidth = null;\n\n    this.scaleDenominator = null;\n\n    this.tileHeight = null;\n\n    this.tileWidth = null;\n\n    this.topLeftCorner = null;\n}\n\nTileMatrix.prototype = {\n\n    constructor : TileMatrix,\n\n    /**\n     * Returns top left corner point of the matrix\n     *\n     * @returns {Gp.Point} topLeftCorner - Top Left Corner Point of the matrix expressed in the tileMatrixSet coordinates system.\n     */\n    getTopLeftCorner : function () {\n        return this.topLeftCorner;\n    },\n\n    /**\n     * Returns Scale denominator associated to that matrix.\n     *\n     * @returns {Number} scaleDenominator - Scale denominator associated to that matrix.\n     */\n    getScaleDenominator : function () {\n        return this.scaleDenominator;\n    },\n\n    /**\n     * Returns tile height of matrix\n     *\n     * @returns {Number} tileHeight - tile height in number of pixels\n     */\n    getTileHeight : function () {\n        return this.tileHeight;\n    },\n\n    /**\n     * Returns tile width of matrix\n     *\n     * @returns {Number} tileWidth - tile width in number of pixels\n     */\n    getTileWidth : function () {\n        return this.tileWidth;\n    },\n\n    /**\n     * Returns matrix height (number of tiles)\n     *\n     * @returns {Number} matrixHeight - Number of tiles from the top to the bottom of the matrix.\n     */\n    getMatrixHeight : function () {\n        return this.matrixHeight;\n    },\n\n    /**\n     * Returns matrix width (number of tiles)\n     *\n     * @returns {Number} matrixWidth - Number of tiles from the left to the right of the matrix.\n     */\n    getMatrixWidth : function () {\n        return this.matrixWidth;\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TileMatrix);\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Object used to describe a layer extent on a Tile Matrix.\n *\n * @property {Number} minTileCol - minimum column index where tile can be found on the Tile matrix.\n * @property {Number} maxTileCol - maximum column index where tile can be found on the Tile matrix.\n * @property {Number} minTileRow - minimum row index where tile can be found on the Tile matrix.\n * @property {Number} maxTileCol - maximum row index where tile can be found on the Tile matrix.\n *\n * @namespace\n * @alias Gp.Services.Config.TileMatrixLimit\n */\n\nfunction TileMatrixLimit () {\n    if (!(this instanceof TileMatrixLimit)) {\n        throw new TypeError(\"TileMatrixLimit constructor cannot be called as a function.\");\n    }\n\n    this.minTileRow = null;\n\n    this.maxTileRow = null;\n\n    this.minTileCol = null;\n\n    this.maxTileCol = null;\n}\n\n/**\n * @lends module:Autoconf/Response/TileMatrixLimit\n */\nTileMatrixLimit.prototype = {\n\n    constructor : TileMatrixLimit\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TileMatrixLimit);\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AbstractService__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtilityService_GeocodeRequest__ = __webpack_require__(67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationUtilityService_ReverseGeocodeRequest__ = __webpack_require__(69);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__LocationUtilityService_GeocodeFilterExtension__ = __webpack_require__(13);\n\n\n\n\n\n\n/**\n * @classdesc\n *\n * Requête de type LocationUtilityService (LUS)\n * (Factory)\n *\n * @example\n * // encapsule un objet dans une coquille XSL, Factory sur les objets Geocode/ReverseGeocode\n * lus = new LocationUtilityService ();\n * lus.addRequest (req);\n * lus.toString();\n *  ou\n * lus = new LocationUtilityService ({\n *      location : \"saint mandé\",\n *      returnFreeForm : true,\n *      filterOptions : {\n *          type :  ['PositionOfInterest']\n *      }\n * });\n * lus.toString();\n *\n * // out ->\n * // <GeocodeRequest>\n * //   <Address countryCode=\"PositionOfInterest\">\n * //     <freeFormAddress>saint mandé</freeFormAddress>\n * //   </Address>\n * // </GeocodeRequest>\n *\n * // creation de l'objet Geocode\n * req = new GeocodeRequest ();\n * req.addAddress (new Address (/*todo/*));\n * req.toString();\n * // out ->\n * // <GeocodeRequest>\n * //   <Address countryCode=\"PositionOfInterest\">\n * //     <freeFormAddress>saint mandé</freeFormAddress>\n * //   </Address>\n * // </GeocodeRequest>\n *\n * // creation de l'objet ReverseGeocode\n * req = new ReverseGeocodeRequest ();\n * req.addPosition (new Position (position:{x: , y: }));\n * req.addPreference (['StreetAddress']);\n * req.toString();\n * // out ->\n * // <ReverseGeocodeRequest>\n * //     <Position>\n * //       <gml:Point xmlns:gml=\"http://www.opengis.net/gml\">\n * //           <gml:pos>50.347775 3.205098</gml:pos>\n * //       </gml:Point>\n * //     </Position>\n * //     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>\n * //  </ReverseGeocodeRequest>\n *\n * @constructor\n * @alias Gp.Formats.XLS.LocationUtilityService\n * @param {Object} options - options\n * @param {Object}   options.location - location\n * @param {String}   options.position - position : {x : \"\", y : \"\"}\n * @param {String}   options.returnFreeForm - true|false\n * @param {Object}   options.filterOptions - filtres\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction LocationUtilityService (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur LocationUtilityService ()]\");\n\n    if (!(this instanceof LocationUtilityService)) {\n        throw new TypeError(\"LocationUtilityService constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe\n     */\n    this.CLASSNAME = \"LocationUtilityService\";\n\n    /**\n     * Type de classe de geocodage\n     * ex. GeocodeRequest ou ReverseGeocodeRequest\n     */\n    this.CLASSTYPE = null;\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_1__AbstractService__[\"a\" /* default */].apply(this, arguments);\n\n    // on determine le type de geocodage si les options sont renseignées\n    if (this.options) {\n        this.CLASSTYPE = (this.options.location) ? \"GeocodeRequest\" : (this.options.position) ? \"ReverseGeocodeRequest\" : null;\n    }\n}\n\n/**\n * @lends module:LocationUtilityService#\n */\nLocationUtilityService.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__AbstractService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/**\n * Constructeur (alias)\n */\nLocationUtilityService.prototype.constructor = LocationUtilityService;\n\n/**\n * (overwrite) Ajout d'un objet de type LUS : GeocodeRequest ou ReverseGeocodeRequest\n *\n * @param {Object} oLUSRequest - objet de type LUS\n */\nLocationUtilityService.prototype.addRequest = function (oLUSRequest) {\n    // on determine le type de geocodage\n    this.CLASSTYPE = oLUSRequest.CLASSNAME;\n\n    // on controle les types acceptés\n    switch (this.CLASSTYPE) {\n        case \"GeocodeRequest\":\n        case \"ReverseGeocodeRequest\":\n            this.oRequest = oLUSRequest;\n            break;\n        default:\n            throw new Error(\"Ce n'est pas un objet de type 'LUS Request' !?\");\n    }\n};\n\n/**\n * (overwrite) Ajout d'un objet de type GeocodeFilterExtension\n *\n * @param {Object} oFilter - objet de type Filtre\n */\nLocationUtilityService.prototype.addFilter = function (oFilter) {\n    // FIXME gestion des filtres à partir des tables de geocodages\n    if (oFilter instanceof __WEBPACK_IMPORTED_MODULE_4__LocationUtilityService_GeocodeFilterExtension__[\"a\" /* default */]) {\n        this.oFilter = oFilter;\n    }\n};\n\n/**\n * (overwrite) toString\n *\n * @returns {String}\n */\nLocationUtilityService.prototype.toString = function () {\n    // soit, on a un objet LUS Request déjà instancié\n    // sinon, il faut le construire à partir des options à disposition\n    if (!this.oRequest) {\n        // il nous faut des options\n        if (!this.options) {\n            throw new Error(\"Les options ne sont pas renseignées, impossible de construire la requête !\");\n        }\n\n        // si les options 'location' et 'position' sont renseignées,\n        // on prendra par defaut le choix du geocodage direct\n        if (this.CLASSTYPE === \"GeocodeRequest\") {\n            var settingsDirect = {\n                location : this.options.location,\n                returnFreeForm : this.options.returnFreeForm,\n                filterOptions : this.options.filterOptions || {}\n            };\n            this.oRequest = new __WEBPACK_IMPORTED_MODULE_2__LocationUtilityService_GeocodeRequest__[\"a\" /* default */](settingsDirect);\n            // ajout des filtres spécifiques au service du geocodage direct de l'IGN\n            if (this.oFilter) {\n                this.oRequest.addFilter(this.oFilter);\n            }\n        } else if (this.CLASSTYPE === \"ReverseGeocodeRequest\") {\n            var settingsInv = {\n                position : this.options.position,\n                returnFreeForm : this.options.returnFreeForm,\n                filterOptions : this.options.filterOptions || {}\n            };\n            this.oRequest = new __WEBPACK_IMPORTED_MODULE_3__LocationUtilityService_ReverseGeocodeRequest__[\"a\" /* default */](settingsInv);\n        } else {\n            this.logger.error(\"impossible de determiner le type de geocodage : Direct ou Inverse !?\");\n        }\n    }\n\n    // objet indefini !?\n    if (!this.oRequest) {\n        throw new Error(\"Type de Geocodage indefini !\");\n    }\n\n    this.strRequest = this.oRequest.toString();\n    return this.strRequest;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LocationUtilityService);\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__ = __webpack_require__(15);\n\n\n\n/**\n * Single location object returned by the underlying geocoding web service.\n *\n * @property {Float} accuracy - Accuracy of the response towards the requested location between 0 (unaccurate) and 1 (exact match).\n *\n * @namespace\n * @extends {Gp.Services.Geocode.GeocodedLocation}\n * @alias Gp.Services.Geocode.DirectGeocodedLocation\n */\nfunction DirectGeocodedLocation () {\n    if (!(this instanceof DirectGeocodedLocation)) {\n        throw new TypeError(\"DirectGeocodedLocation constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage) : \"DirectGeocodedLocation\"\n     * @type {String}\n     */\n    this.CLASSNAME = \"DirectGeocodedLocation\";\n\n    this.accuracy = null;\n}\n\nDirectGeocodedLocation.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__[\"a\" /* default */].prototype);\n\nDirectGeocodedLocation.prototype.constructor = DirectGeocodedLocation;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DirectGeocodedLocation);\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__ = __webpack_require__(15);\n\n\n\n/**\n * Single location object returned by the underlying reverse geocoding web service.\n *\n * @property {Float} searchCenterDistance - Distance between the requested point and the location.\n *\n * @namespace\n * @extends {Gp.Services.Geocode.GeocodedLocation}\n * @alias Gp.Services.Geocode.ReverseGeocodedLocation\n */\nfunction ReverseGeocodedLocation () {\n    if (!(this instanceof ReverseGeocodedLocation)) {\n        throw new TypeError(\"ReverseGeocodedLocation constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage) : \"ReverseGeocodedLocation\"\n     * @type {String}\n     */\n    this.CLASSNAME = \"ReverseGeocodedLocation\";\n\n    this.searchCenterDistance = null;\n}\n\nReverseGeocodedLocation.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodedLocation__[\"a\" /* default */].prototype);\n\nReverseGeocodedLocation.prototype.constructor = ReverseGeocodedLocation;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocodedLocation);\n\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\n * Response object for {@link module:Services~autoComplete Gp.Services.autoComplete ()} invocation when successful. Received as the argument of onSuccess callback function.\n *\n * @property {Array.<Gp.Services.AutoComplete.SuggestedLocation>} suggestedLocations - SuggestedLocations array.\n *\n * @namespace\n * @alias Gp.Services.AutoCompleteResponse\n */\nfunction AutoCompleteResponse () {\n    if (!(this instanceof AutoCompleteResponse)) {\n        throw new TypeError(\"AutoCompleteResponse constructor cannot be called as a function.\");\n    }\n\n    this.suggestedLocations = [];\n}\n\nAutoCompleteResponse.prototype = {\n\n    constructor : AutoCompleteResponse\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoCompleteResponse);\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Single SuggestedLocation Object returned by underlying web service.\n * Each suggested location represents a street address (\"StreetAddress\") or a place name (\"PositionOfInterest\").\n *\n * @property {String} type - Suggested location type : \"StreetAddress\" ou \"PositionOfInterest\"\n * @property {Gp.Point} position - Position of the suggested location given in requested coordinates system.\n * @property {String} commune - Suggested municipality\n * @property {String} fullText - Full text representation of the suggested location.\n * @property {String} postalCode - Suggested location postcode\n * @property {Integer} classification - Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).\n * @property {String} street - Street name of the suggested location (\"StreetAddress\" only).\n * @property {String} kind - Nature of the suggested location : \"prefecture\", \"monument\", \"commune\", ... for instance (\"PositionOfInterest\" only).\n *\n * @namespace\n * @alias Gp.Services.AutoComplete.SuggestedLocation\n */\nfunction SuggestedLocation () {\n    if (!(this instanceof SuggestedLocation)) {\n        throw new TypeError(\"SuggestedLocation constructor cannot be called as a function.\");\n    }\n\n    /* REPONSE :\n        {\n           \"status\" : \"OK\",\n           \"results\" : [\n              {\n                 \"country\":\"PositionOfInterest\",\n                 \"x\":-1.559185,\n                 \"y\":47.952603,\n                 \"city\":\"Brie\",\n                 \"zipcode\":\"35150\",\n                 \"street\":\"corbe\",\n                 \"kind\":\"Lieu-dit habité\",\n                 \"fulltext\":\"corbe, 35150 Brie\",\n                 \"classification\":6\n              },\n              {\n                 \"country\":\"StreetAddress\",\n                 \"x\":1.538295,\n                 \"y\":43.19646,\n                 \"city\":\"Brie\",\n                 \"zipcode\":\"09700\",\n                 \"street\":\"courreste\",\n                 \"kind\":\"\",\n                 \"fulltext\":\"courreste, 09700 Brie\",\n                 \"classification\":7\n              }\n           ]\n        }\n    */\n\n    /* REPONSE EN ERREUR\n        {\n            status : \"ERROR\",\n            results : [ ]\n        }\n    */\n\n    /**\n     * Suggested location type : \"StreetAddress\" ou \"PositionOfInterest\"\n     * @type {String}\n     */\n    this.type = null;\n\n    /**\n     * Position of the suggested location given in requested coordinates system.\n     * @type {Gp.Point}\n     */\n    this.position = {\n        x : null,\n        y : null\n    };\n\n    /**\n     * Suggested municipality\n     * @type {String}\n     */\n    this.commune = null;\n\n    /**\n     * Full text representation of the suggested location.\n     * @type {String}\n     */\n    this.fullText = null;\n\n    /**\n     * Suggested location postcode\n     * @type {Number}\n     */\n    this.postalCode = null;\n\n    /**\n     * Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).\n     * @type {Integer}\n     */\n    this.classification = null;\n\n    /**\n     * Street name of the suggested location (\"StreetAddress\" only).\n     * @type {String}\n     */\n    this.street = null;\n\n    /**\n     * Place name of the suggested location (\"PositionOfInterest\" only).\n     * @type {String}\n     */\n    this.poi = null;\n\n    /**\n     * Nature of the suggested location : \"prefecture\", \"monument\", \"commune\", ... for instance (\"PositionOfInterest\" only).\n     * @type {String}\n     */\n    this.kind = null;\n}\n\nSuggestedLocation.prototype = {\n\n    constructor : SuggestedLocation\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (SuggestedLocation);\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(44);\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Services_Services__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Services_DefaultUrlService__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Services_Alti_Response_model_AltiResponse__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Services_Alti_Response_model_Elevation__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Services_AutoComplete_Response_model_AutoCompleteResponse__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Services_AutoComplete_Response_model_SuggestedLocation__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Services_AutoConf_Response_model_AutoConfResponse__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Services_AutoConf_Response_model_Constraint__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Services_AutoConf_Response_model_Format__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Services_AutoConf_Response_model_Layer__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Services_AutoConf_Response_model_Legend__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Services_AutoConf_Response_model_Metadata__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Services_AutoConf_Response_model_Originator__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Services_AutoConf_Response_model_Service__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__Services_AutoConf_Response_model_Style__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__Services_AutoConf_Response_model_Territory__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__Services_AutoConf_Response_model_Thematic__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__Services_AutoConf_Response_model_TileMatrix__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__Services_AutoConf_Response_model_TileMatrixLimit__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__Services_AutoConf_Response_model_TileMatrixSet__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__Services_Geocode_Response_model_GeocodeResponse__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__Services_Geocode_Response_model_GeocodedLocation__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__Services_Geocode_Response_model_DirectGeocodedLocation__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__Services_Geocode_Response_model_ReverseGeocodedLocation__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__Services_Route_Response_model_RouteResponse__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__Services_Route_Response_model_RouteInstruction__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__Protocols_XHR__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__Utils_Helper__ = __webpack_require__(4);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Gp = {\n    servicesVersion : \"2.0.0\",\n    servicesDate : \"2018-04-05\",\n    /**\n     * Methode pour rajouter une classe / objet au namespace global.\n     *\n     * @method extend\n     * @param {String} strNS - nom sous lequel on veut présenter la\n     *        classe / objet (Gp.\"strNS\").\n     * @param {Object} value - la classe / objet à rajouter au NS global.\n     * @returns {Object} this\n     */\n    extend : function (strNS, value) {\n        var parts = strNS.split(\".\");\n        var parent = this;\n        var pl;\n\n        pl = parts.length;\n\n        for (var i = 0; i < pl; i++) {\n            // create a property if it doesn't exist\n            if (typeof parent[parts[i]] === \"undefined\") {\n                parent[parts[i]] = {};\n            }\n\n            var n = pl - 1;\n            if (i === n) {\n                parent[parts[i]] = value;\n            }\n\n            parent = parent[parts[i]];\n        }\n\n        return this;\n    }\n};\n\n// on declare les ns dans root global\nGp.extend(\"Protocols\", {});\nGp.extend(\"Protocols.XHR\", __WEBPACK_IMPORTED_MODULE_27__Protocols_XHR__[\"a\" /* default */]);\nGp.extend(\"Services\", __WEBPACK_IMPORTED_MODULE_0__Services_Services__[\"a\" /* default */]);\n// Export Alti\nGp.extend(\"Services.AltiResponse\", __WEBPACK_IMPORTED_MODULE_2__Services_Alti_Response_model_AltiResponse__[\"a\" /* default */]);\nGp.extend(\"Services.Alti.Elevation\", __WEBPACK_IMPORTED_MODULE_3__Services_Alti_Response_model_Elevation__[\"a\" /* default */]);\n// Export Autocomplete\nGp.extend(\"Services.AutoCompleteResponse\", __WEBPACK_IMPORTED_MODULE_4__Services_AutoComplete_Response_model_AutoCompleteResponse__[\"a\" /* default */]);\nGp.extend(\"Services.AutoComplete.SuggestedLocation\", __WEBPACK_IMPORTED_MODULE_5__Services_AutoComplete_Response_model_SuggestedLocation__[\"a\" /* default */]);\n// Export Autoconf\nGp.extend(\"Services.GetConfigResponse\", __WEBPACK_IMPORTED_MODULE_6__Services_AutoConf_Response_model_AutoConfResponse__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Constraint\", __WEBPACK_IMPORTED_MODULE_7__Services_AutoConf_Response_model_Constraint__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Format\", __WEBPACK_IMPORTED_MODULE_8__Services_AutoConf_Response_model_Format__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Layer\", __WEBPACK_IMPORTED_MODULE_9__Services_AutoConf_Response_model_Layer__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Legend\", __WEBPACK_IMPORTED_MODULE_10__Services_AutoConf_Response_model_Legend__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Metadata\", __WEBPACK_IMPORTED_MODULE_11__Services_AutoConf_Response_model_Metadata__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Originator\", __WEBPACK_IMPORTED_MODULE_12__Services_AutoConf_Response_model_Originator__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Service\", __WEBPACK_IMPORTED_MODULE_13__Services_AutoConf_Response_model_Service__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Style\", __WEBPACK_IMPORTED_MODULE_14__Services_AutoConf_Response_model_Style__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Territory\", __WEBPACK_IMPORTED_MODULE_15__Services_AutoConf_Response_model_Territory__[\"a\" /* default */]);\nGp.extend(\"Services.Config.Thematic\", __WEBPACK_IMPORTED_MODULE_16__Services_AutoConf_Response_model_Thematic__[\"a\" /* default */]);\nGp.extend(\"Services.Config.TileMatrix\", __WEBPACK_IMPORTED_MODULE_17__Services_AutoConf_Response_model_TileMatrix__[\"a\" /* default */]);\nGp.extend(\"Services.Config.TileMatrixLimit\", __WEBPACK_IMPORTED_MODULE_18__Services_AutoConf_Response_model_TileMatrixLimit__[\"a\" /* default */]);\nGp.extend(\"Services.Config.TileMatrixSet\", __WEBPACK_IMPORTED_MODULE_19__Services_AutoConf_Response_model_TileMatrixSet__[\"a\" /* default */]);\n// Export Geocode\nGp.extend(\"Services.GeocodeResponse\", __WEBPACK_IMPORTED_MODULE_20__Services_Geocode_Response_model_GeocodeResponse__[\"a\" /* default */]);\nGp.extend(\"Services.Geocode.GeocodedLocation\", __WEBPACK_IMPORTED_MODULE_21__Services_Geocode_Response_model_GeocodedLocation__[\"a\" /* default */]);\nGp.extend(\"Services.Geocode.DirectGeocodedLocation\", __WEBPACK_IMPORTED_MODULE_22__Services_Geocode_Response_model_DirectGeocodedLocation__[\"a\" /* default */]);\nGp.extend(\"Services.Geocode.ReverseGeocodedLocation\", __WEBPACK_IMPORTED_MODULE_23__Services_Geocode_Response_model_ReverseGeocodedLocation__[\"a\" /* default */]);\n// Export IsoCurve\nGp.extend(\"Services.IsoCurveResponse\", __WEBPACK_IMPORTED_MODULE_24__Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__[\"a\" /* default */]);\n// Export Route\nGp.extend(\"Services.RouteResponse\", __WEBPACK_IMPORTED_MODULE_25__Services_Route_Response_model_RouteResponse__[\"a\" /* default */]);\nGp.extend(\"Services.Route.RouteInstruction\", __WEBPACK_IMPORTED_MODULE_26__Services_Route_Response_model_RouteInstruction__[\"a\" /* default */]);\n// Export Erreurs et Outils\nGp.extend(\"Error\", __WEBPACK_IMPORTED_MODULE_28__Exceptions_ErrorService__[\"a\" /* default */]);\nGp.extend(\"Helper\", __WEBPACK_IMPORTED_MODULE_29__Utils_Helper__[\"a\" /* default */]);\n// Export DefaultUrls\nGp.extend(\"Services.DefaultUrl\", __WEBPACK_IMPORTED_MODULE_1__Services_DefaultUrlService__[\"a\" /* default */]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Gp); // = export { Gp as default };\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Alti_Alti__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AutoConf_AutoConf__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Geocode_Geocode__ = __webpack_require__(63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Geocode_ReverseGeocode__ = __webpack_require__(78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__AutoComplete_AutoComplete__ = __webpack_require__(82);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Route_Route__ = __webpack_require__(84);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ProcessIsoCurve_ProcessIsoCurve__ = __webpack_require__(96);\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"point|circle|bbox\" }] */\n\n/**\n* Geoportal web services invocation namespace.\n*\n* @module Services\n* @alias Gp.Services\n*/\n\n\n\n\n\n\n\n\nvar Services = {\n    /**\n     * Access to Geoportal resources metadata availables with one ore several keys, using [Auto-configuration service]{@link https://wxs.ign.fr/APIKEY/autoconf} of the Geoportal platform.\n     *\n     * @method getConfig\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GetConfigResponse} object as a parameter except if \"rawResponse\" parameter is set to true : a String will be returned.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/autoconf] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=JSONP] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting an underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    getConfig : function (options) {\n        var autoconfService = new __WEBPACK_IMPORTED_MODULE_1__AutoConf_AutoConf__[\"a\" /* default */](options);\n        autoconfService.call();\n    },\n\n    /**\n     * Getting elevations in or along of one or several points on french territories using the [elevation services of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/alti.html}.<br/>\n     * Two use cases are availables :<br/>\n     * 1. getting elevations of the given points : don't use the options.sampling parameter ;<br/>\n     * 2. getting a regular set of elevations along the given points : use the options.sampling parameter.\n     *\n     * @method getAltitude\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {Array.<Object>} options.positions - Array of positions ({lon:float, lat:float}) expressed in CRS:84 coordinates system, where to get elevations. 50 positions maximum may be given. 2 positions minimum are required if you use the options.sampling parameter.\n     * @param {Number} [options.sampling] - Number of points to use (between 2 and 5000) in order to compute an elevation path. The points given with the options.positions parameter are used to fix the planimetric path along which the elevations will be computed.<br/>\n     * If not used, only elevations of these positions will be returned.\n     * @param {Boolean} [options.zonly=false] - Set this parameter to true if you only want to have elevations returned without corresponding coordinates.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AltiResponse} object as a parameter, except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/alti/rest/elevation.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     * @param {String} [options.api='REST'] - What API to use for interacting with underlying web service : 'REST' or 'WPS'. Only use if you know what you are doing.\n     * @param {String} [options.outputFormat='xml'] - Output format for underlying web service response : 'xml' or 'json'. Only use if you know what you are doing.\n     */\n    getAltitude : function (options) {\n        var altiService = new __WEBPACK_IMPORTED_MODULE_0__Alti_Alti__[\"a\" /* default */](options);\n        altiService.call();\n    },\n    /**\n     * Getting positon of a geographic identifier (places names, address, cadastral parcel, other...) using the [geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage.html}.\n     *\n     * @example\n     * Gp.Services.geocode ({\n     *     apiKey : \"jhyvi0fgmnuxvfv0zjzorvdn\",\n     *     location : \"73 avenue de Paris, Saint-Mandé\",\n     *     // traitement des resultats\n     *     onSuccess  : function (result) {\n     *         console.log(\"found (x:\"+result.position.x+\", y:\"+result.position.y+\")\") ;\n     *     }\n     * }) ;\n     *\n     *\n     * @method geocode\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {String|Object} options.location - Geographic identifier to locate. May be provided as a single String or a structured Object for an address search. In this last case, the following properties are availaibles.\n     *      @param {Number} [options.location.number] - Street number.\n     *      @param {String} [options.location.street] - Street name.\n     *      @param {String} [options.location.city] - City name.\n     *      @param {Number} [options.location.postalCode] - Postal Code\n     * @param {Object} [options.filterOptions] - Additional filters to apply to search. The following properties may be given.\n     *      @param {Gp.BBox} [options.filterOptions.bbox] - Bounding box where to perform the search. Properties expressed in options.srs coordinates system.\n     *      @param {Array.<String>} [options.filterOptions.type] - Geographical identifier types to search. Values currently availables are : \"PositionOfInterest\" for place names, \"StreetAddress\" for address search, \"CadastralParcel\" for Cadastral parcels search. Default is \"StreetAddress\".\n     *\n     *      @param {String} [options.filterOptions.[prop]] - Additionnal properties to filter search. Properties depends on options.filterOptions.type, and values type should be \"String\".\n     *      <br/><br/>\n     *      Common Properties availables for all search types :<br/>\n     *      \"municipality\", \"insee\", \"department\".\n     *      <br/><br/>\n     *      Properties availables for address search :<br/>\n     *      \"quality\", \"ID\", \"ID_TR\" and \"territory\".\n     *      <br/><br/>\n     *      Properties availables for place names search :<br/>\n     *      \"importance\", \"nature\" and \"territory\".\n     *      <br/><br/>\n     *      Properties availables for cadastral parcels search :<br/>\n     *      \"sheet\", \"section\", and \"absorbedcity\".\n     * @param {Number} [options.maximumResponses = 25] - Maximum number of responses. Default underlying service value applies (25) if not provided.\n     * @param {Boolean} [options.returnFreeForm = false] - Set this parameter to true if you wish to have an address returned in a single String (unstructured). If unset, default underlying service value (false) applies.\n     * @param {String} [options.srs = EPSG:4326] - Coordinates System used to expres coordinates for parameters and responses. Default underlying service value (EPSG:4326) applies.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/geoportail/ols] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    geocode : function (options) {\n        var geocodeService = new __WEBPACK_IMPORTED_MODULE_2__Geocode_Geocode__[\"a\" /* default */](options);\n        geocodeService.call();\n    },\n    /**\n     * Retrieving geographical identifiers (place names, address, cadastral parcels, ...) near a given position, using the [reverse geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage-inverse.html}.\n     *\n     * @method reverseGeocode\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {Gp.Point} options.position - Reference position where to search geographical identifiers. Its coordinates are expressed in the coordinates system given with options.srs parameter. (default is CRS:84, that means position.x is the longitude and position.y the latitude)\n     * @param {Object} [options.filterOptions] - Additional filters to apply to search. The following properties may be given.\n     *      @param {Array.<String>} [options.filterOptions.type] - Geographical identifier types to search. Values currently availables are : \"PositionOfInterest\" for place names, \"StreetAddress\" for address search, \"CadastralParcel\" for Cadastral parcels search. Default is \"StreetAddress\".\n     *      @param {Gp.BBox} [options.filterOptions.bbox] - Bounding box where to perform the search. Expressed in options.srs coordinates system.\n     *      @param {Gp.Circle} [options.filterOptions.circle] - Circle where to perform the search. Expressed in options.srs coordinates system.\n     * @param {Array.<Gp.Point>} [options.filterOptions.polygon] - Polygon where to perform the search. Expressed in options.srs coordinates system.\n     * @param {Number} [options.maximumResponses] - Maximum number of responses. Default underlying service value applies (25) if not provided.\n     * @param {Boolean} [options.returnFreeForm = false] - Set this parameter to true if you wish to have an address returned in a single String (unstructured). If unset, default underlying service value (false) applies.\n     * @param {String} [options.srs = CRS:84] - Coordinates System used to express coordinates for parameters and responses. Only WGS 84 geographical positioning is supported. Therefore, two values are allowed : \"CRS:84\" (position.x is the longitude and position.y the latitude) and \"EPSG:4326\" (position.x is the latitude and position.y the longitude) . Default is CRS:84.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/geoportail/ols] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    reverseGeocode : function (options) {\n        var reverseGeocodeService = new __WEBPACK_IMPORTED_MODULE_3__Geocode_ReverseGeocode__[\"a\" /* default */](options);\n        reverseGeocodeService.call();\n    },\n    /**\n     * Getting suggestions of probable places names or address based on uncomplete texts, using the [autocompletion service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/autocompletion.html}\n     *\n     * @method autoComplete\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {String} options.text - Text input to complete.\n     * @param {Array.<String>} [options.filterOptions.type = \"StreetAddress\"] - Suggestion types to provide : address (\"StreetAddress\") and/or place name (\"PositionOfInterest\").\n     * @param {Array.<String>} [options.filterOptions.territory] - Places where to limit the search of suggestions : \"METROPOLE\" (Corsica and metropolitan France), \"DOMTOM\" (French overseas departments and territories), or an INSEE code of a department. No limitation by default. For instance : ['METROPOLE', '31']\n     * @param {Number} [options.maximumResponses = 10] - Maximum number of responses.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AutoCompleteResponse} object as a parameter except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/ols/apis/completion] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    autoComplete : function (options) {\n        var autoCompleteService = new __WEBPACK_IMPORTED_MODULE_4__AutoComplete_AutoComplete__[\"a\" /* default */](options);\n        autoCompleteService.call();\n    },\n    /**\n     * Getting a route from one point to another using the [route service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/itineraires.html}.\n     *\n     * @method route\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {String} [options.routePreference = \"fastest\"] - Indicates the way to compute the route : \"fastest\" (time optimisation) or \"shortest\" (distance optimisation).\n     * @param {Gp.Point} options.startPoint - Start point of the route. Expressed in CRS:84 coordinates system (startPoint.x corresponds to longitude, startPoint.y corresponds to latitude).\n     * @param {Gp.Point} options.endPoint - End point of the route. Expressed in CRS:84 coordinates system (endPoint.x corresponds to longitude, endPoint.y corresponds to latitude).\n     * @param {Array.<Gp.Point>} [options.viaPoints] - Ordered via Points of the route. Expressed in CRS:84 coordinates system (viaPoints[i].x corresponds to longitude, viaPoints[i].y corresponds to latitude).\n     * @param {String} [options.graph = \"Voiture\"] - User profile to use to compute the route : \"Voiture\" (using a vehicule) or \"Pieton\" (pedestrian). Has an influence on the kind of roads the route may use and the average speed.\n     * @param {Array.<String>} [options.exclusions] - Indicates if route has to avoid some features (\"toll\", \"bridge\" or \"tunnel\").\n     * @param {Boolean} [options.geometryInInstructions = false] - Indicates if route geometry has to be also returned with route instructions.\n     * @param {Boolean} [options.provideBoundingBox = true] - Indicates if route instructions has to be localised with a BBOX in the response.\n     * @param {String} [options.distanceUnit = \"km\"] - The unit used to provide distances in the response (\"m\" or \"km\").\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.RouteResponse} object as a parameter except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.outputFormat='json'] - Output format (\"json\" or \"xml\") to use for underlying webService. Only use if you know what you are doing.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/itineraire/rest/route.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    route : function (options) {\n        var routeService = new __WEBPACK_IMPORTED_MODULE_5__Route_Route__[\"a\" /* default */](options);\n        routeService.call();\n    },\n    /**\n     * Computing a set of places (curve) reachable from a given point (or from where to start to reach a given point) within a time or distance constraint using the [isochrone service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/isochrones.html}.\n     *\n     * @method isoCurve\n     * @param {Object} options - Options for function call.\n     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link http://professionnels.ign.fr/ign/contrats}.\n     * @param {Gp.Point} options.position - Start or Arrival (options.reverse===true) Point for the computing. Expressed in CRS:84 coordinates system (position.x corresponds to longitude, position.y corresponds to latitude).\n     * @param {String} [options.graph = \"Voiture\"] - User profile to use to compute the isoCurve : \"Voiture\" (using a vehicule) or \"Pieton\" (pedestrian). Has an influence on the kind of roads to use and the average speed.\n     * @param {Array.<String>} [options.exclusions] - Indicates if route has to avoid some features (\"toll\", \"bridge\" or \"tunnel\").\n     * @param {String} [options.method = \"time\"] - Computing method to use : \"time\" (using a duration as a constraint) or \"distance\" (using a distance as a constraint).\n     * @param {Float} options.time - Maximum duration (expressed in seconds) to use when options.method is set to \"time\".\n     * @param {Float} options.distance - Maximum distance (expressed in meters) to use when options.method is set to \"distance\".\n     * @param {Boolean} [options.reverse = false] - Set this parameter to true if you want options.position to be the destination (instead of departure) for the computing.\n     * @param {Boolean} [options.smoothing = false] - Set this parameter to true if you want the resulting geometry to be smoothed.\n     * @param {Boolean} [options.holes = false] - Set this parameter to true if you want the resulting geometry (polygon) to have holes if pertinent.\n     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.IsoCurveResponse} object as a parameter except if \"rawResponse\" is set to true.\n     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.\n     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.\n     * @param {String} [options.outputFormat='json'] - Output format (\"json\" or \"xml\") to use for underlying webService. Only use if you know what you are doing.\n     * @param {String} [options.serverUrl=http (s)://wxs.ign.fr/APIKEY/isochrone/isochrone.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.\n     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.\n     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.\n     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.\n     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {String} [options.contentType=\"application/xml\"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.\n     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.\n     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you are doing.\n     */\n    isoCurve : function (options) {\n        var processIsoCurveService = new __WEBPACK_IMPORTED_MODULE_6__ProcessIsoCurve_ProcessIsoCurve__[\"a\" /* default */](options);\n        processIsoCurveService.call();\n    }\n};\n\n/**\n * Point object.\n *\n * @namespace\n * @alias Gp.Point\n *\n * @property {Float} x - Point abscissa\n * @property {Float} y - Point ordinate\n */\nvar point = {};\n\n/**\n * Circle object.\n *\n * @namespace\n * @alias Gp.Circle\n *\n * @property {Float} x - Circle center abscissa.\n * @property {Float} y - Circle center ordinate.\n * @property {Float} radius - Circle radius.\n */\nvar circle = {};\n\n/**\n * Bounding box object, expressed with four coordinates.\n *\n * @namespace\n * @alias Gp.BBox\n *\n * @property {Float} left - minimum abscissa\n * @property {Float} right - maximum abscissa\n * @property {Float} bottom - minimum ordinate\n * @property {Float} top - maximum ordinate\n */\nvar bbox = {};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Services);\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Request_AltiRequestFactory__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Response_AltiResponseFactory__ = __webpack_require__(58);\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n *\n * Appel du service d'altimétrie du Géoportail\n *\n * @todo gestion du parma. output et callback\n * @todo outputFormat (REST) et format (WPS)\n * @todo La reponse JSON peut encapsuler un XML !\n *\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.Alti\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {Array.<Object>} options.positions - Tableau ({lon:float,lat:float}) contenant les coordonnées des points (CRS:84)\n *      dont on veut connaître les altitudes (ou à partir desquelles on va calculer le profil).\n *      Chaque élément du tableau est un objet JavaScript avec deux attributs : lon et lat, qui sont des flottants.\n *      Minimum 2 éléments si on souhaite calculer un profil altimétrique (ElevationLine).\n *      Maximum 50 éléments.\n *\n * @param {String} options.outputFormat - Le format de la réponse du service alti : 'xml' ou 'json'.\n *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service dans le cas de l'API REST,\n *      ou la valeur du paramètre 'format' dans le cas de la norme WPS.\n *      Nécessaire si serverUrl est renseigné, et qu'on souhaite passer par l'API REST,\n *      pour connaître le format dans lequel sera fournie la réponse (pour son traitement).\n *      Non nécessaire pour la norme WPS. Par défaut, ce paramètre vaut 'json'.\n *\n * @param {Number} [options.sampling] - Nombre de points à utiliser pour déterminer le tracé d'un profil altimétrique, compris entre 2 et 5000.\n *      A spécifier lorsqu'on souhaite accéder à cette fonctionnalité.\n *      Dans ce cas, les points fournis en entrée (au minimum de deux) servent à déterminer l'axe planimétrique\n *      le long duquel le profil doit être calculé.\n *      Si le paramètre sampling n'est pas spécifié ou moins de deux points sont fournis,\n *      c'est le service Elevation qui sera interrogé (altitudes simples calculées pour les points fournis).\n *      Une valeur de sampling strictement inférieure à 2 déclenchera un échantillonnage avec la valeur par défaut du service (3 points).\n *\n * @param {String} [options.api] - Manière d'accéder au service : 'REST' (via l'API REST) ou 'WPS' (via la norme WPS).\n *      Par défaut, on utilise l'API REST.\n *\n * @param {Boolean} [options.zonly] - Permet de ne récupérer que les altitudes en sortie s'il vaut 'true'.\n *      Vaut 'false' par défaut.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      positions : [{lon:, lat:}, {lon:, lat:}],\n *      outputFormat : 'json' // json|xml\n *      sampling : 3,\n *      api : 'REST', // REST|WPS\n *      zonly : false // false|true\n *   };\n *\n * @private\n */\nfunction Alti (options) {\n    if (!(this instanceof Alti)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"Alti\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"Alti\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.Alti\");\n    this.logger.trace(\"[Constructeur Alti (options)]\");\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    if (!options.positions) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"positions\"));\n    }\n\n    if (options.positions.length === 0) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"positions\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.positions = options.positions;\n\n    // format de réponse du service : \"json\" ou \"xml\" (valeur par défaut), en minuscule !\n    this.options.outputFormat = (typeof options.outputFormat === \"string\") ? options.outputFormat.toLowerCase() : \"xml\";\n\n    // sampling\n    this.options.sampling = options.sampling || null;\n\n    // type d'api utilisé pour requeter le service, en majuscule !\n    this.options.api = (typeof options.api === \"string\") ? options.api.toUpperCase() : \"REST\";\n\n    // l'api ne peut être interrogée qu'en GET.\n    if (this.options.api === \"REST\") {\n        this.options.httpMethod = \"GET\";\n    }\n\n    // param. zonly\n    this.options.zonly = options.zonly || false;\n\n    // gestion de l'url du service par defaut\n    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n    // en fonction du type d'api, REST ou WPS, du format de reponse demandé (outputFormat)\n    // ainsi que sur le type de service (profil ou elevation)\n    if (!this.options.serverUrl) {\n        var lstUrlByDefault = __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__[\"a\" /* default */].Alti.url(this.options.apiKey);\n        var urlFound = null;\n        switch (this.options.api) {\n            case \"WPS\":\n                urlFound = lstUrlByDefault.wps;\n                break;\n            case \"REST\":\n                var key = (options.sampling ? \"profil\" : \"elevation\") + \"-\" + this.options.outputFormat;\n                urlFound = lstUrlByDefault[key];\n                break;\n            default:\n                throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_UNKNOWN\", \"api\"));\n        }\n\n        if (!urlFound) {\n            throw new Error(\"Url by default not found !\");\n        }\n        this.options.serverUrl = urlFound;\n        this.logger.trace(\"Server URL by default : \" + this.options.serverUrl);\n    }\n\n    // gestion du type de service\n    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)\n    var idx = this.options.serverUrl.lastIndexOf(\".\");\n    if (idx !== -1) {\n        var extension = this.options.serverUrl.substring(idx + 1);\n        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...\n            this.logger.trace(\"Server Extension URL : \" + extension);\n            switch (extension.toLowerCase()) {\n                case \"json\":\n                case \"xml\":\n                    this.options.outputFormat = extension.toLowerCase();\n                    break;\n                default:\n                    throw new Error(\"type of service : unknown or unsupported (json or xml) !\");\n            }\n        }\n    }\n}\n\n/**\n * @lends module:Alti#\n */\nAlti.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/**\n * Constructeur (alias)\n */\nAlti.prototype.constructor = Alti;\n\n/**\n * Création de la requête (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nAlti.prototype.buildRequest = function (error, success) {\n    // utilisation en mode callback\n    var options = {\n        httpMethod : this.options.httpMethod,\n        /** callback */\n        onSuccess : function (result) {\n            // sauvegarde de la requete !\n            this.request = result;\n            success.call(this, this.request);\n        },\n        onError : error,\n        scope : this,\n        // spécifique au service :\n        positions : this.options.positions,\n        outputFormat : this.options.outputFormat,\n        sampling : this.options.sampling,\n        api : this.options.api,\n        zonly : this.options.zonly\n    };\n\n    __WEBPACK_IMPORTED_MODULE_5__Request_AltiRequestFactory__[\"a\" /* default */].build(options);\n};\n\n/**\n * Analyse de la reponse (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nAlti.prototype.analyzeResponse = function (error, success) {\n    // INFO\n    // Factory pour masquer la complexité du retour du service qui renvoie soit\n    //  - une 'string' qui contient du XML ou JSON natif en mode XHR\n    //  - un objet JSON qui est natif ou encapsulé\n\n    if (this.response) {\n        var options = {\n            response : this.response,\n            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_6__Response_AltiResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Alti);\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_Helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__XHR__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__JSONP__ = __webpack_require__(53);\n/**\n * Protocols : Interface de dialogue avec les webservices\n *\n * @module Protocols\n * @private\n * @alias Gp.Protocols.Protocols\n */\n\n\n\n\nvar Protocol = {\n\n    /**\n     * Interface unique d\"envoi d\"une requête.\n     *\n     * @method send\n     * @static\n     * @param {Object} options - options generales\n     * @param {String} options.url      - url du service\n     * @param {String} options.method   - GET, POST, PUT, DELETE\n     * @param {String} options.protocol - XHR | JSONP\n     * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...\n     * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)\n     * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix=\"\", la fonction s'appellera \"callback\")\n     * @param {String} options.timeOut  - 0 ms\n     * @param {Boolean} options.nocache  - true|false\n     * @param {Object|String} options.data        - content (post) ou param (get)\n     * @param {Object|String} options.headers     - (post) ex. referer\n     * @param {Object|String} options.content - (post) ex. \"application/json\"\n     * @param {String} options.scope       - this (TODO)\n     * @param {Function} options.onResponse - callback\n     * @param {Function} options.onFailure - callback\n     * @param {Function} options.onTimeOut - callback\n     * @param {String} options.proxyUrl -  (TODO)\n     */\n    send : function (options) {\n        // INFO\n        // \"output\" - param est interne à la classe \"Protocol\" (parametrable via \"wrap\"), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré par le filtre LUA :\n        //          ex. json|xml (json par defaut).\n        //          Ce param. permet d\"encapsuler du XML dans du JSON :\n        //              {http : {status:200, error:null},xml :\"réponse du service\"}\n        //          Utile pour les services qui ne repondent que du XML (ex. Geocodage)\n        //\n        // |-------------------------------------------------|\n        // |      \\service |      |     |                    |\n        // | output\\ format| json | xml |     remarques      |\n        // |--------\\------|------|-----|--------------------|\n        // |    json       | json | json| json/xml encapsulé |\n        // |    xml        | json | xml | param inactif      |\n        // |-------------------------------------------------|\n        // ex. le service demande une reponse native au \"format\" json et avec un \"output\" json.\n        // on a donc une reponse json encapsulé dans un json : ce qu'on ne souhaite pas !\n        // dans ce cas on ne renseigne pas output=json\n\n        // INFO\n        // \"wrap\" - choix d\"encapsuler ou non les reponses dans du JSON.\n        //      Par defaut, on encapsule uniquement les reponses sur le protocole JSONP (et qui sont en xml) !\n\n        // INFO\n        // \"callback\" - param est interne à la classe \"Protocol\" (non parametrable), et à ajouter à l\"url\n        //      ce param est independant du service car il est géré aussi par le filtre LUA :\n        //          ex. callback|null\n        //          Ce param. permet de renvoyer une reponse javascript :\n        //              callback ({http : {status:200, error:null},xml :\"réponse du service\"})\n        //          Ce param. est non renseigné par defaut car pour du JSONP, on utilise le\n        //          le protocol JSONP, et ce dernier implemente déjà le callback !\n\n        // settings par defaut\n        var settings = options || {\n            method : \"GET\",\n            // protocol : \"JSONP\",\n            protocol : \"XHR\",\n            timeOut : 0,\n            format : null,\n            wrap : true,\n            nocache : true,\n            output : \"json\",\n            callback : null,\n            callbackSuffix : null\n        };\n\n        // on determine l'environnement d'execution : browser ou non ?\n        // et on stoppe pour nodeJS... sur un protocole JSONP !\n        if (typeof window === \"undefined\" && options.protocol === \"JSONP\") {\n            console.log(\"Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS\");\n            return;\n        }\n\n        if (options.protocol === \"XHR\" || options.format === \"json\") {\n            settings.wrap = false;\n        } else if (options.protocol === \"JSONP\" && options.format === \"xml\") {\n            settings.wrap = true;\n        }\n\n        settings.callback = (options.protocol === \"JSONP\") ? null : null; // FIXME non géré !?\n        settings.output = settings.wrap ? \"json\" : null;\n\n        // on encapsule les reponses dans un objet JSON\n        if (settings.wrap) {\n            var params = {};\n            params.output = settings.output;\n            params.callback = settings.callback;\n            delete params.callback; // FIXME non géré !?\n            settings.url = __WEBPACK_IMPORTED_MODULE_0__Utils_Helper__[\"a\" /* default */].normalyzeUrl(options.url, params);\n        }\n\n        // choix de l\"implementation :\n        // XHR ou JSONP\n        switch (settings.protocol) {\n            case \"XHR\":\n                // on normalise l'url (gestion du cache)\n                if (options.method === \"GET\" && options.nocache) {\n                    settings.url = __WEBPACK_IMPORTED_MODULE_0__Utils_Helper__[\"a\" /* default */].normalyzeUrl(settings.url, {\n                        t : new Date().getTime()\n                    });\n                }\n                // appel du service en XHR\n                __WEBPACK_IMPORTED_MODULE_1__XHR__[\"a\" /* default */].call(settings);\n                break;\n            case \"JSONP\":\n\n                // on normalise l'url si les params. sont renseignés dans la string|object \"data\"\n                if (settings.data) {\n                    settings.url = __WEBPACK_IMPORTED_MODULE_0__Utils_Helper__[\"a\" /* default */].normalyzeUrl(settings.url, settings.data);\n                }\n\n                // appel du service en JSONP\n                __WEBPACK_IMPORTED_MODULE_2__JSONP__[\"a\" /* default */].call(settings);\n                break;\n            default:\n                throw new Error(\"protocol not supported (XHR|JSONP) !\");\n        }\n    }\n\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Protocol);\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.4+314e4831\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar TRY_CATCH_ERROR = { error: null };\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    TRY_CATCH_ERROR.error = error;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === TRY_CATCH_ERROR) {\n      reject(promise, TRY_CATCH_ERROR.error);\n      TRY_CATCH_ERROR.error = null;\n    } else if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = void 0,\n      failed = void 0;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = getThen(entry);\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        handleMaybeThenable(promise, entry, _then);\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    return promise.then(function (value) {\n      return constructor.resolve(callback()).then(function () {\n        return value;\n      });\n    }, function (reason) {\n      return constructor.resolve(callback()).then(function () {\n        throw reason;\n      });\n    });\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50), __webpack_require__(51)))\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_52__;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/**\n * JSONP : Implémentation du protocole JSONP de la plateforme Géoportail (cf. {@link https://github.com/sobstel/jsonp.js}).\n *\n * @module JSONP\n * @private\n * @alias Gp.Protocols.JSONP\n */\n\n\nvar JSONP = {\n\n    /**\n     * Construction d'un identifiant statique basé sur le timestamp,\n     * et qui s'incremente de +1 à chaque appel\n     */\n    uuid : (function () {\n        var id = Math.floor(Date.now());\n        return function () {\n            return id++;\n        };\n    })(),\n\n    /**\n     * Cette fonction réalise l'appel du service fourni via le paramètre \"options.url\"\n     * en mettant en œuvre le protocole JSONP.\n     *\n     * @method call\n     * @static\n     * @param {Object} options - parametres d'invocation du service en JSONP\n     * @param {String} options.url - URL du service à invoquer (indépendamment du protocole JSONP).\n     *  Cette URL contient déjà les paramètres du service.\n     *  Si le paramètre dédié à la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas présent, il est rajouté par la fonction ;\n     *  sa valeur est déterminée en fonction du paramètre callbackName.\n     * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considère que le service n'a pas répondu.\n     *  Une valeur de 0 pour ce paramètre permet de désactiver la gestion du timeOut.\n     * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback à rajouter sur l'URL.\n     *  Si aucun suffixe n'est spécifié (cas par défaut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: \"callback1458574396582 ()\"\n     * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramètre callback à rajouter sur l'URL.\n     *  Si l'URL fournie contient déjà le paramètre callback, le paramètre callbackName ne sera pas pris en compte.\n     *  La fonction de callback est créée dynamiquement par la fonction JSONP ;\n     *  elle a deux fonctions :\n     *    elle annule la condition de timeOut\n     *    puis appelle la fonction fournie par l'utilisateur via le paramètre onResponse.\n     * @param {Function} options.onResponse - Nom de la fonction qui sera appelée lors de la réception des résultats du service.\n     *  Ce paramètre sera ignoré si l'URL contient déjà le paramètre callback.\n     *  La fonction de rappel appelée sera alors celle ayant pour nom la valeur de ce paramètre.\n     * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelée en cas de non réponse du service.\n     *  Le temps au bout duquel on considère que le service n'a pas répondu est déterminé par le paramètre timeOut.\n     *  @example\n     *  var options = {\n     *      url : 'http://localhost/some/test.json&callback=myResults',\n     *      timeOut : 100,\n     *      callbackName : 'myResults',\n     *      callbackSuffix : \"\",\n     *      onResponse : function (response) {\n     *          console.log('results : ', response);\n     *      },\n     *\n     *   };\n     *   JSONP.call(options);\n     */\n    call : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"JSONP\");\n        logger.trace(\"[JSONP::call ()]\");\n\n        // analyse parametres\n\n        if (!options) {\n            logger.error(\"missing parameter : options !\");\n            throw new Error(\"missing parameter : options !\");\n        }\n\n        if (!options.url) {\n            logger.error(\"missing parameter : options.url !\");\n            throw new Error(\"missing parameter : options.url !\");\n        }\n\n        if (!options.timeOut) {\n            logger.info(\"setting 'options.timeOut' default value\");\n            options.timeOut = 0;\n        }\n\n        // FIXME si un callback coté client a été mis en place,\n        // cette condition sur cette methode n'a pas de sens !?\n        if (!options.onResponse) {\n            logger.error(\"missing parameter : options.onResponse !\");\n            throw new Error(\"missing parameter : options.onResponse !\");\n            // FIXME doit on definir un callback interne par defaut !?\n            // options.onResponse = function (data) {\n            //    console.log(\"response callback (inner) : \", data);\n            // };\n        }\n\n        // ID du callback à utiliser : null ou string.\n        // si l'utilisateur a spécifié un suffixe pour le callback, on le récupère comme un ID (ex: options.callbackSuffix = \"\")\n        // sinon, on utilise un timestamp : this.uuid ()\n        var callbackId = (typeof options.callbackSuffix === \"string\") ? options.callbackSuffix : this.uuid();\n\n        // on recherche le parametre callback et son nom de fonction dans l'url\n        var urlHasCallbackKey = false;\n        var urlHasCallbackName = false;\n\n        var idx = options.url.indexOf(\"callback=\");\n\n        if (idx !== -1) {\n            urlHasCallbackKey = true;\n            // extraction callbackName de l'url : entre \"callback=\" et \"&\" ou fin de ligne\n            var j = options.url.indexOf(\"&\", idx);\n            if (j === -1) {\n                j = options.url.length;\n            }\n\n            // on ecrase le parametre options.callbackName s'il avait été défini\n            var callbackName = options.url.substring(idx + 9, j);\n\n            if (callbackName) {\n                urlHasCallbackName = true;\n                options.callbackName = callbackName;\n                logger.info(\"setting 'options.callbackName' value (\" + options.callbackName + \") from 'options.url' parameter\");\n            }\n        }\n\n        // on ajoute le parametre callback dans l'URL s'il n'existe pas\n        if (!urlHasCallbackKey) {\n            // gestion des autres param. et \"?\"\n            var k = options.url.indexOf(\"?\");\n            if (k === -1) {\n                // aucun param., ni de '?'\n                options.url = options.url + \"?\" + \"callback=\";\n            } else if (k === options.url.length) {\n                // uniquement le '?'\n                options.url = options.url + \"callback=\";\n            } else {\n                // le '?' et les param. existent\n                options.url = options.url + \"&\" + \"callback=\";\n            }\n            logger.info(\"setting callback default key in 'options.url' : \" + options.url);\n        }\n\n        // utilisation de la fonction callback coté client ?\n        var HasCallbackName = options.callbackName ? true : urlHasCallbackName;\n\n        // on ajoute le nom de la fonction callback dans l'URL si elle n'existe pas\n        if (!urlHasCallbackName) {\n            // fonction callback par defaut\n            if (!options.callbackName) {\n                logger.info(\"setting 'options.callbackName' default value\");\n                options.callbackName = \"callback\"; // ou \"gp.protocol.jsonp\" ?\n                // info : si on ne veut pas gerer d'ID dans le callback,\n                // options.callbackSuffix = \"\"\n                if (callbackId || callbackId === \"\") {\n                    options.callbackName += callbackId;\n                }\n            }\n            options.url = options.url.replace(\"callback=\", \"callback=\" + options.callbackName);\n            logger.info(\"setting callback function name in 'options.url' : \" + options.url);\n        }\n\n        // timeOut par defaut\n        if (!options.onTimeOut) {\n            logger.info(\"setting 'options.onTimeOut' default value\");\n            /** callback timeout par defaut */\n            options.onTimeOut = function (/* error */) {\n                console.log(\"TimeOut while invoking url : \" + options.url);\n            };\n        }\n\n        if (!HasCallbackName) {\n            var self = this;\n\n            // event du timeout\n            var onTimeOutTrigger = null;\n\n            // declenche le timeout si > à 0 !\n            if (options.timeOut > 0) {\n                onTimeOutTrigger = window.setTimeout(\n                    function () {\n                        /** fonction de reponse du service */\n                        window[options.callbackName] = function () {};\n                        options.onTimeOut();\n                        self._deleteScript(callbackId);\n                    }, options.timeOut);\n            }\n\n            // FIXME le nom de la fonction n'accepte pas de namespace !\n            // ex. Gp.Function.callback\n            /**\n            * fonction de reponse du service\n            * @param {Object} data - data\n            * @private\n            */\n            window[options.callbackName] = function (data) {\n                window.clearTimeout(onTimeOutTrigger);\n                options.onResponse(data);\n                self._deleteScript(callbackId);\n            };\n        }\n\n        this._createScript(callbackId, options.url);\n    },\n\n    /**\n    * create Script\n    * @param {String} callbackId - callback Id\n    * @param {String} url - url\n    * @private\n    */\n    _createScript : function (callbackId, url) {\n        var scriptu;\n        var scripto = document.getElementById(\"results\" + callbackId);\n\n        scriptu = document.createElement(\"script\");\n        scriptu.setAttribute(\"type\", \"text/javascript\");\n        scriptu.setAttribute(\"src\", url);\n        scriptu.setAttribute(\"charset\", \"UTF-8\");\n        scriptu.setAttribute(\"id\", \"results\" + callbackId);\n        scriptu.setAttribute(\"async\", \"true\"); // FIXME async ?\n        // head ou body ou autres ?\n        var node = document.documentElement || document.getElementsByTagName(\"head\")[0];\n        if (scripto === null) {\n            node.appendChild(scriptu);\n        } else {\n            // s'il existe déjà, on le remplace !\n            node.replaceChild(scriptu, scripto);\n        }\n    },\n\n    /**\n    * delete Script\n    * @param {String} callbackId - callback Id\n    * @private\n    */\n    _deleteScript : function (callbackId) {\n        var script = document.getElementById(\"results\" + callbackId);\n        if (script) {\n            var node = script.parentNode || document.documentElement;\n            if (!node) {\n                return;\n            }\n            node.removeChild(script);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (JSONP);\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__AltiRequestREST__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__AltiRequestWPS__ = __webpack_require__(56);\n/**\n * Creation d'une requête en REST ou WPS\n * (Factory)\n *\n * @module AltiRequestFactory\n * @alias Gp.Services.Alti.Request.AltiRequestFactory\n * @private\n */\n\n\n\n\n\nvar AltiRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      httpMethod : 'GET', // GET|POST\n     *      onSuccess : function (response) {},\n     *      onError : function (error) {},\n     *      scope : this,\n     *      positions : [{lon:, lat:}, {lon:, lat:}],\n     *      outputFormat : 'json' // json|xml\n     *      sampling : 3,\n     *      api : 'REST', // REST|WPS\n     *      zonly : false // false|true\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AltiRequestFactory\");\n        logger.trace([\"AltiRequestFactory::build()\"]);\n\n        var request = null;\n\n        // on factorise les options par groupe;\n        // - global,\n        // - param, les params pour les data inputs\n        // - wps, les param du service\n        // - callback\n\n        var settings = {\n            // ajout des valeurs par defaut spécifiques au service\n            type : options.sampling ? \"Profil\" : \"Elevation\",\n            method : options.httpMethod,\n            param : {\n                positions : null,\n                delimiter : null, // FIXME par defaut, on ne le met pas en place car ça fait planter la requête !?\n                indent : null, // par defaut\n                crs : null, // par defaut\n                format : null, // (only to POST)\n                sampling : null, // (only use by Profil)\n                zonly : null // (only use by Elevation)\n            }\n        };\n\n        // surcharge des valeurs obligatoires\n        settings.param.positions = options.positions;\n        settings.param.format = options.outputFormat;\n        settings.param.sampling = options.sampling;\n        settings.param.zonly = options.zonly;\n\n        // gestion des callback\n        var bOnError = !!((options.onError !== null && typeof options.onError === \"function\"));\n        var bOnSuccess = !!((options.onSuccess !== null && typeof options.onSuccess === \"function\"));\n\n        var message = null;\n        switch (options.api) {\n            case \"REST\":\n                // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !\n                var myReq = new __WEBPACK_IMPORTED_MODULE_2__AltiRequestREST__[\"a\" /* default */](settings);\n                if (!myReq.processRequestString()) {\n                    message = \"Error in process request (rest) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                request = myReq.requestString;\n                break;\n            case \"WPS\":\n                // ajout des valeurs par defaut spécifiques au service WPS\n                settings.wps = {\n                    service : null, // par defaut\n                    version : null, // par defaut\n                    identifier : null, // par defaut\n                    rawdataoutput : null, // par defaut\n                    request : null // par defaut\n                };\n\n                request = __WEBPACK_IMPORTED_MODULE_3__AltiRequestWPS__[\"a\" /* default */].build(settings);\n                if (!request) {\n                    message = \"Error in process request (wps) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                break;\n            default:\n                message = \"Type of API is not supported by service (REST or WPS) !\";\n                if (bOnError) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                    return;\n                }\n                throw new Error(message);\n        }\n\n        if (bOnSuccess) {\n            options.onSuccess.call(options.scope, request);\n        }\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiRequestFactory);\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_AltiElevationRequest__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_AltiProfilRequest__ = __webpack_require__(23);\n/* jshint multistr : true */\n\n\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des requêtes de type REST sur le service altimetrique.\n *\n * @todo Le service Alti n'implemente pas le POST !?\n * @constructor\n * @alias Gp.Services.Alti.Request.AltiRequestREST\n * @param {Object} options - options\n * @param {Object}   options.param.positions - tableau de coordonnées lon/lat\n * @param {String}   options.param.delimiter - '|'\n * @param {Boolean}  options.param.indent - false|true\n * @param {String}   options.param.crs - 'CRS:84'\n * @param {String}   options.param.sampling - 3\n * @param {Boolean}  options.param.zonly - false|true\n * @param {String}   options.param.format - \"JSON|XML\"\n * @param {String}   options.type - \"Profil|Elevation\"\n * @param {String}   options.method - GET|POST\n *\n * @example\n *      var options = {\n *           type : 'Profil', // Elevation\n *           method : 'GET',  // par defaut\n *           param : {\n *               positions : [\n *                   {lon:'1.11', lat:'1.11'},\n *                   {lon:'1.10', lat:'1.10'},\n *                   {lon:'1.12', lat:'1.12'}\n *               ],\n *               delimiter : \";\",         // par defaut\n *               indent    : true,        // par defaut\n *               crs       : 'EPSG:4326', // par defaut\n *               format    : 'json',      // par defaut (only to POST)\n *               sampling  : 3 ,          // par defaut (only use by Profil)\n *               zonly     : false        // par defaut (only use by Elevation)\n *           }\n *      };\n *\n *      var result;\n *      try {\n *          var obj = new AltiRequestREST (options);\n *          if (! obj.processRequestString ()) {\n *              throw new Error(\"Request empty !?\")\n *          }\n *          result = obj.requestString;\n *      } catch (e) {\n *          // exceptions...\n *      }\n * @private\n */\nfunction AltiRequestREST (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AltiRequestREST\");\n    this.logger.trace(\"[Constructeur AltiRequestREST ()]\");\n\n    if (!(this instanceof AltiRequestREST)) {\n        throw new TypeError(\"AltiRequestREST constructor cannot be called as a function.\");\n    }\n\n    this.options = options || {};\n\n    // existance des options\n    if (!this.options) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"options\"));\n    }\n\n    // type de requete : Altitude ou Profil\n    // (param. à determiner en fonction des parametres d'entrée)\n    if (!this.options.type) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"type (Elevation or Profil)\"));\n    }\n\n    // construction du modele de requête\n    // (test du type d'objet candidat)\n    this.DataObject = null;\n    switch (this.options.type) {\n        case \"Elevation\":\n            this.DataObject = new __WEBPACK_IMPORTED_MODULE_2__model_AltiElevationRequest__[\"a\" /* default */](this.options.param);\n            break;\n        case \"Profil\":\n            this.DataObject = new __WEBPACK_IMPORTED_MODULE_3__model_AltiProfilRequest__[\"a\" /* default */](this.options.param);\n            break;\n        default:\n            throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_TYPE\", \"type (Elevation or Profil)\"));\n    }\n\n    /**\n     * methode.\n     * Par defaut, \"GET\".\n     */\n    this.method = this.options.method || \"GET\";\n}\n\nAltiRequestREST.prototype = {\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : AltiRequestREST,\n\n    /**\n     * Template de la requête.\n     */\n    template : {\n        get : {\n            // FIXME on retire le param 'delimiter' : &delimiter='__DELIMITER__'\n            value : \"lon=__LON__&lat=__LAT__&indent=__INDENT__&crs='__CRS__'\",\n            input : {\n                point : \"&zonly=__ZONLY__\",\n                profil : \"&sampling=__SAMPLING__\"\n            }\n        },\n        post : {\n            // FIXME on retire le param 'delimiter' : delimiter='__DELIMITER__'\\n\\\n            value : \"lon=__LON__\\n\" +\n                \"lat=__LAT__\\n\" +\n                \"indent=__INDENT__\\n\" +\n                \"crs='__CRS__'\\n\",\n            input : {\n                point : \"zonly=__ZONLY__\",\n                profil : \"sampling=__SAMPLING__\"\n            }\n        }\n    },\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out : lon=0.2367,2.1570&lat=48.0551,46.6077&delimiter=,&indent=true&zonly=true&crs='CRS:84'\n     * // POST out : Not yet supported method POST !\n     * @returns {String}\n     */\n    processRequestString : function () {\n        this.logger.trace(\"AltiRequestREST::processRequestString ()\");\n\n        var template = \"\";\n        if (this.method === \"POST\") {\n            template = this.template.post.value;\n        } else if (this.method === \"GET\") {\n            template = this.template.get.value;\n        }\n\n        template = template.replace(/__LON__/g, this.DataObject.getLon());\n        template = template.replace(/__LAT__/g, this.DataObject.getLat());\n        // FIXME on retire le param 'delimiter'\n        // template = template.replace(/__DELIMITER__/g, this.DataObject.delimiter);\n        template = template.replace(/__INDENT__/g, this.DataObject.indent);\n        template = template.replace(/__CRS__/g, this.DataObject.crs);\n\n        // ajout +\n        template = template + this.__addDataInputs();\n        this.logger.trace(\"traduction tmpl\", template);\n\n        // sauvegarde\n        this.requestString = template;\n\n        return this.requestString;\n    },\n\n    /**\n     * Ajout de parametres spécifiques (ex. zonly)\n     *\n     * @returns {String}\n     */\n    __addDataInputs : function () {\n        this.logger.trace(\"AltiRequestREST::addDataInput ()\");\n\n        var myTemplate;\n        if (this.method === \"POST\") {\n            myTemplate = this.template.post;\n        } else if (this.method === \"GET\") {\n            myTemplate = this.template.get;\n        } else {\n            throw new Error(\"No other HTTP method supported by the service !\");\n        }\n\n        var tmpl = null;\n        if (this.DataObject.CLASSNAME === \"AltiElevationRequest\") {\n            tmpl = myTemplate.input.point;\n            return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly);\n        } else if (this.DataObject.CLASSNAME === \"AltiProfilRequest\") {\n            tmpl = myTemplate.input.profil;\n            return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);\n        } else {\n            throw new Error(\"No other object supported than elevation or profil !?\");\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiRequestREST);\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_WPS__ = __webpack_require__(57);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_AltiElevationRequest__ = __webpack_require__(21);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model_AltiProfilRequest__ = __webpack_require__(23);\n/**\n * Classe d'interface des requêtes de type WPS sur le service altimetrique.\n * (Factory)\n *\n * @module Gp.Services.Alti.Request.AltiRequestWPS\n * @alias Gp.Services.Alti.Request.AltiRequestWPS\n * @private\n */\n\n\n\n\n\n\nvar AltiRequestWPS = {\n\n    /**\n     * Interface unique de construction de la requête.\n     *\n     * @method build\n     * @param {Object} options - options\n     * @param {Object}   options.param.positions - tableau de coordonnées lon/lat\n     * @param {String}   options.param.delimiter - '|'\n     * @param {Boolean}  options.param.indent - false|true\n     * @param {String}   options.param.crs - 'CRS:84'\n     * @param {String}   options.param.sampling - 3\n     * @param {Boolean}  options.param.zonly - false|true\n     * @param {String}   options.param.format - \"JSON|XML\" (only to POST)\n     * @param {String}   options.wps.service - \"WPS\"\n     * @param {String}   options.wps.version - \"1.0.0\"\n     * @param {String}   options.wps.identifier - \"gs:WPSElevation|gs:WPSLineElevation\"\n     * @param {String}   options.wps.rawdataoutput - \"result\"\n     * @param {String}   options.wps.request - \"Execute\"\n     * @param {String}   options.type - \"Profil|Elevation\"\n     * @param {String}   options.method - GET|POST\n     * @example\n     *      var options = {\n     *           type : 'Profil', // Elevation\n     *           method : 'GET',  // par defaut\n     *           param : {\n     *               positions : [\n     *                   {lon:'1.11', lat:'1.11'},\n     *                   {lon:'1.10', lat:'1.10'},\n     *                   {lon:'1.12', lat:'1.12'}\n     *               ],\n     *               delimiter : \";\",         // par defaut\n     *               indent    : true,        // par defaut\n     *               crs       : 'EPSG:4326', // par defaut\n     *               format    : 'json',      // par defaut (only to POST)\n     *               sampling  : 3 ,          // par defaut (only use by Profil)\n     *               zonly     : false,       // par defaut (only use by Elevation)\n     *           },\n     *           wps : {\n     *                 service : 'WPS',         // par defaut\n     *                 version : '1.0.0',       // par defaut\n     *                 identifier : 'gs:WPS',   // par defaut, Elevation = gs:WPSElevation, Profil = gs:WPSLineElevation\n     *                 rawdataoutput : 'result',// par defaut\n     *                 request : 'Execute'      // par defaut\n     *           }\n     *       };\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AltiRequestWPS\");\n        logger.trace([\"AltiRequestWPS::build()\"]);\n\n        // existance des options\n        if (!options) {\n            throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"options\"));\n        }\n\n        // type de requete : Altitude ou Profil\n        // (param. à determiner en fonction des parametres d'entrée)\n        if (!options.type) {\n            throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"type (Elevation or Profil)\"));\n        }\n\n        // construction du modele de requête\n        // (test du type d'objet candidat)\n        var DataObject = null;\n        switch (options.type) {\n            case \"Elevation\":\n                // surcharge\n                options.wps.identifier = \"gs:WPSElevation\";\n                DataObject = new __WEBPACK_IMPORTED_MODULE_3__model_AltiElevationRequest__[\"a\" /* default */](options.param);\n                break;\n            case \"Profil\":\n                // surcharge\n                options.wps.identifier = \"gs:WPSLineElevation\";\n                DataObject = new __WEBPACK_IMPORTED_MODULE_4__model_AltiProfilRequest__[\"a\" /* default */](options.param);\n                break;\n            default:\n                throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_TYPE\", \"type (Elevation or Profil)\"));\n        }\n\n        // construction de la requête WPS\n        var settings = {\n            data : DataObject,\n            method : options.method,\n            param : options.wps\n        };\n\n        var rqstWPS = new __WEBPACK_IMPORTED_MODULE_2__Formats_WPS__[\"a\" /* default */](settings);\n\n        if (!rqstWPS.processRequestString()) {\n            throw new Error(\"Enable to process request !\");\n        }\n\n        return rqstWPS.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiRequestWPS);\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n * Standard WPS\n *\n * @constructor\n * @alias Gp.Formats.WPS\n * @param {Object} options - options\n * @param {Object}   options.data - objet\n * @param {String}   options.method - POST|GET\n * @param {String}   options.param.service - \"WPS\"\n * @param {String}   options.param.version - \"1.0.0\"\n * @param {String}   options.param.identifier - \"gs:WPSElevation|gs:WPSLineElevation\"\n * @param {String}   options.param.rawdataoutput - \"result\"\n * @param {String}   options.param.request - \"Execute\"\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n * @private\n */\nfunction WPS (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur WPS()]\");\n\n    if (!(this instanceof WPS)) {\n        throw new TypeError(\"WPS constructor cannot be called as a function.\");\n    }\n\n    this.options = options || {};\n\n    /**\n     * Objet DATA\n     */\n    this.DataObject = this.options.data;\n\n    if (!this.DataObject) {\n        throw new TypeError(\"This data object is not defined !\");\n    }\n\n    /**\n     * param service.\n     * Par defaut, \"WPS\".\n     */\n    this.paramservice = this.options.param.service || \"WPS\";\n\n    /**\n     * param version.\n     * Par defaut, \"1.0.0\".\n     */\n    this.paramversion = this.options.param.version || \"1.0.0\";\n\n    /**\n     * param identifier\n     * Par defaut, \"gs:WPS\"\n     */\n    this.paramidentifier = this.options.param.identifier || \"gs:WPS\";\n\n    /**\n     * param rawdataoutput\n     * Par defaut, \"result\".\n     */\n    this.paramrawdataoutput = this.options.param.rawdataoutput || \"result\";\n\n    /**\n     * param request\n     * Par defaut, \"Execute\".\n     */\n    this.paramrequest = this.options.param.request || \"Execute\";\n\n    /**\n     * methode.\n     * Par defaut, \"GET\".\n     */\n    this.method = this.options.method || \"GET\";\n}\n\nWPS.prototype = {\n\n    /**\n     * @lends module:WPS#\n     */\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : WPS,\n\n    /**\n     * Template de la requête.\n     */\n    template : {\n        get : {\n            value : \"service=__SERVICE__\" +\n                \"&version=__VERSION__\" +\n                \"&rawdataoutput=__RAWDATAOUTPUT__\" +\n                \"&identifier=__IDENTIFIER__\" +\n                \"&request=__REQUEST__\" +\n                \"&datainputs=<!-- __DATAINPUTS__ -->\",\n\n            input : \"__KEY__=__DATA__\"\n\n        },\n        post : {\n\n            value : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\" +\n                \"<wps:__REQUEST__ version=\\\"__VERSION__\\\" service=\\\"__SERVICE__\\\" \" +\n                \"__NAMESPACE__ __SCHEMALOCATION__>\" +\n                \"<ows:Identifier>__IDENTIFIER__</ows:Identifier>\" +\n                \"<wps:DataInputs>\" +\n                \"<!-- __DATAINPUTS__ -->\" +\n                \"</wps:DataInputs>\" +\n                \"<wps:ResponseForm>\" +\n                \"<wps:RawDataOutput>\" +\n                \"<ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>\" +\n                \"</wps:RawDataOutput>\" +\n                \"</wps:ResponseForm>\" +\n                \"</wps:__REQUEST__>\",\n\n            input : \"<wps:Input>\" +\n                \"<ows:Identifier>__KEY__</ows:Identifier>\" +\n                \"<wps:Data>\" +\n                \"<wps:LiteralData>__DATA__</wps:LiteralData>\" +\n                \"</wps:Data>\" +\n                \"</wps:Input>\"\n        }\n    },\n\n    /**\n     * Namespace par defaut de la requete POST.\n     *\n     * @returns {String}\n     */\n    namespaceByDefault : function () {\n        var ns = [\n            \"xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\",\n            \"xmlns=\\\"http://www.opengis.net/wps/1.0.0\\\"\",\n            \"xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\",\n            \"xmlns:wps=\\\"http://www.opengis.net/wps/1.0.0\\\"\",\n            \"xmlns:ows=\\\"http://www.opengis.net/ows/1.1\\\"\",\n            \"xmlns:gml=\\\"http://www.opengis.net/gml\\\"\",\n            \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\"\",\n            \"xmlns:wcs=\\\"http://www.opengis.net/wcs/1.1.1\\\"\",\n            \"xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\"\"\n        ];\n\n        return ns.join(\" \");\n    },\n\n    /**\n     * Schemalocation par defaut.\n     *\n     * @returns {String}\n     */\n    schemaLocationByDefault : function () {\n        return \"xsi:schemaLocation=\\\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\\\"\";\n    },\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out :\n     * //  service=__SERVICE__\n     * //  &version=__VERSION__\n     * //  &rawdataoutput=__RAWDATAOUTPUT__\n     * //  &identifier=__IDENTIFIER__\n     * //  &request=__REQUEST__\n     * //  &datainputs=\"__DATAINPUTS__\"\n     * //  avec __DATAINPUTS__ = __KEY__=__DATA__;...\n     *\n     * // POST out :\n     * //      <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n     * //      <wps:__REQUEST__ version=\\\"__VERSION__\\\" service=\\\"__SERVICE__\\\"\n     * //         __NAMESPACE__ __SCHEMALOCATION__>\n     * //          <ows:Identifier>__IDENTIFIER__</ows:Identifier>\n     * //          <wps:DataInputs>\n     * //              <!-- __DATAINPUTS__ -->\n     * //          </wps:DataInputs>\n     * //          <wps:ResponseForm>\n     * //              <wps:RawDataOutput>\n     * //              <ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>\n     * //              </wps:RawDataOutput>\n     * //          </wps:ResponseForm>\n     * //      </wps:__REQUEST__>\",\n     * //      avec __DATAINPUTS__\n     * //             <wps:Input>\n     * //                  <ows:Identifier>__KEY__</ows:Identifier>\n     * //                  <wps:Data>\n     * //                    <wps:LiteralData>__DATA__</wps:LiteralData>\n     * //                  </wps:Data>\n     * //              </wps:Input>\n     *\n     * @returns {Boolean}\n     */\n    processRequestString : function () {\n        this.logger.trace(\"WPS::processRequestString ()\");\n\n        var template = \"\";\n        if (this.method === \"POST\") {\n            template = this.template.post.value;\n        } else if (this.method === \"GET\") {\n            template = this.template.get.value;\n        } else {\n            this.logger.error(\"No other method supported by the service !\");\n            return false;\n        }\n\n        template = template.replace(/__SERVICE__/g, this.paramservice);\n        template = template.replace(/__VERSION__/g, this.paramversion);\n        template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);\n        template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);\n        template = template.replace(/__REQUEST__/g, this.paramrequest);\n\n        // ajout +\n        if (this.method === \"POST\") {\n            template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);\n            template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);\n        }\n\n        // ajout des datainputs\n        template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());\n\n        if (!template) {\n            this.logger.warn(\"traduction tmpl : empty request !?\");\n            return false;\n        }\n\n        this.requestString = template;\n        this.logger.trace(\"traduction tmpl\", template);\n\n        return true;\n    },\n\n    /**\n     * Ajout des données\n     *\n     * @returns {String}\n     */\n    __addDataInputs : function () {\n        this.logger.trace(\"WPS::__addDataInputs ()\");\n\n        // c'est un peu grossier...\n        var tmpl = this.method === \"GET\" ? this.template.get.input : this.template.post.input;\n        var sep = this.method === \"GET\" ? \";\" : \"\";\n\n        var result = \"\";\n        var that = this;\n        var map = this.DataObject.getData();\n        for (var i = 0; i < map.length; i++) {\n            // FIXME closure ?\n            (function (j) {\n                if (sep) {\n                    sep = (j === map.length - 1) ? \"\" : \";\";\n                }\n                result = result.concat(that.__addDataInput(tmpl, map[j].k, map[j].v), sep);\n            })(i);\n        }\n\n        return result;\n    },\n\n    /**\n     * Ajout d'une données.\n     *\n     * @param {String} tmpl - template\n     * @param {String} key - clef\n     * @param {String} data - valeur\n     * @returns {String}\n     */\n    __addDataInput : function (tmpl, key, data) {\n        var tmp = tmpl;\n        tmp = tmp.replace(/__KEY__/g, key);\n        tmp = tmp.replace(/__DATA__/g, data);\n        return tmp;\n    },\n\n    /**\n     * Definir le mode de requête\n     *\n     * @param {String} method - GET|POST\n     */\n    setMethod : function (method) {\n        if (method === \"GET\" || method === \"POST\") {\n            this.method = method;\n        } else {\n            this.logger.warn(\"support only GET and POST method !\");\n        }\n    },\n\n    /**\n     * Retourne le mode de requete (GET|POST).\n     *\n     * @returns {AltiRequest.options.mode|String}\n     */\n    getMethod : function () {\n        return this.method;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (WPS);\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Formats_AltiResponseReader__ = __webpack_require__(59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__model_AltiResponse__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__model_Elevation__ = __webpack_require__(10);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON\n * (Factory)\n *\n * @module AltiResponseFactory\n * @private\n * @alias Gp.Services.Alti.Response.AltiResponseFactory\n */\n\n\n\n\n\n\n\n\nvar AltiResponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      outputFormat :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AltiResponseFactory\");\n        logger.trace([\"AltiResponseFactory::build()\"]);\n\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                logger.trace(\"analyze response : raw\");\n                data = options.response;\n            } else {\n                switch (options.outputFormat) {\n                    case \"xml\":\n                        logger.trace(\"analyze response : xml\");\n\n                        try {\n                            var p = new __WEBPACK_IMPORTED_MODULE_3__Formats_XML__[\"a\" /* default */]({\n                                reader : __WEBPACK_IMPORTED_MODULE_4__Formats_AltiResponseReader__[\"a\" /* default */]\n                            });\n\n                            if (typeof options.response === \"string\") {\n                                p.setXMLString(options.response);\n                            } else {\n                                p.setXMLDoc(options.response);\n                            }\n\n                            data = p.parse();\n\n                            if (!data) {\n                                throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION_2\"));\n                            }\n                        } catch (e) {\n                            var message = e.message;\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                                message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", message),\n                                status : 200,\n                                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                            }));\n                            return;\n                        }\n\n                        break;\n\n                    case \"json\":\n                        logger.trace(\"analyze response : json\");\n                        logger.trace(\"analyze response : \", typeof options.response);\n\n                        var JSONResponse;\n                        if (typeof options.response === \"string\") {\n                            JSONResponse = JSON.parse(options.response);\n                        } else {\n                            JSONResponse = options.response;\n                        }\n\n                        // le service renvoie t il une erreur ?\n                        if (JSONResponse.error) {\n                            // ex. {\"error\": {\"code\": \"BAD_PARAMETER\",\"description\": \"The values () cannot be parsed as a valid longitude (double value such as -180 < lat < 180).\"}}\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                                message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", JSONResponse.error.description),\n                                status : 200,\n                                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                            }));\n                            return;\n                        }\n\n                        // analyse de la reponse\n                        if (JSONResponse) {\n                            var elevations = JSONResponse.elevations;\n                            var altiResponse = new __WEBPACK_IMPORTED_MODULE_5__model_AltiResponse__[\"a\" /* default */]();\n                            var elevation;\n                            if (Array.isArray(elevations) && elevations.length) {\n                                for (var i = 0; i < elevations.length; i++) {\n                                    elevation = new __WEBPACK_IMPORTED_MODULE_6__model_Elevation__[\"a\" /* default */]();\n\n                                    if (typeof elevations[i] === \"object\") {\n                                        // elevations[i] est un objet elevation\n                                        if (elevations[i].lon) {\n                                            elevation.lon = elevations[i].lon;\n                                        }\n                                        if (elevations[i].lat) {\n                                            elevation.lat = elevations[i].lat;\n                                        }\n                                        if (elevations[i].z) {\n                                            elevation.z = elevations[i].z;\n                                        }\n                                        if (elevations[i].acc) {\n                                            elevation.acc = elevations[i].acc;\n                                        }\n                                    } else if (typeof elevations[i] === \"number\") {\n                                        // elevations[i] est un nombre, dans le cas de zonly=true notamment\n                                        elevation.z = elevations[i];\n                                    }\n\n                                    if (Array.isArray(altiResponse.elevations)) {\n                                        altiResponse.elevations.push(elevation);\n                                    }\n                                }\n                            }\n                            data = altiResponse;\n                        }\n\n                        if (!data) {\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                                message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE_2\"),\n                                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR,\n                                status : -1\n                            }));\n                            return;\n                        }\n                        break;\n\n                    default:\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                            message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT_2\"),\n                            type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR,\n                            status : -1\n                        }));\n                        return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                } else if (data.error) {\n                    var errorMess = data.error.description;\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", errorMess),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiResponseFactory);\n\n\n/***/ }),\n/* 59 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Response_model_AltiResponse__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Response_model_Elevation__ = __webpack_require__(10);\n\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service Altimétrique du Géoportail\n *      (calcul altimétrique simple ou profil altimétrique d'une courbe),\n *      lorsque le paramètre output = xml,\n *      afin de récupérer les élévations retournées.\n *\n * @module AltiResponseReader\n * @alias Gp.Services.Alti.Formats.AltiResponseReader\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n/**\n *\n * Objet AltiResponseReader\n *\n * @member {Object} AltiResponseReader\n *\n * @property {Object} AltiResponseReader.READERS - Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} AltiResponseReader.READERS.elevations -  Lecture d'un noeud \"elevations\" de la réponse XML\n *      du service alti, correspondant logiquement à la racine du document\n *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)\n *\n * @property {Method} AltiResponseReader.READERS.elevation - ecture d'un noeud \"elevation\" de la réponse xml du service alti.\n *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)\n *\n * @property {Method} AltiResponseReader.READERS.lat - Lecture d'un noeud \"lat\" de la réponse xml du service alti.\n *      (contient une valeur de latitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.lon - Lecture d'un noeud \"lon\" de la réponse xml du service alti.\n *      (contient une valeur de longitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.z - Lecture d'un noeud \"z\" de la réponse xml du service alti.\n *      (contient une valeur d'altitude, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.acc - Lecture d'un noeud \"acc\" de la réponse xml du service alti.\n *      (contient une valeur de précision, qui est un flottant)\n *\n * @property {Method} AltiResponseReader.READERS.exceptionreport - Lecture d'un noeud \"ExceptionReport\" de la réponse xml du service alti.\n *\n * @property {Method} AltiResponseReader.READERS.exception - Lecture d'un noeud \"Exception\" de la réponse xml du service alti.\n *\n * @property {Method} AltiResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,\n *      à l'aide des readers de la classe.\n *\n */\nvar AltiResponseReader = {};\n\nAltiResponseReader.READERS = {\n\n    /**\n     * Lecture d'un noeud \"elevations\" de la réponse XML du service alti, correspondant logiquement à la racine du document\n     *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)\n     *\n     * @param {DOMElement} root - racine de la réponse XML\n     * @static\n     * @memberof AltiResponseReader\n     */\n    elevations : function (root) {\n        // INFO : on passe en paramètre l'objet en entrée elevations, vide, à remplir.\n        var altiResponse = new __WEBPACK_IMPORTED_MODULE_0__Response_model_AltiResponse__[\"a\" /* default */]();\n\n        if (root.hasChildNodes()) {\n            var children = root.childNodes;\n            var child;\n            var elevation;\n\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n\n                if (AltiResponseReader.READERS[child.nodeName]) {\n                    elevation = AltiResponseReader.READERS[child.nodeName](child);\n                    altiResponse.elevations.push(elevation);\n                }\n            }\n        }\n\n        return altiResponse;\n    },\n\n    /**\n     * Lecture d'un noeud \"elevation\" de la réponse xml du service alti.\n     *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)\n     *\n     * @param {DOMElement} node - noeud elevation à lire pour récupérer les informations de l'élévation retournée (z [, lon, lat, acc])\n     * @return {Array} elevationResponse - format de la réponse en sortie, instance de AltiResponse\n     * @static\n     * @memberof AltiResponseReader\n     */\n    elevation : function (node) {\n        var elevation = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Elevation__[\"a\" /* default */]();\n\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (AltiResponseReader.READERS[child.nodeName]) {\n                    // INFO : on passe en paramètre l'objet en entrée elevation, vide, à remplir.\n                    AltiResponseReader.READERS[child.nodeName](child, elevation);\n                }\n            }\n        }\n        return elevation;\n    },\n\n    /**\n     * Lecture d'un noeud \"lat\" de la réponse xml du service alti.\n     *      (contient une valeur de latitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la latitude\n     * @param {Object} elevation - objet dans lequel stocker la latitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    lat : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.lat = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : latitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"lon\" de la réponse xml du service alti.\n     *      (contient une valeur de longitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la longitude\n     * @param {Object} elevation - objet dans lequel stocker la longitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    lon : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.lon = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : longitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"z\" de la réponse xml du service alti.\n     *      (contient une valeur d'altitude, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'altitude\n     * @param {Object} elevation - objet dans lequel stocker l'altitude retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    z : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            if (elevation) {\n                elevation.z = parseFloat(textNode.nodeValue);\n            } else {\n                elevation = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Elevation__[\"a\" /* default */]();\n                elevation.z = parseFloat(textNode.nodeValue);\n                return elevation;\n            }\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : altitude attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"acc\" de la réponse xml du service alti.\n     *      (contient une valeur de précision, qui est un flottant)\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer la précision\n     * @param {Object} elevation - objet dans lequel stocker la précision retournée\n     * @static\n     * @memberof AltiResponseReader\n     */\n    acc : function (node, elevation) {\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            elevation.acc = parseFloat(textNode.nodeValue);\n        } else {\n            throw new Error(\"Erreur dans la lecture de la réponse du service : précision (acc) attendue mais absente\");\n        }\n    },\n\n    /**\n     * Lecture d'un noeud \"ExceptionReport\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} exceptionReport - objet contenant l'exception\n     * @static\n     * @memberof AltiResponseReader\n     */\n    exceptionreport : function (node) {\n        var response = {};\n\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"Exception\") {\n                    response.exceptionReport = AltiResponseReader.READERS.exception(child);\n                }\n            }\n        }\n\n        return response;\n    },\n\n    /**\n     * Lecture d'un noeud \"Exception\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} exceptionReport - objet contenant l'exception, avec deux attributs :\n     *      {String} exceptionReport.exceptionCode - qui contient l'identifiant du code de l'exception\n     *      {String} exceptionReport.exception - qui contient le message de l'exception\n     * @static\n     * @memberof AltiResponseReader\n     */\n    exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"exceptionCode\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    },\n\n    /**\n     * Lecture d'un noeud \"Error\" de la réponse xml du service alti.\n     *\n     * @param {DOMElement} node - noeud à lire pour récupérer l'exception\n     * @return {Object} error - objet contenant l'exception\n     * @static\n     */\n    error : function (node) {\n        var response = {\n            error : {}\n        };\n        // get error code and description\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                var textNode;\n                // get error code\n                if (child.nodeType === 1 && child.nodeName === \"code\") { // 1 === node.ELEMENT_NODE\n                    textNode = child.firstChild;\n                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n                        response.error.code = textNode.nodeValue;\n                    }\n                }\n                // get error description\n                if (child.nodeType === 1 && child.nodeName === \"description\") { // 1 === node.ELEMENT_NODE\n                    textNode = child.firstChild;\n                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n                        response.error.description = textNode.nodeValue;\n                    }\n                }\n            }\n        }\n        return response;\n    }\n\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,\n *      à l'aide des readers de la classe.\n *\n * @method AltiResponseReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @static\n * @memberof AltiResponseReader\n */\nAltiResponseReader.read = function (root) {\n    if (root.nodeName === \"elevations\") {\n        var altiResponse = AltiResponseReader.READERS.elevations(root);\n        return altiResponse;\n    } else if (root.nodeName === \"ExceptionReport\") {\n        var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);\n        return exceptionReport;\n    } else if (root.nodeName === \"error\") {\n        var error = AltiResponseReader.READERS.error(root);\n        return error;\n    } else {\n        throw new Error(\"Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.\");\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AltiResponseReader);\n\n\n/***/ }),\n/* 60 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Utils_Helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Response_AutoConfResponseFactory__ = __webpack_require__(61);\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service d'autoconfiguration du Géoportail\n *\n * @private\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.AutoConf\n *\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {String} [options.layerId] - Le nom de l'agrégat (couche) dont on veut connaître les informations détaillées.\n *      La présence de cette propriété implique l'utilisation de la deuxième opération du service pour accéder aux informations d'une couche aggrégée.\n *      Dans ce cas, la fonction effectuera quand même dans un premier temps la récupération des informations de l'auto-\n *      configuration complète, sauf si un premier appel à l'autoconf a déjà été fait avec cette clé (i.e. si la variable globale est définie\n *      pour la clé de contrat). Elle ira ensuite chercher les informations des couches agrégées, qui seront ajoutées à la variable globale Gp.Config.\n *\n * @example\n *   var options = {\n *      // options communes aux services\n *      apiKey : \"apikey\",\n *      protocol : 'JSONP', // JSONP|XHR\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      layerId : \"ORTHOIMAGERY.ORTHOPHOTOS.3D$GEOPORTAIL:OGC:WMTS@aggregate\"\n *   };\n */\nfunction AutoConf (options) {\n    if (!(this instanceof AutoConf)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"AutoConf\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"AutoConf\";\n\n    // Autoconf default protocol remains JSONP (#see http://ignf.github.io/geoportal-access-lib/latest/jsdoc/tutorial-optimize-getconfig.html)\n    if (!options) {\n        options = {};\n    }\n    options.protocol = options.protocol || \"JSONP\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_5__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.AutoConf\");\n    this.logger.trace(\"[Constructeur AutoConf (options)]\");\n\n    // #####################\n    // analyse des options\n    // #####################\n\n    // gestion de l'url du service par defaut\n    if (!this.options.serverUrl) {\n        // si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n        // en fonction du nombre de clés en entrée et du paramètre layerId\n        if (!this.options.serverUrl) {\n            var lstUrlByDefault = __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__[\"a\" /* default */].AutoConf.url(this.options.apiKey);\n\n            if (!this.options.layerId) {\n                // cas d'une autoconf simple\n                if (Array.isArray(this.options.apiKey) && this.options.apiKey.length > 0) {\n                    // cas d'un tableau de clés en entrée\n                    this.options.serverUrl = lstUrlByDefault.apiKeys;\n                } else {\n                    this.options.serverUrl = lstUrlByDefault.apiKey;\n                }\n            } else {\n                // cas d'une autoconf pour des couches aggrégées\n                this.options.serverUrl = lstUrlByDefault.aggregate + this.options.layerId;\n            }\n        }\n    }\n\n    // INFO\n    // le service ne repond pas en mode POST (405 Method Not Allowed)\n    if (this.options.protocol === \"XHR\" && this.options.httpMethod === \"POST\") {\n        this.logger.warn(\"Le service ne gére pas le mode d'interrogation en POST, on bascule sur du GET !\");\n        this.options.httpMethod = \"GET\"; // on surcharge !\n    }\n\n    // #####################\n    // attributs d'instances\n    // #####################\n\n    /**\n     * Format forcé de la réponse du service : \"xml\"\n     * sauf si l'on souhaite une reponse brute (options.rawResponse)\n     */\n    this.options.outputFormat = (this.options.rawResponse) ? \"\" : \"xml\";\n}\n\n/**\n * @lends module:AutoConf#\n */\n\nAutoConf.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_5__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nAutoConf.prototype.constructor = AutoConf;\n\n/**\n * Création de la requête (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback de succès de la création de la requête\n */\nAutoConf.prototype.buildRequest = function (error, success) {\n    var scope = typeof window !== \"undefined\" ? window : {};\n\n    if (scope.Gp && scope.Gp.Config && scope.Gp.Config.generalOptions && scope.Gp.Config.layers) {\n        if (scope.Gp.Config.generalOptions.apiKeys[this.options.apiKey]) {\n            if (this.options.layerId) { // cas d'une autoconf + détaillée sur une couche agrégée\n                if (scope.Gp.Config.layers[this.options.layerId] && scope.Gp.Config.layers[this.options.layerId].aggregatedLayers) {\n                    this.logger.warn(\"Gp.Config existe déjà pour cette clé et cette couche\");\n                    this.options.onSuccess.call(this, scope.Gp.Config);\n                    return;\n                }\n            } else {\n                this.logger.warn(\"Gp.Config existe déjà pour cette clé\");\n                this.options.onSuccess.call(this, scope.Gp.Config);\n                return;\n            }\n        }\n    }\n\n    // requete par defaut\n    this.request = \"\";\n\n    // gestion de l'autoconf local\n    // Le fichier en local doit respecter le format de sortie du service.\n    //  - En XHR, le format est en xml\n    //  - En JSONP, le format est en xml encapsulé dans un json avec une fonction de callback\n    //    ex. callback ({\"http\":{\"status\":200,\"error\":null},\"xml\":\"...\"})\n    var bLocal;\n    if (this.options.serverUrl.indexOf(\"http://\") === -1) {\n        bLocal = true;\n    } else {\n        bLocal = false;\n    }\n\n    // FIXME param. KVP optionnel sur un service uniquement (pas sur un autoconf local !)\n    if (!bLocal && this.layerId) {\n        this.request = __WEBPACK_IMPORTED_MODULE_2__Utils_Helper__[\"a\" /* default */].normalyzeParameters({\n            layerId : this.layerId\n        });\n    }\n\n    // normalement pas d'erreur d'autoconf...\n    (this.request || this.request === \"\")\n        ? success.call(this, this.request)\n        : error.call(this, new __WEBPACK_IMPORTED_MODULE_3__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\")));\n};\n\n/**\n * Analyse de la reponse (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback de succès de l'analyse de la réponse\n */\nAutoConf.prototype.analyzeResponse = function (error, success) {\n    if (this.response) {\n        var options = {\n            layerId : this.options.layerId,\n            response : this.response,\n            rawResponse : this.options.rawResponse,\n            onSuccess : success,\n            onError : error,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_6__Response_AutoConfResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_3__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoConf);\n\n\n/***/ }),\n/* 61 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Formats_AutoConfResponseReader__ = __webpack_require__(62);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML\n *\n * @module AutoConfReponseFactory\n * @private\n * @alias Gp.Services.AutoConf.Response.AutoConfResponseFactory\n * @todo gérer le cas du JSONP qui encapsule du XML ?\n */\n\n\n\n\n\n\nvar AutoConfReponseFactory = {\n\n    /**\n     * interface unique\n     * Fabrique d'analyse des réponses (xml) du service d'autoconfiguration.\n     * Création d'un format XML, auquel on associe un reader et une chaîne XML, et qui renverra un objet JavaScript correspondant.\n     * Si une erreur est levée lors de l'analyse, ou si l'objet est vide ou contient une exception : appel de la fonction de callback onError\n     * Sinon, appel de la fonction de callback onSuccess (définies dans Autoconf.analyzeResponse)\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant AutoConf\n     *\n     * @example\n     *   var options = {\n     *      layerId :\n     *      response :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AutoConfResponseFactory\");\n        logger.trace([\"AutoConfResponseFactory::build()\"]);\n\n        // data de type AutoConfResponse\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                data = options.response;\n            } else {\n                try {\n                    var p = new __WEBPACK_IMPORTED_MODULE_3__Formats_XML__[\"a\" /* default */]({\n                        reader : __WEBPACK_IMPORTED_MODULE_4__Formats_AutoConfResponseReader__[\"a\" /* default */]\n                    });\n\n                    if (typeof options.response === \"string\") {\n                        p.setXMLString(options.response);\n                    } else {\n                        p.setXMLDoc(options.response);\n                    }\n\n                    data = p.parse();\n                } catch (e) {\n                    // si une exception a été levée, on appelle le callback d'erreur avec le message renvoyé\n                    var message = e.message;\n                    if (typeof options.response === \"string\") {\n                        message += \"\\n (raw response service'\" + options.response + \"')\";\n                    } else {\n                        message += \"\\n (raw response service'\" + options.response.documentElement.innerHTML + \"')\";\n                    }\n\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", message),\n                        status : 200,\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                    }));\n                    return;\n                }\n\n                // Si la réponse est vide, on appelle le callback d'erreur\n                var isEmpty = true;\n                for (var key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        isEmpty = false;\n                    }\n                }\n                if (isEmpty) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY_2\")));\n                    return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service, on appelle le callback d'erreur\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n            }\n        } else {\n            // si la réponse (xmlString) est vide, on appelle le callback d'erreur\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        // définition de la variable globale Gp.Config à partir de la réponse\n        var scope = typeof window !== \"undefined\" ? window : {};\n\n        if (!scope.Gp) {\n            scope.Gp = {};\n        }\n        if (!scope.Gp.Config) {\n            scope.Gp.Config = data;\n        } else {\n            this.mergeConfig(scope.Gp.Config, data, options.layerId);\n        }\n\n        // si tout s'est bien passé, on appelle le callback de succès\n        options.onSuccess.call(options.scope, scope.Gp.Config);\n    },\n\n    /**\n     * Fonction utilisée dans le cas où l'autoconfiguration est appelée plusieurs fois\n     * (par exemple pour des clés différentes ou pour des infos sur une couche agrégée)\n     *\n     * @method mergeConfig\n     * @static\n     * @param {Object} GpConfig - Variable Gp.Config préexistante\n     * @param {Object} data - la nouvelle réponse de l'autoconf, à fusionner avec GpConfig\n     * @param {String} [layerId] - l'identifiant d'une couche agrégée dans le cas d'une 2è opération de l'autoconf\n     */\n    mergeConfig : function (GpConfig, data, layerId) {\n        if (data && GpConfig) {\n            // on boucle sur les propriétés (generalOptions, layers, projections, services, tileMatrixSets, territories)\n            for (var prop in data) {\n                if (data.hasOwnProperty(prop)) {\n                    // on récupère la nouvelle clé dans generalOptions\n                    if (prop === \"generalOptions\") {\n                        for (var key in data[prop].apiKeys) {\n                            if (data[prop].apiKeys.hasOwnProperty(key) && !GpConfig.generalOptions.apiKeys[key]) {\n                                GpConfig.generalOptions.apiKeys[key] = data[prop].apiKeys[key];\n                            }\n                        }\n                        // on récupère les nouveaux objets (TMS, layers, projections...)\n                    } else {\n                        if (GpConfig[prop]) {\n                            for (var obj in data[prop]) {\n                                if (data[prop].hasOwnProperty(obj) && !GpConfig[prop][obj]) {\n                                    GpConfig[prop][obj] = data[prop][obj];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // dans le cas d'une autoconf pour une couche agrégée, on récupère l'info\n            if (layerId) {\n                var aggregatedLayers = [];\n\n                for (var lyr in data.layers) {\n                    if (data.layers.hasOwnProperty(lyr)) {\n                        aggregatedLayers.push(lyr);\n                    }\n                }\n\n                if (GpConfig.layers[layerId]) {\n                    GpConfig.layers[layerId].aggregatedLayers = aggregatedLayers;\n                }\n            }\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoConfReponseFactory);\n\n\n/***/ }),\n/* 62 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Response_model_AutoConfResponse__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Response_model_Format__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Response_model_Layer__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Response_model_Legend__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Response_model_Metadata__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Response_model_Originator__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Response_model_Service__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Response_model_Style__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__Response_model_Territory__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Response_model_Thematic__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Response_model_TileMatrixSet__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__Response_model_TileMatrix__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__Response_model_TileMatrixLimit__ = __webpack_require__(37);\n\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service d'autoconfiguration du Géoportail\n *      afin de récupérer les informations retournées.\n * @module AutoConfResponseReader\n * @private\n * @alias Gp.Services.AutoConf.Formats.AutoConfResponseReader\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar AutoConfResponseReader = {};\n\n/**\n * version du service d'autoconf\n */\nAutoConfResponseReader.VERSION = \"1.1.0\";\n\n/**\n * Objet stockant les différents namespaces et les URI associées\n */\nAutoConfResponseReader.NAMESPACES = {\n    xmlns : \"http://www.opengis.net/context\",\n    gpp : \"http://api.ign.fr/geoportail\",\n    ows : \"http://www.opengis.net/ows/1.1\",\n    sld : \"http://www.opengis.net/sld\",\n    wmts : \"http://www.opengis.net/wmts/1.0\",\n    xlink : \"http://www.w3.org/1999/xlink\",\n    xsi : \"http://www.w3.org/2001/XMLSchema-instance\"\n};\n\n/**\n * Localisation (URL) du schema de définition du XML (XSD)\n */\nAutoConfResponseReader.SCHEMALOCATION = [\n    \"http://www.opengis.net/context http://gpp3-wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://wxs.ign.fr/schemas/autoconf/autoconf.xsd\",\n    \"http://www.opengis.net/context http://gpp3-wxs.ign.fr/schemas/extContext.xsd http://api.ign.fr/geoportail http://gpp3-wxs.ign.fr/schemas/autoconf.xsd\"\n];\n\n/**\n * Namespace par défaut du format\n */\nAutoConfResponseReader.DEFAULTPREFIX = \"context\";\n\n/**\n * Objet contenant des fonctions de lecture, appelées \"READERS\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n */\nAutoConfResponseReader.READERS = {\n\n    context : {\n\n        /** ViewContext */\n        ViewContext : function (viewContextNode) {\n            // info : balise \"racine\" de la réponse de l'autoconf\n\n            // vérification de la version du service, et des namespaces de l'en-tête\n            __checkServiceAttributes(viewContextNode);\n\n            // create AutoConfResponse\n            var config = new __WEBPACK_IMPORTED_MODULE_0__Response_model_AutoConfResponse__[\"a\" /* default */]();\n\n            __getChildNodes(viewContextNode, config);\n\n            return config;\n        },\n\n        // info : /General/Title\n        // ou : /LayerList/Layer/Title\n        /** Title */\n        Title : function (titleNode, data) {\n            if (data && data.generalOptions) { // cas de la variable config générale\n                data.generalOptions.title = __getChildValue(titleNode);\n            } else if (data && data.lyr) { // cas d'une layer\n                data.lyr.title = __getChildValue(titleNode);\n            }\n        },\n\n        // info : /LayerList/Layer/Abstract\n        /** Abstract */\n        Abstract : function (node, data) {\n            if (data && data.lyr) {\n                data.lyr.description = __getChildValue(node);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Services/Server\n        // ou : /LayerList/Server\n        /** Server */\n        Server : function (node, data) {\n            var serverId = node.getAttribute(\"service\");\n            var title = node.getAttribute(\"title\");\n            var version = node.getAttribute(\"version\");\n            if (serverId) {\n                if (data && data.services && typeof data.services === \"object\" && !data.services[serverId]) {\n                    // on est dans la balise Services\n                    var s = new __WEBPACK_IMPORTED_MODULE_7__Response_model_Service__[\"a\" /* default */]();\n                    s.title = title;\n                    s.version = version;\n                    // récupération de l'url du service, dans une balise enfant \"OnlineResource\"\n                    __getChildNodes(node, s);\n                    // ajout du service à la variable config\n                    data.services[serverId] = s;\n                } else if (data && data.lyr) {\n                    // on est dans la balise Layer\n                    if (!data.lyr.serviceParams) {\n                        // si l'objet serviceParams n'a pas encore été créé, on le crée.\n                        data.lyr.serviceParams = {};\n                    }\n                    data.lyr.serviceParams.id = serverId;\n                    data.lyr.serviceParams.version = version;\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Services/Server/OnlineResource\n        // ou : /LayerList/Layer/Server/OnlineResource\n        // ou : /LayerList/Layer/Extention/gpp:Layer/gpp:QuickLook/OnlineResource\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/gpp:LegendURL/OnlineResource\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:MetadataURL/OnlineResource\n        /** OnlineResource */\n        OnlineResource : function (node, service) {\n            if (service && service.hasOwnProperty(\"serverUrl\")) {\n                service.serverUrl = node.getAttribute(\"xlink:href\");\n            }\n        },\n\n        // info : /LayerList\n        /** LayerList */\n        LayerList : function (layerListNode, config) {\n            // liste de balises \"layer\"\n            __getChildNodes(layerListNode, config);\n\n            if (config && config.layers && config.generalOptions && config.services) {\n                // récupération des clés et des couches associées\n                for (var lyr in config.layers) {\n                    if (config.layers.hasOwnProperty(lyr)) {\n                        var layerConfig = config.layers[lyr];\n\n                        // récupération de la clé associée\n                        var apiKeys = layerConfig.apiKeys;\n                        if (apiKeys && Array.isArray(apiKeys)) {\n                            for (var i = 0; i < apiKeys.length; i++) {\n                                // pour chaque clé API, on ajoute la couche\n                                var key = apiKeys[i];\n                                if (config.generalOptions.apiKeys) {\n                                    if (!config.generalOptions.apiKeys[key] || !Array.isArray(config.generalOptions.apiKeys[key])) {\n                                        config.generalOptions.apiKeys[key] = [];\n                                    }\n                                    config.generalOptions.apiKeys[key].push(lyr);\n                                }\n                            }\n                        }\n\n                        // récupération du service associé\n                        var serviceParams = layerConfig.serviceParams;\n                        if (serviceParams && serviceParams.id) {\n                            if (!config.services[serviceParams.id]) {\n                                var s = new __WEBPACK_IMPORTED_MODULE_7__Response_model_Service__[\"a\" /* default */]();\n                                if (serviceParams.serverUrl) {\n                                    s.serverUrl = serviceParams.serverUrl;\n                                }\n                                if (serviceParams.version) {\n                                    s.version = serviceParams.version;\n                                }\n                                config.services[serviceParams.id] = s;\n                            }\n                        }\n\n                        // récupération de la projection associée (dans le cas d'une couche WMTS)\n                        if (layerConfig.wmtsOptions && layerConfig.wmtsOptions.tileMatrixSetLink && config.tileMatrixSets) {\n                            var tmsLink = layerConfig.wmtsOptions.tileMatrixSetLink;\n                            var tileMatrixSets = config.tileMatrixSets;\n                            for (var tms in tileMatrixSets) {\n                                if (tileMatrixSets.hasOwnProperty(tms) && tms === tmsLink) {\n                                    layerConfig.defaultProjection = tileMatrixSets[tms].projection;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n\n        // info : /LayerList/Layer\n        /** Layer */\n        Layer : function (layerNode, config) {\n            if (config && config.layers) {\n                var lyrData = {\n                    lyr : new __WEBPACK_IMPORTED_MODULE_3__Response_model_Layer__[\"a\" /* default */](),\n                    lyrId : null\n                };\n\n                var hidden = layerNode.getAttribute(\"hidden\");\n                if (hidden === \"1\") {\n                    lyrData.lyr.hidden = true;\n                } else {\n                    lyrData.lyr.hidden = false;\n                }\n\n                var queryable = layerNode.getAttribute(\"queryable\");\n                if (queryable === \"1\") {\n                    lyrData.lyr.queryable = true;\n                } else {\n                    lyrData.lyr.queryable = false;\n                }\n\n                // on peut avoir les balises : Server, Name, Title, Abstract, DataURL, MetadataURL,\n                // sld:MinScaleDenominator, sld:MaxScaleDenominator, SRS, FormatList, StyleList\n                // DimensionList, Extension\n                __getChildNodes(layerNode, lyrData);\n\n                // si on a bien récupéré l'identifiant de la couche, on s'en sert pour l'ajouter au tableau associatif des couches disponibles\n                if (lyrData.lyrId) {\n                    // Dans le cas des services, on modifie le contexte de l'identifiant.\n                    if (lyrData.lyr.serviceParams && lyrData.lyr.serviceParams.id) {\n                        var serviceid = lyrData.lyr.serviceParams.id;\n                        if (serviceid.toUpperCase().indexOf(\"OPENLS\") !== -1 || serviceid.toUpperCase().indexOf(\"ELEVATION\") !== -1) {\n                            // Il faut changer l'identifiant de la ressource.\n                            var resourceId = lyrData.lyrId.split(\"$\")[0];\n                            lyrData.lyrId = resourceId + \"$\" + serviceid;\n                        }\n                    }\n\n                    // on ajoute l'information dans les attributs de la couche\n                    lyrData.lyr.layerId = lyrData.lyrId;\n                    // et dans le tableau Gp.Config.layers\n                    config.layers[lyrData.lyrId] = lyrData.lyr;\n                }\n            }\n        },\n\n        // info : /LayerList/Layer/Name\n        /** TODO : jsdoc block */\n        Name : function (node, lyrData) {\n            if (lyrData && lyrData.lyr) {\n                lyrData.lyr.name = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/SRS (dans le cas des couches WMS ou WFS)\n        /** TODO : jsdoc block */\n        SRS : function (node, lyrData) {\n            // on récupère la projection de la couche (SRS)\n            if (lyrData && lyrData.lyr) {\n                lyrData.lyr.defaultProjection = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/FormatList/Format\n        /** TODO : jsdoc block */\n        Format : function (node, lyrData) {\n            if (lyrData && lyrData.lyr) {\n                var f = new __WEBPACK_IMPORTED_MODULE_2__Response_model_Format__[\"a\" /* default */]();\n                var current = node.getAttribute(\"current\");\n                if (current === \"1\") {\n                    f.current = true;\n                } else {\n                    f.current = false;\n                }\n                f.name = __getChildValue(node);\n                // si on n'a pas encore ajouté de format, on crée le tableau vide\n                if (!lyrData.lyr.formats || !Array.isArray(lyrData.lyr.formats)) {\n                    lyrData.lyr.formats = [];\n                }\n                lyrData.lyr.formats.push(f);\n            }\n        },\n\n        // info : /LayerList/Layer/StyleList/Style\n        /** TODO : jsdoc block */\n        Style : function (node, lyrData) {\n            if (lyrData && lyrData.lyr) {\n                var s = new __WEBPACK_IMPORTED_MODULE_8__Response_model_Style__[\"a\" /* default */]();\n                var current = node.getAttribute(\"current\");\n                if (current === \"1\" || current === 1) {\n                    s.current = true;\n                } else {\n                    s.current = false;\n                }\n                if (node.hasChildNodes) {\n                    var children = node.childNodes;\n                    var child;\n                    var childName;\n                    for (var i = 0; i < children.length; i++) {\n                        child = children[i];\n                        if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                            childName = child.localName || child.baseName || child.nodeName;\n                            if (childName === \"Name\") {\n                                s.name = __getChildValue(child);\n                            } else if (childName === \"Title\") {\n                                s.title = __getChildValue(child);\n                            }\n                        }\n                    }\n                }\n                // si on n'a pas encore ajouté de style, on crée le tableau vide\n                if (!lyrData.lyr.styles || !Array.isArray(lyrData.lyr.styles)) {\n                    lyrData.lyr.styles = [];\n                }\n                lyrData.lyr.styles.push(s);\n            }\n        },\n\n        // info : /LayerList/Layer/DimensionList/Dimension\n        /** TODO : jsdoc block */\n        Dimension : function (node, lyrData) {\n            // possède des attributs obligatoires : name, units, unitSymbol et userValue\n            // et d'autres attributs facultatifs : default, multipleValues, nearestValue, current\n            var name = node.getAttribute(\"name\");\n            var dim = __getChildValue(node);\n            if (lyrData && lyrData.lyr) {\n                // si on n'a pas encore ajouté de dimension, on crée l'objet vide\n                if (!lyrData.lyr.dimensions) {\n                    lyrData.lyr.dimensions = {};\n                }\n                if (name === \"Type\") {\n                    lyrData.lyr.dimensions.type = dim;\n                } else if (name === \"VisibilityRange\") {\n                    lyrData.lyr.dimensions.visibilityRange = dim;\n                } else if (name === \"VisibilityMode \") {\n                    lyrData.lyr.dimensions.visibilityMode = dim;\n                } else if (name === \"GeometricType\") {\n                    lyrData.lyr.dimensions.geometricType = dim;\n                } else if (name === \"NoDataValue\") {\n                    lyrData.lyr.dimensions.noDataValue = dim;\n                }\n            }\n        }\n\n    },\n\n    gpp : {\n\n        // info : /General/Extension/gpp:General/gpp:Theme\n        /** TODO : jsdoc block */\n        Theme : function (themeNode, config) {\n            if (config && config.generalOptions && config.generalOptions.hasOwnProperty(\"theme\")) {\n                config.generalOptions.theme = __getChildValue(themeNode);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:defaultGMLGFIStyleUrl\n        /** TODO : jsdoc block */\n        defaultGMLGFIStyleUrl : function (node, config) {\n            if (config && config.generalOptions && config.generalOptions.hasOwnProperty(\"defaultGMLGFIStyle\")) {\n                config.generalOptions.defaultGMLGFIStyle = __getChildValue(node);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory\n        /** TODO : jsdoc block */\n        Territory : function (territoryNode, config) {\n            // info : Information to configure the API for this territory\n            var tid = territoryNode.getAttribute(\"id\");\n            if (tid) {\n                // create a new Territory\n                var t = new __WEBPACK_IMPORTED_MODULE_9__Response_model_Territory__[\"a\" /* default */]();\n\n                var isDefault = territoryNode.getAttribute(\"default\");\n                if (isDefault === \"1\") {\n                    t.isDefault = true;\n                } else {\n                    t.isDefault = false;\n                }\n                // read territory informations\n                __getChildNodes(territoryNode, t);\n                // add territory to config\n                if (config && config.territories && typeof config.territories === \"object\") {\n                    config.territories[tid] = t;\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:defaultCRS\n        /** TODO : jsdoc block */\n        defaultCRS : function (node, territory) {\n            // info : Identifier for the default Coordinate Reference System (CRS).\n            if (territory && territory.hasOwnProperty(\"defaultCRS\")) {\n                territory.defaultCRS = __getChildValue(node);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:AdditionalCRS\n        // ou : /LayerList/Extension/gpp:Layer/gpp:AdditionalCRS\n        /** TODO : jsdoc block */\n        AdditionalCRS : function (node, data) {\n            // info : Identifier for additional Coordinate Reference System (CRS).\n            // info : data peut être une instance de Territory.js, ou une instance de Layer.js\n            var addCRS = __getChildValue(node);\n            if (addCRS && data) {\n                if (Array.isArray(data.additionalCRS)) { // cas d'un territoire\n                    data.additionalCRS.push(addCRS);\n                } else { // cas d'une couche\n                    // si le tableau n'est pas encore créé\n                    if (!data.additionalProjections || !Array.isArray(data.additionalProjections)) {\n                        data.additionalProjections = [];\n                    }\n                    data.additionalProjections.push(addCRS);\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:DefaultLayer\n        /** TODO : jsdoc block */\n        DefaultLayer : function (node, territory) {\n            var lyr = node.getAttribute(\"layerId\");\n            if (lyr && territory && Array.isArray(territory.defaultLayers)) {\n                territory.defaultLayers.push(lyr);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:BoundingBox\n        // ou : /LayerList/Extension/gpp:Layer/gpp:BoundingBox\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint/gpp:BoundingBox\n        // ou : /LayerList/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint/gpp:BoundingBox\n        /** TODO : jsdoc block */\n        BoundingBox : function (node, data) {\n            if (data) {\n                var values = __getChildValue(node).split(\",\");\n                if (values.length === 4) {\n                    // get bbox coordinates (wgs84)\n                    var bbox = {\n                        left : parseFloat(values[0]),\n                        right : parseFloat(values[2]),\n                        top : parseFloat(values[3]),\n                        bottom : parseFloat(values[1])\n                    };\n                    // get temporal extent params (constraint or layer)\n                    var minT = node.getAttribute(\"minT\");\n                    var maxT = node.getAttribute(\"maxT\");\n\n                    if (data.hasOwnProperty(\"geoBBOX\")) { // cas d'un territoire\n                        data.geoBBOX = bbox;\n                    } else if (data.hasOwnProperty(\"bbox\")) { // cas d'une constraint\n                        if (data.bbox.left || data.bbox.right || data.bbox.top || data.bbox.bottom) {\n                            // si on a déjà une bbox, il faut stocker d'autres contraintes\n                            if (!data.multiConstraints) {\n                                data.multiConstraints = [];\n                            }\n                            var newConstraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                            newConstraint.bbox = bbox;\n                            newConstraint.temporalExtent = [minT, maxT];\n                            data.multiConstraints.push(newConstraint);\n                        } else {\n                            // contrainte classique\n                            data.bbox = bbox;\n                            data.temporalExtent = [minT, maxT];\n                        }\n                    } else { // cas d'une layer\n                        if (!data.globalConstraint) {\n                            data.globalConstraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                        }\n                        data.globalConstraint.bbox = bbox;\n                        data.globalConstraint.temporalExtent = [minT, maxT];\n                    }\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Resolution\n        /** TODO : jsdoc block */\n        Resolution : function (node, territory) {\n            // info : The default resolution to display on this territory, in CRS coordinate system\n            var res = __getChildValue(node);\n            if (res && territory && territory.defaultOptions && territory.defaultOptions.hasOwnProperty(\"resolution\")) {\n                territory.defaultOptions.resolution = parseFloat(res);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Center/gpp:x\n        /** TODO : jsdoc block */\n        x : function (node, territory) {\n            var lon = __getChildValue(node);\n            if (lon && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty(\"lon\")) {\n                territory.geoCenter.lon = parseFloat(lon);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/gpp:Center/gpp:y\n        /** TODO : jsdoc block */\n        y : function (node, territory) {\n            var lat = __getChildValue(node);\n            if (lat && territory && territory.geoCenter && territory.geoCenter.hasOwnProperty(\"lat\")) {\n                territory.geoCenter.lat = parseFloat(lat);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Resolutions\n        /** TODO : jsdoc block */\n        Resolutions : function (resNode, config) {\n            // info : List of resolutions in CRS:84 (comma separated values)\n            if (config && config.generalOptions && config.generalOptions.hasOwnProperty(\"wgs84Resolutions\")) {\n                config.generalOptions.wgs84Resolutions = __getChildValue(resNode).split(\",\");\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer\n        /** TODO : jsdoc block */\n        Layer : function (node, lyrData) {\n            // attributs : id, opacity, order, visibleInCatalog, aggregate, more\n            if (lyrData && lyrData.hasOwnProperty(\"lyrId\") && lyrData.lyr) {\n                lyrData.lyrId = node.getAttribute(\"id\");\n                var aggregate = node.getAttribute(\"aggregate\");\n                var more = node.getAttribute(\"more\");\n                if (aggregate || more) {\n                    lyrData.lyr.isAggregate = true;\n                }\n                __getChildNodes(node, lyrData.lyr);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint\n        // ou : /LayerList/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint\n        /** TODO : jsdoc block */\n        Constraint : function (node, data) {\n            var c = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n            __getChildNodes(node, c);\n            if (data) {\n                // on peut être dans le cas d'un originator ou d'une layer, tous les deux ont l'attribut constraints\n                if (!data.constraints || !Array.isArray(data.constraints)) {\n                    data.constraints = [];\n                }\n\n                // cas de plusieurs contraintes (par ex différents territoires)\n                if (c.multiConstraints && Array.isArray(c.multiConstraints)) {\n                    // on récupère la première contrainte, stockée normalement\n                    var constraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                    constraint.crs = c.crs;\n                    constraint.bbox = c.bbox;\n                    constraint.minScaleDenominator = c.minScaleDenominator;\n                    constraint.maxScaleDenominator = c.maxScaleDenominator;\n                    constraint.temporalExtent = c.temporalExtent;\n                    data.constraints.push(constraint);\n\n                    // puis on récupère les autres contraintes, à partir de multiConstraints\n                    for (var i = 0; i < c.multiConstraints.length; i++) {\n                        constraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                        constraint.crs = c.crs;\n                        constraint.minScaleDenominator = c.minScaleDenominator;\n                        constraint.maxScaleDenominator = c.maxScaleDenominator;\n                        constraint.bbox = c.multiConstraints[i].bbox;\n                        constraint.temporalExtent = c.multiConstraints[i].temporalExtent;\n                        data.constraints.push(constraint);\n                    }\n                } else {\n                    // cas d'une contrainte classique\n                    data.constraints.push(c);\n                }\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/gpp:Constraint/gpp:CRS\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Constraints/gpp:Constraint/gpp:CRS\n        /** TODO : jsdoc block */\n        CRS : function (node, data) {\n            // nothing to do.\n            if (data && data.hasOwnProperty(\"crs\")) {\n                data.crs = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Thematics/gpp:Thematic\n        /** TODO : jsdoc block */\n        Thematic : function (node, lyr) {\n            if (lyr) {\n                var t = new __WEBPACK_IMPORTED_MODULE_10__Response_model_Thematic__[\"a\" /* default */]();\n                t.inspire = false;\n                t.name = __getChildValue(node);\n                // si aucune thématique n'a été ajoutée, on crée le tableau vide\n                if (!lyr.thematics || !Array.isArray(lyr.thematics)) {\n                    lyr.thematics = [];\n                }\n                lyr.thematics.push(t);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Thematics/gpp:InspireThematic\n        /** TODO : jsdoc block */\n        InspireThematic : function (node, lyr) {\n            if (lyr) {\n                var t = new __WEBPACK_IMPORTED_MODULE_10__Response_model_Thematic__[\"a\" /* default */]();\n                t.inspire = true;\n                t.name = __getChildValue(node);\n                // si aucune thématique n'a été ajoutée, on crée le tableau vide\n                if (!lyr.thematics || !Array.isArray(lyr.thematics)) {\n                    lyr.thematics = [];\n                }\n                lyr.thematics.push(t);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator\n        /** TODO : jsdoc block */\n        Originator : function (node, lyr) {\n            if (lyr) {\n                // info : contient des balises Attribution, Logo, URL, et Constraints\n                var o = new __WEBPACK_IMPORTED_MODULE_6__Response_model_Originator__[\"a\" /* default */]();\n                o.name = node.getAttribute(\"name\");\n                __getChildNodes(node, o);\n                // si aucun originator n'a été ajouté, on crée le tableau vide\n                if (!lyr.originators || !Array.isArray(lyr.originators)) {\n                    lyr.originators = [];\n                }\n                lyr.originators.push(o);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Attribution\n        /** TODO : jsdoc block */\n        Attribution : function (node, originator) {\n            if (originator && originator.hasOwnProperty(\"attribution\")) {\n                originator.attribution = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Logo\n        /** TODO : jsdoc block */\n        Logo : function (node, originator) {\n            if (originator && originator.hasOwnProperty(\"logo\")) {\n                originator.logo = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:URL\n        /** TODO : jsdoc block */\n        URL : function (node, originator) {\n            if (originator && originator.hasOwnProperty(\"url\")) {\n                originator.url = __getChildValue(node);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend\n        /** TODO : jsdoc block */\n        Legend : function (node, lyr) {\n            // 2 balises : sld:MinScaleDenominator et gpp:LegendURL\n            var l = new __WEBPACK_IMPORTED_MODULE_4__Response_model_Legend__[\"a\" /* default */]();\n            __getChildNodes(node, l);\n            if (lyr) {\n                // si aucune légende n'a encore été ajoutée, on crée le tableau vide\n                if (!lyr.legends || !Array.isArray(lyr.legends)) {\n                    lyr.legends = [];\n                }\n                lyr.legends.push(l);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/gpp:LegendURL\n        /** TODO : jsdoc block */\n        LegendURL : function (node, legend) {\n            if (legend && legend.hasOwnProperty(\"format\")) {\n                legend.format = node.getAttribute(\"format\");\n                if (node.hasChildNodes) {\n                    var child = node.childNodes[0];\n                    var childName = child.localName || child.baseName || child.nodeName;\n                    if (childName === \"OnlineResource\" && legend.hasOwnProperty(\"url\")) {\n                        legend.url = child.getAttribute(\"xlink:href\");\n                    }\n                }\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:QuickLook\n        /** TODO : jsdoc block */\n        QuickLook : function (node, lyr) {\n            // info : contient une balise OnlineResource avec l'url dans l'attribut \"xlink:href\"\n            if (node.hasChildNodes) {\n                var child = node.childNodes[0];\n                var childName = child.localName || child.baseName || child.nodeName;\n                if (childName === \"OnlineResource\" && lyr) {\n                    lyr.quicklookUrl = child.getAttribute(\"xlink:href\");\n                }\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:MetadataURL\n        /** TODO : jsdoc block */\n        MetadataURL : function (node, lyr) {\n            if (lyr) {\n                // info : contient une balise OnlineResource avec l'url dans l'attribut \"xlink:href\"\n                var m = new __WEBPACK_IMPORTED_MODULE_5__Response_model_Metadata__[\"a\" /* default */]();\n                m.format = node.getAttribute(\"format\");\n                if (node.hasChildNodes) {\n                    var child = node.childNodes[0];\n                    var childName = child.localName || child.baseName || child.nodeName;\n                    if (childName === \"OnlineResource\") {\n                        m.url = child.getAttribute(\"xlink:href\");\n                    }\n                }\n                // si aucune metadata n'a été ajoutée, on crée le tableau vide\n                if (!lyr.metadata && !Array.isArray(lyr.metadata)) {\n                    lyr.metadata = [];\n                }\n                lyr.metadata.push(m);\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/gpp:Keys/gpp:Key\n        /** TODO : jsdoc block */\n        Key : function (node, lyr) {\n            if (lyr) {\n                // récupération de la clé API\n                var key = node.getAttribute(\"id\");\n                // si on n'a pas encore ajouté de clé, on crée le tableau vide\n                if (!lyr.apiKeys || !Array.isArray(lyr.apiKeys)) {\n                    lyr.apiKeys = [];\n                }\n                lyr.apiKeys.push(key);\n\n                // récupération de l'url du service avec la clé API\n                var serverUrl = __getChildValue(node);\n                if (!lyr.serviceParams) {\n                    lyr.serviceParams = {};\n                }\n                if (!lyr.serviceParams.serverUrl) {\n                    lyr.serviceParams.serverUrl = {};\n                }\n                if (!lyr.serviceParams.serverUrl[key]) {\n                    lyr.serviceParams.serverUrl[key] = serverUrl;\n                }\n            }\n        }\n\n    },\n\n    ows : {\n        /** TODO : jsdoc block */\n        Identifier : function (node, data) {\n            if (data && data.hasOwnProperty(\"TMS\")) { // dans le cas d'un TileMatrixSet\n                data.identifier = __getChildValue(node);\n            } else if (data && data.hasOwnProperty(\"matrixId\")) { // dans le cas d'une TileMatrix\n                data.matrixId = __getChildValue(node);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        SupportedCRS : function (node, tmsData) {\n            if (tmsData && tmsData.TMS && tmsData.TMS.hasOwnProperty(\"projection\")) {\n                tmsData.TMS.projection = __getChildValue(node);\n            }\n        }\n    },\n\n    sld : {\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/sld:MinScaleDenominator\n        // ou : /LayerList/Layer/sld:MinScaleDenominator\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/sld:MinScaleDenominator\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Legends/gpp:Legend/sld:MinScaleDenominator\n        /** TODO : jsdoc block */\n        MinScaleDenominator : function (node, data) {\n            var minScale = __getChildValue(node);\n            if (minScale && data) {\n                if (data.hasOwnProperty(\"defaultOptions\")) { // cas d'un territoire\n                    data.defaultOptions.minScaleDenominator = parseFloat(minScale);\n                } else if (data.lyr) { // cas d'une layer\n                    if (!data.lyr.globalConstraint) {\n                        data.lyr.globalConstraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                    }\n                    data.lyr.globalConstraint.minScaleDenominator = parseFloat(minScale);\n                } else if (data.hasOwnProperty(\"minScaleDenominator\")) { // cas d'une contrainte ou d'une légende\n                    data.minScaleDenominator = parseFloat(minScale);\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:Territories/gpp:Territory/sld:MaxScaleDenominator\n        // ou : /LayerList/Layer/sld:MaxScaleDenominator\n        // ou : /LayerList/Layer/Extension/gpp:Layer/gpp:Originators/gpp:Originator/gpp:Constraints/sld:MaxScaleDenominator\n        /** TODO : jsdoc block */\n        MaxScaleDenominator : function (node, data) {\n            var maxScale = __getChildValue(node);\n            if (maxScale && data) {\n                if (data.hasOwnProperty(\"defaultOptions\")) { // cas d'un territoire\n                    data.defaultOptions.maxScaleDenominator = parseFloat(maxScale);\n                } else if (data.lyr) { // cas d'une layer\n                    if (!data.lyr.globalConstraint) {\n                        data.lyr.globalConstraint = new __WEBPACK_IMPORTED_MODULE_1__Response_model_Constraint__[\"a\" /* default */]();\n                    }\n                    data.lyr.globalConstraint.maxScaleDenominator = parseFloat(maxScale);\n                } else if (data.hasOwnProperty(\"maxScaleDenominator\")) { // cas d'une contrainte\n                    data.maxScaleDenominator = parseFloat(maxScale);\n                }\n            }\n        }\n    },\n\n    wmts : {\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSetLimits\n        /** TODO : jsdoc block */\n        TileMatrixSetLimits : function (node, lyr) {\n            // info : contient des balises wmts:TileMatrixLimits\n            if (lyr) {\n                var limits = {};\n                // on récupère les limites dans les balises TileMatrixLimits\n                __getChildNodes(node, limits);\n\n                if (!lyr.wmtsOptions) {\n                    lyr.wmtsOptions = {};\n                }\n                lyr.wmtsOptions.tileMatrixSetLimits = limits;\n            }\n        },\n\n        // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSetLimits/wmts:TileMatrixLimits\n        /** TODO : jsdoc block */\n        TileMatrixLimits : function (node, limits) {\n            var limit = new __WEBPACK_IMPORTED_MODULE_13__Response_model_TileMatrixLimit__[\"a\" /* default */]();\n            var limitId;\n            if (node.hasChildNodes) {\n                var children = node.childNodes;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    var childName = child.localName || child.baseName || child.nodeName;\n                    if (childName === \"TileMatrix\") {\n                        limitId = __getChildValue(child);\n                    } else if (childName === \"MinTileRow\") {\n                        limit.minTileRow = __getChildValue(child);\n                    } else if (childName === \"MaxTileRow\") {\n                        limit.maxTileRow = __getChildValue(child);\n                    } else if (childName === \"MinTileCol\") {\n                        limit.minTileCol = __getChildValue(child);\n                    } else if (childName === \"MaxTileCol\") {\n                        limit.maxTileCol = __getChildValue(child);\n                    }\n                }\n                if (limitId && limits && !limits[limitId]) {\n                    limits[limitId] = limit;\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet\n        // ou : // info : /LayerList/Layer/Extension/gpp:Layer/wmts:TileMatrixSetLink/wmts:TileMatrixSet\n        /** TODO : jsdoc block */\n        TileMatrixSet : function (node, data) {\n            // info : Describes a particular set of tile matrices.\n\n            if (data && data.tileMatrixSets) { // les tileMatrixSets de General\n                // nouvel objet TileMatrixSet\n                var tmsData = {};\n                tmsData.TMS = new __WEBPACK_IMPORTED_MODULE_11__Response_model_TileMatrixSet__[\"a\" /* default */]();\n                tmsData.resolutions = [];\n\n                // lecture des informations du TMS\n                __getChildNodes(node, tmsData);\n\n                // récupération des identifiants des niveaux de matrice (pour faciliter l'accès au WMTS via les API carto)\n                var tileMatrices = tmsData.TMS.tileMatrices;\n                for (var tm in tileMatrices) {\n                    if (tileMatrices.hasOwnProperty(tm)) {\n                        tmsData.TMS.matrixIds.push(tm);\n                    }\n                }\n\n                if (tmsData.TMS.getProjection() === \"IGNF:WGS84G\" || tmsData.TMS.getProjection() === \"EPSG:4326\") {\n                    if (data.generalOptions && Array.isArray(data.generalOptions.wgs84Resolutions)) {\n                        var wgs84Resolutions = data.generalOptions.wgs84Resolutions;\n                        for (var i = 0; i < wgs84Resolutions.length; i++) {\n                            // info : les résolutions stockées dans wgs84Resolutions, issues de l'autoconf, sont des string\n                            tmsData.resolutions[i] = parseFloat(wgs84Resolutions[i]);\n                        }\n                    }\n                }\n\n                // tri des résolutions (par ordre décroissant cette fois)\n                if (Array.isArray(tmsData.resolutions) && tmsData.resolutions.sort !== undefined) {\n                    tmsData.resolutions.sort(\n                        function (x, y) {\n                            return y - x;\n                        }\n                    );\n                }\n                tmsData.TMS.nativeResolutions = tmsData.resolutions;\n\n                // ajout du TileMatrixSet à la variable config\n                data.tileMatrixSets[tmsData.identifier] = tmsData.TMS;\n            } else { // le TileMatrixSetLink d'une couche (layer)\n                if (data && !data.wmtsOptions) {\n                    data.wmtsOptions = {};\n                }\n                // ajout du lien vers le TMS\n                data.wmtsOptions.tileMatrixSetLink = __getChildValue(node);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix\n        /** TODO : jsdoc block */\n        TileMatrix : function (node, tmsData) {\n            // info : Describes a particular tile matrix.\n\n            if (tmsData) {\n                // nouveau niveau de matrice : TileMatrix\n                var tileMatrix = new __WEBPACK_IMPORTED_MODULE_12__Response_model_TileMatrix__[\"a\" /* default */]();\n\n                // lecture des information du TileMatrix\n                __getChildNodes(node, tileMatrix);\n\n                // calcul de la résolution associée au dénominateur d'échelle du niveau de pyramide, selon la projection.\n                if (tmsData.TMS && tmsData.TMS.getProjection()) {\n                    var proj = tmsData.TMS.getProjection();\n                    if (proj === \"EPSG:3857\" || proj === \"EPSG:2154\") {\n                        // calcul de la résolution associée, en m/px\n                        // en se basant sur une \"taille standard de pixel\" de 0.28mm*0.28mm (standard WMTS 1.0)\n                        var r = tileMatrix.scaleDenominator * 0.00028;\n                        if (tmsData.resolutions && Array.isArray(tmsData.resolutions)) {\n                            tmsData.resolutions.push(r);\n                        }\n                    }\n                }\n\n                // ajout du TileMatrix au TileMatrixSet\n                if (tmsData.TMS && tmsData.TMS.tileMatrices) {\n                    tmsData.TMS.tileMatrices[tileMatrix.matrixId] = tileMatrix;\n                }\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:ScaleDenominator\n        /** TODO : jsdoc block */\n        ScaleDenominator : function (node, tileMatrix) {\n            var scale = __getChildValue(node);\n            if (scale && tileMatrix && tileMatrix.hasOwnProperty(\"scaleDenominator\")) {\n                tileMatrix.scaleDenominator = parseFloat(scale);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TopLeftCorner\n        /** TODO : jsdoc block */\n        TopLeftCorner : function (node, tileMatrix) {\n            var values = __getChildValue(node).split(\" \");\n            if (values && tileMatrix) {\n                tileMatrix.topLeftCorner = {};\n                tileMatrix.topLeftCorner.x = parseFloat(values[0]);\n                tileMatrix.topLeftCorner.y = parseFloat(values[1]);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TileWidth\n        /** TODO : jsdoc block */\n        TileWidth : function (node, tileMatrix) {\n            var value = __getChildValue(node);\n            if (value && tileMatrix && tileMatrix.hasOwnProperty(\"tileWidth\")) {\n                tileMatrix.tileWidth = parseInt(value, 10);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:TileHeight\n        /** TODO : jsdoc block */\n        TileHeight : function (node, tileMatrix) {\n            var value = __getChildValue(node);\n            if (value && tileMatrix && tileMatrix.hasOwnProperty(\"tileHeight\")) {\n                tileMatrix.tileHeight = parseInt(value, 10);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:MatrixWidth\n        /** TODO : jsdoc block */\n        MatrixWidth : function (node, tileMatrix) {\n            var value = __getChildValue(node);\n            if (value && tileMatrix && tileMatrix.hasOwnProperty(\"matrixWidth\")) {\n                tileMatrix.matrixWidth = parseInt(value, 10);\n            }\n        },\n\n        // info : /General/Extension/gpp:General/gpp:TileMatrixSets/wmts:TileMatrixSet/wmts:TileMatrix/wmts:MatrixHeight\n        /** TODO : jsdoc block */\n        MatrixHeight : function (node, tileMatrix) {\n            var value = __getChildValue(node);\n            if (value && tileMatrix && tileMatrix.hasOwnProperty(\"matrixHeight\")) {\n                tileMatrix.matrixHeight = parseInt(value, 10);\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    serviceException : function (node) {\n        var response = {};\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"exception\") {\n                    response.exceptionReport = AutoConfResponseReader.READERS[\"exception\"](child);\n                }\n            }\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"code\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    }\n\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service d'autoconf,\n *      à l'aide des READERS de la classe.\n *\n * @method AutoConfResponseReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @return {Object} config|exceptionReport : l'objet contenant les informations de la réponse XML,\n *      sous la forme d'un objet AutoConfResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.\n * @static\n * @memberof AutoConfResponseReader\n */\nAutoConfResponseReader.read = function (root) {\n    if (root.nodeName === \"ViewContext\") {\n        var nsPrefix = root.prefix || AutoConfResponseReader.DEFAULTPREFIX;\n        var config = AutoConfResponseReader.READERS[nsPrefix][root.nodeName](root);\n        return config;\n    } else if (root.nodeName === \"serviceException\") {\n        var exceptionReport = AutoConfResponseReader.READERS[root.nodeName](root);\n        return exceptionReport;\n    } else {\n        throw new Error(\"Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.\");\n    }\n};\n\n/**\n * Récupération des attributs d'un noeud élément\n *\n * @private\n * @memberof AutoConfResponseReader\n * @method __getAttributes\n * @param {DOMElement} node - noeud contenant l'attribut recherché\n * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs\n */\nfunction __getAttributes (node) {\n    if (node.attributes.length > 0) {\n        var nodeAttributes = {};\n        var attributes = node.attributes;\n        for (var i = 0; i < attributes.length; i++) {\n            var attribute = attributes[i];\n            nodeAttributes[attribute.nodeName] = attribute.nodeValue;\n        }\n        return nodeAttributes;\n    }\n}\n\n/**\n * Récupération des noeuds enfants (seulement de type ELEMENT), à partir d'un noeud donné, pour lecture (readNode).\n *\n * @private\n * @memberof AutoConfResponseReader\n * @method __getChildNodes\n * @param {DOMElement} node - a DOM node\n * @param {Array|Object} [data] - an object to be filled with node data\n */\nfunction __getChildNodes (node, data) {\n    if (node.hasChildNodes()) {\n        var children = node.childNodes;\n        var child;\n        var childName;\n        var childPrefix;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                childName = child.localName || child.baseName || child.nodeName;\n                childPrefix = child.prefix || AutoConfResponseReader.DEFAULTPREFIX;\n\n                if (AutoConfResponseReader.READERS[childPrefix][childName]) {\n                    var reader = AutoConfResponseReader.READERS[childPrefix][childName];\n                    reader(child, data);\n                } else {\n                    __getChildNodes(child, data);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Lecture de la valeur du premier child d'un noeud, si elle existe.\n *\n * @private\n * @memberof AutoConfResponseReader\n * @method __getChildValue\n * @param {DOMElement} node - a DOM node\n * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.\n */\nfunction __getChildValue (node) {\n    var textNode;\n    var value = \"\";\n\n    if (node.hasChildNodes()) {\n        textNode = node.firstChild;\n        if (textNode.nodeType === 3 || textNode.nodeType === 4) { // 3 === node.TEXT_NODE\n            value = textNode.nodeValue;\n        }\n    }\n    return value;\n}\n\n/**\n * Vérification des attributs du service, dans la balise XLS de la réponse :\n *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.\n *\n * @private\n * @memberof AutoConfResponseReader\n * @method __checkServiceAttributes\n * @param {DOMElement} viewContextNode - a DOM node, corresponding to XLS first tag.\n */\nfunction __checkServiceAttributes (viewContextNode) {\n    if (viewContextNode.attributes.length > 0) {\n        // on récupère et parcourt les attributs de la balise XLS de la réponse\n        var xlsAttributes = __getAttributes(viewContextNode);\n        for (var att in xlsAttributes) {\n            if (xlsAttributes.hasOwnProperty(att)) {\n                // vérification de la version\n                if (att === \"version\") {\n                    if (xlsAttributes[\"version\"] !== AutoConfResponseReader.VERSION) {\n                        console.log(\"[AutoConfResponseReader] autoconf version is not the expected one : there may be errors in parsing\");\n                        return;\n                    }\n                }\n\n                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend\n                if (att === \"xmlns\") {\n                    if (xlsAttributes[att] !== AutoConfResponseReader.NAMESPACES.xmlns) {\n                        console.log(\"[AutoConfResponseReader] autoconf response default namespace is not the expected one\");\n                        return;\n                    }\n                    continue;\n                }\n\n                var prefix = att.split(\":\")[0];\n                var ns = att.split(\":\")[1];\n\n                // si on a un autre xmlns, on vérifie aussi les URI\n                if (prefix === \"xmlns\" && ns) {\n                    // si l'attribut correspond à un namespace défini dans le reader\n                    if (AutoConfResponseReader.NAMESPACES[ns]) {\n                        // il faut que les URI correspondent aussi.\n                        if (AutoConfResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {\n                            console.log(\"[AutoConfResponseReader] autoconf response \" + att + \" namespace is not the expected one\");\n                            return;\n                        }\n                    }\n                }\n\n                // pour finir on vérifie la localisation du schema XSD du service\n                if (ns === \"schemaLocation\") {\n                    if (xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[0] && xlsAttributes[att] !== AutoConfResponseReader.SCHEMALOCATION[1]) {\n                        console.log(\"[AutoConfResponseReader] autoconf response schema location is not the expected one\");\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoConfResponseReader);\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Request_DirectGeocodeRequestFactory__ = __webpack_require__(64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Response_DirectGeocodeResponseFactory__ = __webpack_require__(76);\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service de géocodage direct du Géoportail :\n *     envoi de la requête construite selon les paramètres en options,\n *     éventuellement parsing et analyse  de la réponse,\n *     retour d'une réponse en paramètre de la fonction onSuccess.\n *\n *\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.Geocode\n *\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {String|Object} options.location - Nom de l'adresse, du toponyme, de l'unité administrative ou de la parcelle cadastrale recherchée.\n *      Sous forme de String, la propriété permet de faire une recherche déstructurée.\n *      Sous forme d'objet, la propriété permet de structurer la recherche.\n *      Dans ce cas, les propriétés possibles de cet objet sont décrites ci-après.\n *      @param {Number} [options.location.number] - Numéro du bâtiment de l'adresse recherchée, dans le cas d'une recherche structurée\n *      (si options.location est un objet Javascript).\n *      @param {String} [options.location.street] - Nom de la rue de l'adresse recherchée, dans le cas d'une recherche structurée\n *      (si options.location est un objet Javascript).\n *      @param {String} [options.location.city] - Nom de la ville de l'adresse recherchée, dans le cas d'une recherche structurée\n *      (si options.location est un objet Javascript).\n *      @param {Number} [options.location.postalCode] - Numéro du code postal de l'adresse recherchée, dans le cas d'une recherche structurée\n *      (si options.location est un objet Javascript).\n *\n * @param {Object} [options.filterOptions] - Les propriétés possibles de cet objet sont décrites ci-après.\n * @param {Object} [options.filterOptions.bbox] - Emprise dans laquelle on souhaite effectuer la recherche.\n *      Les propriétés possibles de cet objet sont décrites ci-après.\n *      @param {Float} options.filterOptions.bbox.left - Abscisse du côté gauche de la BBOX\n *      @param {Float} options.filterOptions.bbox.right - Abscisse du côté droit de la BBOX\n *      @param {Float} options.filterOptions.bbox.top - Ordonnée supérieure de la BBOX\n *      @param {Float} options.filterOptions.bbox.bottom - Ordonnée inférieure de la BBOX\n *\n * @param {Array.<String>} [options.filterOptions.type = \"StreetAddress\"] - Type de l'objet recherché.\n *      Le service de géocodage du Géoportail permet de rechercher des 'PostionOfInterest' pour des toponymes, des 'StreetAddress'\n *      pour des adresses postales, et/ou des 'CadastralParcel' pour des parcelles cadastrales.\n *      D'autres types pourront être rajoutés selon l'évolution du service.\n *      Par défaut, type = ['StreetAddress'].\n *\n * @param {String} [options.filterOptions.[proprietes du filtre]] - Critère supplémentaire pour filtrer la recherche sous la forme\n *      d'un couple clé/valeur à définir selon les possibilités du serveur ajouté à la requête.\n *      Le service de géocodage du Géoportail permet de filtrer tous les résultats avec les propriétés :\n *          \"municipality\", \"insee\", et \"department\".\n *      Il permet aussi de filtrer les adresses postales avec les propriétés :\n *          \"quality\", \"ID\", \"ID_TR\" et \"territory\".\n *      Il permet de filtrer les toponymes avec les propriétés :\n *          \"importance\", \"nature\" et \"territory\".\n *      Enfin, il permet de filtrer les parcelles cadastrales avec les propriétés :\n *          \"sheet\", \"section\", et \"absorbedcity\". Pas de valeur par défaut.\n *\n * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.\n *      Pas de valeur par défaut.\n *      Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 25.\n *\n * @param {Boolean} [options.returnFreeForm] - Indique si l'on souhaite en réponse un localisant concaténée plutôt que structuré.\n *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'false'.\n *\n * @param {String} [options.srs] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.\n *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'EPSG:4326'.\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      positions : [{lon:, lat:}, {lon:, lat:}],\n *      (...)\n *   };\n * @private\n */\nfunction Geocode (options) {\n    if (!(this instanceof Geocode)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"Geocode\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"Geocode\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.Geocode\");\n    this.logger.trace(\"[Constructeur Geocode (options)]\");\n\n    if (!options.location) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"location\"));\n    }\n\n    // FIXME ECMAScript 5 support\n    if (typeof options.location === \"object\" && Object.keys(options.location).length === 0) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"location\"));\n    } else if (typeof options.location === \"string\" && options.location.length === 0) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"location\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.location = options.location;\n\n    // on definit des filtres apr defaut\n    if (!options.filterOptions || typeof options.filterOptions !== \"object\") {\n        this.options.filterOptions = options.filterOptions = {\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)\n    // ceci permet de tester le cas où 'options.filterOptions' : {}\n    if (Object.keys(options.filterOptions).length === 0) {\n        this.options.filterOptions = {\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    var filter = Object.keys(options.filterOptions);\n    for (var i = 0; i < filter.length; i++) {\n        var key = filter[i];\n        // on transforme certains filtres qui pourraient être numériques en string\n        var filtersCouldBeNumberList = [\"department\", \"number\", \"postalCode\", \"insee\", \"importance\", \"ID\", \"IDTR\", \"absorbedCity\", \"sheet\", \"section\", \"inseeRegion\", \"inseeDepartment\"];\n        if (filtersCouldBeNumberList.indexOf(key) !== -1 && typeof options.filterOptions[key] !== \"string\") {\n            options.filterOptions[key] = options.filterOptions[key].toString();\n        }\n        // on supprime les filtres vides\n        if (!options.filterOptions[key]) {\n            delete this.options.filterOptions[key];\n        }\n    }\n\n    this.options.filterOptions.type = options.filterOptions.type || [\"StreetAddress\"];\n    this.options.maximumResponses = options.maximumResponses || 25;\n    this.options.returnFreeForm = options.returnFreeForm || false;\n    this.options.srs = options.srs || \"EPSG:4326\";\n\n    // attributs d'instances\n\n    /**\n     * Format forcé de la réponse du service : \"xml\"\n     * sauf si l'on souhaite une reponse brute (options.rawResponse)\n     */\n    this.options.outputFormat = (this.options.rawResponse) ? \"\" : \"xml\";\n}\n\n/**\n * @lends module:Geocode#\n */\nGeocode.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nGeocode.prototype.constructor = Geocode;\n\n/**\n * Création de la requête (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nGeocode.prototype.buildRequest = function (error, success) {\n    var options = {\n        httpMethod : this.options.httpMethod,\n        // options specifiques du service\n        location : this.options.location,\n        returnFreeForm : this.options.returnFreeForm,\n        filterOptions : this.options.filterOptions,\n        srs : this.options.srs,\n        maximumResponses : this.options.maximumResponses\n    };\n\n    this.request = __WEBPACK_IMPORTED_MODULE_4__Request_DirectGeocodeRequestFactory__[\"a\" /* default */].build(options);\n\n    // on teste si la requete a bien été construite !\n    (!this.request)\n        ? error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\")))\n        : success.call(this, this.request);\n};\n\n/**\n * Analyse de la reponse (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nGeocode.prototype.analyzeResponse = function (error, success) {\n    /* INFO :\n         Etape 1 : Création de la requête\n            -> Appel du format OpenLS pour créer une requête à partir des paramètres (par exemple)\n              (soit directement une URL si GET, soit une requête XML si POST)\n            /!\\ tester si apiKey && serverUrl => on ne garde que serverUrl\n            -> stockage de la requête dans this.request\n         Etape 2 : Envoi de la requête selon le bon protocole\n            -> appel du protocol JSONP ou XHR, et envoi (par ex send ()) (this.protocol)\n            -> récupération de la réponse xml dans la fonction onSuccess () (this.response)\n            -> si code HTTP 200 et pas de message d'erreur : etape 3\n            -> si code HTTP != 200 : lancement de la fonction de callback onFailure avec le message d'erreur\n         Etape 3 : Analyse de la réponse xml et construction du JSON (si rawResponse === false )\n            -> appel du parser pour récupérer le xmlDocument\n            -> appel du reader OpenLS pour lire les éléments et récupérer l'objet JSON\n               correspondant au type de géocodage (défini dans les specs)\n         Etape 4 : Lancement de la fonction de callback onSuccess avec la réponse :\n            -> xmlResponse (si rawResponse === true)\n            -> ou geocodedLocations\n    */\n\n    if (this.response) {\n        var options = {\n            response : this.response,\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_5__Response_DirectGeocodeResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Geocode);\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_LocationUtilityService__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_XLS_LocationUtilityService_GeocodeFilterExtension__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Request_model_StreetAddress__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Request_model_PositionOfInterest__ = __webpack_require__(73);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Request_model_CadastralParcel__ = __webpack_require__(74);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Request_model_Administratif__ = __webpack_require__(75);\n/**\n * Creation d'une requête OpenLS en mode POST ou GET\n * (Factory)\n *\n * @module DirectGeocodeRequestFactory\n * @alias Gp.Services.Geocode.Request.DirectGeocodeRequestFactory\n * @private\n */\n\n\n\n\n\n\n\n\n\nvar DirectGeocodeRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Geocode\n     *\n     * @example\n     *   var options = {\n     *      httpMethod:\n     *      // options specifiques du service\n     *      location:\n     *      returnFreeForm:\n     *      filterOptions:\n     *      srs:\n     *      maximumResponses:\n     *   };\n     *   var result = DirectGeocodeRequestFactory.build(options);\n     *   if (!result) {\n     *       // error...\n     *   }\n     * @returns {String} request\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"DirectGeocodeRequestFactory\");\n        logger.trace([\"DirectGeocodeRequestFactory::build()\"]);\n\n        var request = null;\n\n        // gestion des filtres (table de geocodage) !\n        // par defaut, on les ajoute toute ...\n        var oFilter = new __WEBPACK_IMPORTED_MODULE_3__Formats_XLS_LocationUtilityService_GeocodeFilterExtension__[\"a\" /* default */]();\n        oFilter.addFilterExtensions(new __WEBPACK_IMPORTED_MODULE_7__Request_model_Administratif__[\"a\" /* default */]());\n        oFilter.addFilterExtensions(new __WEBPACK_IMPORTED_MODULE_4__Request_model_StreetAddress__[\"a\" /* default */]());\n        oFilter.addFilterExtensions(new __WEBPACK_IMPORTED_MODULE_5__Request_model_PositionOfInterest__[\"a\" /* default */]());\n        oFilter.addFilterExtensions(new __WEBPACK_IMPORTED_MODULE_6__Request_model_CadastralParcel__[\"a\" /* default */]());\n\n        // objet LUS\n        // on peut aussi par un objet XLS::GeocodeRequest\n        var oLUS = new __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_LocationUtilityService__[\"a\" /* default */]({\n            location : options.location,\n            returnFreeForm : options.returnFreeForm,\n            filterOptions : options.filterOptions\n        });\n        oLUS.addFilter(oFilter);\n\n        // Format XLS\n        var oXLS = new __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__[\"a\" /* default */]({\n            srsName : options.srs,\n            maximumResponses : options.maximumResponses\n        });\n        oXLS.namespace = true;\n        oXLS.setService(oLUS);\n\n        // request brute !\n        request = oXLS.build();\n\n        // en mode GET, la requête est encodée\n        // et le param. 'qxml' est ajouté\n        if (options.httpMethod === \"GET\") {\n            var myRequest = \"qxml=\" +\n                encodeURIComponent(request)\n                    .replace(/-/g, \"%2D\")\n                    .replace(/_/g, \"%5F\")\n                    .replace(/\\./g, \"%2E\")\n                    .replace(/!/g, \"%21\")\n                    .replace(/~/g, \"%7E\")\n                    .replace(/\\*/g, \"%2A\")\n                    .replace(/'/g, \"%27\")\n                    .replace(/\\(/g, \"%28\")\n                    .replace(/\\)/g, \"%29\");\n            request = myRequest;\n        }\n\n        logger.trace(request);\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DirectGeocodeRequestFactory);\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n *\n * Entête de la requête XSL\n *\n * @example\n * // header XSL\n * header = new RequestHeader ();\n * header.srsName = \"epsg:4326\";\n * header.toString();\n * // out ->\n * // <RequestHeader srsName=\"epsg:4326\"/>\n *\n * @constructor\n * @alias Gp.Formats.XLS.RequestHeader\n * @param {Object} options - options\n * @param {Object}   options.srsName - projection\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction RequestHeader (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur RequestHeader ()]\");\n\n    if (!(this instanceof RequestHeader)) {\n        throw new TypeError(\"RequestHeader constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {\n        srsName : \"EPSG:4326\"\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\nRequestHeader.prototype = {\n\n    /**\n     * @lends module:RequestHeader#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __SRSNAME__\n     */\n    template : \"<RequestHeader srsName=\\\"__SRSNAME__\\\"/>\",\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : RequestHeader,\n\n    /**\n     * toString\n     */\n    toString : function () {\n        var template = null;\n        template = this.template;\n        template = template.replace(/__SRSNAME__/g, this.options.srsName);\n        this.requestString = template;\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RequestHeader);\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* jshint bitwise: false */\n\n\n/**\n * @classdesc\n *\n * Requête XLS\n *\n * @example\n * // request XSL\n * request = new Request ();\n * request.maximumResponses = 26;\n * request.methodName = \"GeocodeRequest\";\n * request.version = \"1.2\";\n * request.toString();\n * // out ->\n * // <Request maximumResponses=\"26\" methodName=\"GeocodeRequest\" requestID=\"uid1349081498314_388\" version=\"1.2\">\n * //   <!-- __LUS__ -->\n * //  </Request>\n *\n * @constructor\n * @alias Gp.Formats.XLS.Request\n * @param {Object} options - options\n * @param {Object}   options.maximumResponses - 25\n * @param {String}   options.methodName - nom de l'objet LUS, \"GeocodeRequest\" | \"ReverseGeocodeRequest\"\n * @param {String}   options.version - '1.2'\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction Request (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur Request ()]\");\n\n    if (!(this instanceof Request)) {\n        throw new TypeError(\"Request constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {\n        maximumResponses : 25,\n        methodName : null,\n        version : \"1.2\"\n    };\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\nRequest.prototype = {\n\n    /**\n     * @lends module:Request#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __MAXRESPONSES__, __METHODNAME__, __UUID__, __VERSION__\n     * __REQUESTSERVICE__\n     */\n    template : \"<Request maximumResponses=\\\"__MAXRESPONSES__\\\" methodName=\\\"__METHODNAME__\\\" requestID=\\\"__UUID__\\\" version=\\\"__VERSION__\\\">\" +\n        \"<!-- __REQUESTSERVICE__ -->\" +\n        \"</Request>\",\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : Request,\n\n    /**\n     * an rfc4122 version 4 compliant guid\n     */\n    guid : function () {\n        // INFO\n        // cf. http://byronsalau.com/blog/how-to-create-a-guid-uuid-in-javascript/\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0;\n            var v = c === \"x\" ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    },\n\n    /**\n     * toString\n     */\n    toString : function () {\n        var template = null;\n        template = this.template;\n        template = template.replace(/__MAXRESPONSES__/g, this.options.maximumResponses);\n        template = template.replace(/__METHODNAME__/g, this.options.methodName);\n        template = template.replace(/__UUID__/g, this.guid());\n        template = template.replace(/__VERSION__/g, this.options.version);\n\n        this.requestString = template;\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Request);\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_Address__ = __webpack_require__(68);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__GeocodeFilterExtension__ = __webpack_require__(13);\n\n\n\n\n/**\n * @classdesc\n * Requête de geocodage direct\n *\n * ```\n * XSD\n * Geocodage direct (balise xsd) :\n *   element ref=\"RequestHeader\" [ (attribute name=\"clientName\" attribute name=\"clientPassword\" attribute name=\"sessionID\" attribute name=\"srsName\" attribute name=\"MSID\") ]\n *     element name=\"Request\" attribute name=\"methodName\" attribute name=\"version\" attribute name=\"requestID\" [ attribute name=\"maximumResponses\" ]\n *       element name=\"GeocodeRequest\" attribute name=\"returnFreeForm\"\n *         element ref=\"xls:Address\"\n * ```\n *\n * @example\n * // creation de l'objet Geocode an ajoutant un objet Address\n * req = new GeocodeRequest ();\n * req.returnFreeForm = true; // TODO !\n * req.addAddress (new Address ({\n *      location : \"saint mandé\",\n *      type : ['PositionOfInterest'],\n *      filter : {\n *          (...)\n *      }\n * }));\n * req.toString();\n * // out ->\n * // <GeocodeRequest>\n * //   <Address countryCode=\"PositionOfInterest\">\n * //     <freeFormAddress>saint mandé</freeFormAddress>\n * //   </Address>\n * // </GeocodeRequest>\n *\n * // creation de l'objet Geocode avec les options uniquement\n * req = new GeocodeRequest ({\n *      location : \"saint mandé\",\n *      returnFreeForm : true,\n *      filterOptions : {\n *          type : ['PositionOfInterest'],\n *          (...)\n *      }\n * });\n * req.toString();\n * // out ->\n * // <GeocodeRequest>\n * //   <Address countryCode=\"PositionOfInterest\">\n * //     <freeFormAddress>saint mandé</freeFormAddress>\n * //   </Address>\n * // </GeocodeRequest>\n * @constructor\n *\n * @alias Gp.Formats.XLS.LocationUtilityService.GeocodeRequest\n * @param {Object} options - options\n * @param {Object}   options.location - location\n * @param {String}   options.returnFreeForm - returnFreeForm\n * @param {String}   options.filterOptions - filtres\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction GeocodeRequest (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur GeocodeRequest ()]\");\n\n    if (!(this instanceof GeocodeRequest)) {\n        throw new TypeError(\"GeocodeRequest constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {};\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    // TODO\n    // gestion de l'option 'returnFreeForm' si elle n'est pas renseignée dans les options !\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"GeocodeRequest\";\n}\n\nGeocodeRequest.prototype = {\n\n    /**\n     * @lends module:GeocodeRequest#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    strRequest : null,\n\n    /**\n     * Addresse\n     * @type {Address}\n     */\n    oAddress : null,\n\n    /**\n     * Filter\n     * @type {GeocodeFilterExtension}\n     */\n    oFilter : null,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __ADDRESS__, __RETURNFREEFORM__\n     */\n    template : \"<GeocodeRequest returnFreeForm=\\\"__RETURNFREEFORM__\\\">\" +\n        \"__ADDRESS__\" +\n        \"</GeocodeRequest>\",\n\n    /**\n     * Ajout d'un objet de type Adresse\n     *\n     * @param {Object} oAddress - Adresse\n     */\n    addAddress : function (oAddress) {\n        if (oAddress instanceof __WEBPACK_IMPORTED_MODULE_1__model_Address__[\"a\" /* default */]) {\n            this.oAddress = oAddress;\n        }\n    },\n\n    /**\n     * Ajout d'un objet de type GeocodeFilterExtension\n     *\n     * @param {Object} oFilter - GeocodeFilterExtension\n     */\n    addFilter : function (oFilter) {\n        // FIXME gestion des filtres à partir des tables de geocodages\n        if (oFilter instanceof __WEBPACK_IMPORTED_MODULE_2__GeocodeFilterExtension__[\"a\" /* default */]) {\n            this.oFilter = oFilter;\n        }\n    },\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : GeocodeRequest,\n\n    /**\n     * toString\n     *\n     * @returns {String}\n     */\n    toString : function () {\n        var template = \"\";\n        template = this.template;\n\n        // soit on a déjà un objet Address instancié,\n        // sinon, on le fabrique via les options\n        if (!this.oAddress) {\n            var settings = {};\n            settings.location = this.options.location;\n            settings.type = this.options.filterOptions.type || [\"StreetAddress\"];\n            settings.filter = this.options.filterOptions;\n            delete settings.filter.type; // on ne met pas le 'type' dans les filtres...\n\n            // gestion des filtres\n            if (this.oFilter) {\n                // on reconstruit les filtres\n                settings.filter = {};\n\n                // on determine la liste des filtres possibles\n                // pour chaque table de geocodage en param\n                for (var idx in settings.type) {\n                    var filter = settings.type[idx];\n                    var oFilter = this.oFilter.getFilter(filter);\n\n                    if (!oFilter) {\n                        this.logger.warn(\"Le filtre '\" + filter + \"' n'existe pas !?\");\n                        continue;\n                    }\n\n                    var mFilter = this.options.filterOptions;\n\n                    // correspondances des attributs de filtres possibles avec ceux qui sont en options\n                    var attributs = oFilter.attributesList;\n                    for (var idxe = 0; idxe < attributs.length; idxe++) {\n                        var key = attributs[idxe];\n                        if (mFilter[key]) {\n                            var matchingKey = oFilter.serviceAttributes[idxe];\n                            oFilter.placeAttributes[matchingKey] = mFilter[key];\n                            this.logger.trace(\"Selection du filtre '\" + key + \"' sur le type '\" + filter + \"'.\");\n                        }\n                    }\n\n                    // ajout des valeurs des filtres\n                    var places = oFilter.placeAttributes;\n                    for (var kplace in places) {\n                        if (places.hasOwnProperty(kplace)) {\n                            settings.filter[kplace] = places[kplace];\n                        }\n                    }\n                }\n            }\n\n            this.oAddress = new __WEBPACK_IMPORTED_MODULE_1__model_Address__[\"a\" /* default */](settings);\n            if (!this.oAddress) {\n                throw new Error(\"La construction de l'adresse n'est pas correctement definie !?\");\n            }\n        }\n\n        // FIXME gestion des filtres pour un objet Address déjà instancié ?\n\n        template = template.replace(/__ADDRESS__/g, this.oAddress.toString());\n        template = template.replace(/__RETURNFREEFORM__/g, (this.options.returnFreeForm) ? \"true\" : \"false\");\n\n        this.strRequest = template;\n        return this.strRequest;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GeocodeRequest);\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n\n/**\n * @classdesc\n *\n * Location type \"Address\".\n *\n * Modèles de classes :\n * ------------------\n * ```\n *\n *                Address\n *            (est composé de)\n *           ______ | _________ _________________\n *          /       |          \\                 \\\n *      Place (StreetAddress ou FreeFormAddress) PostalCode\n *       (*)       _|_\n *                /   \\\n *           Street   Building\n * ```\n * ```\n * XSD\n * Address (balise xsd) :\n *   ex. <Address countryCode=\"StreetAddress\"><freeFormAddress>1 r de paris saint denis</freeFormAddress></Address>\n *   attribute name=\"countryCode\"\n *     element name=\"freeFormAddress\"\n *     element ref=\"xls:Place\"\n *     element ref=\"gml:Envelope\"\n *  ou\n *   ex. <Address countryCode=\"StreetAddress\"><StreetAddress><Street>1 rue Marconi</Street></StreetAddress><Place type=\"Municipality\">Metz</Place><PostalCode>57000</PostalCode></Address>\n *   attribute name=\"countryCode\"\n *     element ref=\"xls:StreetAddress\"\n *     element ref=\"xls:PostalCode\"\n *     element ref=\"xls:Place\"\n *     element ref=\"gml:Envelope\"\n * ```\n *\n * @example\n * // simple\n * adr = new Address ({\n *    location : \"2 av pasteur, Saint-Mandée\",\n *    type : [\"StreetAddress\"],\n *    filter : {}\n * });\n * adr.toString();\n * // -> out\n * // <Address countryCode=\"StreetAddress\">\n * //   <freeFormAddress>2 av pasteur, Saint-Mandée</freeFormAddress>\n * // </Address>\n *\n * // avec filtre\n * adr = new Address ({\n *    location : {\n *      number : 2,\n *      street : \"av pasteur\",\n *      city : \"Saint-Mandée\", // FIXME filter Place \"commune\" ou \"municipality\" ?\n *      postalCode : \"94166\"   // FIXME filter Place ou balise PostalCode ?\n *    },\n *    type : [\"StreetAddress\"],\n *    filter : {\n *      territory : \"FR\",\n *      department : \"94\"\n *    }\n * });\n * adr.toString();\n * // -> out\n * // <Address countryCode=\"StreetAddress\">\n * //   <StreetAddress>\n * //   <Building number=\"2\"/>\n * //   <Street>2 av pasteur</Street>\n * // </StreetAddress>\n * // <Place type=\"municipality\">Saint-Mandée</Place>\n * // <Place type=\"departement\">94</Place>\n * // <Place type=\"territoire\">FR</Place>\n * // <PostalCode>94166</PostalCode>\n * // </Address>\n *\n * // avec bbox\n * adr = new Address ({\n *    location : \"2 av pasteur, Saint-Mandée\",\n *    type : [\"StreetAddress\"],\n *    filter : {\n *      bbox : {left:1, right:2, top:2, bottom:0}\n *    }\n * });\n * adr.toString();\n * // -> out\n * // <Address countryCode=\"StreetAddress\">\n * //   <freeFormAddress>2 av pasteur, Saint-Mandée</freeFormAddress>\n * //   <gml:Envelope>\n * //     <gml:lowerCorner>1 0</gml:lowerCorner>\n * //     <gml:upperCorner>2 2</gml:upperCorner>\n * //   </gl:Envelope>\n * // </Address>\n *\n * @constructor\n * @alias Gp.Formats.XLS.LocationUtilityService.Address\n * @param {Object} options - options\n * @param {Object} options.location - location\n * @param {String} options.type - type\n * @param {String} options.filter - filtres\n * @param {String} options.filter.* - Filtré en fonction des tables de geocodage interrogées\n *\n * @private\n */\nfunction Address (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Address\");\n    this.logger.trace(\"[Constructeur Address ()]\");\n\n    if (!(this instanceof Address)) {\n        throw new TypeError(\"Address constructor cannot be called as a function.\");\n    }\n\n    // param par defaut\n    this.options = options || {\n        location : {},\n        type : [\"StreetAddress\"],\n        filter : {}\n    };\n\n    // param obligatoire\n    if (!options.location) {\n        throw new Error(\"l'option 'location' n'est pas renseignée !\");\n    }\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\n/**\n * @lends module:Address#\n */\nAddress.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : Address,\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     *\n     * substitution des valeurs suivantes :\n     * - address :  __COUNTRYCODE__, __LOCATION__, __PLACE__, __POSTALCODE__, __ENVELOPE__\n     * - freeFormAddress : __FREEFORMADDRESSVALUE__\n     * - streetAddress : __STREET__, __BUILDING__\n     * - street : __STREETVALUE__\n     * - building : __BUILDINGVALUE__\n     * - place : __PLACEATYPE__, __PLACEVALUE__\n     * - postalCode : __POSTALCODEVALUE__\n     * - gml:envelope : __LEFT__ __BOTTOM__ __RIGHT__ __TOP__\n     *\n     * @todo gestion de l\"indentation\n     */\n    template : {\n        address : \"<Address countryCode=\\\"__COUNTRYCODE__\\\">\" +\n            \"__LOCATION__\" +\n            \"__PLACE__\" +\n            \"__POSTALCODE__\" +\n            \"__ENVELOPE__\" +\n            \"</Address>\",\n        location : {\n            freeFormAddress : \"<freeFormAddress>__FREEFORMADDRESSVALUE__</freeFormAddress>\",\n            streetAddress : {\n                container : \"<StreetAddress>\" +\n                    \"__STREET__\" +\n                    \"__BUILDING__\" +\n                    \"</StreetAddress>\",\n                building : \"<Building number=\\\"__BUILDINGVALUE__\\\"/>\",\n                street : \"<Street>__STREETVALUE__</Street>\"\n            }\n        },\n        place : \"<Place type=\\\"__PLACETYPE__\\\">__PLACEVALUE__</Place>\",\n        postalCode : \"<PostalCode>__POSTALCODEVALUE__</PostalCode>\",\n        envelope : \"<gml:Envelope>\" +\n            \"<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>\" +\n            \"<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>\" +\n            \"</gml:Envelope>\"\n    }\n\n};\n\n/**\n * toString\n *\n * @returns {String}\n */\nAddress.prototype.toString = function () {\n    var template = null;\n    template = this.template.address;\n    template = template.replace(/__COUNTRYCODE__/g, this.options.type);\n\n    // on a une adresse structurée ou libre ?\n    if (typeof this.options.location === \"string\") {\n        // balise freeFormeAddress\n        var tmplFreeFormAddress = this.template.location.freeFormAddress;\n        tmplFreeFormAddress = tmplFreeFormAddress.replace(/__FREEFORMADDRESSVALUE__/g, this.options.location);\n        template = template.replace(/__LOCATION__/g, tmplFreeFormAddress);\n    } else {\n        // balises Street et Building\n        var tmplBuilding = \"\";\n        var tmplStreet = \"\";\n\n        if (this.options.location.number) {\n            tmplBuilding = this.template.location.streetAddress.building;\n            tmplBuilding = tmplBuilding.replace(/__BUILDINGVALUE__/g, this.options.location.number);\n        }\n\n        if (this.options.location.street) {\n            tmplStreet = this.template.location.streetAddress.street;\n            tmplStreet = tmplStreet.replace(/__STREETVALUE__/g, this.options.location.street);\n        }\n\n        // balise streetAddress\n        var tmplStreetAddress = this.template.location.streetAddress.container;\n        tmplStreetAddress = tmplStreetAddress.replace(/__STREET__/g, tmplStreet);\n        tmplStreetAddress = tmplStreetAddress.replace(/__BUILDING__/g, tmplBuilding);\n        template = template.replace(/__LOCATION__/g, tmplStreetAddress);\n    }\n\n    // a t on un filtre de type PostalCode ?\n    var tmplPostalCode = \"\";\n    if (this.options.location.postalCode) {\n        tmplPostalCode = this.template.postalCode;\n        tmplPostalCode = tmplPostalCode.replace(/__POSTALCODEVALUE__/g, this.options.location.postalCode);\n    }\n\n    // a t on un filtre de type GML::Envelope ?\n    var tmplEnvelope = \"\";\n    if (this.options.filter) {\n        var bbox = this.options.filter.bbox;\n        if (bbox) {\n            tmplEnvelope = this.template.envelope;\n            tmplEnvelope = tmplEnvelope.replace(/__LEFT__/g, bbox.left);\n            tmplEnvelope = tmplEnvelope.replace(/__BOTTOM__/g, bbox.bottom);\n            tmplEnvelope = tmplEnvelope.replace(/__RIGHT__/g, bbox.right);\n            tmplEnvelope = tmplEnvelope.replace(/__TOP__/g, bbox.top);\n        }\n    }\n\n    // liste des filtres Place\n    var Places = [];\n\n    // a t on des filtres de type Place ?\n    var tmplPlace = \"\";\n    if (this.options.filter) {\n        var filters = this.options.filter;\n        for (var filter in filters) {\n            if (filter === \"bbox\") {\n                continue;\n            }\n            // FIXME gestion des filtres spécifiques IGN ?\n            tmplPlace = this.template.place;\n            tmplPlace = tmplPlace.replace(/__PLACETYPE__/g, filter);\n            tmplPlace = tmplPlace.replace(/__PLACEVALUE__/g, filters[filter]);\n            Places.push(tmplPlace);\n        }\n    }\n\n    // a t on un filtre de type Place dans location ?\n    var tmplPlaceCity = \"\";\n    if (this.options.location.city) {\n        tmplPlaceCity = this.template.place;\n        tmplPlaceCity = tmplPlaceCity.replace(/__PLACETYPE__/g, \"Municipality\");\n        tmplPlaceCity = tmplPlaceCity.replace(/__PLACEVALUE__/g, this.options.location.city);\n        Places.push(tmplPlaceCity);\n    }\n\n    template = template.replace(/__POSTALCODE__/g, tmplPostalCode);\n    template = template.replace(/__PLACE__/g, Places.join(\"\\n\"));\n    template = template.replace(/__ENVELOPE__/g, tmplEnvelope);\n\n    this.requestString = template;\n    return this.requestString;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Address);\n\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_Position__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_Preference__ = __webpack_require__(71);\n\n\n\n\n\n/**\n * @classdesc\n *\n * Requête de geocodage inverse\n *\n * XSD\n * ```\n * Geocodage inverse (balise xsd) :\n *   element ref=\"RequestHeader\" [ (attribute name=\"clientName\" attribute name=\"clientPassword\" attribute name=\"sessionID\" attribute name=\"srsName\" attribute name=\"MSID\") ]\n *     element name=\"Request\" attribute name=\"methodName\" attribute name=\"version\" attribute name=\"requestID\" [ attribute name=\"maximumResponses\" ]\n *       element name=\"ReverseGeocodeRequest\"\n *         element ref=\"xls:Position\"\n *         element name=\"ReverseGeocodePreference\" (enumeration)\n * ```\n *\n * @example\n * // creation de l\"objet ReverseGeocode\n * req = new ReverseGeocodeRequest ();\n * req.addPosition (new Position (position:{x: , y: }));\n * req.addPreference ([\"StreetAddress\"]);\n * req.toString();\n * // out ->\n * // <ReverseGeocodeRequest>\n * //     <Position>\n * //       <gml:Point xmlns:gml=\"http://www.opengis.net/gml\">\n * //           <gml:pos>50.347775 3.205098</gml:pos>\n * //       </gml:Point>\n * //     </Position>\n * //     <ReverseGeocodePreference>StreetAddress</ReverseGeocodePreference>\n * //  </ReverseGeocodeRequest>\n * @constructor\n * @alias Gp.Formats.XLS.ReverseGeocodeRequest\n * @param {Object} options - options\n * @param {Object}   options.position - position\n * @param {String}   options.returnFreeForm - returnFreeForm\n * @param {String}   options.filterOptions - filtres\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction ReverseGeocodeRequest (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur ReverseGeocodeRequest ()]\");\n\n    if (!(this instanceof ReverseGeocodeRequest)) {\n        throw new TypeError(\"ReverseGeocodeRequest constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {};\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"ReverseGeocodeRequest\";\n}\n\nReverseGeocodeRequest.prototype = {\n\n    /**\n     * @lends module:ReverseGeocodeRequest#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    strRequest : null,\n\n    /**\n     * Position\n     * @type {Position}\n     */\n    oPosition : null,\n\n    /**\n     * Preference\n     * @type {Preference}\n     */\n    oPreference : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : ReverseGeocodeRequest,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __POSITION__, __PREFERENCE__, __RETURNFREEFORM__\n     */\n    template : \"<ReverseGeocodeRequest returnFreeForm=\\\"__RETURNFREEFORM__\\\">\" +\n        \"__POSITION__\" +\n        \"__PREFERENCE__\" +\n        \"</ReverseGeocodeRequest>\",\n\n    /**\n     * Ajout d\"un objet de type Position\n     *\n     * @param {Object} oPosition - Position\n     */\n    addPosition : function (oPosition) {\n        if (oPosition instanceof __WEBPACK_IMPORTED_MODULE_1__model_Position__[\"a\" /* default */]) {\n            this.oPosition = oPosition;\n        }\n    },\n\n    /**\n     * Ajout d\"une liste de table de référence LUS :\n     * [StreetAddress, PointOfInterest, CadastralParcel, Administrativ]\n     *\n     * @param {Object} oPreference - Preference\n     */\n    addPreferences : function (oPreference) {\n        if (oPreference instanceof __WEBPACK_IMPORTED_MODULE_2__model_Preference__[\"a\" /* default */]) {\n            this.oPreference = oPreference;\n        }\n    },\n\n    /**\n     * toString\n     */\n    toString : function () {\n        var template = \"\";\n        template = this.template;\n\n        // si on a déjà un objet Preference instancié,\n        // sinon, on le fabrique via les options\n        if (!this.oPreference) {\n            this.oPreference = new __WEBPACK_IMPORTED_MODULE_2__model_Preference__[\"a\" /* default */](this.options.filterOptions.type || [\"StreetAddress\"]);\n            if (!this.oPreference) {\n                throw new Error(\"Les preferences ne sont pas definies !?\");\n            }\n        }\n        template = template.replace(/__PREFERENCE__/g, this.oPreference.toString());\n\n        // si on a déjà un objet Position instancié,\n        // sinon, on le fabrique via les options\n        if (!this.oPosition) {\n            var settings = {\n                position : this.options.position,\n                filter : {}\n            };\n\n            // FIXME gestion des filtres ?\n            if (this.options.filterOptions) {\n                settings.filter = this.options.filterOptions;\n                delete settings.filter.type; // pas besoin ?\n            }\n            this.oPosition = new __WEBPACK_IMPORTED_MODULE_1__model_Position__[\"a\" /* default */](settings);\n            if (!this.oPosition) {\n                throw new Error(\"La position et ses filtres ne sont pas definis !?\");\n            }\n        }\n        template = template.replace(/__POSITION__/g, this.oPosition.toString());\n        template = template.replace(/__RETURNFREEFORM__/g, (this.options.returnFreeForm) ? \"true\" : \"false\");\n\n        this.strRequest = template;\n        return this.strRequest;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocodeRequest);\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n * Location de type Position\n *\n * ```\n * XSD\n * Position (balise xsd) :\n *   ex. <Position><gml:Point xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>50.347775 3.205098</gml:pos></gml:Point></Position>\n *   ex. <Position><gml:CircleByCenterPoint xmlns:gml=\"http://www.opengis.net/gml\"><gml:pos>48.85978570614691 2.2913572761128878</gml:pos><gml:radius>1000</gml:radius></gml:CircleByCenterPoint></Position>\n *   (au choix)\n *   element ref=\"gml:Point\"\n *   element ref=\"gml:CircleByCenterPoint\"\n *   element ref=\"gml:Polygon\"\n *   element ref=\"gml:MultiPolygon\"\n * ```\n *\n * FIXME les autres elements ne sont pas implémentés (QoP, Speed, Direction, Time, ...) ?\n *\n * ```\n * template : \"<Position>\n *                  __GMLPOINT__\n *                  __GMLFILTER__\n *             </Position>\"\n * ```\n * ```\n * GML : {\n *  pos     : \"<gml:pos>__X__ __Y__</gml:pos>\",\n *  point   : \"<gml:Point xmlns:gml=\\\"http://www.opengis.net/gml\\\">__POS__</gml:Point>\",\n *  circle  : \"<gml:CircleByCenterPoint xmlns:gml=\\\"http://www.opengis.net/gml\\\">__POS__<gml:radius>__RADIUS__</gml:radius></gml:CircleByCenterPoint>\",\n *  // not yet implemented !\n *  polygon      : \"\",\n *  multipolygon : \"\"\n * }\n * ```\n *\n * @constructor\n * @alias Gp.Formats.XLS.LocationUtilityService.Position\n * @param {Object} options - options données en entrée\n * @param {Object} options.position - x/y\n * @param {Object} options.filter - filtre\n * @param {Object} options.filter.circle - un cercle\n * @param {Object} options.filter.polygon - un polygone\n *\n * @private\n */\nfunction Position (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Position\");\n    this.logger.trace(\"[Constructeur Position ()]\");\n\n    if (!(this instanceof Position)) {\n        throw new TypeError(\"Position constructor cannot be called as a function.\");\n    }\n\n    // param par defaut\n    this.options = options || {};\n\n    // param obligatoire\n    if (!options.position) {\n        throw new Error(\"l'option 'position' n'est pas renseignée !\");\n    }\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\n/**\n * @lends module:Position#\n */\nPosition.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : Position,\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     *\n     * substitution des valeurs suivantes :\n     * __GMLPOINT__ __GMLFILTER__\n     * __X__ __Y__ __RADIUS__\n     * __XY__\n     * @todo indentation XML\n     * @todo implementation classe GML\n     */\n    template : {\n        position : \"<Position>\" +\n            \"__GMLPOINT__\" +\n            \"__GMLFILTER__\" +\n            \"</Position>\",\n        gml : {\n            point : \"<gml:Point xmlns:gml=\\\"http://www.opengis.net/gml\\\"><gml:pos>__X__ __Y__</gml:pos></gml:Point>\",\n            pos : null,\n            filter : {\n                bbox : \"<gml:Envelope xmlns:gml=\\\"http://www.opengis.net/gml\\\">\" +\n                    \"<gml:lowerCorner>__LEFT__ __BOTTOM__</gml:lowerCorner>\" +\n                    \"<gml:upperCorner>__RIGHT__ __TOP__</gml:upperCorner>\" +\n                    \"</gml:Envelope>\",\n                circle : \"<gml:CircleByCenterPoint xmlns:gml=\\\"http://www.opengis.net/gml\\\"><gml:pos>__X__ __Y__</gml:pos><gml:radius>__RADIUS__</gml:radius></gml:CircleByCenterPoint>\",\n                polygon : \"<gml:Polygon xmlns:gml=\\\"http://www.opengis.net/gml\\\"><gml:exterior><gml:LinearRing><gml:posList>__XY__</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>\",\n                multipolygon : null\n            }\n        }\n    }\n};\n\n/**\n * toString\n *\n * @returns {String}\n */\nPosition.prototype.toString = function () {\n    var template = this.template.position;\n\n    var tmplGmlPoint = this.template.gml.point;\n    tmplGmlPoint = tmplGmlPoint.replace(/__X__/g, this.options.position.x);\n    tmplGmlPoint = tmplGmlPoint.replace(/__Y__/g, this.options.position.y);\n\n    var tmplGmlFilter = \"\";\n    if (this.options.filter) {\n        var filter = this.options.filter;\n\n        for (var name in filter) {\n            switch (name) {\n                case \"circle\":\n                    tmplGmlFilter = this.template.gml.filter[name];\n                    tmplGmlFilter = tmplGmlFilter.replace(/__X__/g, filter[name].x);\n                    tmplGmlFilter = tmplGmlFilter.replace(/__Y__/g, filter[name].y);\n                    tmplGmlFilter = tmplGmlFilter.replace(/__RADIUS__/g, filter[name].radius);\n                    break;\n                case \"bbox\":\n                    tmplGmlFilter = this.template.gml.filter[name];\n                    tmplGmlFilter = tmplGmlFilter.replace(/__LEFT__/g, filter[name].left);\n                    tmplGmlFilter = tmplGmlFilter.replace(/__BOTTOM__/g, filter[name].bottom);\n                    tmplGmlFilter = tmplGmlFilter.replace(/__RIGHT__/g, filter[name].right);\n                    tmplGmlFilter = tmplGmlFilter.replace(/__TOP__/g, filter[name].top);\n                    break;\n                case \"polygon\":\n                    // FIXME implementation simple du polygone !\n                    // aucun test de fermeture du polygone, ni de gestion des trous !\n                    tmplGmlFilter = this.template.gml.filter[name];\n                    var strPoints = \"\";\n                    var lstPoints = filter[name];\n                    for (var i = 0; i < lstPoints.length; i++) {\n                        var coord = lstPoints[i];\n                        if (Array.isArray(coord)) {\n                            this.logger.error(\"Holes are not implemented !\");\n                            break;\n                        }\n                        if ((coord.x && coord.y) || (coord.x === 0 || coord.y === 0)) {\n                            strPoints += coord.x + \" \" + coord.y;\n                        }\n                        if (lstPoints.length !== i + 1) {\n                            strPoints += \" \";\n                        }\n                    }\n                    tmplGmlFilter = tmplGmlFilter.replace(/__XY__/g, strPoints);\n                    break;\n                case \"multipolygon\":\n                    this.logger.warn(\"Filter '\" + name + \"' is not yet implemented !\");\n                    break;\n                default:\n                    this.logger.error(\"This filter '\" + name + \"' is not useful !\");\n            }\n        }\n    }\n\n    template = template.replace(/__GMLPOINT__/g, tmplGmlPoint);\n    template = template.replace(/__GMLFILTER__/g, tmplGmlFilter);\n\n    this.requestString = template;\n    return this.requestString;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Position);\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n *\n * Preference (Reverse)\n *\n * FIXME liste des types de tables de geocodage\n *\n * ```\n * template : \"<ReverseGeocodePreference>__TYPE__</ReverseGeocodePreference>\"\n * ```\n *\n * @constructor\n * @alias Gp.Formats.XLS.LocationUtilityService.Preference\n * @param {String} type - type de table de geocodage\n *\n * @private\n *\n */\n\nfunction Preference (type) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Preference\");\n    this.logger.trace(\"[Constructeur Preference ()]\");\n\n    if (!(this instanceof Preference)) {\n        throw new TypeError(\"Preference constructor cannot be called as a function.\");\n    }\n\n    /**\n     * type de table de geocodage\n     * @type {Array.<String>}\n     */\n    this.type = type;\n}\n\n/**\n * @lends module:Preference#\n */\nPreference.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : Preference,\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     *\n     * substitution des valeurs suivantes :\n     *  __TYPE__\n     *\n     */\n    template : \"<ReverseGeocodePreference>__TYPE__</ReverseGeocodePreference>\"\n};\n\n/**\n * toString\n *\n * @returns {String}\n */\nPreference.prototype.toString = function () {\n    var Preferences = [];\n    var tmplPreference = \"\";\n    for (var idx = 0; idx < this.type.length; idx++) {\n        tmplPreference = this.template;\n        tmplPreference = tmplPreference.replace(/__TYPE__/g, this.type[idx]);\n        Preferences.push(tmplPreference);\n    }\n\n    this.strRequest = Preferences.join(\"\\n\");\n    return this.strRequest;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Preference);\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__ = __webpack_require__(7);\n\n\n\n/**\n * @classdesc\n * Format des attributs d'un résultat de géocodage de type StreetAddress.\n *\n * @constructor\n * @alias Gp.Services.Geocode.Request.StreetAddress\n * @private\n */\nfunction StreetAddress () {\n    if (!(this instanceof StreetAddress)) {\n        throw new TypeError(\"StreetAddress constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage)\n     * @type {String}\n     */\n    this.CLASSNAME = \"StreetAddress\";\n\n    /**\n     * Liste des attributs possibles pour une GeocodeLocation de type StreetAddress\n     * - **bbox** : Emprise de l'adresse dans le système de coordonnées demandé {left, right, top, bottom}. *{Object}*\n     * - **ID** : Identifiant BD ADRESSE dans le cas où le résultat est une adresse. *{String}*\n     * - **IDTR** : Identifiant \"Route Adresse\" de la voie portant l'adresse dans la base BD ADRESSE. *{String}*\n     * - **quality** : Indicateur de qualité du géocodage (pour plus d'infos : http://api.ign.fr/tech-docs-js/fr/developpeur/search.html *{String}*\n     * - **territory** : Code du territoire français où se situe l'adresse *{String}*\n     * - **commune** : Ville l'adresse. *{String}*\n     * - **department** : Département l'adresse. *{String}*\n     * - **insee** : Code INSEE de l'adresse. *{Number}*\n     * - **municipality** : Municipalité de l'adresse. *{String}*\n     */\n\n    this.attributesList = [\"bbox\", \"ID\", \"IDTR\", \"quality\", \"territory\", \"commune\", \"department\", \"insee\", \"municipality\"];\n\n    this.serviceAttributes = [\"bbox\", \"ID\", \"IDTR\", \"Qualite\", \"Territoire\", \"Commune\", \"Departement\", \"INSEE\", \"Municipality\"];\n}\n\n/**\n * @lends module:StreetAdress#\n */\nStreetAddress.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].prototype);\n\n/**\n * Constructeur (alias)\n */\nStreetAddress.prototype.constructor = StreetAddress;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (StreetAddress);\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__ = __webpack_require__(7);\n\n\n\n/**\n * @classdesc\n * Format des attributs d'un résultat de géocodage de type PositionOfInterest\n *\n * @constructor\n * @alias Gp.Services.Geocode.Request.PositionOfInterest\n * @private\n */\nfunction PositionOfInterest () {\n    if (!(this instanceof PositionOfInterest)) {\n        throw new TypeError(\"PositionOfInterest constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage)\n     * @type {String}\n     */\n    this.CLASSNAME = \"PositionOfInterest\";\n\n    /**\n     * Liste des attributs possibles pour une GeocodeLocation de type PositionOfInterest\n     * - **bbox** : Emprise du toponyme dans le système de coordonnées demandé {left, right, top, bottom} *{Object}*\n     * - **importance** : Importance du toponyme *{number}*\n     * - **nature** : Nature du toponyme. *{String}*\n     * - **territory** : Code du territoire français où se situe le toponyme *{String}*\n     * - **commune** : Ville du toponyme. *{String}*\n     * - **department** : Département du toponyme. *{String}*\n     * - **insee** : Code INSEE de la commune où se situe le toponyme. *{Number}*\n     * - **municipality** : Municipalité du toponyme. *{String}*\n     */\n\n    this.attributesList = [\"bbox\", \"importance\", \"nature\", \"territory\", \"commune\", \"department\", \"insee\", \"municipality\"];\n\n    this.serviceAttributes = [\"bbox\", \"Importance\", \"Nature\", \"Territoire\", \"Commune\", \"Departement\", \"INSEE\", \"Municipality\"];\n}\n\n/**\n * @lends module:PositionOfInterest#\n */\nPositionOfInterest.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].prototype);\n\n/**\n * Constructeur (alias)\n */\nPositionOfInterest.prototype.constructor = PositionOfInterest;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PositionOfInterest);\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__ = __webpack_require__(7);\n\n\n\n/**\n * @classdesc\n * Format des attributs d'un filtre de géocodage de type CadastralParcel.\n *\n * @constructor\n * @alias Gp.Services.Geocode.Request.CadastralParcel\n * @private\n */\nfunction CadastralParcel () {\n    if (!(this instanceof CadastralParcel)) {\n        throw new TypeError(\"CadastralParcel constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"CadastralParcel\";\n\n    /**\n     * Liste des attributs possibles pour une GeocodeLocation de type CadastralParcel\n     * - **absorbedCity** : Code commune absorbée de la parcelle :\n     *      lorsqu'une parcelle est issue p d'une ancienne commune qui a fusionné avec une autre.\n     *      Sinon, le code vaut '000'. *{String}*\n     * - **sheet** : Feuille de la parcelle (ex 1). *{String}*\n     * - **number** : Numéro de la parcelle (ex. 0041) *{String}*\n     * - **section** : Section de la parcelle (ex 0D). *{String}*\n     * - **commune** : Ville du filtre. *{String}*\n     * - **department** : Département du filtre. *{String}*\n     * - **insee** : Code INSEE du filtre. *{Number}*\n     * - **municipality** : Municipalité du filtre. *{String}*\n     * - **origin** : L'origine de l'objet parcellaire renvoyé\n     *      (correspond à l'attribut \"type\" dans la réponse XML)\n     *      Pour plus d'informations : http://api.ign.fr/tech-docs-js/fr/developpeur/search.html#Recherche_par_parcelles_cadastrales *{Number}*\n     *\n     */\n\n    this.attributesList = [\"absorbedCity\", \"sheet\", \"number\", \"section\", \"commune\", \"department\", \"insee\", \"municipality\", \"origin\"];\n\n    this.serviceAttributes = [\"CommuneAbsorbee\", \"Feuille\", \"Numero\", \"Section\", \"Commune\", \"Departement\", \"INSEE\", \"Municipality\", \"Type\"];\n}\n\n/**\n * @lends module:CadastralParcel#\n */\nCadastralParcel.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].prototype);\n\n/**\n * Constructeur (alias)\n */\nCadastralParcel.prototype.constructor = CadastralParcel;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CadastralParcel);\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__ = __webpack_require__(7);\n\n\n\n/**\n * @classdesc\n * Format des attributs d'un filtre de géocodage de type Administratif.\n * @constructor\n * @alias Gp.Services.Geocode.Request.Administratif\n * @private\n */\nfunction Administratif () {\n    if (!(this instanceof Administratif)) {\n        throw new TypeError(\"Administratif constructor cannot be called as a function.\");\n    }\n\n    // INFO\n    // appel du constructeur de la classe mère\n    // avec passage de param.\n    __WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].apply(this, arguments);\n\n    /**\n     * Nom de la classe (heritage)\n     * @type {String}\n     */\n    this.CLASSNAME = \"Administratif\";\n\n    /**\n     * Liste des attributs possibles pour une GeocodedLocation de type Administratif\n     * - **bbox** : Emprise de l'unité administrative dans le système de coordonnées demandé *{left, right, top, bottom}*\n     * - **prefecture** - Nom de la préfécture de la région ou du département *{String}*\n     * - **inseeRegion** - Numéro INSEE de la région *{String}*\n     * - **inseeDepartment** - Numéro INSEE du département *{String}*\n     * - **municipality** - Nom de l'unité administrative *{String}*\n     *\n     */\n\n    this.attributesList = [\"bbox\", \"prefecture\", \"inseeRegion\", \"inseeDepartment\", \"municipality\"];\n\n    this.serviceAttributes = [\"bbox\", \"Prefecture\", \"InseeRegion\", \"InseeDepartement\", \"Municipality\"];\n}\n\n/**\n * @lends module:Administratif#\n */\nAdministratif.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__GeocodeLocation__[\"a\" /* default */].prototype);\n\n/**\n * Constructeur (alias)\n */\nAdministratif.prototype.constructor = Administratif;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Administratif);\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_DirectGeocodeResponseReader__ = __webpack_require__(77);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML\n * ou d'un JSON encapsulant du XML\n * (Factory)\n *\n * @module GeocodeResponseFactory\n * @alias Gp.Services.Geocode.Response.GeocodeResponseFactory\n * @todo La reponse JSON peut encapsuler un XML !\n * @private\n */\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\nvar DirectGeocodeReponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Geocode\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // data de type GeocodeResponse\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                data = options.response;\n            } else {\n                try {\n                    var p = new __WEBPACK_IMPORTED_MODULE_2__Formats_XML__[\"a\" /* default */]({\n                        reader : __WEBPACK_IMPORTED_MODULE_3__Formats_DirectGeocodeResponseReader__[\"a\" /* default */]\n                    });\n\n                    if (typeof options.response === \"string\") {\n                        p.setXMLString(options.response);\n                    } else {\n                        p.setXMLDoc(options.response);\n                    }\n\n                    data = p.parse();\n\n                    if (!data) {\n                        throw new Error(\"L'analyse de la réponse du service !?\");\n                    }\n                } catch (e) {\n                    var message = e.message;\n                    if (typeof options.response === \"string\") {\n                        message += \"('\" + options.response + \"')\";\n                    } else {\n                        message += \"('\" + options.response.documentElement.innerHTML + \"')\";\n                    }\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", message),\n                        type : __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR,\n                        status : -1\n                    }));\n                    return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200 // FIXME : 200 ?\n                    }));\n                    return;\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\"),\n                type : __WEBPACK_IMPORTED_MODULE_0__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                status : -1 // FIXME : status response\n            }));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DirectGeocodeReponseFactory);\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Response_model_GeocodeResponse__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Response_model_DirectGeocodedLocation__ = __webpack_require__(39);\n\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service de géocodage direct du Géoportail\n *      afin de récupérer les résultats retournés.\n * @module DirectGeocodeResponseReader\n * @alias Gp.Services.Geocode.Formats.DirectGeocodeResponseReader\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\n/**\n * @member DirectGeocodeResponseReader\n */\nvar DirectGeocodeResponseReader = {};\n\n/**\n * @property {String} DirectGeocodeResponseReader.VERSION - version du service de géocodage\n */\nDirectGeocodeResponseReader.VERSION = \"1.2\";\n\n/**\n * Objet stockant les différents namespaces et les URI associées\n */\nDirectGeocodeResponseReader.NAMESPACES = {\n    xmlns : \"http://www.opengis.net/xls\",\n    gml : \"http://www.opengis.net/gml\",\n    xls : \"http://www.opengis.net/xls\",\n    xlsext : \"http://www.opengis.net/xlsext\",\n    xsi : \"http://www.w3.org/2001/XMLSchema-instance\"\n};\n\n/**\n * Localisation (URL) du schema de définition du XML (XSD)\n */\nDirectGeocodeResponseReader.SCHEMALOCATION = \"http://wxs.ign.fr/schemas/olsAll.xsd\";\n\n/**\n * Namespace par défaut du format\n */\nDirectGeocodeResponseReader.DEFAULTPREFIX = \"xls\";\n\n/**\n * Objet contenant des fonctions de lecture, appelées \"READERS\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n */\nDirectGeocodeResponseReader.READERS = {\n\n    xls : {\n\n        /** TODO : jsdoc block */\n        XLS : function (root) {\n            var geocodeResponse = new __WEBPACK_IMPORTED_MODULE_2__Response_model_GeocodeResponse__[\"a\" /* default */]();\n\n            // vérification de la version du service, et des namespaces de l'en-tête\n            __checkServiceAttributes(root);\n\n            // puis lancement de la lecture de l'ensemble des noeuds, en bouclant sur les childNodes\n            __getChildNodes(root, geocodeResponse);\n\n            return geocodeResponse;\n        },\n\n        /** TODO : jsdoc block */\n        GeocodedAddress : function (node, geocodeResponse) {\n            var geocodedLocation = new __WEBPACK_IMPORTED_MODULE_3__Response_model_DirectGeocodedLocation__[\"a\" /* default */]();\n\n            __getChildNodes(node, geocodedLocation);\n\n            // Ajout du résultat au tableau geocodedLocations de geocodeReponse\n            if (geocodeResponse && Array.isArray(geocodeResponse.locations)) {\n                geocodeResponse.locations.push(geocodedLocation);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        GeocodeMatchCode : function (node, geocodedLocation) {\n            var acc = node.getAttribute(\"accuracy\");\n            if (acc && geocodedLocation) {\n                geocodedLocation.accuracy = parseFloat(acc);\n            }\n            var matchType = node.getAttribute(\"matchType\");\n            if (matchType && geocodedLocation) {\n                geocodedLocation.matchType = matchType;\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Address : function (node, geocodedLocation) {\n            var countrycode = node.getAttribute(\"countryCode\");\n            if (geocodedLocation && countrycode) {\n                geocodedLocation.type = countrycode;\n            }\n            // on va récupérer les autres informations (StreetAddress, place, postalCode...)\n            __getChildNodes(node, geocodedLocation);\n        },\n\n        /** TODO : jsdoc block */\n        freeFormAddress : function (node, geocodedLocation) {\n            if (geocodedLocation && geocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                geocodedLocation.placeAttributes.freeform = __getChildValue(node);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Building : function (node, geocodedLocation) {\n            var num = node.getAttribute(\"number\");\n            if (geocodedLocation && geocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                if (num) {\n                    geocodedLocation.placeAttributes.number = num;\n                } else if (node.getAttribute(\"buildingName\")) {\n                    geocodedLocation.placeAttributes.number = node.getAttribute(\"buildingName\");\n                } else if (node.getAttribute(\"subdivision\")) {\n                    geocodedLocation.placeAttributes.number = node.getAttribute(\"subdivision\");\n                }\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Street : function (node, geocodedLocation) {\n            if (geocodedLocation && geocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                // in case of a streetAddress result : street represents the street name\n                if (geocodedLocation.type === \"StreetAddress\") {\n                    geocodedLocation.placeAttributes.street = __getChildValue(node);\n\n                    // in case of a cadastral parcel result : street represents the cadastral parcel identifier\n                } else if (geocodedLocation.type === \"CadastralParcel\") {\n                    geocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);\n                }\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Place : function (node, geocodedLocation) {\n            var placeType = node.getAttribute(\"type\");\n            var placeName = __getChildValue(node);\n\n            if (geocodedLocation && geocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                if (placeType === \"Municipality\") {\n                    geocodedLocation.placeAttributes.municipality = placeName;\n                } else if (placeType === \"Bbox\") {\n                    var values = placeName.split(\";\");\n                    if (values.length === 4) {\n                        geocodedLocation.placeAttributes.bbox = {\n                            left : parseFloat(values[0]),\n                            right : parseFloat(values[2]),\n                            top : parseFloat(values[1]),\n                            bottom : parseFloat(values[3])\n                        };\n                    }\n                } else if (placeType === \"Commune\") {\n                    geocodedLocation.placeAttributes.commune = placeName;\n                } else if (placeType === \"Departement\") {\n                    geocodedLocation.placeAttributes.department = placeName;\n                } else if (placeType === \"INSEE\") {\n                    geocodedLocation.placeAttributes.insee = placeName;\n                } else if (placeType === \"Qualite\") {\n                    geocodedLocation.placeAttributes.quality = placeName;\n                } else if (placeType === \"Territoire\") {\n                    geocodedLocation.placeAttributes.territory = placeName;\n                } else if (placeType === \"ID\") {\n                    geocodedLocation.placeAttributes.ID = placeName;\n                } else if (placeType === \"ID_TR\") {\n                    geocodedLocation.placeAttributes.IDTR = placeName;\n                } else if (placeType === \"Importance\") {\n                    geocodedLocation.placeAttributes.importance = parseInt(placeName, 10);\n                } else if (placeType === \"Nature\") {\n                    geocodedLocation.placeAttributes.nature = placeName;\n                } else if (placeType === \"Numero\") {\n                    geocodedLocation.placeAttributes.number = placeName;\n                } else if (placeType === \"Feuille\") {\n                    geocodedLocation.placeAttributes.sheet = placeName;\n                } else if (placeType === \"Section\") {\n                    geocodedLocation.placeAttributes.section = placeName;\n                } else if (placeType === \"CommuneAbsorbee\") {\n                    geocodedLocation.placeAttributes.absorbedCity = placeName;\n                } else if (placeType === \"Arrondissement\") {\n                    if (placeName) {\n                        geocodedLocation.placeAttributes.arrondissement = placeName;\n                    }\n                } else if (placeType === \"Type\") {\n                    geocodedLocation.placeAttributes.origin = placeName;\n                } else if (placeType === \"Prefecture\") {\n                    geocodedLocation.placeAttributes.prefecture = placeName;\n                } else if (placeType === \"InseeRegion\") {\n                    geocodedLocation.placeAttributes.inseeRegion = placeName;\n                } else if (placeType === \"InseeDepartment\") {\n                    geocodedLocation.placeAttributes.inseeDepartment = placeName;\n                }\n            }\n        },\n\n        /** TODO : jsdoc block */\n        PostalCode : function (node, geocodedLocation) {\n            if (geocodedLocation && geocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                geocodedLocation.placeAttributes.postalCode = __getChildValue(node);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Error : function (node) {\n            // on imagine qu'on a une balise ainsi :\n            // <Error message=\"Message...\" errorCode=\"InternalServerError\"/>\n            var srvMess = node.getAttribute(\"message\");\n            var errorCode = node.getAttribute(\"errorCode\");\n            var message = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\",\n                \"(\" + errorCode + \") : \" + srvMess);\n            throw new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : message,\n                type : __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n            });\n        }\n    },\n\n    gml : {\n\n        /** TODO : jsdoc block */\n        pos : function (node, geocodedLocation) {\n            var pos = __getChildValue(node);\n            if (geocodedLocation && pos) {\n                geocodedLocation.position = {\n                    x : parseFloat(pos.split(\" \")[0]),\n                    y : parseFloat(pos.split(\" \")[1])\n                };\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    ExceptionReport : function (node) {\n        var response = {};\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"Exception\") {\n                    response.exceptionReport = DirectGeocodeResponseReader.READERS[\"Exception\"](child);\n                }\n            }\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    Exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"exceptionCode\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    }\n\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,\n *      à l'aide des READERS de la classe.\n *\n * @method DirectGeocodeResponseReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse XML,\n *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.\n * @static\n * @memberof DirectGeocodeResponseReader\n */\nDirectGeocodeResponseReader.read = function (root) {\n    if (root.nodeName === \"XLS\") {\n        var nsPrefix = root.prefix;\n        if (!nsPrefix) {\n            nsPrefix = DirectGeocodeResponseReader.DEFAULTPREFIX;\n        }\n        var geocodeResponse = DirectGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);\n        return geocodeResponse;\n    } else if (root.nodeName === \"ExceptionReport\") {\n        var exceptionReport = DirectGeocodeResponseReader.READERS[root.nodeName](root);\n        return exceptionReport;\n    } else {\n        var mess = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", root.nodeName);\n        throw new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */]({\n            message : mess,\n            type : __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR,\n            status : 200\n        });\n    }\n};\n\n/**\n * Récupération des attributs d'un noeud élément\n *\n * @private\n * @memberof DirectGeocodeResponseReader\n * @method __getAttributes\n * @param {DOMElement} node - noeud contenant l'attribut recherché\n * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs\n */\nfunction __getAttributes (node) {\n    if (node.attributes.length > 0) {\n        var nodeAttributes = {};\n        var attributes = node.attributes;\n        for (var i = 0; i < attributes.length; i++) {\n            var attribute = attributes[i];\n            nodeAttributes[attribute.nodeName] = attribute.nodeValue;\n        }\n        return nodeAttributes;\n    }\n}\n\n/**\n * Récupération des noeuds enfants à partir d'un noeud donné, pour lecture (readNode).\n *\n * @private\n * @memberof DirectGeocodeResponseReader\n * @method __getChildNodes\n * @param {DOMElement} node - a DOM node\n * @param {Array|Object} [data] - an object to be filled with node data\n */\nfunction __getChildNodes (node, data) {\n    if (node.hasChildNodes()) {\n        var children = node.childNodes;\n        var child;\n        var childName;\n        var childPrefix;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                childName = child.localName || child.baseName || child.nodeName;\n                childPrefix = child.prefix || DirectGeocodeResponseReader.DEFAULTPREFIX;\n\n                if (DirectGeocodeResponseReader.READERS[childPrefix][childName]) {\n                    var reader = DirectGeocodeResponseReader.READERS[childPrefix][childName];\n                    reader(child, data);\n                } else {\n                    __getChildNodes(child, data);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Lecture de la valeur du premier child d'un noeud, si elle existe.\n *\n * @private\n * @memberof DirectGeocodeResponseReader\n * @method __getChildValue\n * @param {DOMElement} node - a DOM node\n * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.\n */\nfunction __getChildValue (node) {\n    var textNode;\n    var value = \"\";\n\n    if (node.hasChildNodes()) {\n        textNode = node.firstChild;\n        if (textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            value = textNode.nodeValue;\n        }\n    }\n    return value;\n}\n\n/**\n * Vérification des attributs du service, dans la balise XLS de la réponse :\n *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.\n *\n * @private\n * @memberof DirectGeocodeResponseReader\n * @method __checkServiceAttributes\n * @param {DOMElement} XLSNode - a DOM node, corresponding to XLS first tag.\n */\nfunction __checkServiceAttributes (XLSNode) {\n    if (XLSNode.attributes.length > 0) {\n        // on récupère et parcourt les attributs de la balise XLS de la réponse\n        var xlsAttributes = __getAttributes(XLSNode);\n        for (var att in xlsAttributes) {\n            if (xlsAttributes.hasOwnProperty(att)) {\n                // vérification de la version\n                if (att === \"version\") {\n                    if (xlsAttributes[\"version\"] !== DirectGeocodeResponseReader.VERSION) {\n                        console.log(\"[DirectGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing\");\n                        return;\n                    }\n                }\n\n                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend\n                if (att === \"xmlns\") {\n                    if (xlsAttributes[att] !== DirectGeocodeResponseReader.NAMESPACES[DirectGeocodeResponseReader.DEFAULTPREFIX]) {\n                        console.log(\"[DirectGeocodeResponseReader] geocode response default namespace is not the expected one\");\n                        return;\n                    }\n                    continue;\n                }\n\n                var prefix = att.split(\":\")[0];\n                var ns = att.split(\":\")[1];\n\n                // si on a un autre xmlns, on vérifie aussi les URI\n                if (prefix === \"xmlns\" && ns) {\n                    // si l'attribut correspond à un namespace défini dans le reader\n                    if (DirectGeocodeResponseReader.NAMESPACES[ns]) {\n                        // il faut que les URI correspondent aussi.\n                        if (DirectGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {\n                            console.log(\"[DirectGeocodeResponseReader] geocode response \" + att + \" namespace is not the expected one\");\n                            return;\n                        }\n                    }\n                }\n\n                // pour finir on vérifie la localisation du schema XSD du service\n                if (ns === \"schemaLocation\") {\n                    if (DirectGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {\n                        console.log(\"[DirectGeocodeResponseReader] geocode response schema location is not the expected one\");\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DirectGeocodeResponseReader);\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Request_ReverseGeocodeRequestFactory__ = __webpack_require__(79);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Response_ReverseGeocodeResponseFactory__ = __webpack_require__(80);\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service de géocodage inverse du Géoportail :\n *     envoi de la requête construite selon les paramètres en options,\n *     éventuellement parsing et analyse  de la réponse,\n *     retour d'une réponse en paramètre de la fonction onSuccess.\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.ReverseGeocode\n *\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {Object} options.position - Position du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs.\n *      @param {Float} options.position.x - Abcisse du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs. (= longitude si srs = \"CRS:84\", latitude si srs = \"EPSG:4326\")\n *      @param {Float} options.position.y - Ordonnée du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs. (= latitude si srs = \"CRS:84\", longitude si srs = \"EPSG:4326\")\n *\n * @param {Object} [options.filterOptions] - Les propriétés possibles de cet objet sont décrites ci-après.\n * @param {Object} [options.filterOptions.bbox] - Emprise dans laquelle on souhaite effectuer la recherche.\n *      Les propriétés possibles de cet objet sont décrites ci-après.\n *      @param {Float} options.filterOptions.bbox.left   - Abscisse du côté gauche de la BBOX\n *      @param {Float} options.filterOptions.bbox.right  - Abscisse du côté droit de la BBOX\n *      @param {Float} options.filterOptions.bbox.top    - Ordonnée supérieure de la BBOX\n *      @param {Float} options.filterOptions.bbox.bottom - Ordonnée inférieure de la BBOX\n *\n * @param {Object} [options.filterOptions.circle] - Cercle dans lequel on souhaite effectuer la recherche.\n *      Les propriétés possibles de cet objet sont décrites ci-après.\n *      @param {Float} options.filterOptions.circle.x      - Abscisse du centre du cercle de recherche.\n *      @param {Float} options.filterOptions.circle.y      - Ordonnée du centre du cercle de recherche.\n *      @param {Float} options.filterOptions.circle.radius - Rayon du cercle de recherche.\n *\n * @param {Array.<Object>} [options.filterOptions.polygon] - Polygone dans lequel on souhaite effectuer la recherche.\n *      Liste des couples x et y pour chaque point constituant le polygone.\n *\n * @param {Array.<String>} [options.filterOptions.type = \"StreetAddress\"] - Type de l'objet recherché.\n *      Le service de géocodage du Géoportail permet de rechercher des 'PostionOfInterest' pour des toponymes, des 'StreetAddress'\n *      pour des adresses postales et/ou des 'CadastralParcel' pour des parcelles cadastrales.\n *      D'autres types pourront être rajoutés selon l'évolution du service.\n *      Par défaut, type = ['StreetAddress'].\n *\n * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.\n *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 25.\n *\n * @param {String} [options.srs = CRS:84] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.\n *      Pas de valeur par défaut.\n *      Si le serveur consulté est celui du Géoportail, la valeur par défaut est : \"CRS:84\".\n *\n * @example\n *   var options = {\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      position : {x:0 , y:0},\n *      filterOptions :{\n *          bbox : {left : 0, right : 1, top : 1, bottom : 0},\n *          [circle : {\n *              x : 0,\n *              y : 0,\n *              radius : 100\n *          }]\n *          [polygon  : [{x:0,y:0}, {x:1,y:1}, {x:2,y:2}, {x:3,y:2}, {x:4,y:1}, {x:0,y:0}]]\n *          type : ['StreetAddress']\n *      },\n *      maximumResponses : 25,\n *      srs : 'EPSG:4326'\n *   };\n *\n * @private\n */\nfunction ReverseGeocode (options) {\n    if (!(this instanceof ReverseGeocode)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"ReverseGeocode\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"ReverseGeocode\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.ReverseGeocode\");\n    this.logger.trace(\"[Constructeur ReverseGeocode (options)]\");\n\n    if (!options.position) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position\"));\n    }\n\n    // on lance une exception afin d'eviter au service de le faire...\n    if (options.position.x === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position.x\"));\n    }\n\n    if (options.position.y === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position.y\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.position = options.position;\n\n    // on definit des filtres par defaut\n    if (!options.filterOptions || typeof options.filterOptions !== \"object\") {\n        this.options.filterOptions = options.filterOptions = {\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)\n    // ceci permet de tester le cas où : object = {}\n    if (Object.keys(options.filterOptions).length === 0) {\n        this.options.filterOptions = {\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    // on teste pour chaque filtre, les conditions suivantes : null ou vide !\n    var filter = Object.keys(options.filterOptions);\n    for (var i = 0; i < filter.length; i++) {\n        var key = filter[i];\n        if (!options.filterOptions[key] || Object.keys(options.filterOptions[key]).length === 0) {\n            delete this.options.filterOptions[key];\n        }\n    }\n\n    this.options.filterOptions.type = options.filterOptions.type || [\"StreetAddress\"];\n    // on vérifie que le type est bien dans un tableau\n    if (!Array.isArray(this.options.filterOptions.type)) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_TYPE\", \"filterOptions.type\"));\n    }\n\n    this.options.maximumResponses = options.maximumResponses || 25;\n\n    // FIXME : cet attribut (returnFreeForm) n'est pas spécifié dans la doc du constructeur ?\n    // Il est inutile en effet, mais présent dans les specs...\n    this.options.returnFreeForm = options.returnFreeForm || false;\n    // info : en réalité le service ne reconnait que EPSG:4326. this.options.srs permet essentiellement de différencier EPSG:4326 (lat,lon) et CRS:84 (lon,lat)\n    this.options.srs = options.srs || \"CRS:84\";\n\n    // si on n'a pas un systeme de coordonnées EPSG géographique, il faut inverser les coordonnées\n    // (car elles sont en lon, lat alors que le service attend une position en lat, lon).\n    // dans le cas d'EPSG:4326 par exemple, les coordonnées sont bien en lat, lon donc on ne fait rien.\n    if (ReverseGeocode.geoEPSG.indexOf(this.options.srs) === -1) {\n        // pour la position\n        this.options.position = {\n            x : this.options.position.y,\n            y : this.options.position.x\n        };\n        // pour les filtres spatiaux s'ils sont spécifiés\n        if (this.options.filterOptions && this.options.filterOptions.circle) {\n            var circle = this.options.filterOptions.circle;\n            this.options.filterOptions.circle = {\n                x : circle.y,\n                y : circle.x,\n                radius : circle.radius\n            };\n        }\n        if (this.options.filterOptions && this.options.filterOptions.polygon) {\n            var polygon = this.options.filterOptions.polygon;\n            for (i = 0; i < polygon.length; i++) {\n                var coords = polygon[i];\n                this.options.filterOptions.polygon[i] = {\n                    x : coords.y,\n                    y : coords.x\n                };\n            }\n        }\n    }\n\n    // attributs d'instances\n\n    /**\n     * Format forcé de la réponse du service : \"xml\"\n     * sauf si l'on souhaite une reponse brute (options.rawResponse)\n     */\n    this.options.outputFormat = (this.options.rawResponse) ? \"\" : \"xml\";\n}\n\n/**\n * @lends module:ReverseGeocode#\n */\nReverseGeocode.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nReverseGeocode.prototype.constructor = ReverseGeocode;\n\n/**\n * (overwrite)\n * Création de la requête\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nReverseGeocode.prototype.buildRequest = function (error, success) {\n    var options = {\n        httpMethod : this.options.httpMethod,\n        // options specifiques du service\n        position : this.options.position,\n        returnFreeForm : this.options.returnFreeForm,\n        filterOptions : this.options.filterOptions,\n        srs : \"EPSG:4326\", // info : en réalité le service ne reconnait que EPSG:4326. this.options.srs permet essentiellement de différencier EPSG:4326 (lat,lon) et CRS:84 (lon,lat)\n        maximumResponses : this.options.maximumResponses\n    };\n\n    this.request = __WEBPACK_IMPORTED_MODULE_4__Request_ReverseGeocodeRequestFactory__[\"a\" /* default */].build(options);\n\n    // on teste si la requete a bien été construite !\n    (!this.request)\n        ? error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\")))\n        : success.call(this, this.request);\n};\n\n/**\n * (overwrite)\n * Analyse de la reponse\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nReverseGeocode.prototype.analyzeResponse = function (error, success) {\n    if (this.response) {\n        var options = {\n            response : this.response,\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_5__Response_ReverseGeocodeResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/**\n * Codes EPSG géographiques (lat/lon). Utiles car les coordonnées doivent être inversées.\n */\nReverseGeocode.geoEPSG = [\"EPSG:4326\"];\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocode);\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_LocationUtilityService__ = __webpack_require__(38);\n/**\n * Creation d'une requête OpenLS en mode POST ou GET\n * (Factory)\n *\n * @module ReverseGeocodeRequestFactory\n * @alias Gp.Services.Geocode.Request.ReverseGeocodeRequestFactory\n * @private\n */\n\n\n\n\nvar ReverseGeocodeRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Geocode\n     *\n     * @example\n     *   var options = {\n     *      httpMethod :\n     *      // options specifiques du service\n     *      position :\n     *      returnFreeForm :\n     *      filterOptions :\n     *      srs :\n     *      maximumResponses :\n     *   };\n     *   var result = ReverseGeocodeRequestFactory.build(options);\n     *   if (!result) {\n     *       // error...\n     *   }\n     * @returns {String} request\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"ReverseGeocodeRequestFactory\");\n        logger.trace([\"ReverseGeocodeRequestFactory::build()\"]);\n\n        // options non definies\n        var settings = options || {};\n\n        var request = null;\n\n        // objet LUS\n        var oLUS = new __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_LocationUtilityService__[\"a\" /* default */]({\n            position : settings.position,\n            returnFreeForm : settings.returnFreeForm,\n            filterOptions : settings.filterOptions\n        });\n\n        // Format XLS\n        var oXLS = new __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__[\"a\" /* default */]({\n            srsName : settings.srs,\n            maximumResponses : settings.maximumResponses\n        });\n        oXLS.namespace = true;\n        oXLS.setService(oLUS);\n\n        // request brute !\n        request = oXLS.build();\n\n        // en mode GET, la requête est encodée\n        // et le param. 'qxml' est ajouté\n        if (settings.httpMethod === \"GET\") {\n            var myRequest = \"qxml=\" +\n                encodeURIComponent(request)\n                    .replace(/-/g, \"%2D\")\n                    .replace(/_/g, \"%5F\")\n                    .replace(/\\./g, \"%2E\")\n                    .replace(/!/g, \"%21\")\n                    .replace(/~/g, \"%7E\")\n                    .replace(/\\*/g, \"%2A\")\n                    .replace(/'/g, \"%27\")\n                    .replace(/\\(/g, \"%28\")\n                    .replace(/\\)/g, \"%29\");\n            request = myRequest;\n        }\n\n        logger.trace(request);\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocodeRequestFactory);\n\n\n/***/ }),\n/* 80 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_ReverseGeocodeResponseReader__ = __webpack_require__(81);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML\n * ou d'un JSON encapsulant du XML\n * (Factory)\n *\n * @module ReverseGeocodeResponseFactory\n * @alias Gp.Services.ReverseGeocode.Response.ReverseGeocodeResponseFactory\n * @todo La reponse JSON peut encapsuler un XML !\n * @private\n */\n\n\n\n\n\n\nvar ReverseGeocodeReponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant ReverseGeocode\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // data de type ReverseGeocodeResponse\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                data = options.response;\n            } else {\n                try {\n                    var p = new __WEBPACK_IMPORTED_MODULE_2__Formats_XML__[\"a\" /* default */]({\n                        reader : __WEBPACK_IMPORTED_MODULE_3__Formats_ReverseGeocodeResponseReader__[\"a\" /* default */]\n                    });\n\n                    if (typeof options.response === \"string\") {\n                        p.setXMLString(options.response);\n                    } else {\n                        p.setXMLDoc(options.response);\n                    }\n\n                    data = p.parse();\n\n                    if (!data) {\n                        throw new Error(\"L'analyse de la réponse du service !?\");\n                    }\n                } catch (e) {\n                    // on relaye l'erreur reçue\n                    e.status = 200;\n                    options.onError.call(options.scope, e);\n                    return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                // TODO : quand cela arrive-t-il ?\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n\n                // dans le cas d'un srs non EPSG géographique, il faut réinverser les coordonnées (lat,lon => lon,lat)\n                if (options.scope && options.scope.options && options.scope.options.srs && options.scope.options.srs !== \"EPSG:4326\") {\n                    var location;\n                    var pos;\n                    if (data || data.locations || data.locations.length) {\n                        for (var i = 0; i < data.locations.length; i++) {\n                            location = data.locations[i];\n                            if (location) {\n                                pos = location.position;\n                                if (pos) {\n                                    // on inverse les 2 coordonnées\n                                    location.position = {\n                                        x : pos.y,\n                                        y : pos.x\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\"),\n                type : __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                status : -1 // FIXME : status response\n            }));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocodeReponseFactory);\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Response_model_GeocodeResponse__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Response_model_ReverseGeocodedLocation__ = __webpack_require__(40);\n\n/**\n * Fonction retournant un objet contenant des clés de lecture (readers)\n *      qui permettent de parser des réponses XML du service de géocodage inverse du Géoportail\n *      afin de récupérer les résultats retournés.\n * @module ReverseGeocodeResponseReader\n * @alias Gp.Services.Geocode.Formats.ReverseGeocodeResponseReader\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\n/**\n * Objet ReverseGeocodeResponseReader\n * @member {Object} ReverseGeocodeResponseReader\n *\n * @property {String} ReverseGeocodeResponseReader.VERSION - Version du service de géocodage\n *\n * @property {Object} ReverseGeocodeResponseReader.NAMESPACES - Objet stockant les différents namespaces et les URI associées\n *\n * @property {String} ReverseGeocodeResponseReader.SCHEMALOCATION - Localisation (URL) du schema de définition du XML (XSD)\n *\n * @property {String} ReverseGeocodeResponseReader.DEFAULTPREFIX - Namespace par défaut du format\n *\n * @property {Object} ReverseGeocodeResponseReader.READERS - Objet contenant des fonctions de lecture, appelées \"READERS\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} ReverseGeocodeResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,\n *      à l'aide des READERS de la classe.\n *\n */\n\nvar ReverseGeocodeResponseReader = {};\n\n/**\n * version du service de géocodage\n */\nReverseGeocodeResponseReader.VERSION = \"1.2\";\n\n/**\n * Objet stockant les différents namespaces et les URI associées\n */\nReverseGeocodeResponseReader.NAMESPACES = {\n    xmlns : \"http://www.opengis.net/xls\",\n    gml : \"http://www.opengis.net/gml\",\n    xls : \"http://www.opengis.net/xls\",\n    xlsext : \"http://www.opengis.net/xlsext\",\n    xsi : \"http://www.w3.org/2001/XMLSchema-instance\"\n};\n\n/**\n * Localisation (URL) du schema de définition du XML (XSD)\n */\nReverseGeocodeResponseReader.SCHEMALOCATION = \"http://wxs.ign.fr/schemas/olsAll.xsd\";\n\n/**\n * Namespace par défaut du format\n */\nReverseGeocodeResponseReader.DEFAULTPREFIX = \"xls\";\n\n/**\n * Objet contenant des fonctions de lecture, appelées \"READERS\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n */\nReverseGeocodeResponseReader.READERS = {\n\n    xls : {\n\n        /** TODO : jsdoc block */\n        XLS : function (root) {\n            var reverseGeocodeResponse = new __WEBPACK_IMPORTED_MODULE_2__Response_model_GeocodeResponse__[\"a\" /* default */]();\n\n            // vérification de la version du service, et des namespaces de l'en-tête\n            __checkServiceAttributes(root);\n\n            // puis lancement de la lecture de l'ensemble des noeuds, en bouclant sur les childNodes\n            __getChildNodes(root, reverseGeocodeResponse);\n\n            return reverseGeocodeResponse;\n        },\n\n        /** TODO : jsdoc block */\n        ReverseGeocodedLocation : function (node, reverseGeocodeResponse) {\n            var reverseGeocodedLocation = new __WEBPACK_IMPORTED_MODULE_3__Response_model_ReverseGeocodedLocation__[\"a\" /* default */]();\n\n            __getChildNodes(node, reverseGeocodedLocation);\n\n            // Ajout du résultat au tableau locations de reverseGeocodeResponse\n            if (reverseGeocodeResponse && Array.isArray(reverseGeocodeResponse.locations)) {\n                reverseGeocodeResponse.locations.push(reverseGeocodedLocation);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Address : function (node, reverseGeocodedLocation) {\n            var countrycode = node.getAttribute(\"countryCode\");\n            if (reverseGeocodedLocation && countrycode) {\n                reverseGeocodedLocation.type = countrycode;\n            }\n            // on va récupérer les autres informations (StreetAddress, place, postalCode...)\n            __getChildNodes(node, reverseGeocodedLocation);\n        },\n\n        /** TODO : jsdoc block */\n        Building : function (node, reverseGeocodedLocation) {\n            var num = node.getAttribute(\"number\");\n            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                if (num) {\n                    reverseGeocodedLocation.placeAttributes.number = num;\n                } else if (node.getAttribute(\"buildingName\")) {\n                    reverseGeocodedLocation.placeAttributes.number = node.getAttribute(\"buildingName\");\n                } else if (node.getAttribute(\"subdivision\")) {\n                    reverseGeocodedLocation.placeAttributes.number = node.getAttribute(\"subdivision\");\n                }\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Street : function (node, reverseGeocodedLocation) {\n            // in case of a streetAddress result : street represents the street name\n            if (reverseGeocodedLocation.type === \"StreetAddress\") {\n                reverseGeocodedLocation.placeAttributes.street = __getChildValue(node);\n\n                // in case of a cadastral parcel result : street represents the cadastral parcel identifier\n            } else if (reverseGeocodedLocation.type === \"CadastralParcel\") {\n                reverseGeocodedLocation.placeAttributes.cadastralParcel = __getChildValue(node);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Place : function (node, reverseGeocodedLocation) {\n            var placeType = node.getAttribute(\"type\");\n            var placeName = __getChildValue(node);\n\n            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                if (placeType === \"Municipality\") {\n                    reverseGeocodedLocation.placeAttributes.municipality = placeName;\n                } else if (placeType === \"Bbox\") {\n                    var values = placeName.split(\";\");\n                    if (values.length === 4) {\n                        reverseGeocodedLocation.placeAttributes.bbox = {\n                            left : parseFloat(values[0]),\n                            right : parseFloat(values[2]),\n                            top : parseFloat(values[1]),\n                            bottom : parseFloat(values[3])\n                        };\n                    }\n                } else if (placeType === \"Commune\") {\n                    reverseGeocodedLocation.placeAttributes.commune = placeName;\n                } else if (placeType === \"Departement\") {\n                    reverseGeocodedLocation.placeAttributes.department = placeName;\n                } else if (placeType === \"INSEE\") {\n                    reverseGeocodedLocation.placeAttributes.insee = placeName;\n                } else if (placeType === \"Qualite\") {\n                    reverseGeocodedLocation.placeAttributes.quality = placeName;\n                } else if (placeType === \"Territoire\") {\n                    reverseGeocodedLocation.placeAttributes.territory = placeName;\n                } else if (placeType === \"ID\") {\n                    reverseGeocodedLocation.placeAttributes.ID = placeName;\n                } else if (placeType === \"ID_TR\") {\n                    reverseGeocodedLocation.placeAttributes.IDTR = placeName;\n                } else if (placeType === \"Importance\") {\n                    reverseGeocodedLocation.placeAttributes.importance = parseInt(placeName, 10);\n                } else if (placeType === \"Nature\") {\n                    reverseGeocodedLocation.placeAttributes.nature = placeName;\n                } else if (placeType === \"Numero\") {\n                    reverseGeocodedLocation.placeAttributes.number = placeName;\n                } else if (placeType === \"Feuille\") {\n                    reverseGeocodedLocation.placeAttributes.sheet = placeName;\n                } else if (placeType === \"Section\") {\n                    reverseGeocodedLocation.placeAttributes.section = placeName;\n                } else if (placeType === \"CommuneAbsorbee\") {\n                    reverseGeocodedLocation.placeAttributes.absorbedCity = placeName;\n                } else if (placeType === \"Arrondissement\") {\n                    if (placeName) {\n                        reverseGeocodedLocation.placeAttributes.arrondissement = placeName;\n                    }\n                } else if (placeType === \"Type\") {\n                    reverseGeocodedLocation.placeAttributes.origin = placeName;\n                } else if (placeType === \"Prefecture\") {\n                    reverseGeocodedLocation.placeAttributes.prefecture = placeName;\n                } else if (placeType === \"InseeRegion\") {\n                    reverseGeocodedLocation.placeAttributes.inseeRegion = placeName;\n                } else if (placeType === \"InseeDepartment\") {\n                    reverseGeocodedLocation.placeAttributes.inseeDepartment = placeName;\n                }\n            }\n        },\n\n        /** TODO : jsdoc block */\n        PostalCode : function (node, reverseGeocodedLocation) {\n            if (reverseGeocodedLocation && reverseGeocodedLocation.hasOwnProperty(\"placeAttributes\")) {\n                reverseGeocodedLocation.placeAttributes.postalCode = __getChildValue(node);\n            }\n        },\n\n        /** TODO : jsdoc block */\n        SearchCentreDistance : function (node, reverseGeocodedLocation) {\n            if (reverseGeocodedLocation) {\n                reverseGeocodedLocation.searchCenterDistance = parseFloat(node.getAttribute(\"value\"));\n            }\n        },\n\n        /** TODO : jsdoc block */\n        Error : function (node) {\n            // <Error message=\"For input string : &quot;2,45&quot;\" errorCode=\"InternalServerError\"/>\n            var srvMess = node.getAttribute(\"message\");\n            var errorCode = node.getAttribute(\"errorCode\");\n            var message = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\",\n                \"(\" + errorCode + \") : \" + srvMess);\n            throw new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : message,\n                type : __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n            });\n        }\n    },\n\n    gml : {\n\n        /** TODO : jsdoc block */\n        pos : function (node, reverseGeocodedLocation) {\n            var pos = __getChildValue(node);\n            if (reverseGeocodedLocation && pos) {\n                reverseGeocodedLocation.position = {\n                    x : parseFloat(pos.split(\" \")[0]),\n                    y : parseFloat(pos.split(\" \")[1])\n                };\n            }\n        }\n    },\n\n    xlsext : {\n        /** TODO : jsdoc block */\n        ExtendedGeocodeMatchCode : function (node, reverseGeocodedLocation) {\n            if (reverseGeocodedLocation) {\n                reverseGeocodedLocation.matchType = __getChildValue(node);\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    ExceptionReport : function (node) {\n        var response = {};\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"Exception\") {\n                    response.exceptionReport = ReverseGeocodeResponseReader.READERS[\"Exception\"](child);\n                }\n            }\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    Exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"exceptionCode\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    }\n\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service de géocodage,\n *      à l'aide des READERS de la classe.\n *\n * @method ReverseGeocodeResponseReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse XML,\n *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.\n * @static\n * @memberof ReverseGeocodeResponseReader\n */\nReverseGeocodeResponseReader.read = function (root) {\n    if (root.nodeName === \"XLS\") {\n        var nsPrefix = root.prefix;\n        if (!nsPrefix) {\n            nsPrefix = ReverseGeocodeResponseReader.DEFAULTPREFIX;\n        }\n        var geocodeResponse = ReverseGeocodeResponseReader.READERS[nsPrefix][root.nodeName](root);\n        return geocodeResponse;\n    } else if (root.nodeName === \"ExceptionReport\") {\n        var exceptionReport = ReverseGeocodeResponseReader.READERS[root.nodeName](root);\n        return exceptionReport;\n    } else {\n        throw new Error(\"Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.\");\n    }\n};\n\n/**\n * Récupération des attributs d'un noeud élément\n *\n * @private\n * @memberof ReverseGeocodeResponseReader\n * @method __getAttributes\n * @param {DOMElement} node - noeud contenant l'attribut recherché\n * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs\n */\nfunction __getAttributes (node) {\n    if (node.attributes.length > 0) {\n        var nodeAttributes = {};\n        var attributes = node.attributes;\n        for (var i = 0; i < attributes.length; i++) {\n            var attribute = attributes[i];\n            nodeAttributes[attribute.nodeName] = attribute.nodeValue;\n        }\n        return nodeAttributes;\n    }\n}\n\n/**\n * Récupération des noeuds enfants à partir d'un noeud donné, pour lecture (readNode).\n *\n * @private\n * @memberof ReverseGeocodeResponseReader\n * @method __getChildNodes\n * @param {DOMElement} node - a DOM node\n * @param {Array|Object} [data] - an object to be filled with node data\n */\nfunction __getChildNodes (node, data) {\n    if (node.hasChildNodes()) {\n        var children = node.childNodes;\n        var child;\n        var childName;\n        var childPrefix;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                childName = child.localName || child.baseName || child.nodeName;\n                childPrefix = child.prefix || ReverseGeocodeResponseReader.DEFAULTPREFIX;\n\n                if (ReverseGeocodeResponseReader.READERS[childPrefix][childName]) {\n                    var reader = ReverseGeocodeResponseReader.READERS[childPrefix][childName];\n                    reader(child, data);\n                } else {\n                    __getChildNodes(child, data);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Lecture de la valeur du premier child d'un noeud, si elle existe.\n *\n * @private\n * @memberof ReverseGeocodeResponseReader\n * @method __getChildValue\n * @param {DOMElement} node - a DOM node\n * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.\n */\nfunction __getChildValue (node) {\n    var textNode;\n    var value = \"\";\n\n    if (node.hasChildNodes()) {\n        textNode = node.firstChild;\n        if (textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            value = textNode.nodeValue;\n        }\n    }\n    return value;\n}\n\n/**\n * Vérification des attributs du service, dans la balise XLS de la réponse :\n *      version, namespaces, et namespace par défaut doivent correspondre à ceux attendus.\n *\n * @private\n * @memberof ReverseGeocodeResponseReader\n * @method __checkServiceAttributes\n * @param {DOMElement} XLSNode - a DOM node, corresponding to XLS first tag.\n */\nfunction __checkServiceAttributes (XLSNode) {\n    if (XLSNode.attributes.length > 0) {\n        // on récupère et parcourt les attributs de la balise XLS de la réponse\n        var xlsAttributes = __getAttributes(XLSNode);\n        for (var att in xlsAttributes) {\n            if (xlsAttributes.hasOwnProperty(att)) {\n                // vérification de la version\n                if (att === \"version\") {\n                    if (xlsAttributes[\"version\"] !== ReverseGeocodeResponseReader.VERSION) {\n                        console.log(\"[ReverseGeocodeResponseReader] geocode version is not the expected one : there may be errors in parsing\");\n                        return;\n                    }\n                }\n\n                // on vérifie que l'uri du namespace par défaut est bien celle que l'on attend\n                if (att === \"xmlns\") {\n                    if (xlsAttributes[att] !== ReverseGeocodeResponseReader.NAMESPACES[ReverseGeocodeResponseReader.DEFAULTPREFIX]) {\n                        console.log(\"[ReverseGeocodeResponseReader] geocode response default namespace is not the expected one\");\n                        return;\n                    }\n                    continue;\n                }\n\n                var prefix = att.split(\":\")[0];\n                var ns = att.split(\":\")[1];\n\n                // si on a un autre xmlns, on vérifie aussi les URI\n                if (prefix === \"xmlns\" && ns) {\n                    // si l'attribut correspond à un namespace défini dans le reader\n                    if (ReverseGeocodeResponseReader.NAMESPACES[ns]) {\n                        // il faut que les URI correspondent aussi.\n                        if (ReverseGeocodeResponseReader.NAMESPACES[ns] !== xlsAttributes[att]) {\n                            console.log(\"[ReverseGeocodeResponseReader] geocode response \" + att + \" namespace is not the expected one\");\n                            return;\n                        }\n                    }\n                }\n\n                // pour finir on vérifie la localisation du schema XSD du service\n                if (ns === \"schemaLocation\") {\n                    if (ReverseGeocodeResponseReader.SCHEMALOCATION !== xlsAttributes[att]) {\n                        console.log(\"[ReverseGeocodeResponseReader] geocode response schema location is not the expected one\");\n                        return;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ReverseGeocodeResponseReader);\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Response_AutoCompleteResponseFactory__ = __webpack_require__(83);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils_Helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Exceptions_ErrorService__ = __webpack_require__(2);\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service d'autocomplétion du Géoportail :\n * envoi de la requête construite selon les paramètres en options,\n * éventuellement parsing et analyse  de la réponse,\n * retour d'une réponse en paramètre de la fonction onSuccess.\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.AutoComplete\n *\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {String} options.text - La chaîne de caractère à compléter.\n *      Cette chaîne n'est pas \"URL encodée\".\n *      C'est l'API qui s'occupe de l'encoder pour l'inclure dans la requête.\n *\n * @param {Array.<String>} [options.filterOptions.type = \"StreetAddress\"] - Type de l'objet recherché.\n *      Le service d'autocomplétion du Géoportail permet de rechercher des toponymes 'PostionOfInterest' et/ou des adresses postales 'StreetAddress'.\n *      D'autres types pourront être rajoutés selon l'évolution du service.\n *      Par défaut, type = ['StreetAddress'].\n *\n * @param {Array.<String>} [options.filterOptions.territory] - Limitation de la zone de recherche de localisants.\n *      Le service d'autocomplétion du Géoportail permet de limiter la recherche à la métropole et la Corse : options.filterOptions.territory = ['METROPOLE'],\n *      DOMS TOMS : options.filterOptions.territory = ['DOMTOM'], ou à une liste de départements : options.filterOptions.territory = ['31', '34']\n *      Pas de valeur par défaut.\n *      La valeur par défaut est donc celle du service.\n *      Le service d'autocomplétion du Géoportail renvoie toutes les informations quand aucun territoire n'est spécifié.\n *\n * @param {Number} [options.maximumResponses = 10] - Nombre de réponses maximal que l'on souhaite recevoir.\n *      Pas de valeur par défaut.\n *      La valeur par défaut sera donc celle du service : 10.\n *\n * @example\n *   var options = {\n *      // options communes aux services\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      text : \"\",\n *      filterOptions : {\n *          type : [\"StreetAddress\"],\n *          territory : ['METROPOLE', 'DOMTOM', '31']\n *      },\n *      maximumResponses : 10\n *   };\n * @private\n */\nfunction AutoComplete (options) {\n    if (!(this instanceof AutoComplete)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_3__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"AutoComplete\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"AutoComplete\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_0__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_2__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.AutoComplete\");\n    this.logger.trace(\"[Constructeur AutoComplete (options)]\");\n\n    if (!options.text) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_3__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"text\"));\n    }\n\n    // ajout des options spécifiques au service\n    this.options.text = options.text;\n\n    // on definit des filtres par defaut\n    if (!options.filterOptions || typeof options.filterOptions !== \"object\") {\n        this.options.filterOptions = options.filterOptions = {\n            territory : [],\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    // FIXME ECMAScript 5 support (valable pour un objet uniquement !)\n    // ceci permet de tester le cas où : object = {}\n    if (Object.keys(options.filterOptions).length === 0) {\n        this.options.filterOptions = {\n            territory : [],\n            type : [\"StreetAddress\"]\n        };\n    }\n\n    this.options.filterOptions.type = options.filterOptions.type || [\"StreetAddress\"];\n    this.options.filterOptions.territory = options.filterOptions.territory || [];\n    this.options.maximumResponses = options.maximumResponses || 10;\n\n    // INFO\n    // le service ne repond pas en mode POST (405 Method Not Allowed)\n    if (this.options.protocol === \"XHR\" && this.options.httpMethod === \"POST\") {\n        this.logger.warn(\"Le service ne gére pas le mode d'interrogation en POST, on bascule sur du GET !\");\n        this.options.httpMethod = \"GET\"; // on surcharge !\n    }\n\n    // attributs d'instances\n\n    /**\n     * Format forcé de la réponse du service : \"json\"\n     * sauf si l'on souhaite une reponse brute (options.rawResponse)\n     */\n    this.options.outputFormat = (this.options.rawResponse) ? \"\" : \"json\";\n}\n\n/**\n * @lends module:AutoComplete#\n */\n\nAutoComplete.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_0__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nAutoComplete.prototype.constructor = AutoComplete;\n\n/**\n * (overwrite)\n * Création de la requête\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nAutoComplete.prototype.buildRequest = function (error, success) {\n    // ex.\n    // http://wxs.ign.fr/CLEF/ols/apis/completion?\n    // text=Brie-Comt&\n    // type=StreetAddress,PositionOfInterest&\n    // territory=METROPOLE&\n    // maximumResponses=10\n\n    // traitement des param KPV sous forme de tableau\n    var territories = \"\";\n    if (this.options.filterOptions.territory) {\n        territories = this.options.filterOptions.territory.join(\";\");\n    }\n\n    var types = \"\";\n    if (this.options.filterOptions.type) {\n        types = this.options.filterOptions.type.join(\",\");\n    }\n\n    // normalisation de la requete avec param KPV\n    this.request = __WEBPACK_IMPORTED_MODULE_4__Utils_Helper__[\"a\" /* default */].normalyzeParameters({\n        text : encodeURIComponent(this.options.text),\n        type : types,\n        terr : territories,\n        maximumResponses : this.options.maximumResponses\n    });\n\n    (!this.request)\n        ? error.call(this, new __WEBPACK_IMPORTED_MODULE_5__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_3__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\")))\n        : success.call(this, this.request);\n};\n\n/**\n * (overwrite)\n * Analyse de la reponse\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback de succès de l'analyse de la réponse\n */\nAutoComplete.prototype.analyzeResponse = function (error, success) {\n    if (this.response) {\n        var options = {\n            response : this.response,\n            rawResponse : this.options.rawResponse,\n            onSuccess : success,\n            onError : error,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_1__Response_AutoCompleteResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_5__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_3__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoComplete);\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__model_AutoCompleteResponse__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__model_SuggestedLocation__ = __webpack_require__(42);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON\n * (Factory)\n *\n * @module AutoCompleteResponseFactory\n * @private\n * @alias Gp.Services.AutoComplete.Response.AutoCompleteResponseFactory\n */\n\n\n\n\n\n\nvar AutoCompleteResponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      outputFormat :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"AutoCompleteResponseFactory\");\n        logger.trace([\"AutoCompleteResponseFactory::build()\"]);\n\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                logger.trace(\"analyze response : raw\");\n                data = options.response;\n            } else {\n                var JSONResponse;\n                if (typeof options.response === \"string\") {\n                    JSONResponse = JSON.parse(options.response);\n                } else {\n                    JSONResponse = options.response;\n                }\n\n                // analyse de la réponse\n                if (JSONResponse) {\n                    // le service renvoie t il une erreur ?\n                    if (JSONResponse.error) {\n                        // ex. ?\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                            message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", JSONResponse.error.description),\n                            status : JSONResponse.error.code,\n                            type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                        }));\n                        return;\n                    }\n\n                    // création de l'objet réponse\n                    data = new __WEBPACK_IMPORTED_MODULE_3__model_AutoCompleteResponse__[\"a\" /* default */]();\n\n                    // boucle sur les résultats de l'autocomplétion\n                    if (JSONResponse.results && Array.isArray(JSONResponse.results)) {\n                        var suggestedLocation;\n\n                        for (var i = 0; i < JSONResponse.results.length; i++) {\n                            var result = JSONResponse.results[i];\n                            suggestedLocation = new __WEBPACK_IMPORTED_MODULE_4__model_SuggestedLocation__[\"a\" /* default */]();\n\n                            if (suggestedLocation) {\n                                if (result && result.country === \"StreetAddress\") {\n                                    suggestedLocation.street = result.street;\n                                    suggestedLocation.type = \"StreetAddress\";\n                                } else if (result && result.country === \"PositionOfInterest\") {\n                                    suggestedLocation.poi = result.street;\n                                    suggestedLocation.kind = result.kind;\n                                    suggestedLocation.type = \"PositionOfInterest\";\n                                }\n\n                                if (suggestedLocation.position) {\n                                    suggestedLocation.position.x = result.x;\n                                    suggestedLocation.position.y = result.y;\n                                }\n\n                                suggestedLocation.commune = result.city;\n                                suggestedLocation.fullText = result.fulltext;\n                                suggestedLocation.postalCode = result.zipcode;\n                                suggestedLocation.classification = result.classification;\n                            }\n                            // Ajout du résultat au tableau reverseGeocodedLocations de geocodedLocation\n                            data.suggestedLocations.push(suggestedLocation);\n                        }\n                    } else {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT_3\")));\n                        return;\n                    }\n\n                    if (!data.suggestedLocations.length) {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT_3\")));\n                        return;\n                    }\n                }\n\n                if (!data) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE_2\"),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR,\n                        status : -1\n                    }));\n                    return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n            }\n        } else {\n            // si la réponse (xmlString) est vide, on appelle le callback d'erreur\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        // si tout s'est bien passé, on appelle le callback de succès\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AutoCompleteResponseFactory);\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Request_RouteRequestFactory__ = __webpack_require__(85);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Response_RouteResponseFactory__ = __webpack_require__(93);\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service d'itinéraire du Géoportail :\n *     envoi de la requête construite selon les paramètres en options,\n *     éventuellement parsing et analyse  de la réponse,\n *     retour d'une réponse en paramètre de la fonction onSuccess.\n *\n * @alias Gp.Services.Route\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {String} [options.api] - Manière d'accéder au service : 'REST' (via l'API REST) ou 'OLS' (via la norme XLS).\n * Par défaut, on utilise l'API REST.\n *\n * @param {String} options.outputFormat - Le format de la réponse du service itineraire : 'xml' ou 'json'.\n *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service dans le cas de l'API REST.\n *      Nécessaire si serverUrl est renseigné, et qu'on souhaite passer par l'API REST,\n *      pour connaître le format dans lequel sera fournie la réponse (pour son traitement).\n *      Non nécessaire pour la norme OLS. Par défaut, ce paramètre vaut 'json'.\n *\n * @param {String} [options.routePreference = \"fastest\"] - Mode de calcul à utiliser :\n * - le plus rapide « fastest »\n * - le plus court « shortest »\n * Par défaut : « fastest ».\n *\n * @param {Object} options.startPoint - Point de départ du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)\n * @param {Float} options.startPoint.x - Abcisse du point de départ du calcul d'itinéraire.\n * @param {Float} options.startPoint.y - Ordonnée du point de départ du calcul d'itinéraire.\n *\n * @param {Object} options.endPoint - Point d'arrivée du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)\n * @param {Float} options.endPoint.x - Abcisse du point d'arrivée du calcul d'itinéraire.\n * @param {Float} options.endPoint.y - Ordonnée du point d'arrivée du calcul d'itinéraire.\n *\n * @param {Object[]} [options.viaPoints] - Liste de point ({x:Float,y:Float}) intermédaires que l'itinéraire doit emprunter dans l'ordre du tableau.\n *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326) :{x:float, y:float}\n *\n * @param {String} [options.graph = \"voiture\"] - Type de graphe utilisé : \"Voiture\" ou \"Pieton\".\n *      Détermine le profil de vitesses utilisé pour le calcul ainsi que les tronçons autorisés ou non.\n *      Par défaut, c'est la valeur \"Voiture\" qui sera utilisée.\n *\n * @param {String[]} [options.exclusions] - Critères d'exclusions à appliquer pour le calcul. (correspond au paramètre \"avoidFeature\" d'OpenLS)\n *      On précise ici le type de tronçons que l'on ne veut pas que l'itinéraire emprunte\n *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).\n *\n * @param {Boolean} [options.geometryInInstructions = false] - Indique si la géométrie de l'itinéraire doit être reprise morceau par morceau dans les instructions.\n *      (correspond au paramètre \"provideGeometry\" d'OpenLS) Par défaut : false.\n *\n * @param {Boolean} [options.provideBbox = true] - Indique si les instructions doivent être localisées par une bbox dans la réponse.\n *      Par défaut : true.\n *\n * @param {String} [options.distanceUnit = \"km\"] - Indique si la distance doit être exprimée en km ou m dans la réponse.\n *      Par défaut : km.\n *\n * @param {String} [options.srs] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.\n *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'EPSG:4326'.\n *\n * @example\n *  var options = {\n *      // options communes aux services\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      api : 'OLS',\n *      outputFormat : 'xml',\n *      startPoint : {\n *          x : 42.1121,\n *          y : 1.5557\n *      },\n *      endPoint : {\n *          x : 42.1121,\n *          y : 1.5557\n *      },\n *      provideBbox : false,\n *      exclusions : [\"Bridge\", \"Tunnel\", \"Toll\"],\n *      distanceUnit : \"km\",\n *      graph : \"Voiture\",\n *      geometryInInstructions : false,\n *      routePreference : \"fastest\"\n *  };\n *\n * @private\n */\nfunction Route (options) {\n    if (!(this instanceof Route)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"Route\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"Route\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.Route\");\n    this.logger.trace(\"[Constructeur Route (options)]\");\n\n    if (!options.startPoint) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"startPoint\"));\n    }\n\n    // on lance une exception afin d'eviter au service de le faire...\n    if (options.startPoint.x === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"startPoint.x\"));\n    }\n\n    if (options.startPoint.y === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"startPoint.y\"));\n    }\n\n    if (!options.endPoint) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"endPoint\"));\n    }\n\n    // on lance une exception afin d'eviter au service de le faire...\n    if (options.endPoint.x === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"endPoint.x\"));\n    }\n\n    if (options.endPoint.y === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"endPoint.y\"));\n    }\n\n    // options par defaut\n    // on passe l'option api en majuscules afin d'éviter des exceptions.\n    this.options.api = (typeof options.api === \"string\") ? options.api.toUpperCase() : \"REST\";\n\n    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.\n    this.options.outputFormat = (typeof options.outputFormat === \"string\") ? options.outputFormat.toLowerCase() : \"json\";\n\n    this.options.startPoint = options.startPoint;\n    this.options.endPoint = options.endPoint;\n    this.options.viaPoints = options.viaPoints || null; // INFO mapping viaPoints <=> xls:viaPoint\n    this.options.exclusions = options.exclusions || null; // INFO mapping exclusions <=> xls:avoidFeature\n    this.options.routePreference = options.routePreference || \"fastest\";\n    this.options.graph = options.graph || \"Voiture\";\n    this.options.geometryInInstructions = options.geometryInInstructions || false; // INFO mapping geometryInInstructions <=> xls:provideGeometry\n    this.options.provideBbox = options.provideBbox || true; // INFO mapping provideBbox <=> xls:provideBoundingBox\n    this.options.distanceUnit = options.distanceUnit || \"km\";\n    this.options.expectedStartTime = null; // FIXME not yet implemented !\n    this.options.srs = options.srs || \"EPSG:4326\";\n\n    // FIXME : les readers OLS ne sont pas implémentés. on utilise donc l'API REST.\n    this.options.api = \"REST\";\n    this.logger.warn(\"FIXME : Surcharge option 'api' : REST\");\n    if (this.options.protocol === \"XHR\") {\n        this.options.httpMethod = \"GET\";\n        this.logger.trace(\"Surcharge option 'HttpMethod' : \" + this.options.httpMethod);\n    }\n\n    // gestion de l'url du service par defaut\n    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n    // en fonction du type d'api, REST ou OLS\n    if (!this.options.serverUrl) {\n        var lstUrlByDefault = __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__[\"a\" /* default */].Route.url(this.options.apiKey);\n        var urlFound = null;\n        switch (this.options.api) {\n            case \"OLS\":\n                urlFound = lstUrlByDefault.ols;\n                break;\n            case \"REST\":\n                var key = \"route\" + \"-\" + this.options.outputFormat;\n                urlFound = lstUrlByDefault[key];\n                break;\n            default:\n                throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_UNKNOWN\", \"api\"));\n        }\n\n        if (!urlFound) {\n            throw new Error(\"Url by default not found !\");\n        }\n        this.options.serverUrl = urlFound;\n        this.logger.trace(\"Serveur URL par defaut : \" + this.options.serverUrl);\n    }\n\n    // gestion du type de service\n    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)\n    var idx = this.options.serverUrl.lastIndexOf(\".\");\n    if (idx !== -1) {\n        var extension = this.options.serverUrl.substring(idx + 1);\n        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...\n            this.logger.trace(\"Serveur Extension URL : \" + extension);\n            switch (extension.toLowerCase()) {\n                case \"json\":\n                case \"xml\":\n                    this.options.outputFormat = extension.toLowerCase();\n                    break;\n                default:\n                    throw new Error(\"type of service : unknown or unsupported (json or xml) !\");\n            }\n        }\n    }\n}\n\n/**\n * @lends module:Route#\n */\nRoute.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nRoute.prototype.constructor = Route;\n\n/**\n * (overwrite)\n * Création de la requête\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nRoute.prototype.buildRequest = function (error, success) {\n    var options = {\n        // spécifique au service\n        api : this.options.api,\n        startPoint : this.options.startPoint,\n        endPoint : this.options.endPoint,\n        viaPoints : this.options.viaPoints,\n        provideBbox : this.options.provideBbox,\n        exclusions : this.options.exclusions,\n        distanceUnit : this.options.distanceUnit,\n        graph : this.options.graph,\n        geometryInInstructions : this.options.geometryInInstructions,\n        routePreference : this.options.routePreference,\n        srs : this.options.srs\n    };\n\n    this.request = __WEBPACK_IMPORTED_MODULE_5__Request_RouteRequestFactory__[\"a\" /* default */].build(options);\n\n    // on teste si la requete a bien été construite !\n    if (!this.request) {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\")));\n    } else {\n        success.call(this, this.request);\n    }\n};\n\n/**\n * (overwrite)\n * Analyse de la reponse\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nRoute.prototype.analyzeResponse = function (error, success) {\n    // INFO\n    // Factory pour masquer la complexité du retour du service qui renvoie soit\n    //  - une 'string' qui contient du XML ou JSON natif en mode XHR\n    //  - un objet JSON qui est natif ou encapsulé\n\n    if (this.response) {\n        var options = {\n            distanceUnit : this.options.distanceUnit, // FIXME ce parametre nous permet de choisir le type d'unité dans la reponse !\n            response : this.response,\n            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !\n            api : this.options.api, // utile de connaitre le type d'API car la reponse est differente !\n            rawResponse : this.options.rawResponse,\n            onError : error,\n            onSuccess : success,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_6__Response_RouteResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Route);\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RouteRequestOLS__ = __webpack_require__(86);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RouteRequestREST__ = __webpack_require__(91);\n/**\n * Creation d'une requête OpenLS ou REST en mode POST ou GET\n * (Factory)\n *\n * @module RouteRequestFactory\n * @alias Gp.Services.Route.Request.RouteRequestFactory\n * @private\n */\n\n\n\n\n\nvar RouteRequestFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Route\n     *\n     * @example\n     *   // utilisation avec les callback\n     *   var options = {\n     *      (...)\n     *      onSuccess : function (response) {},\n     *      onError : function (error) {},\n     *      // spécifique au service\n     *      api : 'OLS',\n     *      startPoint : {\n     *          x : 42.1121,\n     *          y : 1.5557\n     *      },\n     *      endPoint : {\n     *          x : 42.1121,\n     *          y : 1.5557\n     *      },\n     *      provideBbox : false,\n     *      exclusions : [\"Bridge\", \"Tunnel\", \"Toll\"],\n     *      distanceUnit : \"km\",\n     *      graph : \"Voiture\",\n     *      geometryInInstructions : false,\n     *      routePreference : \"fastest\"\n     *   };\n     *   RouteRequestFactory.build(options);\n     *\n     *   // utilisation sans callback\n     *   var options = {...};\n     *   try {\n     *      var result = RouteRequestFactory.build(options);\n     *      if (! result) { throw new Error(\"...\"):}\n     *   } catch (e) {\n     *      // todo\n     *   }\n     * @returns {String} request\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RouteRequestFactory\");\n        logger.trace([\"RouteRequestFactory::build()\"]);\n\n        var request = null;\n\n        var settings = options || {};\n\n        // gestion des callback\n        var bOnError = !!((options.onError !== null && typeof options.onError === \"function\"));\n\n        var message = null;\n        // choix entre les 2 types d'API pour consulter le service\n        switch (options.api) {\n            case \"REST\":\n                // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !\n                var myReq = new __WEBPACK_IMPORTED_MODULE_3__RouteRequestREST__[\"a\" /* default */](settings);\n                if (!myReq.processRequestString()) {\n                    message = \"Error process request (rest) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                request = myReq.requestString;\n                break;\n            case \"OLS\":\n                request = __WEBPACK_IMPORTED_MODULE_2__RouteRequestOLS__[\"a\" /* default */].build(settings);\n                if (!request) {\n                    message = \"Error process request (ols) !\";\n                    if (bOnError) {\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                        return;\n                    }\n                    throw new Error(message);\n                }\n                break;\n            default:\n                message = \"Type of API is not supported by service (REST or OLS) !\";\n                if (bOnError) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_1__Exceptions_ErrorService__[\"a\" /* default */](message));\n                    return;\n                }\n                throw new Error(message);\n        }\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteRequestFactory);\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_RouteService__ = __webpack_require__(87);\n/**\n * Creation d'une requête OpenLS en mode POST ou GET\n * (Factory)\n *\n * @module RouteRequestOLS\n * @alias Gp.Services.Route.Request.RouteRequestOLS\n * @private\n */\n\n\n\n\nvar RouteRequestOLS = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Route\n     *\n     * @example\n     *   var options = {\n     *      (...)\n     *   };\n     *\n     * @returns {String} request\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RouteRequestOLS\");\n        logger.trace([\"RouteRequestOLS::build()\"]);\n\n        var request = null;\n\n        // spécifique au service\n        var settings = {\n            startPoint : options.startPoint,\n            endPoint : options.endPoint,\n            viaPoint : options.viaPoints, // mapping OLS et options\n            provideBoundingBox : options.provideBbox, // mapping OLS et options\n            avoidFeature : options.exclusions, // mapping OLS et options\n            expectedStartTime : options.expectedStartTime, // TODO format ?\n            distanceUnit : options.distanceUnit,\n            graph : options.graph,\n            provideGeometry : options.geometryInInstructions, // mapping OLS et options\n            routePreference : options.routePreference\n        };\n\n        // objet RouteService\n        var oRS = new __WEBPACK_IMPORTED_MODULE_2__Formats_XLS_RouteService__[\"a\" /* default */](settings);\n\n        // Format XLS\n        var oXLS = new __WEBPACK_IMPORTED_MODULE_1__Formats_XLS__[\"a\" /* default */]({\n            srsName : options.srs,\n            maximumResponses : options.maximumResponses\n        });\n        oXLS.namespace = true;\n        oXLS.setService(oRS);\n\n        // request brute !\n        request = oXLS.build();\n\n        // en mode GET, la requête est encodée\n        // et le param. 'qxml' est ajouté\n        if (options.httpMethod === \"GET\") {\n            var myRequest = \"qxml=\" +\n                encodeURIComponent(request)\n                    .replace(/-/g, \"%2D\")\n                    .replace(/_/g, \"%5F\")\n                    .replace(/\\./g, \"%2E\")\n                    .replace(/!/g, \"%21\")\n                    .replace(/~/g, \"%7E\")\n                    .replace(/\\*/g, \"%2A\")\n                    .replace(/'/g, \"%27\")\n                    .replace(/\\(/g, \"%28\")\n                    .replace(/\\)/g, \"%29\");\n            request = myRequest;\n        }\n\n        return request;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteRequestOLS);\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AbstractService__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__RouteService_DetermineRouteRequest__ = __webpack_require__(88);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RouteService_RouteRequestExtension__ = __webpack_require__(90);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__RouteService_RouteRequestExtension___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__RouteService_RouteRequestExtension__);\n\n\n\n\n\n/**\n * @classdesc\n *\n * Requête de type RouteService\n * (Factory)\n *\n * XSD :\n * ----\n * [] => non implementé !\n *\n * ```\n * element name=\"DetermineRouteRequest\"\n *  [attribute name=\"provideRouteHandle\" default=\"false\"]\n *  attribute name=\"distanceUnit\"       default=\"M\"\n *      [element ref=\"xls:RouteHandle\" || element ref=\"xls:RoutePlan\"]\n *      element ref=\"xls:RoutePlan\"\n *      element ref=\"xls:RouteInstructionsRequest\"\n *      [element ref=\"xls:RouteGeometryRequest\"]\n *      [element ref=\"xls:RouteMapRequest\"]\n * ```\n * ```\n * element name=\"RoutePlan\"\n *  [attribute name=\"useRealTimeTraffic\" default=\"false\"]\n *  [attribute name=\"expectedStartTime\"  type=\"dateTime\"]\n *  [attribute name=\"expectedEndTime\"    type=\"dateTime\"]\n *      element ref=\"xls:RoutePreference\"\n *      element ref=\"xls:WayPointList\"\n *      element ref=\"xls:AvoidList\"\n * ```\n * ```\n * element name=\"RoutePreference\" => value = Fastest | Shortest | Pedestrian\n * ```\n * ```\n * element name=\"WayPointList\"\n *      element ref=\"xls:StartPoint\"\n *      element ref=\"xls:ViaPoint\" minOccurs=\"0\"\n *      element ref=\"xls:EndPoint\"\n * ```\n * ```\n * element name=\"StartPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"ViaPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"EndPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"AvoidList\"\n *      [element ref=\"xls:AOI\"]\n *      [element ref=\"xls:_Location\"] (cf. element name=\"Position\")\n *      element ref=\"xls:AvoidFeature\"\n * ```\n * ```\n * [element name=\"AOI\"]\n *      [element ref=\"gml:CircleByCenterPoint\" || element ref=\"gml:Polygon\" || element ref=\"gml:Envelope\"]\n * ```\n * ```\n * element name=\"AvoidFeature\" => value = highway | tollway | tunnel | bridge\n * ```\n * ```\n * [element name=\"RouteMapRequest\"]\n *      [element name=\"Output\"]\n *          attribute name=\"width\"\n *          attribute name=\"height\"\n *          attribute name=\"format\"\n *          attribute name=\"BGcolor\"\n *          attribute name=\"transparent\"\n *          attribute name=\"style\" => value = Overview | Maneuver\n *          element name=\"BBoxContext\" type=\"gml:EnvelopeType\"\n * ```\n * ```\n * element name=\"RouteInstructionsRequest\"\n *  [attribute name=\"format\"]           default=\"text/plain\"\n *  attribute name=\"provideGeometry\"    default=\"false\"\n *  attribute name=\"provideBoundingBox\" default=\"false\"\n * ```\n * ```\n * [element name=\"RouteGeometryRequest\"]\n *  [attribute name=\"scale\"]                  default=\"1\"\n *  [attribute name=\"provideStartingPortion\"] default=\"false\"\n *  [attribute name=\"maxPoints\"]              default=\"100\"\n *      [element name=\"BoundingBox\" type=\"gml:EnvelopeType\" ]\n * ```\n *\n * --------\n * Requête :\n * --------\n * ```\n * <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n * <XLS\n * xmlns:xls=\"http://www.opengis.net/xls\"\n * xmlns:sch=\"http://www.ascc.net/xml/schematron\"\n * xmlns:gml=\"http://www.opengis.net/gml\"\n * xmlns:xlsext=\"http://www.opengis.net/xlsext\"\n * xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n * xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n * xsi:schemaLocation=\"http://www.opengis.net/xls http://schemas.opengis.net/ols/1.1.0/RouteService.xsd\"\n * version=\"1.1\" xls:lang=\"en\">\n * <RequestHeader/>\n * <Request methodName=\"RouteRequest\" requestID=\"123456789\" version=\"1.1\">\n *   <DetermineRouteRequest distanceUnit=\"KM\">\n *     <RoutePlan>\n *       <RoutePreference>Fastest</RoutePreference>\n *       <xlsext:vehicle name=\"Car\" />\n *       <WayPointList>\n *         <StartPoint>\n *           <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>2.29993 48.87228</gml:pos></gml:Point></Position>\n *         </StartPoint>\n *         <EndPoint>\n *           <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>-1.53604 47.21548</gml:pos></gml:Point></Position>\n *         </EndPoint>\n *       </WayPointList>\n *     </RoutePlan>\n *     <RouteInstructionsRequest provideGeometry=\"true\"/>\n *     <RouteGeometryRequest/>\n *   </DetermineRouteRequest>\n * </Request>\n * </XLS\n * ```\n * -----------\n * References :\n * -----------\n * - {@link https://geoportail.forge.ign.fr/jira/browse/GPP-CI}\n * - {@link https://geoportail.forge.ign.fr/jira/browse/GPP-CI-1 Specif. ols}\n * - {@link https://geoportail.forge.ign.fr/jira/browse/GPP-CI-9 Extension}\n * - {@link https://github.com/Emergya/openlayers/blob/master/lib/OpenLayers/Format/XLS/v1_2_0.js}\n *\n * @example\n * // encapsule un objet dans une coquille XSL, Factory sur les objets ''\n * rs = new RouteService ();\n * rs.addRequest (req);\n * rs.toString();\n *  ou\n * rs = new RouteService ({\n *      ...\n * });\n * rs.toString();\n *\n * @extends {Gp.Formats.XLS}\n * @constructor\n * @alias Gp.Formats.XLS.RouteService\n * @param {Object} options - options\n * @param {Object}   options.routePreference - « fastest », « shortest » ou « pedestrian »\n * @param {String}   options.startPoint - Point de départ (coordonnées exprimées en WGS84G)\n * @param {String}   options.viaPoint - Liste de points intermédiaires\n * @param {String}   options.endPoint - Point d'arrivée (coordonnées)\n * @param {Object}   options.avoidFeature - « highway », « tollway », « tunnel » ou « bridge »\n * @param {Object}   options.graph - « car »\n * @param {Object}   options.expectedStartTime - Date et heure de départ\n * @param {Object}   options.provideGeometry - true | false\n * @param {Object}   options.provideBoundingBox - true | false\n * @param {Object}   options.distanceUnit - Unité dans lesquelles la distance est exprimée (« m » ou « km »)\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @example\n * var options = {\n *      // spécifique au service\n *      startPoint: {\n *          x: 42.1121,\n *          y: 1.5557\n *      },\n *      endPoint: {\n *          x: 42.1121,\n *          y: 1.5557\n *      },\n *      viaPoint : [\n *          {x: 42.1121,y: 1.5557},\n *          {x: 42.1121,y: 1.5557},\n *          {x: 42.1121,y: 1.5557}\n *      ],\n *      provideBoundingBox : false,\n *      avoidFeature : [\"bridge\", \"tunnel\", \"tollway\"],\n *      expectedStartTime : \"2015-12-23\", // YYYY-MM-DDThh:mm:ssZ\n *      distanceUnit : \"km\",\n *      vehicle: \"car\",\n *      provideGeometry : false,\n *      routePreference : \"fastest\"\n * };\n *\n * @private\n */\nfunction RouteService (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur RouteService ()]\");\n\n    if (!(this instanceof RouteService)) {\n        throw new TypeError(\"RouteService constructor cannot be called as a function.\");\n    }\n\n    /**\n     * Nom de la classe\n     */\n    this.CLASSNAME = \"RouteService\";\n\n    /**\n     * Type de classe\n     * RouteRequest par defaut\n     */\n    this.CLASSTYPE = \"RouteRequest\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_1__AbstractService__[\"a\" /* default */].apply(this, arguments);\n}\n\n/**\n * @lends module:RouteService#\n */\nRouteService.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_1__AbstractService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/**\n * Constructeur (alias)\n */\nRouteService.prototype.constructor = RouteService;\n\n/**\n * (overwrite) Ajout d'un objet de type  : RouteRequest\n *\n * @param {Object} oRequest - RouteRequest\n */\nRouteService.prototype.addRequest = function (oRequest) {\n    // on controle les types acceptés\n    if (oRequest.CLASSNAME === \"DetermineRouteRequest\") {\n        this.oRequest = oRequest;\n    } else {\n        throw new Error(\"Ce n'est pas un objet de type 'Route Request' !?\");\n    }\n};\n\n/**\n * (overwrite) Ajout d'un objet de type RouteFilterExtension\n *\n * @param {Object} oFilter - RouteFilterExtension\n */\nRouteService.prototype.addFilter = function (oFilter) {\n    // gestion des extensions (vehicle)\n    if (oFilter instanceof __WEBPACK_IMPORTED_MODULE_3__RouteService_RouteRequestExtension___default.a) {\n        this.oFilter = oFilter;\n    }\n};\n\n/**\n * (overwrite) toString\n *\n * @returns {String}\n */\nRouteService.prototype.toString = function () {\n    // soit, on a un objet Request déjà instancié\n    // sinon, il faut le construire à partir des options à disposition\n    if (!this.oRequest) {\n        // il nous faut des options\n        if (!this.options) {\n            throw new Error(\"Les options ne sont pas renseignées, impossible de construire la requête !\");\n        }\n\n        if (this.CLASSTYPE === \"RouteRequest\") {\n            var settings = {\n                distanceUnit : this.options.distanceUnit || null,\n                provideGeometry : this.options.provideGeometry || null,\n                provideBoundingBox : this.options.provideBoundingBox || null,\n                route : {\n                    routePreference : this.options.routePreference || null,\n                    startPoint : this.options.startPoint,\n                    viaPoint : this.options.viaPoint || null,\n                    endPoint : this.options.endPoint,\n                    avoidFeature : this.options.avoidFeature || null,\n                    graph : this.options.graph || null,\n                    expectedStartTime : this.options.expectedStartTime || null\n                }\n            };\n            this.oRequest = new __WEBPACK_IMPORTED_MODULE_2__RouteService_DetermineRouteRequest__[\"a\" /* default */](settings);\n            // ajout des filtres spécifiques au service\n            if (this.oFilter) {\n                this.oRequest.addFilter(this.oFilter);\n            }\n        }\n    }\n\n    // objet indefini !?\n    if (!this.oRequest) {\n        throw new Error(\"Type de requête indefini !\");\n    }\n\n    this.strRequest = this.oRequest.toString();\n    return this.strRequest;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteService);\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__model_RoutePlan__ = __webpack_require__(89);\n\n\n\n/**\n * @classdesc\n *\n * Requête de calcul d'itinéraire\n *\n * ----\n * XSD :\n * ----\n * [] => non implementé !\n *\n * ```\n * element name=\"DetermineRouteRequest\"\n *  [attribute name=\"provideRouteHandle\" default=\"false\"]\n *  attribute name=\"distanceUnit\"       default=\"M\"\n *      [element ref=\"xls:RouteHandle\" || element ref=\"xls:RoutePlan\"]\n *      element ref=\"xls:RoutePlan\"\n *      element ref=\"xls:RouteInstructionsRequest\"\n *      [element ref=\"xls:RouteGeometryRequest\"]\n *      [element ref=\"xls:RouteMapRequest\"]\n * ```\n * ```\n * element name=\"RouteInstructionsRequest\"\n *  [attribute name=\"format\"]           default=\"text/plain\"\n *  attribute name=\"provideGeometry\"    default=\"false\"\n *  attribute name=\"provideBoundingBox\" default=\"false\"\n * ```\n * ```\n * element name=\"RouteGeometryRequest\"\n *  [attribute name=\"scale\"]                  default=\"1\"\n *  [attribute name=\"provideStartingPortion\"] default=\"false\"\n *  [attribute name=\"maxPoints\"]              default=\"100\"\n *      [element name=\"BoundingBox\" type=\"gml:EnvelopeType\" ]\n * ```\n * ```\n * [element name=\"RouteMapRequest\"]\n *      [element name=\"Output\"]\n *          [attribute name=\"width\"]\n *          [attribute name=\"height\"]\n *          [attribute name=\"format\"]\n *          [attribute name=\"BGcolor\"]\n *          [attribute name=\"transparent\"]\n *          [attribute name=\"style\"] => value = Overview | Maneuver\n *          [element name=\"BBoxContext\" type=\"gml:EnvelopeType\"]\n * ```\n *\n * --------\n * Requête :\n * --------\n * ```\n *   <DetermineRouteRequest distanceUnit=\"KM\">\n *     <RoutePlan>\n *              <RoutePreference>Fastest</RoutePreference>\n *              <xlsext:vehicle name=\"Car\" />\n *              <WayPointList>\n *                  <StartPoint>\n *                      <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>2.29993 48.87228</gml:pos></gml:Point></Position>\n *                  </StartPoint>\n *                  <EndPoint>\n *                      <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>-1.53604 47.21548</gml:pos></gml:Point></Position>\n *                  </EndPoint>\n *              </WayPointList>\n *     </RoutePlan>\n *     <RouteInstructionsRequest provideGeometry=\"true\"/>\n *     <RouteGeometryRequest/>\n *   </DetermineRouteRequest>\n * ```\n *\n * @constructor\n * @alias Gp.Formats.XLS.RouteService.DetermineRouteRequest\n * @param {Object} options - options\n * @param {Object}   options.route.routePreference - « fastest », « shortest » ou « pedestrian »\n * @param {String}   options.route.startPoint - Point de départ (coordonnées exprimées en WGS84G)\n * @param {String}   options.route.viaPoint - Liste de points intermédiaires\n * @param {String}   options.route.endPoint - Point d'arrivée (coordonnées)\n * @param {Object}   options.route.avoidFeature - « highway », « tollway », « tunnel » ou « bridge »\n * @param {Object}   options.route.vehicle - « car »\n * @param {Object}   options.route.expectedStartTime - Date et heure de départ\n * @param {Object}   options.provideGeometry - true | false\n * @param {Object}   options.provideBoundingBox - true | false\n * @param {Object}   options.distanceUnit - Unité dans lesquelles la distance est exprimée (« m » ou « km »)\n * @param {Function} options.onsuccess - function callback success (TODO)\n * @param {Function} options.onerror   - function callback error   (TODO)\n *\n * @private\n */\nfunction DetermineRouteRequest (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur DetermineRouteRequest ()]\");\n\n    if (!(this instanceof DetermineRouteRequest)) {\n        throw new TypeError(\"DetermineRouteRequest constructor cannot be called as a function.\");\n    }\n\n    // options par defaut\n    this.options = options || {};\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     */\n    this.CLASSNAME = \"DetermineRouteRequest\";\n}\n\nDetermineRouteRequest.prototype = {\n\n    /**\n     * @lends module:DetermineRouteRequest#\n     */\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    strRequest : null,\n\n    /**\n     * RoutePlan\n     * @type {Address}\n     */\n    oRoutePlan : null,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * __DISTANCEUNIT__,\n     * __ROUTEPLAN__, __ROUTEINSTRUCTIONREQUEST__, __ROUTEGEOMETRYREQUEST__, __ROUTEMAPREQUEST__\n     * __PROVIDEGEOMETRY__, __PROVIDEBBOX__\n     */\n    template : {\n        determineRouteRequest : \"<DetermineRouteRequest distanceUnit=\\\"__DISTANCEUNIT__\\\">\" +\n            \"__ROUTEPLAN__\" +\n            \"__ROUTEINSTRUCTIONREQUEST__\" +\n            \"__ROUTEGEOMETRYREQUEST__\" +\n            \"__ROUTEMAPREQUEST__\" +\n            \"</DetermineRouteRequest>\",\n        routeInstructionRequest : \"<RouteInstructionsRequest \" +\n            \"provideGeometry=\\\"__PROVIDEGEOMETRY__\\\" \" +\n            \"provideBoundingBox=\\\"__PROVIDEBBOX__\\\" />\",\n        routeGeometryRequest : \"<RouteGeometryRequest />\",\n        routeMapRequest : \"\" // FIXME <RouteMapRequest/> not yet implemented !\n    },\n\n    /**\n     * Ajout d'un objet de type RoutePlan\n     *\n     * @param {Object} oRoutePlan - RoutePlan\n     */\n    addRoute : function (oRoutePlan) {\n        if (oRoutePlan instanceof __WEBPACK_IMPORTED_MODULE_1__model_RoutePlan__[\"a\" /* default */]) {\n            this.oRoutePlan = oRoutePlan;\n        }\n    },\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : DetermineRouteRequest,\n\n    /**\n     * toString\n     *\n     * @returns {String}\n     */\n    toString : function () {\n        var template = \"\";\n        template = this.template.determineRouteRequest;\n        template = template.replace(/__DISTANCEUNIT__/g, this.options.distanceUnit || \"KM\");\n\n        // soit on a déjà un objet RoutePlan instancié,\n        // sinon, on le fabrique via les options\n        if (!this.oRoutePlan) {\n            var settings = this.options.route;\n\n            this.oRoutePlan = new __WEBPACK_IMPORTED_MODULE_1__model_RoutePlan__[\"a\" /* default */](settings);\n            if (!this.oRoutePlan) {\n                throw new Error(\"La construction du calcul d'initineraire n'est pas correctement definie !?\");\n            }\n        }\n\n        // routeplan\n        template = template.replace(/__ROUTEPLAN__/g, this.oRoutePlan.toString());\n\n        // instruction\n        var tmplInstruction = this.template.routeInstructionRequest;\n        tmplInstruction = tmplInstruction.replace(/__PROVIDEGEOMETRY__/g, this.options.provideGeometry || false);\n        tmplInstruction = tmplInstruction.replace(/__PROVIDEBBOX__/g, this.options.provideBoundingBox || false);\n        template = template.replace(/__ROUTEINSTRUCTIONREQUEST__/g, tmplInstruction);\n\n        // geometry\n        var tmplGeometry = this.template.routeGeometryRequest;\n        template = template.replace(/__ROUTEGEOMETRYREQUEST__/g, tmplGeometry);\n\n        // map\n        var tmplMap = this.template.routeMapRequest;\n        template = template.replace(/__ROUTEMAPREQUEST__/g, tmplMap);\n\n        this.strRequest = template;\n        return this.strRequest;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DetermineRouteRequest);\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n/**\n * @classdesc\n *  * Élément regroupant l'ensemble des données et paramètres pour le calcul d'itinéraire : points de navigation, configuration.\n *\n * ----\n * XSD :\n * ----\n * [] => non implementé !\n *\n * ```\n * element name=\"RoutePlan\"\n *  [attribute name=\"useRealTimeTraffic\" default=\"false\"]\n *  [attribute name=\"expectedStartTime\"  type=\"dateTime\"]\n *  [attribute name=\"expectedEndTime\"    type=\"dateTime\"]\n *      element ref=\"xls:RoutePreference\"\n *      element ref=\"xls:WayPointList\"\n *      element ref=\"xls:AvoidList\"\n * ```\n * ```\n * element name=\"RoutePreference\"\n *  => value = fastest | shortest | pedestrian\n * ```\n * ```\n * element name=\"WayPointList\"\n *      element ref=\"xls:StartPoint\"\n *      element ref=\"xls:ViaPoint\" minOccurs=\"0\"\n *      element ref=\"xls:EndPoint\"\n * ```\n * ```\n * element name=\"StartPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"ViaPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"EndPoint\"\n *    [element name=\"GeocodeMatchCode\"]\n *      [attribute name=\"accuracy\"]\n *      [attribute name=\"matchType\"] => value = City, Street, Street number, Street enhanced, ...\n *    element name=\"Position\"\n *      element ref=\"gml:Point\"\n * ```\n * ```\n * element name=\"AvoidList\"\n *      [element ref=\"xls:AOI\"]\n *      [element ref=\"xls:_Location\"] (cf. element name=\"Position\")\n *      element ref=\"xls:AvoidFeature\"\n * ```\n * ```\n * [element name=\"AOI\"]\n *      [element ref=\"gml:CircleByCenterPoint\" || element ref=\"gml:Polygon\" || element ref=\"gml:Envelope\"]\n * ```\n * ```\n * element name=\"AvoidFeature\" => value = highway | tollway | tunnel | bridge\n * ```\n *\n * --------\n * Requête :\n * --------\n * ```\n *     <RoutePlan>\n *       <RoutePreference>Fastest</RoutePreference>\n *       <xlsext:vehicle name=\"Car\" />\n *       <WayPointList>\n *         <StartPoint>\n *           <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>2.29993 48.87228</gml:pos></gml:Point></Position>\n *         </StartPoint>\n *         <EndPoint>\n *           <Position><gml:Point srsName=\"EPSG:4326\"><gml:pos>-1.53604 47.21548</gml:pos></gml:Point></Position>\n *         </EndPoint>\n *       </WayPointList>\n *       <AvoidList>\n *          <AvoidFeature>highway</AvoidFeature>\n *          <AvoidFeature>tollway</AvoidFeature>\n *          <AvoidFeature>tunnel</AvoidFeature>\n *       </AvoidList>\n *     </RoutePlan>\n * ```\n * @constructor\n * @alias Gp.Formats.XLS.RouteService.RoutePlan\n * @param {Object} options - options\n *\n * @private\n */\nfunction RoutePlan (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RoutePlan\");\n    this.logger.trace(\"[Constructeur RoutePlan ()]\");\n\n    if (!(this instanceof RoutePlan)) {\n        throw new TypeError(\"RoutePlan constructor cannot be called as a function.\");\n    }\n\n    // param par defaut\n    this.options = options || {};\n\n    // param obligatoire\n    if (!options.startPoint) {\n        throw new Error(\"l'option 'startPoint' n'est pas renseignée !\");\n    }\n\n    if (!options.endPoint) {\n        throw new Error(\"l'option 'endPoint' n'est pas renseignée !\");\n    }\n\n    // et on ajoute les options en paramètre aux options par défaut\n    for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n            this.options[opt] = options[opt];\n        }\n    }\n}\n\nRoutePlan.prototype = {\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : RoutePlan,\n\n    /**\n     * request (out)\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Template de la requête.\n     * substitution des valeurs suivantes :\n     * - __ROUTEPREFERENCE__, __VALUEROUTEPREFERENCE__\n     * - __GRAPH__, __VALUEGRAPH__\n     * - __WAYPOINTLIST__ (lst?), __STARTPOINT__, __VIAPOINT__, __ENDPOINT__, __POINT__, __X__, __Y__\n     * - __AVOIDLIST__ (lst!), __AVOIDFEATURE__, __VALUEAVOIDFEATURE__\n     */\n    template : {\n        routePlan : \"<RoutePlan>\" +\n            \"__ROUTEPREFERENCE__\" +\n            \"__GRAPH__\" +\n            \"__WAYPOINTLIST__\" +\n            \"__AVOIDLIST__\" +\n            \"</RoutePlan>\",\n        routePreference : \"<RoutePreference>__VALUEROUTEPREFERENCE__</RoutePreference>\",\n        graph : \"<xlsext:graphName xmlns:xlsext=\\\"http://www.opengis.net/xlsext\\\" name=\\\"__VALUEGRAPH__\\\"/>\",\n        wayPointList : {\n            container : \"<WayPointList>\" +\n                \"__STARTPOINT__\" +\n                \"__VIAPOINT__\" +\n                \"__ENDPOINT__\" +\n                \"</WayPointList>\",\n            point : \"<Position><gml:Point xmlns:gml=\\\"http://www.opengis.net/gml\\\"><gml:pos>__X__ __Y__</gml:pos></gml:Point></Position>\",\n            startPoint : \"<StartPoint>\" +\n                \"__POINT__\" +\n                \"</StartPoint>\",\n            endPoint : \"<EndPoint>\" +\n                \"__POINT__\" +\n                \"</EndPoint>\",\n            viaPoint : \"<ViaPoint>\" +\n                \"__POINT__\" +\n                \"</ViaPoint>\" // implémentation de plusieurs étapes...\n        },\n        avoidList : {\n            container : \"<AvoidList>\" +\n                \"__AVOIDFEATURE__\" +\n                \"</AvoidList>\",\n            avoidFeature : \"<AvoidFeature>__VALUEAVOIDFEATURE__</AvoidFeature>\"\n        }\n    },\n\n    /**\n     * toString\n     *\n     * @returns {String}\n     */\n    toString : function () {\n        var template = \"\";\n        template = this.template.routePlan;\n\n        // preference\n        if (this.options.routePreference) {\n            var tmplPreference = this.template.routePreference;\n            tmplPreference = tmplPreference.replace(/__VALUEROUTEPREFERENCE__/, this.options.routePreference);\n            template = template.replace(/__ROUTEPREFERENCE__/g, tmplPreference);\n        }\n        // clean preference\n        template = template.replace(/__ROUTEPREFERENCE__/g, \"\");\n\n        // exclusions\n        if (this.options.avoidFeature) {\n            var tmplAvoidList = this.template.avoidList.container;\n            var avoidFeatures = [];\n            for (var i = 0; i < this.options.avoidFeature.length; i++) {\n                var tmplAvoidFeature = this.template.avoidList.avoidFeature;\n                tmplAvoidFeature = tmplAvoidFeature.replace(/__VALUEAVOIDFEATURE__/, this.options.avoidFeature[i]);\n                avoidFeatures.push(tmplAvoidFeature);\n            }\n            tmplAvoidList = tmplAvoidList.replace(/__AVOIDFEATURE__/, avoidFeatures.join(\"\\n\"));\n            template = template.replace(/__AVOIDLIST__/g, tmplAvoidList);\n        }\n        // clean exclusions\n        template = template.replace(/__AVOIDLIST__/g, \"\");\n\n        // graph\n        if (this.options.graph) {\n            var tmplVehicle = this.template.graph;\n            tmplVehicle = tmplVehicle.replace(/__VALUEGRAPH__/, this.options.graph);\n            template = template.replace(/__GRAPH__/g, tmplVehicle);\n        }\n        // clean vehicle\n        template = template.replace(/__GRAPH__/g, \"\");\n\n        // points\n        var tmplWayPointList = this.template.wayPointList.container;\n        var tmplPoint = \"\";\n        // start\n        tmplPoint = this.template.wayPointList.point;\n        tmplPoint = tmplPoint.replace(/__X__/, this.options.startPoint.x);\n        tmplPoint = tmplPoint.replace(/__Y__/, this.options.startPoint.y);\n        tmplWayPointList = tmplWayPointList.replace(/__STARTPOINT__/,\n            this.template.wayPointList.startPoint.replace(/__POINT__/, tmplPoint));\n        // end\n        tmplPoint = this.template.wayPointList.point;\n        tmplPoint = tmplPoint.replace(/__X__/, this.options.endPoint.x);\n        tmplPoint = tmplPoint.replace(/__Y__/, this.options.endPoint.y);\n        tmplWayPointList = tmplWayPointList.replace(/__ENDPOINT__/,\n            this.template.wayPointList.endPoint.replace(/__POINT__/, tmplPoint));\n        // via\n        if (this.options.viaPoint) {\n            var points = [];\n            for (var j = 0; j < this.options.viaPoint.length; j++) {\n                var p = this.options.viaPoint[j];\n                tmplPoint = this.template.wayPointList.point;\n                tmplPoint = tmplPoint.replace(/__X__/, p.x);\n                tmplPoint = tmplPoint.replace(/__Y__/, p.y);\n                points.push(tmplPoint);\n            }\n\n            tmplWayPointList = tmplWayPointList.replace(/__VIAPOINT__/,\n                this.template.wayPointList.viaPoint.replace(/__POINT__/, points.join(\"\\n\")));\n        } else {\n            // clean viaPoint\n            tmplWayPointList = tmplWayPointList.replace(/__VIAPOINT__/, \"\");\n        }\n\n        template = template.replace(/__WAYPOINTLIST__/g, tmplWayPointList);\n\n        this.requestString = template;\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RoutePlan);\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports) {\n\n/**\n * not implemented !\n *\n * Extension de type 'graphName' de l'objet RoutePlan'\n *\n * FIXME L'extension 'graphName' est intégré comme étant du standard OLS.\n *       La balise <xlsext:GraphName> viendrait surcharger le comportement de RoutePreference...\n *\n * ex. <xlsext:graphName name=\"Voiture\" />\n */\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_RouteParamREST__ = __webpack_require__(92);\n\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des requêtes de type REST sur le service de calcul d'itineraire\n * (uniquement en GET)\n *\n * @constructor\n * @alias Gp.Services.Route.Request.RouteRequestREST\n * @param {Object} options - options definies dans le composant Route\n *\n * @example\n * var options = {\n *      (...)\n * };\n *\n * @private\n */\nfunction RouteRequestREST (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RouteRequestREST\");\n    this.logger.trace(\"[Constructeur RouteRequestREST ()]\");\n\n    if (!(this instanceof RouteRequestREST)) {\n        throw new TypeError(\"RouteRequestREST constructor cannot be called as a function.\");\n    }\n\n    // existance des options\n    if (!options) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"options\"));\n    }\n\n    /** liste des options */\n    this.settings = options;\n}\n\nRouteRequestREST.prototype = {\n\n    /**\n     * @lends module:RouteRequestREST#\n     */\n\n    /**\n     * request\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : RouteRequestREST,\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out : origin=2.416907353809513,48.8465772142297&destination=2.4248037771493673,48.84591353161838\n     * // POST out : Not yet supported method POST !\n     * @returns {String} request\n     */\n    processRequestString : function () {\n        // INFO\n        // construction simple sans template...,\n        // mais en attendant que les services soient fixés, on taggue ce composant en mode PROTOTYPE !\n        this.logger.warn(\"FIXME : PROTOTYPE !\");\n\n        // Mapping des options avec le service de l'API REST\n        var oParams = new __WEBPACK_IMPORTED_MODULE_2__model_RouteParamREST__[\"a\" /* default */](this.settings);\n        var params = oParams.getParams();\n\n        var request = \"\";\n        for (var i = 0; i < params.length; i++) {\n            var o = params[i];\n            if (request) {\n                request += \"&\";\n            }\n            request += o.k + \"=\" + o.v;\n        }\n\n        // Exemple :\n        //  http://wxs.ign.fr/KEY/itineraire/rest/route.json?\n        //  origin=&\n        //  destination=&\n        //  waypoints=&\n        //  method=DISTANCE&\n        //  graph=Pieton&\n        //  graphName=Pieton&\n        //  exclusions=&\n        //  tolerance=10&\n        //  srs=\n\n        this.logger.trace(request);\n        this.requestString = request;\n\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteRequestREST);\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n\n/**\n * @classdesc\n * Classe de gestion des param. des requêtes du service de calcul d'itineraire (REST).\n *      Permet le mapping avec les options du service.\n * @constructor\n * @alias Gp.Services.Route.Request.RouteParamREST\n * @param {Object} options - options\n *\n * @private\n */\nfunction RouteParamREST (options) {\n    if (!(this instanceof RouteParamREST)) {\n        throw new TypeError(\"RouteParamREST constructor cannot be called as a function.\");\n    }\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur RouteParamREST ()]\");\n\n    /**\n     * Options en paramêtres du constructeur.\n     */\n    this.options = options || {};\n\n    // mapping des options avec l'API REST\n\n    /** Coordonnées du point de départ. */\n    this.origin = this.options.startPoint.x + \",\" + this.options.startPoint.y;\n\n    /** Coordonnées du point d’arrivée. */\n    this.destination = this.options.endPoint.x + \",\" + this.options.endPoint.y;\n\n    /** Coordonnées des étapes point de départ. */\n    this.waypoints = this.options.viaPoints || null;\n\n    /** Date et heure de départ */\n    this.startDateTime = this.options.expectedStartTime || null; // TODO format !?\n\n    /** Nom du graphe à utiliser */\n    this.graphName = this.options.graph;\n\n    /** projection (code EPSG comme epsg:4326 ou wgs84) */\n    this.srs = this.options.srs;\n\n    /** Liste des règles de restrictions à utiliser, séparés pas le caractère , ou ; (Exemple : Toll, Tunnel, Bridge) */\n    this.exclusions = this.options.exclusions;\n\n    /**\n     * itinéraire le plus court (DISTANCE) ou le plus rapide (TIME)\n     * Par defaut, DISTANCE...\n     * cf. mapping ci dessous\n     */\n    this.method = \"TIME\";\n\n    // mapping particulier sur l'option 'routePreference'\n    if (this.options.routePreference) {\n        var value = this.options.routePreference;\n        switch (value) {\n            case \"fastest\":\n                this.method = \"TIME\";\n                break;\n            case \"shortest\":\n                this.method = \"DISTANCE\";\n                break;\n            default:\n                this.logger.warn(\"Par defaut, on prend l'itinéraire le plus rapide !\");\n                this.method = \"TIME\";\n        }\n    }\n\n    /** Format de sortie (résumé de l’itinéraire) */\n    this.format = (this.options.geometryInInstructions) ? \"STANDARDEXT\" : \"STANDARD\";\n\n    // y'a t-il d'autres options à ajouter (par defaut) ?\n\n    /** Distance de tolérance (en mètre) de simplification de la géométrie. */\n    this.tolerance = 10;\n\n    /** identifiant du véhicule (enregistré dans les profils de véhicule) à utiliser */\n    this.profileId = null;\n\n    /** Profil du véhicule (enregistré dans les profils de véhicule) à utiliser */\n    this.profileName = null;\n\n    // options dont le mapping n'est pas possible :\n    // - distanceUnit\n    // - provideBoundingBox\n}\n\n/**\n * CLASSNAME\n */\nRouteParamREST.CLASSNAME = \"RouteParamREST\";\n\nRouteParamREST.prototype = {\n\n    /**\n     * @lends module:RouteParamREST#\n     */\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : RouteParamREST,\n\n    /**\n     * Retourne une liste de points\n     * @returns {Array} une liste de points (sep ';')\n     */\n    getWaypoints : function () {\n        if (!this.waypoints) {\n            return;\n        }\n        var array = [];\n        for (var i = 0; i < this.waypoints.length; i++) {\n            var obj = this.waypoints[i];\n            array.push(obj.x + \",\" + obj.y);\n        }\n\n        return array.join(\";\");\n    },\n\n    /**\n     * Retourne la liste des exclusions\n     * @returns {Array} une liste d'exclusions (sep ';')\n     */\n    getExclusions : function () {\n        return this.exclusions.join(\";\");\n    }\n};\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Array} liste de paramêtres\n */\nRouteParamREST.prototype.getParams = function () {\n    var map = [];\n\n    map.push({\n        k : \"origin\",\n        v : this.origin\n    });\n\n    map.push({\n        k : \"destination\",\n        v : this.destination\n    });\n\n    map.push({\n        k : \"method\",\n        v : this.method\n    });\n\n    if (this.waypoints) {\n        map.push({\n            k : \"waypoints\",\n            v : this.getWaypoints()\n        });\n    }\n\n    if (this.startDateTime) {\n        map.push({\n            k : \"startDateTime\",\n            v : this.startDateTime\n        });\n    }\n\n    if (this.graphName) {\n        map.push({\n            k : \"graphName\",\n            v : this.graphName\n        });\n    }\n\n    if (this.exclusions) {\n        map.push({\n            k : \"exclusions\",\n            v : this.getExclusions()\n        });\n    }\n\n    if (this.srs) {\n        map.push({\n            k : \"srs\",\n            v : this.srs\n        });\n    }\n\n    if (this.format) {\n        map.push({\n            k : \"format\",\n            v : this.format\n        });\n    }\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteParamREST);\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Formats_WKT__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Formats_RouteResponseRESTReader__ = __webpack_require__(94);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Formats_RouteResponseOLSReader__ = __webpack_require__(95);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__model_RouteResponse__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__model_RouteInstruction__ = __webpack_require__(17);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON\n * (Factory)\n *\n * @module RouteResponseFactory\n * @alias Gp.Services.Route.Response.RouteResponseFactory\n * @private\n */\n\n\n\n\n\n\n\n\n\n\nvar RouteResponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant Alti\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      outputFormat :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RouteResponseFactory\");\n        logger.trace(\"RouteResponseFactory::build()\");\n\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                logger.trace(\"analyze response : raw\");\n                data = options.response;\n            } else {\n                switch (options.outputFormat) {\n                    case \"xml\":\n                        logger.trace(\"analyze response : xml\");\n\n                        // type de reader en fonction de l'API\n                        var routeReader = options.api === \"REST\" ? __WEBPACK_IMPORTED_MODULE_5__Formats_RouteResponseRESTReader__[\"a\" /* default */] : __WEBPACK_IMPORTED_MODULE_6__Formats_RouteResponseOLSReader__[\"a\" /* default */];\n\n                        try {\n                            var p = new __WEBPACK_IMPORTED_MODULE_3__Formats_XML__[\"a\" /* default */]({\n                                reader : routeReader\n                            });\n\n                            // FIXME : mode XHR ne retourne que des string ? JSONP aussi à ce niveau ?\n                            if (typeof options.response === \"string\") {\n                                p.setXMLString(options.response);\n                            } else {\n                                p.setXMLDoc(options.response);\n                            }\n\n                            data = p.parse();\n\n                            if (!data) {\n                                throw new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT\", \"xml\"));\n                            }\n                        } catch (e) {\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", options.response)));\n                            return;\n                        }\n\n                        break;\n\n                    case \"json\":\n                        logger.trace(\"analyze response : json\");\n\n                        var JSONResponse;\n                        if (typeof options.response === \"string\") {\n                            JSONResponse = JSON.parse(options.response);\n                        } else {\n                            JSONResponse = options.response;\n                        }\n\n                        // le service renvoie t il une erreur ?\n                        if (JSONResponse.message) {\n                            // ex. {\"message\":\"message not null\", \"status\":\"ERROR\"}\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", JSONResponse.message)));\n                            return;\n                        }\n\n                        // construction de l'objet réponse JSON\n                        if (JSONResponse) {\n                            var legs = [];\n                            var legSteps = [];\n                            var steps = [];\n\n                            data = new __WEBPACK_IMPORTED_MODULE_7__model_RouteResponse__[\"a\" /* default */]();\n\n                            if (data.hasOwnProperty(\"totalTime\")) {\n                                // info : il y a aussi JSONResponse.duration, qui donne la durée en hh:mm:ss.\n                                data.totalTime = parseFloat(JSONResponse.durationSeconds);\n                            }\n                            if (data.hasOwnProperty(\"totalDistance\")) {\n                                data.totalDistance = (options.distanceUnit === \"m\") ? JSONResponse.distanceMeters : JSONResponse.distance;\n                            }\n\n                            if (data.hasOwnProperty(\"bbox\")) {\n                                var coords = JSONResponse.bounds.split(/[,;]/);\n                                data.bbox.left = parseFloat(coords[0]);\n                                data.bbox.bottom = parseFloat(coords[1]);\n                                data.bbox.right = parseFloat(coords[2]);\n                                data.bbox.top = parseFloat(coords[3]);\n                            }\n                            /**\n                            * callback success\n                            * @param {Object} json - json\n                            * @private\n                            */\n                            var onWKTSuccess = function (json) {\n                                data.routeGeometry = json;\n                            };\n                            /**\n                            * callback failed\n                            * @param {Object} e - event\n                            * @private\n                            */\n                            var onWKTError = function (e) {\n                                console.log(e);\n                                options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_FORMAT\", [\"geometryWkt\"])));\n                            };\n\n                            if (data.hasOwnProperty(\"routeGeometry\")) {\n                                var geometry = JSONResponse.geometryWkt || JSONResponse.simplifiedWkt;\n                                if (geometry) {\n                                    __WEBPACK_IMPORTED_MODULE_4__Formats_WKT__[\"a\" /* default */].toJson(geometry, onWKTSuccess, onWKTError);\n                                    if (!data.routeGeometry) {\n                                        return;\n                                    }\n                                }\n                            }\n\n                            if (data.hasOwnProperty(\"routeInstructions\")) {\n                                var legList = JSONResponse.legs;\n                                var i;\n                                if (Array.isArray(legList) && legList.length) {\n                                    for (i = 0; i < legList.length; i++) {\n                                        legs.push(legList[i]);\n                                    }\n                                }\n                                if (Array.isArray(legs) && legs.length) {\n                                    for (i = 0; i < legs.length; i++) {\n                                        legSteps.push(legs[i].steps);\n                                    }\n                                }\n                                if (Array.isArray(legSteps) && legSteps.length) {\n                                    for (i = 0; i < legSteps.length; i++) {\n                                        steps = steps.concat(legSteps[i]);\n                                    }\n                                }\n\n                                steps.forEach(function (step) {\n                                    data.routeInstructions.push(new __WEBPACK_IMPORTED_MODULE_8__model_RouteInstruction__[\"a\" /* default */]());\n                                    data.routeInstructions[data.routeInstructions.length - 1].duration = step.durationSeconds;\n                                    data.routeInstructions[data.routeInstructions.length - 1].distance = (options.distanceUnit === \"m\") ? step.distanceMeters : step.distance;\n                                    data.routeInstructions[data.routeInstructions.length - 1].code = step.navInstruction;\n                                    // geometrie en geojson\n                                    var points = [];\n                                    for (var i = 0; i < step.points.length; i++) {\n                                        var point = step.points[i].split(\",\");\n                                        if (point) {\n                                            points.push(point);\n                                        }\n                                    }\n                                    if (points && points.length !== 0) {\n                                        data.routeInstructions[data.routeInstructions.length - 1].geometry = {\n                                            coordinates : points,\n                                            type : \"LineString\"\n                                        };\n                                    } else {\n                                        data.routeInstructions[data.routeInstructions.length - 1].geometry = null;\n                                    }\n\n                                    /*\n                                    Traduction du code en instruction\n                                    * - F : tout droit\n                                    * - B : demi-tour\n                                    * - L : tourner à gauche\n                                    * - R : tourner à droite\n                                    * - BL : tourner très à gauche\n                                    * - BR : tourner très à droite\n                                    * - FL : tourner légèrement à gauche\n                                    * - FR : tourner légèrement à droite\n                                    * - round_about_entry : entrée rond-point\n                                    * - round_about_exit : sortie rond-point\n                                    */\n\n                                    // on ne souhaite pas de ce type de valeur...\n                                    if (step.name === \"Valeur non renseignée\") {\n                                        step.name = \"\";\n                                    }\n\n                                    switch (step.navInstruction) {\n                                        case \"F\":\n                                            if (step.name) {\n                                                data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tout droit \" + step.name;\n                                            } else {\n                                                data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Continuer tout droit \";\n                                            }\n                                            break;\n                                        case \"B\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Demi-tour \" + step.name;\n                                            break;\n                                        case \"L\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner à gauche \" + step.name;\n                                            break;\n                                        case \"R\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner à droite \" + step.name;\n                                            break;\n                                        case \"BL\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner très à gauche \" + step.name;\n                                            break;\n                                        case \"BR\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner très à droite \" + step.name;\n                                            break;\n                                        case \"FL\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner légèrement à gauche \" + step.name;\n                                            break;\n                                        case \"FR\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Tourner légèrement à droite \" + step.name;\n                                            break;\n                                        case \"round_about_entry\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Entrée rond-point \" + step.name;\n                                            break;\n                                        case \"round_about_exit\":\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Sortie rond-point \" + step.name;\n                                            break;\n                                        case null:\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"Prendre tout droit \" + step.name;\n                                            break;\n                                        default:\n                                            data.routeInstructions[data.routeInstructions.length - 1].instruction = \"?\" + step.navInstruction + \"? \" + step.name;\n                                            break;\n                                    }\n                                });\n                            }\n                        }\n\n                        if (!data) {\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", \"json\")));\n                            return;\n                        }\n                        break;\n\n                    default:\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT\", \"json\", \"xml\")));\n                        return;\n                }\n\n                // Si la réponse contenait une exception renvoyée par le service\n                if (data && data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION_2\")));\n                    return;\n                }\n            }\n        } else {\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteResponseFactory);\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Formats_WKT__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Response_model_RouteResponse__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Response_model_RouteInstruction__ = __webpack_require__(17);\n/**\n * Analyse de la reponse REST\n *\n * @module RouteResponseRESTReader\n * @alias Gp.Services.Route.Formats.RouteResponseRESTReader\n * @todo not yet implemented !\n * @private\n */\n\n// import Logger from \"../../../Utils/LoggerByDefault\";\n\n\n\n\n\n\n/**\n * Objet RouteResponseRestReader\n * @member {Object} RouteResponseRestReader\n *\n * @property {Object} RouteResponseRestReader.READERS - Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} RouteResponseRestReader.read - Méthode permettant de lancer la lecture d'une réponse XML du\n *      service de calcul d'itineraire, à l'aide des readers de la classe.\n *\n */\n\nvar RouteResponseRESTReader = {};\n\nRouteResponseRESTReader.READERS = {\n\n    /** TODO : jsdoc block */\n    routeResult : function (node) {\n        var response = new __WEBPACK_IMPORTED_MODULE_3__Response_model_RouteResponse__[\"a\" /* default */]();\n\n        // on boucle sur les balises \"enfant\" de la réponse :\n        // status, distance, duration, distanceMeters, durationSeconds, bounds, geometryWkt, simplifiedWkt, leg\n        __getChildNodes(node, response);\n\n        if (response.status === \"error\") {\n            var message = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\",\n                response.message);\n            throw new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : message,\n                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n            });\n        }\n\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    status : function (node, response) {\n        var status = __getChildValue(node);\n        if (status === \"ERROR\" || status === \"error\") {\n            if (response) {\n                response.status = \"error\";\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    message : function (node, response) {\n        if (response) {\n            response.message = __getChildValue(node);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    distance : function (node, response) {\n        if (response) {\n            response.totalDistance = __getChildValue(node);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    durationSeconds : function (node, response) {\n        if (response) {\n            response.totalTime = parseFloat(__getChildValue(node));\n        }\n    },\n\n    /** TODO : jsdoc block */\n    bounds : function (node, response) {\n        // get value et split et parseFloat\n        if (response && response.bbox) {\n            var coords = __getChildValue(node).split(/[,;]/);\n            response.bbox.left = parseFloat(coords[0]);\n            response.bbox.bottom = parseFloat(coords[1]);\n            response.bbox.right = parseFloat(coords[2]);\n            response.bbox.top = parseFloat(coords[3]);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    geometryWkt : function (node, response) {\n        if (response) {\n            var geomWkt = node.innerHTML;\n\n            /** TODO : jsdoc block */\n            var onWKTSuccess = function (json) {\n                response.routeGeometry = json;\n            };\n\n            /** TODO : jsdoc block */\n            var onWKTError = function () {\n                var msg = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_FORMAT\", [\"geometryWkt\"]);\n                throw new Error(msg);\n            };\n            // get WKT Geometry from string\n            __WEBPACK_IMPORTED_MODULE_1__Formats_WKT__[\"a\" /* default */].toJson(geomWkt, onWKTSuccess, onWKTError);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    step : function (node, response) {\n        // création d'une nouvelle instruction\n        var routeInstruction = new __WEBPACK_IMPORTED_MODULE_4__Response_model_RouteInstruction__[\"a\" /* default */]();\n        var name;\n\n        // lecture des informations de l'instruction (balises enfants)\n        if (node.hasChildNodes) {\n            var children = node.childNodes;\n            var child;\n            var childName;\n\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n\n                if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                    childName = child.localName || child.baseName || child.nodeName;\n\n                    if (childName === \"durationSeconds\") {\n                        routeInstruction.duration = __getChildValue(child);\n                    } else if (childName === \"distance\") {\n                        routeInstruction.distance = __getChildValue(child);\n                    } else if (childName === \"navInstruction\") {\n                        routeInstruction.code = __getChildValue(child);\n                    } else if (childName === \"name\") {\n                        name = __getChildValue(child);\n                    }\n                }\n            }\n        }\n\n        // on teste le code de l'instruction pour y ajouter la bonne description\n        if (routeInstruction.code) {\n            switch (routeInstruction.code) {\n                case \"F\":\n                    if (name !== \"Valeur non renseignée\") {\n                        routeInstruction.instruction = \"Tout droit \" + name;\n                    } else {\n                        routeInstruction.instruction = \"Continuer tout droit \";\n                    }\n                    break;\n                case \"B\":\n                    routeInstruction.instruction = \"Demi-tour \" + name;\n                    break;\n                case \"L\":\n                    routeInstruction.instruction = \"Tourner à gauche \" + name;\n                    break;\n                case \"R\":\n                    routeInstruction.instruction = \"Tourner à droite \" + name;\n                    break;\n                case \"BL\":\n                    routeInstruction.instruction = \"Tourner très à gauche \" + name;\n                    break;\n                case \"BR\":\n                    routeInstruction.instruction = \"Tourner très à droite \" + name;\n                    break;\n                case \"FL\":\n                    routeInstruction.instruction = \"Tourner légèrement à gauche \" + name;\n                    break;\n                case \"FR\":\n                    routeInstruction.instruction = \"Tourner légèrement à droite \" + name;\n                    break;\n                case \"round_about_entry\":\n                    routeInstruction.instruction = \"Entrée rond-point \" + name;\n                    break;\n                case \"round_about_exit\":\n                    routeInstruction.instruction = \"Sortie rond-point \" + name;\n                    break;\n                case null:\n                    routeInstruction.instruction = \"Prendre \" + name;\n                    break;\n                default:\n                    routeInstruction.instruction = \"?\" + routeInstruction.code + \"? \" + name;\n                    break;\n            }\n        }\n\n        if (Array.isArray(response.routeInstructions)) {\n            response.routeInstructions.push(routeInstruction);\n        }\n    }\n\n};\n\n/** TODO : jsdoc block */\nRouteResponseRESTReader.read = function (root) {\n    var response;\n\n    if (root.nodeName === \"routeResult\") {\n        response = RouteResponseRESTReader.READERS[\"routeResult\"](root);\n        return response;\n    } else {\n        throw new Error(\"Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.\");\n    }\n};\n\n/**\n * Lecture de la valeur du premier child d'un noeud, si elle existe.\n *\n * @private\n * @memberof RouteResponseRESTReader\n * @method __getChildValue\n * @param {DOMElement} node - a DOM node\n * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.\n */\nfunction __getChildValue (node) {\n    var textNode;\n    var value = \"\";\n\n    if (node.hasChildNodes()) {\n        textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            value = textNode.nodeValue;\n        }\n    }\n    return value;\n}\n\n/**\n * Récupération des noeuds enfants à partir d'un noeud donné, pour lecture (readNode).\n *\n * @private\n * @memberof RouteResponseRESTReader\n * @method __getChildNodes\n * @param {DOMElement} node - a DOM node\n * @param {Array|Object} [data] - an object to be filled with node data\n */\nfunction __getChildNodes (node, data) {\n    if (node.hasChildNodes()) {\n        var children = node.childNodes;\n        var child;\n        var childName;\n\n        for (var i = 0; i < children.length; i++) {\n            child = children[i];\n\n            if (child.nodeType === 1) { // 1 === node.ELEMENT_NODE\n                childName = child.localName || child.baseName || child.nodeName;\n\n                if (RouteResponseRESTReader.READERS[childName]) {\n                    var reader = RouteResponseRESTReader.READERS[childName];\n                    reader(child, data);\n                } else {\n                    __getChildNodes(child, data);\n                }\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteResponseRESTReader);\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/**\n * Analyse de la reponse OLS\n *\n * @module RouteResponseOLSReader\n * @alias Gp.Services.Route.Formats.RouteResponseOLSReader\n * @todo not yet implemented !\n * @private\n */\n\n\n\n/**\n * Objet RouteResponseOLSReader\n * @member {Object} RouteResponseOLSReader\n *\n * @property {Object} RouteResponseOLSReader.READERS - Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} RouteResponseOLSReader.read -  Méthode permettant de lancer la lecture d'une réponse\n *      XML du service de calcul d'itineraire, à l'aide des readers de la classe.\n */\nvar RouteResponseOLSReader = {};\n\n/**\n * Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n * @static\n * @memberof RouteResponseOLSReader\n */\nRouteResponseOLSReader.READERS = {\n    /*\n        // INFO\n        // pas de reponse en JSON pour l'API OLS, uniquement du XML !\n\n        // INFO\n        // Exemple d'erreur du service\n        // <?xml version= \"1.0\" encoding= \"UTF-8\" standalone= \"yes\" ?>\n        // <XLS version=\"1.2\" xsi : schemaLocation = \"http://www.opengis.net/xls http://schemas.opengis.net/ols/1.2/olsAll.xsd\" xmlns : xls = \"http://www.opengis.net/xls\" xmlns= \"http://www.opengis.net/xls\" xmlns : xlsext = \"http://www.opengis.net/xlsext\" xmlns : gml = \"http://www.opengis.net/gml\" // xmlns : xsi = \"http://www.w3.org/2001/XMLSchema-instance\" >\n        // <ResponseHeader>\n        //     <ErrorList>\n        //         <Error message=\"Routing error : Error in smartrouting com.geoconcept.smartrouting.SmartRoutingNativeException : failed to connect waypoint { 48.846577, 2.416907, 0.000000 } failed to connect waypoint { 48.846577, 2.416907, 0.000000 } \" errorCode=\"InternalServerError\"/>\n        //     </ErrorList>\n        // </ResponseHeader>\n        // <Response version= \"1.2\" requestID= \"f8358c74-8aee-4203-90b9-2c70db5996a1\" />\n        // </XLS>\n\n        // INFO\n        // Exemple d'erreur NGinx\n        // <ExceptionReport><Exception exceptionCode=\"MissingParameter\">Resource parameter not found</Exception></ExceptionReport>\n    */\n};\n\n/**\n * Méthode permettant de lancer la lecture d'une réponse XML du service de calcul d'itineraire,\n * à l'aide des readers de la classe.\n *\n * @method RouteResponseOLSReader.read\n * @param {DOMElement} root - racine de la réponse XML à lire\n * @static\n * @memberof RouteResponseOLSReader\n */\nRouteResponseOLSReader.read = function (root) {\n    // logger\n    var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"RouteResponseOLSReader\");\n    logger.error(\"not yet implemented !\");\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RouteResponseOLSReader);\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CommonService__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Request_ProcessIsoCurveRequest__ = __webpack_require__(97);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Response_ProcessIsoCurveResponseFactory__ = __webpack_require__(99);\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Appel du service d'isochrone/distance du Géoportail :\n *     envoi de la requête construite selon les paramètres en options,\n *     éventuellement parsing et analyse  de la réponse,\n *     retour d'une réponse en paramètre de la fonction onSuccess.\n * @constructor\n * @extends {Gp.Services.CommonService}\n * @alias Gp.Services.ProcessIsoCurve\n * @param {Object} options - options spécifiques au service (+ les options heritées)\n *\n * @param {String} options.outputFormat - Le format de la réponse du service iso : 'xml' ou 'json'.\n *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service.\n *      Nécessaire si serverUrl est renseigné pour connaître le format dans lequel sera fournie la réponse (pour son traitement).\n *      Par défaut, ce paramètre vaut 'json'.\n *\n * @param {Object} options.position - Point de départ du calcul.\n *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326)\n *      @param {Float} options.position.x - Abcisse du point de départ du calcul d'isochrone/distance.\n *      @param {Float} options.position.y - Ordonnée du point de départ du calcul d'isochrone/distance.\n *\n * @param {String} options.srs - Projection.\n *      Système de coordonnées dans lequel les coordonnées du point « location » sont exprimées et\n *      dans lequel la géométrie de la courbe résultante sera exprimée.\n *      Par défaut, le système de coordonnées utilisé sera « EPSG:4326 ».\n *\n * @param {String} [options.graph = \"voiture\"] - Nom du graphe à utiliser pour le calcul (« Pieton » ou « Voiture »).\n *      La valeur par défaut est : «voiture»\n *\n * @param {Array.<String>} [options.exclusions] - Critères d'exclusions à appliquer pour le calcul.\n *      On précise ici le type de tronçons que l'on ne veut pas que l'isochrone/distance emprunte\n *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).\n *\n * @param {String} [options.method = \"time\"] - Méthode utilisée pour le calcul de la courbe iso.\n *      Les valeurs possible sont \"time\" pour un calcul d'isochrone, \"distance\" pour un calcul d'isodistance.\n *      Pas de valeur spécifié équivaut à un calcul d'isochrone.\n *\n * @param {Float} options.time - Durée maximum (exprimée en secondes) à utiliser pour le calcul de la courbe à partir du ou jusqu'au point « location ».\n *      Ce paramètre doit être renseigné si l'option \"méthod\" a la valeur \"time\".\n *      Si l'option method n'est pas renseignée, ce paramètre doit être renseigné.\n *\n * @param {Float} options.distance - Distance maximum (exprimée en metres) à utiliser pour le calcul de la courbe à partir du ou j'usqu'au point « location ».\n *      Ce paramètre doit être renseigné si l'option \"méthod\" a la valeur \"DISTANCE\".\n *      Si l'option \"method\" n'est pas renseignée, ce paramètre sera ignoré.\n *\n * @param {Boolean} [options.reverse = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.\n *      Par défaut, la valeur « false » est appliquée.\n *\n * @param {Boolean} [options.smoothing = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.\n *      Par défaut, la valeur « false » est appliquée.\n *\n * @param {Boolean} [options.holes = false] - Indique si la géométrie résultante (surface) doit être retournée avec des trous (« true »).\n *      Par défaut, la valeur « false » est appliquée.\n *\n * @example\n *   var options = {\n *      // options communes aux services\n *      apiKey : null,\n *      serverUrl : 'http://localhost/service/',\n *      protocol : 'JSONP', // JSONP|XHR\n *      proxyURL : null,\n *      httpMethod : 'GET', // GET|POST\n *      timeOut : 10000, // ms\n *      rawResponse : false, // true|false\n *      scope : null, // this\n *      onSuccess : function (response) {},\n *      onFailure : function (error) {},\n *      // spécifique au service\n *      position : {\n *           x : 2.3242664298058053,\n *           y : 48.86118017324745\n *      },\n *      distance : 200,\n *      [time : ]\n *      method : \"distance\",\n *      exclusions : [\"Bridge\", \"Tunnel\", \"Toll\"],\n *      graph : \"voiture\",\n *      reverse : false,\n *      smoothing : false,\n *      holes : false\n *  };\n * @private\n */\n\nfunction ProcessIsoCurve (options) {\n    if (!(this instanceof ProcessIsoCurve)) {\n        throw new TypeError(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"CLASS_CONSTRUCTOR\", \"ProcessIsoCurve\"));\n    }\n\n    /**\n     * Nom de la classe (heritage)\n     * FIXME instance ou classe ?\n     */\n    this.CLASSNAME = \"ProcessIsoCurve\";\n\n    // appel du constructeur par heritage\n    __WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].apply(this, arguments);\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"Gp.Services.ProcessIsoCurve\");\n    this.logger.trace(\"[Constructeur ProcessIsoCurve (options)]\");\n\n    if (!options.position) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position\"));\n    }\n\n    // on lance une exception afin d'eviter au service de le faire...\n    if (options.position.x === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position.x\"));\n    }\n\n    if (options.position.y === null) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_MISSING\", \"position.y\"));\n    }\n\n    if (!options.time && !options.distance) {\n        throw new Error(\"Parameter (s) 'distance' missing. Parameter time to calculate an isochrone, parameter distance for an isodistance\");\n    }\n\n    // si on a que le paramètre \"distance\" en entrée, on calcule une isodistance.\n    // Le paramètre \"méthode\" doit pour avoir une réponse du service, être passé à \"distance\"\n    if (!options.time && options.distance) {\n        this.options.method = \"distance\";\n        // on supprime l'éventuel attribut time, résidu d'un appel antérieur\n        if (this.options.time) {\n            delete this.options.time;\n        }\n    }\n\n    // si on a que le paramètre \"time\" en entrée, on calcule une isochrone.\n    // Le paramètre \"méthode\" doit pour avoir une réponse du service, être passé à \"time\"\n    if (options.time && !options.distance) {\n        this.options.method = \"time\";\n        // on supprime l'éventuel attribut time, résidu d'un appel antérieur\n        if (this.options.distance) {\n            delete this.options.distance;\n        }\n    }\n\n    // au cas où on a ni l'un, ni l'autre...\n    this.options.method = this.options.method || \"time\";\n\n    // options par defaut du service\n    this.options.exclusions = options.exclusions || null;\n    this.options.graph = options.graph || \"Voiture\"; // TODO test de la valeur à faire !\n    this.options.reverse = options.reverse || false;\n    this.options.smoothing = options.smoothing || false;\n    this.options.holes = options.holes || false;\n    this.options.srs = options.srs || \"EPSG:4326\";\n\n    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.\n    this.options.outputFormat = (typeof options.outputFormat === \"string\") ? options.outputFormat.toLowerCase() : \"json\";\n\n    // gestion de l'url du service par defaut\n    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut\n    if (!this.options.serverUrl) {\n        var lstUrlByDefault = __WEBPACK_IMPORTED_MODULE_4__DefaultUrlService__[\"a\" /* default */].ProcessIsoCurve.url(this.options.apiKey);\n\n        var urlFound = lstUrlByDefault[\"iso\" + \"-\" + this.options.outputFormat];\n        if (!urlFound) {\n            throw new Error(\"Url by default not found !\");\n        }\n        this.options.serverUrl = urlFound;\n        this.logger.trace(\"Serveur URL par defaut : \" + this.options.serverUrl);\n    }\n\n    // gestion du type de service\n    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)\n    var idx = this.options.serverUrl.lastIndexOf(\".\");\n    if (idx !== -1) {\n        var extension = this.options.serverUrl.substring(idx + 1);\n        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...\n            this.logger.trace(\"Serveur Extension URL : \" + extension);\n            switch (extension.toLowerCase()) {\n                case \"json\":\n                case \"xml\":\n                    this.options.outputFormat = extension.toLowerCase();\n                    break;\n                default:\n                    throw new Error(\"type of service : unknown or unsupported (json or xml) !\");\n            }\n        }\n    }\n}\n\n/**\n * @lends module:ProcessIsoCurve#\n */\nProcessIsoCurve.prototype = Object.create(__WEBPACK_IMPORTED_MODULE_3__CommonService__[\"a\" /* default */].prototype, {\n    // todo\n    // getter/setter\n});\n\n/*\n * Constructeur (alias)\n */\nProcessIsoCurve.prototype.constructor = ProcessIsoCurve;\n\n/**\n * Création de la requête (overwrite)\n *\n * @param {Function} error   - callback des erreurs\n * @param {Function} success - callback\n */\nProcessIsoCurve.prototype.buildRequest = function (error, success) {\n    try {\n        var oIsoCurve = new __WEBPACK_IMPORTED_MODULE_5__Request_ProcessIsoCurveRequest__[\"a\" /* default */](this.options);\n        if (!oIsoCurve.processRequestString()) {\n            throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_REQUEST_BUILD\"));\n        }\n\n        this.request = oIsoCurve.requestString;\n    } catch (e) {\n        error.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](e.message));\n        return;\n    }\n\n    success.call(this, this.request);\n};\n\n/**\n * (overwrite)\n * Analyse de la reponse\n *\n * @param {Function} onError   - callback des erreurs\n * @param {Function} onSuccess - callback de succès de l'analyse de la réponse\n */\nProcessIsoCurve.prototype.analyzeResponse = function (onError, onSuccess) {\n    if (this.response) {\n        var options = {\n            response : this.response,\n            outputFormat : this.options.outputFormat,\n            rawResponse : this.options.rawResponse,\n            onSuccess : onSuccess,\n            onError : onError,\n            scope : this\n        };\n\n        __WEBPACK_IMPORTED_MODULE_6__Response_ProcessIsoCurveResponseFactory__[\"a\" /* default */].build(options);\n    } else {\n        onError.call(this, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurve);\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__model_ProcessIsoCurveParam__ = __webpack_require__(98);\n\n\n\n\n\n/**\n * @classdesc\n * Classe de gestion des requêtes sur le service de calcul d'isoschrone/isodistance.\n *  Les requêtes peuvent être en mode GET ou POST,\n *  et le format de sorti est en JSON ou en XML.\n *\n * @constructor\n * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveRequest\n * @param {Object} options - options\n *\n * @example\n * var options = {\n *      httpMethod : 'GET', // GET|POST\n *      // spécifique au service\n *      exclusions : ['Bridge', 'Tunnel'],\n *      position : {\n *          x : 2.3242664298058053,\n *          y : 48.86118017324745\n *      },\n *      graph : \"Voiture\",\n *      method : 'time',\n *      time : 1000, //distance : 200\n *      reverse : false,\n *      smoothing : false,\n *      holes : false,\n *      srs : 'EPSG:4326'\n *  };\n *\n * try {\n *\n *      var oIsoCurve = new ProcessIsoCurveRequest (options);\n *      if (!oIsoCurve.processRequestString ()) {\n *          // error\n *      }\n *\n *      var request = oIsoCurve.requestString;\n *\n * } catch (e) {\n *      // error\n * }\n * @private\n */\nfunction ProcessIsoCurveRequest (options) {\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"ProcessIsoCurveRequest\");\n    this.logger.trace(\"[Constructeur ProcessIsoCurveRequest ()]\");\n\n    if (!(this instanceof ProcessIsoCurveRequest)) {\n        throw new TypeError(\"ProcessIsoCurveRequest constructor cannot be called as a function.\");\n    }\n\n    // existance des options\n    if (!options) {\n        throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_EMPTY\", \"options\"));\n    }\n\n    /**\n     * Liste des options\n     */\n    this.settings = options;\n\n    /**\n     * Mode HTPP.\n     * Par defaut, \"GET\".\n     * @type {String}\n     */\n    this.mode = this.settings.httpMethod || \"GET\";\n}\n\nProcessIsoCurveRequest.prototype = {\n\n    /**\n     * @lends module:ProcessIsoCurveRequest#\n     */\n\n    /**\n     * Requête\n     * @type {String}\n     */\n    requestString : null,\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : ProcessIsoCurveRequest,\n\n    /**\n     * Template de la requête (POST)\n     * * __X__ __Y__ __SRS__ __GRAPHNAME__ __METHOD__  (obligatoire)\n     * * __REVERSE__ __SMOOTHING__ __HOLES__           (par defaut)\n     * * __TIME__ __TIMEVALUE__                        (choix)\n     * * __DISTANCE__ __DISTANCEVALUE__                (choix)\n     * * __EXCLUSIONS__ __EXCLUSIONFEATURE__ __EXCLUSIONVALUE__ (optionnel)\n     * * __PROFIL__ __PROFILID__ __PROFILNAME__                 (très optionnel)\n     * * __ID__ __IDVALUE__                                     (très optionnel)\n     */\n    template : {\n        container : \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n            \"<isochroneRequest>\\n\" +\n            \"__ID__\" +\n            \"\\t<location>\\n\" +\n            \"\\t\\t<x>__X__</x>\\n\" +\n            \"\\t\\t<y>__Y__</y>\\n\" +\n            \"\\t</location>\\n\" +\n            \"\\t<srs>__SRS__</srs>\\n\" +\n            \"\\t<graphName>__GRAPHNAME__</graphName>\\n\" +\n            \"__PROFIL__\" +\n            \"__EXCLUSIONS__\" +\n            \"\\t<method>__METHOD__</method>\\n\" +\n            \"__TIME__\" +\n            \"__DISTANCE__\" +\n            \"\\t<reverse>__REVERSE__</reverse>\\n\" +\n            \"\\t<smoothing>__SMOOTHING__</smoothing>\\n\" +\n            \"\\t<holes>__HOLES__</holes>\\n\" +\n            \"</isochroneRequest>\",\n        id : \"\\t<id>__IDVALUE__</id>\\n\",\n        profil : \"\\t<profileId>__PROFILID__</profileId>\\n\" + \"\\t<profileName>__PROFILNAME__</profileName>\\n\",\n        exclusions : {\n            container : \"\\t<exclusions>\\n\" +\n                \"__EXCLUSIONFEATURE__\\n\" +\n                \"\\t</exclusions>\\n\",\n            feature : \"\\t\\t<exclusion>__EXCLUSIONVALUE__</exclusion>\"\n        },\n        time : \"\\t<time>__TIMEVALUE__</time>\\n\",\n        distance : \"\\t<distance>__DISTANCEVALUE__</distance>\\n\"\n    },\n\n    /**\n     * Construction de la requête.\n     *\n     * @example\n     * // GET  out :\n     *   //  (http://wxs.ign.fr/KEY/isochrone/isochrone.json?)\n     *   //  location=&\n     *   //  time=& ou distance=&\n     *   //  method=\"DISTANCE|TIME\"&\n     *   //  graph=Pieton&\n     *   //  graphName=Pieton&\n     *   //  exclusions=&\n     *   //  reverse=10&\n     *   //  smoothing=&\n     *   //  holes=&\n     *   //  srs=\n     *\n     * // POST out :\n     *   // <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n     *   // <isochroneRequest>\n     *   //   <id>1</id>\n     *   //   <location>\n     *   //     <x>-1.557189</x>\n     *   //     <y>47.217122</y>\n     *   //   </location>\n     *   //   <srs></srs>\n     *   //   <graphName></graphName>\n     *   //   <profileId></profileId>\n     *   //   <profileName></profileName>\n     *   //   <exclusions>\n     *   //     <exclusion></exclusion>\n     *   //     <exclusion></exclusion>\n     *   //   </exclusions>\n     *   //   <method></method>\n     *   //   <time>50</time>\n     *   //   <distance></distance>\n     *   //   <reverse></reverse>\n     *   //   <smoothing></smoothing>\n     *   //   <holes></holes>\n     *   // </isochroneRequest>\n     *\n     * @returns {String}\n     */\n    processRequestString : function () {\n        var request = \"\";\n        var i = 0;\n\n        switch (this.mode) {\n            case \"GET\":\n                this.logger.trace(\"Process GET Request\");\n\n                // Mapping des options avec le service de l'API REST\n                var oParams = new __WEBPACK_IMPORTED_MODULE_2__model_ProcessIsoCurveParam__[\"a\" /* default */](this.settings);\n                var params = oParams.getParams();\n\n                for (i = 0; i < params.length; i++) {\n                    var o = params[i];\n                    if (request) {\n                        request += \"&\";\n                    }\n                    request += o.k + \"=\" + o.v;\n                }\n\n                break;\n\n            case \"POST\":\n                this.logger.trace(\"Process POST Request\");\n\n                request = this.template.container;\n\n                // options non prises en compte car non implémentées !\n                // clean : id\n                request = request.replace(/__ID__/g, \"\");\n                // clean : profil\n                request = request.replace(/__PROFIL__/g, \"\");\n\n                // options obligatoires\n                request = request.replace(/__X__/g, this.settings.position.x);\n                request = request.replace(/__Y__/g, this.settings.position.y);\n                request = request.replace(/__GRAPHNAME__/g, this.settings.graph);\n\n                // options par defaut\n                request = request.replace(/__SRS__/g, this.settings.srs);\n                request = request.replace(/__SMOOTHING__/g, this.settings.smoothing);\n                request = request.replace(/__HOLES__/g, this.settings.holes);\n                request = request.replace(/__REVERSE__/g, this.settings.reverse);\n\n                // options conditionnelles\n\n                // exclusions\n                if (this.settings.exclusions) {\n                    var tmplExclusions = this.template.exclusions.container;\n                    var exclusions = [];\n                    for (i = 0; i < this.settings.exclusions.length; i++) {\n                        var tmplFeature = this.template.exclusions.feature;\n                        tmplFeature = tmplFeature.replace(/__EXCLUSIONVALUE__/, this.settings.exclusions[i]);\n                        exclusions.push(tmplFeature);\n                    }\n                    tmplExclusions = tmplExclusions.replace(/__EXCLUSIONFEATURE__/, exclusions.join(\"\\n\"));\n                    request = request.replace(/__EXCLUSIONS__/g, tmplExclusions);\n                }\n                // clean exclusions\n                request = request.replace(/__EXCLUSIONS__/g, \"\");\n\n                // distance\n                if (this.settings.distance) {\n                    var tmplDistance = this.template.distance;\n                    tmplDistance = tmplDistance.replace(/__DISTANCEVALUE__/g, this.settings.distance);\n                    request = request.replace(/__DISTANCE__/g, tmplDistance);\n                    // method\n                    request = request.replace(/__METHOD__/g, \"distance\");\n                }\n                // clean\n                request = request.replace(/__DISTANCE__/g, \"\");\n\n                // time\n                if (this.settings.time) {\n                    var tmplTime = this.template.time;\n                    tmplTime = tmplTime.replace(/__TIMEVALUE__/g, this.settings.time);\n                    request = request.replace(/__TIME__/g, tmplTime);\n                    // method\n                    request = request.replace(/__METHOD__/g, \"time\");\n                }\n                // clean\n                request = request.replace(/__TIME__/g, \"\");\n                break;\n\n            default:\n                this.logger.error(\"No other HTTP method supported by the service !\");\n        }\n\n        this.logger.trace(request);\n        this.requestString = request;\n\n        return this.requestString;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurveRequest);\n\n\n/***/ }),\n/* 98 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n\n\n\n/**\n * @classdesc\n *\n * Classe de gestion des param. des requêtes du service de calcul des iso.\n * Permet le mapping avec les options du service.\n *\n * @constructor\n * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveParam\n * @param {Object} options - options\n * @private\n *\n */\nfunction ProcessIsoCurveParam (options) {\n    if (!(this instanceof ProcessIsoCurveParam)) {\n        throw new TypeError(\"ProcessIsoCurveParam constructor cannot be called as a function.\");\n    }\n\n    this.logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger();\n    this.logger.trace(\"[Constructeur ProcessIsoCurveParam ()]\");\n\n    /**\n     * Options en paramêtres du constructeur.\n     */\n    this.options = options || {};\n\n    // mapping des options avec l'API REST\n\n    /** Identifiant de l’isochrone */\n    this.id = this.options.id;\n\n    /** Coordonnées de départ (ou arrivée si le reverse est à true). */\n    this.location = this.options.position;\n\n    /** projection (code EPSG comme epsg:4326 ou wgs84) */\n    this.srs = this.options.srs;\n\n    /**\n     * Profil de véhicule à utiliser pour le calcul.\n     * Voiture ou Pieton\n     */\n    this.graphName = this.options.graph;\n\n    /**\n     * Identifiant et nom du véhicule\n     * FIXME non utilisé\n     */\n    this.profileId = this.options.profileId || null; // TODO !\n    this.profileName = this.options.profileName || null; // TODO !\n\n    /** Liste des règles de restrictions à utiliser */\n    this.exclusions = this.options.exclusions;\n\n    this.reverse = this.options.reverse;\n    this.smoothing = this.options.smoothing;\n    this.holes = this.options.holes;\n\n    /**\n     * \"time\" pour isochrone ou \"distance\" for isodistance.\n     * Par defaut, time...\n     */\n    var value = this.options.method;\n    switch (value) {\n        case \"time\":\n            this.method = \"time\";\n            this.time = this.options.time;\n            break;\n        case \"distance\":\n            this.method = \"distance\";\n            this.distance = this.options.distance;\n            break;\n        default:\n            this.logger.warn(\"Par defaut, on calcule un isochrone !\");\n            this.method = \"time\";\n    }\n}\n\n/**\n * CLASSNAME\n */\nProcessIsoCurveParam.CLASSNAME = \"ProcessIsoCurveParam\";\n\nProcessIsoCurveParam.prototype = {\n\n    /**\n     * @lends module:ProcessIsoCurveParam#\n     */\n\n    /**\n     * Constructeur (alias)\n     */\n    constructor : ProcessIsoCurveParam,\n\n    /**\n     * Retourne la liste des exclusions\n     */\n    getLocation : function () {\n        return this.location.x + \",\" + this.location.y;\n    },\n\n    /**\n     * Retourne la liste des exclusions\n     */\n    getExclusions : function () {\n        return this.exclusions.join(\";\");\n    }\n};\n\n/**\n * Tableau de clefs/valeurs pour param.\n *\n * @returns {Object[]}\n */\nProcessIsoCurveParam.prototype.getParams = function () {\n    var map = [];\n\n    map.push({\n        k : \"location\",\n        v : this.getLocation()\n    });\n\n    map.push({\n        k : \"smoothing\",\n        v : this.smoothing\n    });\n\n    map.push({\n        k : \"holes\",\n        v : this.holes\n    });\n\n    map.push({\n        k : \"reverse\",\n        v : this.reverse\n    });\n\n    map.push({\n        k : \"method\",\n        v : this.method\n    });\n\n    if (this.time) {\n        map.push({\n            k : \"time\",\n            v : this.time\n        });\n    }\n\n    if (this.distance) {\n        map.push({\n            k : \"distance\",\n            v : this.distance\n        });\n    }\n\n    map.push({\n        k : \"graphName\",\n        v : this.graphName\n    });\n\n    if (this.exclusions) {\n        map.push({\n            k : \"exclusions\",\n            v : this.getExclusions()\n        });\n    }\n\n    if (this.srs) {\n        map.push({\n            k : \"srs\",\n            v : this.srs\n        });\n    }\n\n    return map;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurveParam);\n\n\n/***/ }),\n/* 99 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Formats_XML__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Formats_WKT__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Formats_ProcessIsoCurveResponseReader__ = __webpack_require__(100);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__model_ProcessIsoCurveResponse__ = __webpack_require__(18);\n/**\n * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON\n * (Factory)\n *\n * @module ProcessIsoCurveResponseFactory\n * @alias Gp.Services.ProcessIsoCurve.Response.ProcessIsoCurveResponseFactory\n * @private\n */\n\n\n\n\n\n\n\n\nvar ProcessIsoCurveResponseFactory = {\n\n    /**\n     * interface unique\n     *\n     * @method build\n     * @static\n     * @param {Object} options - options definies dans le composant ProcessIsoCurve\n     *\n     * @example\n     *   var options = {\n     *      response :\n     *      outputFormat :\n     *      rawResponse :\n     *      scope :\n     *      onSuccess :\n     *      onError :\n     *   };\n     *\n     */\n    build : function (options) {\n        // logger\n        var logger = __WEBPACK_IMPORTED_MODULE_0__Utils_LoggerByDefault__[\"a\" /* default */].getLogger(\"ProcessIsoCurveResponseFactory\");\n        logger.trace([\"ProcessIsoCurveResponseFactory::build()\"]);\n\n        var data = null;\n\n        if (options.response) {\n            if (options.rawResponse) {\n                logger.trace(\"analyze response : raw\");\n                data = options.response;\n            } else {\n                switch (options.outputFormat) {\n                    case \"xml\":\n                        logger.trace(\"analyze response : xml\");\n\n                        try {\n                            var p = new __WEBPACK_IMPORTED_MODULE_3__Formats_XML__[\"a\" /* default */]({\n                                reader : __WEBPACK_IMPORTED_MODULE_5__Formats_ProcessIsoCurveResponseReader__[\"a\" /* default */]\n                            });\n\n                            // FIXME : mode XHR ne retourne que des string ? JSONP aussi à ce niveau ?\n                            if (typeof options.response === \"string\") {\n                                p.setXMLString(options.response);\n                            } else {\n                                p.setXMLDoc(options.response);\n                            }\n\n                            data = p.parse();\n\n                            if (!data) {\n                                throw new Error(__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION_2\"));\n                            }\n                        } catch (e) {\n                            var message = e.message;\n                            message += \"\\n (raw response service : '\" + options.response + \"')\";\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                                message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", message),\n                                status : 200,\n                                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n                            }));\n                            return;\n                        }\n\n                        break;\n\n                    case \"json\":\n                        logger.trace(\"analyze response : json\");\n\n                        var JSONResponse;\n                        if (typeof options.response === \"string\") {\n                            JSONResponse = JSON.parse(options.response);\n                        } else {\n                            JSONResponse = options.response;\n                        }\n\n                        // analyse de la reponse\n                        if (JSONResponse.status === \"OK\" || JSONResponse.status === \"ok\") {\n                            // création de l'objet de réponse\n                            data = new __WEBPACK_IMPORTED_MODULE_6__model_ProcessIsoCurveResponse__[\"a\" /* default */]();\n\n                            // remplissage de l'objet créé avec les attribtuts de la réponse du service\n                            if (data) {\n                                data.time = JSONResponse.time;\n                                data.distance = JSONResponse.distance;\n                                data.message = JSONResponse.message;\n                                data.id = JSONResponse.id;\n                                data.srs = JSONResponse.srs;\n                                /** callback de la reponse */\n                                var onWKTSuccess = function (json) {\n                                    data.geometry = json;\n                                };\n                                /** callback d'erreur */\n                                var onWKTError = function () {\n                                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_FORMAT\", \"wktGeometry\")\n                                    }));\n                                };\n                                if (data.hasOwnProperty(\"geometry\")) {\n                                    __WEBPACK_IMPORTED_MODULE_4__Formats_WKT__[\"a\" /* default */].toJson(JSONResponse.wktGeometry, onWKTSuccess, onWKTError);\n                                    if (!data.geometry) {\n                                        return;\n                                    }\n                                }\n                                var coords = JSONResponse.location.split(\",\");\n                                if (data.location) {\n                                    data.location.x = coords[0];\n                                    data.location.y = coords[1];\n                                }\n                            } else {\n                                options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", options.response)));\n                                return;\n                            }\n                        } else if (JSONResponse.status === \"ERROR\" || JSONResponse.status === \"error\") {\n                            // JSHint bug if var message is used !?\n                            var mess = JSONResponse.message;\n                            mess += \"\\n (raw response service : '\" + JSONResponse + \"')\";\n                            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", mess)));\n                            return;\n                        }\n                        break;\n\n                    default:\n                        options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_FORMAT\", \"json\", \"xml\")));\n                        return;\n                }\n\n                // info : en cas de problèmes de droits (clé invalide ou autre), la réponse est au format XML !!\n                // ex. <ExceptionReport><Exception exceptionCode=\"MissingParameter\">Key does not exist or has expired</Exception></ExceptionReport>\n                // mais le statut est 403, l'erreur est donc remontée plus tôt.\n                if (data && data.exceptionReport) {\n                    options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                        message : __WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\", data.exceptionReport),\n                        type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR,\n                        status : 200\n                    }));\n                    return;\n                }\n            }\n        } else {\n            // si la réponse est vide, on appelle le callback d'erreur\n            options.onError.call(options.scope, new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */](__WEBPACK_IMPORTED_MODULE_1__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EMPTY\")));\n            return;\n        }\n\n        // si tout s'est bien passé, on appelle le callback de succès\n        options.onSuccess.call(options.scope, data);\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurveResponseFactory);\n\n\n/***/ }),\n/* 100 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Formats_WKT__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Response_model_ProcessIsoCurveResponse__ = __webpack_require__(18);\n/**\n * Analyse de la reponse XML\n *\n * @module ProcessIsoCurveResponseReader\n * @alias Gp.Services.ProcessIsoCurve.Formats.ProcessIsoCurveResponseReader\n * @todo not yet implemented !\n * @private\n */\n\n\n\n\n\n\n/**\n * Objet ProcessIsoCurveResponseReader\n *\n * @member {Object} ProcessIsoCurveResponseReader\n *\n * @property {Object} ProcessIsoCurveResponseReader.READERS - Objet contenant des fonctions de lecture, appelées \"readers\"\n *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire\n *      et la valeur associée est une fonction (node, data)\n *      où node est un noeud du document DOM\n *      et data est un objet où l'on stocke les informations lues dans le XML.\n *\n * @property {Method} ProcessIsoCurveResponseReader.read -  Méthode permettant de lancer la lecture d'une réponse XML\n *       du service de calcul isochrone/isodistance, à l'aide des readers de la classe.\n *\n */\n\nvar ProcessIsoCurveResponseReader = {};\n\n/*\n    // INFO\n    // Exemple d'erreur du service\n    // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n    // <isochroneResult>\n    //  <message>Location point must have 2 components separated with a ,</message>\n    //  <status>ERROR</status>\n    // </isochroneResult>\n\n    // <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n    // <serviceResult>\n    //   <message>ServiceException : Error in isochron computation Error in smartrouting null</message>\n    //   <status>ERROR</status>\n    // </serviceResult>\n\n    // INFO\n    // Exemple d'erreur NGinx\n    // <ExceptionReport><Exception exceptionCode=\"MissingParameter\">Resource parameter not found</Exception></ExceptionReport>\n*/\n\n/*\n    // INFO\n    // Exemple de réponse du service\n\n     // <IsochroneResult>\n     //    <status>OK</status>\n     //    <id/>\n     //    <location>-1.557189,47.217122</location>\n     //    <srs/>\n     //    <distance>5000</distance>\n     //    <wktGeometry>POLYGON ((-1.545312 47.178178, -1.545312 47.180418, ...))</wktGeometry>\n     // </IsochroneResult>\n\n    // <isochronResult>\n    //    <status>OK</status>\n    //    <id>1</id>\n    //    <location>-1.557189,47.217122</location>\n    //    <srs/>\n    //    <time>50</time>\n    //    <wktGeometry>POLYGON ((-1.556864 47.216487, -1.556864 47.216948, ...))</wktGeometry>\n    // </isochronResult>\n*/\n\nProcessIsoCurveResponseReader.READERS = {\n\n    /** TODO : jsdoc block */\n    isochronResult : function (root) {\n        // racine de la réponse XML : on crée l'objet de réponse\n        var response = new __WEBPACK_IMPORTED_MODULE_3__Response_model_ProcessIsoCurveResponse__[\"a\" /* default */]();\n\n        if (root.hasChildNodes()) {\n            var children = root.childNodes;\n            var child;\n\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n\n                if (ProcessIsoCurveResponseReader.READERS[child.nodeName]) {\n                    ProcessIsoCurveResponseReader.READERS[child.nodeName](child, response);\n                }\n            }\n        }\n\n        if (response.status === \"error\") {\n            var message = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\",\n                response.message);\n            throw new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : message,\n                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n            });\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    message : function (node, response) {\n        if (response) {\n            response.message = __getChildValue(node);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    status : function (node, response) {\n        var status = __getChildValue(node);\n        if (status === \"ERROR\" || status === \"error\") {\n            if (response) {\n                response.status = \"error\";\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    id : function (node, response) {\n        if (response) {\n            response.id = __getChildValue(node);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    location : function (node, response) {\n        var coords = __getChildValue(node);\n        if (response && response.location) {\n            response.location.x = parseFloat(coords.split(\",\")[0]);\n            response.location.y = parseFloat(coords.split(\",\")[1]);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    srs : function (node, response) {\n        if (response) {\n            response.srs = __getChildValue(node);\n        }\n    },\n\n    /** TODO : jsdoc block */\n    distance : function (node, response) {\n        if (response) {\n            response.distance = parseFloat(__getChildValue(node));\n        }\n    },\n\n    /** TODO : jsdoc block */\n    time : function (node, response) {\n        if (response) {\n            response.time = parseFloat(__getChildValue(node));\n        }\n    },\n\n    /** TODO : jsdoc block */\n    wktGeometry : function (node, response) {\n        if (response) {\n            var wktGeometry = node.innerHTML;\n            /** TODO : jsdoc block */\n            var onWKTSuccess = function (json) {\n                response.geometry = json;\n            };\n            /** TODO : jsdoc block */\n            var onWKTError = function () {\n                var msg = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"PARAM_FORMAT\", [\"wktGeometry\"]);\n                throw new Error(msg);\n            };\n            if (response.hasOwnProperty(\"geometry\")) {\n                __WEBPACK_IMPORTED_MODULE_1__Formats_WKT__[\"a\" /* default */].toJson(wktGeometry, onWKTSuccess, onWKTError);\n            }\n        }\n    },\n\n    /** TODO : jsdoc block */\n    serviceResult : function (node) {\n        // en cas d'exception du service\n        var response = {};\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (ProcessIsoCurveResponseReader.READERS[child.nodeName]) {\n                    ProcessIsoCurveResponseReader.READERS[child.nodeName](child, response);\n                }\n            }\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    ExceptionReport : function (node) {\n        var response = {};\n        if (node.hasChildNodes()) {\n            var children = node.childNodes;\n            var child;\n            for (var i = 0; i < children.length; i++) {\n                child = children[i];\n                if (child.nodeName === \"Exception\") {\n                    response.exceptionReport = ProcessIsoCurveResponseReader.READERS[\"Exception\"](child);\n                }\n            }\n        }\n        return response;\n    },\n\n    /** TODO : jsdoc block */\n    Exception : function (node) {\n        var exceptionReport = {};\n\n        // get exception code\n        var exceptionCode = node.getAttribute(\"exceptionCode\");\n        if (exceptionCode) {\n            exceptionReport.exceptionCode = exceptionCode;\n        }\n\n        // get exception message\n        var textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            exceptionReport.exception = textNode.nodeValue;\n        }\n\n        return exceptionReport;\n    }\n};\n\n/** TODO : jsdoc block */\nProcessIsoCurveResponseReader.read = function (root) {\n    var response;\n\n    if (root.nodeName === \"isochronResult\" || root.nodeName === \"isochroneResult\" || root.nodeName === \"IsochroneResult\") {\n        response = ProcessIsoCurveResponseReader.READERS[\"isochronResult\"](root);\n        return response;\n    } else if (root.nodeName === \"ExceptionReport\") {\n        response = ProcessIsoCurveResponseReader.READERS[root.nodeName](root);\n        return response;\n    } else if (ProcessIsoCurveResponseReader.READERS[root.nodeName]) {\n        response = ProcessIsoCurveResponseReader.READERS[root.nodeName](root);\n        if (response.status === \"error\") {\n            var errMsg = __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_EXCEPTION\",\n                response.message);\n            throw new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n                message : errMsg,\n                type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_SRVERR\n            });\n        }\n        return response;\n    } else {\n        throw new __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */]({\n            message : __WEBPACK_IMPORTED_MODULE_0__Utils_MessagesResources__[\"a\" /* default */].getMessage(\"SERVICE_RESPONSE_ANALYSE\", root.nodeName),\n            type : __WEBPACK_IMPORTED_MODULE_2__Exceptions_ErrorService__[\"a\" /* default */].TYPE_UNKERR\n        });\n    }\n};\n\n/**\n * Lecture de la valeur du premier child d'un noeud, si elle existe.\n *\n * @private\n * @memberof ProcessIsoCurveResponseReader\n * @method __getChildValue\n * @param {DOMElement} node - a DOM node\n * @return {String} value - valeur du firstChild du noeud en entrée, ou chaîne vide.\n */\nfunction __getChildValue (node) {\n    var textNode;\n    var value = \"\";\n\n    if (node.hasChildNodes()) {\n        textNode = node.firstChild;\n        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE\n            value = textNode.nodeValue;\n        }\n    }\n    return value;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProcessIsoCurveResponseReader);\n\n\n/***/ })\n/******/ ])[\"default\"];\n});\n//# sourceMappingURL=GpServices-src.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvZGlzdC9HcFNlcnZpY2VzLXNyYy5qcz9jN2MzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw2REFBNkQ7QUFDckY7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbURBQW1EO0FBQzdGLGlEQUFpRCxpRUFBaUU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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Q0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU8sa0NBQWtDO0FBQ3BELFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQsMEJBQTBCLHVCQUF1QjtBQUNqRCwwQkFBMEI7QUFDMUI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0JBQW9CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQXVEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUF1RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQkFBcUI7QUFDNUM7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHVDQUF1QztBQUN2QztBQUNBLHNCQUFzQixXQUFXLEdBQUcsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFp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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTixNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsYUFB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QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELHdEQUF3RDs7QUFFeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7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cnRhbCByZXNvdXJjZXMgYWNjZXNzIGxpYnJhcnlcbiAqXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBsaWNlbmNlIENlQ0lMTC1CIChGcmVlIEJTRCBjb21wYXRpYmxlKVxuICogQHNlZSBodHRwOi8vd3d3LmNlY2lsbC5pbmZvL2xpY2VuY2VzL0xpY2VuY2VfQ2VDSUxMLUJfVjEtZW4udHh0XG4gKiBAc2VlIGh0dHA6Ly93d3cuY2VjaWxsLmluZm8vbGljZW5jZXMvTGljZW5jZV9DZUNJTEwtQl9WMS1mci50eHRcbiAqIEBzZWUgaHR0cDovL3d3dy5jZWNpbGwuaW5mby9cbiAqXG4gKiBjb3B5cmlnaHQgQ2VDSUxMLUJcbiAqIGNvcHlyaWdodCBJR05cbiAqIEBhdXRob3IgSUdOXG4gKiBAdmVyc2lvbiAyLjAuMFxuICogQGRhdGUgMjAxOC0wNC0wNVxuICpcbiAqL1xuLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjRcbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ4bWxkb21cIiksIHJlcXVpcmUoXCJyZXF1ZXN0XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiR3BcIiwgW1wicmVxdWlyZVwiLCBcInJlcXVpcmVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiR3BcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ4bWxkb21cIiksIHJlcXVpcmUoXCJyZXF1ZXN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJHcFwiXSA9IGZhY3Rvcnkocm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0pO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMjBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81Ml9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQzKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2xvZ2xldmVsX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfbG9nbGV2ZWxfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9sb2dsZXZlbF9fKTtcbi8qIGdsb2JhbCBfX1BST0RVQ1RJT05fXyAqL1xuXG5cbnZhciBMb2dnZXJCeURlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogbG9nZ2VyIHN0YXRpcXVlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBub20gZHUgbG9nZ2VyXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmV0b3VybmUgdW4gbG9nZ2VyXG4gICAgICovXG4gICAgZ2V0TG9nZ2VyIDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgLy8gU3Vic3RpdHV0ZSBnbG9iYWwgY29uc3RhbnRzIGNvbmZpZ3VyZWQgYXQgY29tcGlsZSB0aW1lXG4gICAgICAgIC8vIGNmLiB3ZWJwYWNrLmNvbmZpZy5qc1xuICAgICAgICAoIGZhbHNlKSA/IExvZy5kaXNhYmxlQWxsKCkgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfbG9nbGV2ZWxfX1tcImVuYWJsZUFsbFwiXSgpO1xuICAgICAgICB2YXIgbG9nbmFtZSA9IG5hbWUgfHwgXCJkZWZhdWx0XCI7XG4gICAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfbG9nbGV2ZWxfX1tcImdldExvZ2dlclwiXShsb2duYW1lKTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKExvZ2dlckJ5RGVmYXVsdCk7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgZXJyZXVycyBxdWkgcGVybWVyIGQnYXNzb2NpZXIgdW4gbWVzc2FnZSBkJ2VycmV1ciDDoCBsJ2V4Y2VwdGlvbiBsYW5jw6llLlxuICpcbiAqIEBleGFtcGxlXG4gKiBNZXNzYWdlc1Jlc291cmNlcy5nZXRNZXNzYWdlKFwiRVJST1JfUEFSQU1fTUlTU0lOR1wiLCBcInhcIiwgXCJ5XCIsIFwielwiKSkpO1xuICogLy8gLS0+IG91dHB1dCA6IFBhcmFtZXRlcihzKSAneCAtIHkgLSB6JyBtaXNzaW5nXG4gKlxuICogQG1vZHVsZSBNZXNzYWdlc1Jlc291cmNlc1xuICogQGFsaWFzIEdwLlV0aWxzLk1lc3NhZ2VzUmVzb3VyY2VzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTWVzc2FnZXNSZXNvdXJjZXMgPSB7XG5cbiAgICAvLyBQYXJhbcOodHJlc1xuICAgIFBBUkFNX01JU1NJTkcgOiBcIlBhcmFtZXRlcihzKSAnJXZhciUnIG1pc3NpbmdcIixcbiAgICBQQVJBTV9FTVBUWSA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgZW1wdHlcIixcbiAgICBQQVJBTV9UWVBFIDogXCJXcm9uZyB0eXBlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJ1wiLFxuICAgIFBBUkFNX0ZPUk1BVCA6IFwiUGFyYW1ldGVyKHMpICcldmFyJScgbm90IGNvcnJlY3RseSBmb3JtYXR0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVCA6IFwiVmFsdWUocykgZm9yIHBhcmFtZXRlcihzKSAnJXZhciUnIG5vdCBzdXBwb3J0ZWRcIixcbiAgICBQQVJBTV9OT1RfU1VQUE9SVF9OT0RFSlMgOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyBub3Qgc3VwcG9ydGVkIHRvIE5vZGVKU1wiLFxuICAgIFBBUkFNX1VOS05PV04gOiBcIlZhbHVlKHMpIGZvciBwYXJhbWV0ZXIocykgJyV2YXIlJyB1bmtub3duXCIsXG5cbiAgICAvLyBTZXJ2aWNlc1xuICAgIC8vIFJlcXXDqnRlXG4gICAgU0VSVklDRV9SRVFVRVNUX0JVSUxEIDogXCJBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIHJlcXVlc3QgYnVpbGRpbmcgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFUVVFU1RfRU1QVFkgOiBcIlRoZSByZXF1ZXN0IHNlbnQgdG8gdGhlIHNlcnZpY2UgaXMgZW1wdHlcIixcblxuICAgIC8vIFLDqXBvbnNlXG4gICAgU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT04gOiBcIlRoZSBzZXJ2aWNlIHJldHVybmVkIGFuIGV4Y2VwdGlvbiA6ICcldmFyJSdcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTl8yIDogXCJUaGUgc2VydmljZSByZXR1cm5lZCBhbiBleGNlcHRpb25cIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0UgOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHBhcnNpbmcgdGhlIHJlc3BvbnNlICcldmFyJScgb2YgdGhlIHNlcnZpY2VcIixcbiAgICBTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VfMiA6IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBwYXJzaW5nIHRoZSByZXNwb25zZVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFkgOiBcIlRoZSByZXNwb25zZSBvZiB0aGUgc2VydmljZSBpcyBlbXB0eVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlfMiA6IFwiVGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZpY2UgY291bGQgbm90IGJlIGFuYWx5emVkIG9yIGlzIGVtcHR5XCIsXG4gICAgU0VSVklDRV9SRVNQT05TRV9GT1JNQVQgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZCAoaGFuZGxlZCBmb3JtYXQocykgOiAnJXZhciUnKVwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzIgOiBcIlRoZSBmb3JtYXQgb2YgdGhlIHNlcnZpY2UgcmVzcG9uc2UgaXMgbm90IHN1cHBvcnRlZFwiLFxuICAgIFNFUlZJQ0VfUkVTUE9OU0VfRk9STUFUXzMgOiBcIk5vIHN1Z2dlc3Rpb24gbWF0Y2hpbmcgdGhlIHNlYXJjaFwiLFxuXG4gICAgLy8gQ2xhc3Nlc1xuICAgIENMQVNTX0NPTlNUUlVDVE9SIDogXCInJXZhciUnIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIixcblxuICAgIC8qKlxuICAgICAqIEZvbmN0aW9uIHF1aSB2YSByZXRvdXJuZXIgbGUgbWVzc2FnZSBkJ2VycmV1ciBhc3NvY2nDqSDDoCBsYSBjbMOpIGRvbm7DqWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0TWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjbGVmIC0gQ2xlZiBkZSBsJ2VycmV1ciAoZXggOiBFUlJPUl9QQVJBTSlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbWV0cmVzIC0gUGFyYW3DqHRyZXMvdmFyaWFibGVzIGNvbmNlcm7DqXMgcGFyIGxlIG1lc3NhZ2UgZCdlcnJldXIgYXNzb2Npw6kgw6AgbGEgY2xlZiBkb25uw6llXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBtZXNzYWdlIC0gU3RyaW5nIGNvbnRlbmFudCBsZSBtZXNzYWdlIGRlIGwnZXhjZXB0aW9uXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZSA6IGZ1bmN0aW9uIChjbGVmLCBwYXJhbWV0cmVzKSB7XG4gICAgICAgIC8vIHBhcmFtIGRlIGxhIGZvbmN0aW9uIHVuaXF1ZW1lbnQgcG91ciBsYSBkb2N1bWVudGF0aW9uLi4uXG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFyZ3VtZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlIGluZGVmaW5lZCAhXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcmFtcy5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJncyA9IHBhcmFtcztcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXNba2V5XTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcIiV2YXIlXCIsIGFyZ3Muam9pbihcIiAtIFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXCIldmFyJVwiLCBcIiV2YXIlIChub3Qgc3BlY2lmaWVkKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gZXJyb3IgZGUgc3RyaW5nLnJlcGxhY2UoKVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE1lc3NhZ2VzUmVzb3VyY2VzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEVycm9ycyByYWlzZWQgYnkgQVBJIGZvciBvbmUgYW1vbmcgdGhyZWUgcmVhc29ucyA6IHdyb25nIEFQSSB1c2FnZSwgdW5kZXJseWluZyBzZXJ2aWNlIGVycm9yIG9yIHVua25vd24gcmVhc29uLlxuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHN0YXR1cyAtIEVycm9yIHN0YXR1cyA6IHdoZW4ge0BsaW5rIEdwLkVycm9yLlRZUEVfU1JWRVJSfSwgZ2l2ZXMgdGhlIFtIVFRQIHN0YXR1cyBvZiB0aGUgdW5kZXJseWluZyB3ZWIgc2VydmljZSByZXNwb25zZV17QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9IVFRQX3N0YXR1c19jb2Rlc30gOyAtMSBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSAtIEVycm9yIHR5cGUgKHtAbGluayBHcC5FcnJvci5UWVBFX1NSVkVSUn0sIHtAbGluayBHcC5FcnJvci5UWVBFX1VTRUVSUn0gb3Ige0BsaW5rIEdwLkVycm9yLlRZUEVfVU5LRVJSfSkuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLkVycm9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGVycm9yIC0gT3B0aW9ucyBmb3IgY3JlYXRpbmcgZXJyb3Igb2JqZWN0LiBDYW4gYmUgYSBTdHJpbmcgKG1lc3NhZ2UpIG9yIGFuIE9iamVjdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvci5tZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byByZXR1cm4gdG8gdXNlci5cbiAqIEBwYXJhbSB7ZW51bX0gW2Vycm9yLnR5cGU9VFlQRV9VTktFUlJdIC0gRXJyb3IgdHlwZVxuICogQHBhcmFtIHtzdGF0dXN9IFtlcnJvci5zdGF0dXM9LTFdIC0gRXJyb3Igc3RhdHVzIDogd2hlbiB7QGxpbmsgR3AuRXJyb3IuVFlQRV9TUlZFUlJ9LCBnaXZlcyB0aGUgW0hUVFAgc3RhdHVzIG9mIHRoZSB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIHJlc3BvbnNlXXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0hUVFBfc3RhdHVzX2NvZGVzfS5cbiAqXG4gKi9cbmZ1bmN0aW9uIEVycm9yU2VydmljZSAoZXJyb3IpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXJyb3JTZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3JTZXJ2aWNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBlcnJvcjtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiIHx8IGVycm9yIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9yO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IC0xO1xuICAgICAgICB0aGlzLnR5cGUgPSBFcnJvclNlcnZpY2UuVFlQRV9VTktFUlI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZS5tZXNzYWdlIHx8IFwidW5kZWZpbmVkIT9cIjtcbiAgICAgICAgdGhpcy50eXBlID0gZS50eXBlO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGUuc3RhdHVzIHx8IC0xO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IFwiRXJyb3JTZXJ2aWNlXCI7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5cbi8qKlxuICogRXJyb3IgcmFpc2VkIHdoZW4gdW5kZXJseWluZyBnZW9wb3J0YWwgc2VydmljZSBhbnN3ZXJzIG9uIGVycm9yLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBzdGF0aWNcbiAqL1xuRXJyb3JTZXJ2aWNlLlRZUEVfU1JWRVJSID0gXCJTRVJWSUNFX0VSUk9SXCI7XG4vKipcbiAqIEVycm9yIHJhaXNlZCB3aGVuIGZ1bmNpb24gdXNlIGlzIGluYXBwcm9wcmlhdGVcbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAc3RhdGljXG4gKi9cbkVycm9yU2VydmljZS5UWVBFX1VTRUVSUiA9IFwiVVNBR0VfRVJST1JcIjtcbi8qKlxuICogRXJyb3IgcmFpc2VkIHdoZW4gQVBJIGNhbid0IHBlcmZvcm0gdGhlIGpvYiBmb3IgYSByZWFzb24gb3RoZXIgdGhhbiB0aGUgdHdvIG90aGVyIG9uZXMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBjb25zdGFudFxuICogQHN0YXRpY1xuICovXG5FcnJvclNlcnZpY2UuVFlQRV9VTktFUlIgPSBcIlVOS05PV05fRVJST1JcIjtcblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkVycm9yU2VydmljZVxuICovXG5FcnJvclNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3RvciA6IHtcbiAgICAgICAgdmFsdWUgOiBFcnJvclNlcnZpY2UsXG4gICAgICAgIHdyaXRhYmxlIDogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZVxuICAgIH1cbn0pO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9yU2VydmljZSk7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfSGVscGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Qcm90b2NvbHNfUHJvdG9jb2xfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19EZWZhdWx0VXJsU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXG5cblxuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb21wb3NhbnQgU2VydmljZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkNvbW1vblNlcnZpY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBjb21tdW5lcyDDoCB0b3VzIGxlcyBzZXJ2aWNlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmFwaUtleSAtIENsZWYgZCdhY2PDqHMgw6AgbGEgcGxhdGVmb3JtZSBHw6lvcG9ydGFpbCxcbiAqICAgICAgbsOpY2Vzc2FpcmUgcG91ciBmcmFuY2hpciBsYSBjb3VjaGUgZGUgY29udHLDtGxlIGRlcyBhY2PDqHMgcG91ciBhdm9pciB1bmUgcsOpcG9uc2UgZHUgc2VydmljZSBpbnZvcXXDqS5cbiAqICAgICAgUGx1c2lldXJzIGNsZWZzIHBldXZlbnQgw6p0cmUgcGFzc8OpZXMgZGFucyBsZSBjYXMgZGUgbCdpbnZvY2F0aW9uIGR1IHNlcnZpY2UgZCdhdXRvY29uZmlndXJhdGlvbi5cbiAqICAgICAgU2kgY2UgcGFyYW3DqHRyZSBuJ2VzdCBwYXMgcmVuc2VpZ27DqSwgYWxvcnMgbGUgcGFyYW3DqHRyZSBzZXJ2ZXJVcmwgZG9pdCDDqnRyZSByZW5zZWlnbsOpIChjb21wcmVuYW50IGFsb3JzLCBzaSBuw6ljZXNzYWlyZSBsYSBjbGVmIEFQSSkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2VydmVyVXJsIC0gVVJMIGQnYWNjw6hzIGF1IHNlcnZpY2UuXG4gKiAgICAgIFBlcm1ldCBkZSBmb3JjZXIgbCd1dGlsaXNhdGlvbiBkJ3VuIHNlcnZpY2Ugw6lxdWl2YWxlbnQgZMOpcGxvecOpIGRlcnJpw6hyZSB1bmUgw6l2ZW50dWVsbGUgYXV0cmUgVVJMIGQnYWNjw6hzLlxuICogICAgICBTaSBjZSBwYXJhbcOodHJlIGVzdCByZW5zZWlnbsOpIGFsb3JzLCBsZSBwYXJhbcOodHJlIGFwaUtleSBlc3QgaWdub3LDqS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvdG9jb2xdIC0gTGUgcHJvdG9jb2xlIMOgIHV0aWxpc2VyIHBvdXIgcsOpY3Vww6lyZXIgbGVzIGluZm9ybWF0aW9ucyBkdSBzZXJ2aWNlIDpcbiAqICAgICAgcGV1dCB2YWxvaXIgJ0pTT05QJyBvdSAnWEhSJy5cbiAqICAgICAgUGFyIGTDqWZhdXQsIGMnZXN0IGxlIHByb3RvY29sZSBYSFIgcXVpIHNlcmEgdXRpbGlzw6kuXG4gKiAgICAgIEF0dGVudGlvbiwgbGUgcHJvdG9jb2xlIEpTT05QIG4nZXN0IHBhcyB2YWxpZGUgZGFucyB1biBlbnZpcm9ubmVtZW50IE5vZGVKUyAoVXRpbGlzYXRpb24gZHUgbW9kZSBYSFIpLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3NsXSAtIEluZGlxdWUgc2kgbCdvbiBzb3VoYWl0ZSBpbnTDqXJyb2dlciBsZXMgc2VydmljZXMgZW4gaHR0cHMuXG4gKiAgICAgIENlIHBhcmFtw6h0cmUgbmUgZm9uY3Rpb25uZSBxdWUgcG91ciB1bmUgdXRpbGlzYXRpb24gaG9ycyBuYXZpZ2F0ZXVyIChleC4gTm9kZUpTKS5cbiAqICAgICAgU3VyIHVuIG5hdmlnYXRldXIsIGxlIHByb3RvY29sZSBlc3QgYXV0b21hdGlxdWVtZW50IGV4dHJhaXQgZGUgbCd1cmwgZHUgc2l0ZS4uLlxuICogICAgICBQYXIgZMOpZmF1dCwgb24gdXRpbGlzZSBsZSBwcm90b2NvbGUgaHR0cCAoc3NsPWZhbHNlKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJveHlVUkxdIC0gTGUgcHJveHkgw6AgdXRpbGlzZXIgcG91ciBwYWxsaWVyIGF1IHByb2Jsw6htZSBkZSBjcm9zcy1kb21haW4gZGFucyBsZSBjYXMgZCd1bmUgcmVxdcOqdGUgWEhSLlxuICogICAgICBVdGlsZSBzaSBsZSBwYXJhbcOodHJlICdwcm90b2NvbCcgdmF1dCAnWEhSJywgaWwgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUgc2kgcHJvdG9jb2wgdmF1dCBKU09OUC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FsbGJhY2tTdWZmaXhdIC0gU3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayDDoCB1dGlsaXNlciwgZGFucyBsZSBjYXMgZHUgcHJvdG9jb2xlIEpTT05QLlxuICogICAgICBQYXIgZMOpZmF1dCwgbGEgZm9uY3Rpb24gZGUgY2FsbGJhY2sgcG9ydGVyYSB1biBub20gZHUgdHlwZSBcImNhbGxiYWNrXCIrSUQsIG/DuSBJRCBlc3Qgc29pdCB1biBpZGVudGlmaWFudCB1bmlxdWUgZ8OpbsOpcsOpIMOgIGNoYXF1ZSByZXF1w6p0ZSxcbiAqICAgICAgc29pdCBsZSBwYXJhbcOodHJlIGNhbGxiYWNrU3VmZml4IHMnaWwgZXN0IHNww6ljaWZpw6kuIFBhciBleGVtcGxlLCBzaSBjYWxsYmFja1N1ZmZpeD1cIl8yXCIsIGxhIGZvbmN0aW9uIHNlcmEgXCJjYWxsYmFja18yICgpXCIuXG4gKiAgICAgIFV0aWxlIHBvdXIgdXRpbGlzZXIgdW5lIHLDqXBvbnNlIGTDqWrDoCBlbmNhcHN1bMOpZSBkYW5zIHVuZSBmb25jdGlvbiBkZSBjYWxsYmFjaywgZG9udCBsZSBub20gZXN0IGNvbm51IChleCA6IGNoYXJnZW1lbnQgZGUgbCdhdXRvY29uZmlndXJhdGlvbiBlbiBsb2NhbClcbiAqICAgICAgVXRpbGUgc2V1bGVtZW50IHNpIGxlIHBhcmFtw6h0cmUgJ3Byb3RvY29sJyB2YXV0ICdKU09OUCcsIGlsIG5lIHNlcmEgcGFzIHByaXMgZW4gY29tcHRlIHNpIHByb3RvY29sIHZhdXQgJ1hIUicuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmh0dHBNZXRob2RdIC0gTGEgbcOpdGhvZGUgSFRUUFxuICogICAgICDDoCB1dGlsaXNlciBkYW5zIGxlIGNhcyBkJ3VuZSByZXF1w6p0ZSBYSFIgOiBwZXV0IHZhbG9pciAnR0VUJyBvdSAnUE9TVCcuXG4gKiAgICAgIE5vbiBwcmlzIGVuIGNvbXB0ZSBzaSAncHJvdG9jb2wnIHZhdXQgSlNPTlAgcXVpIGZvbmN0aW9ubmUgb2JsaWdhdG9pcmVtZW50IGVuIEdFVC5cbiAqICAgICAgUGFyIGTDqWZhdXQsIGMnZXN0IGxhIG3DqXRob2RlIEdFVCBxdWkgZXN0IHV0aWxpc8OpZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGVdIC0gQ29udGVudC1UeXBlIGRlIGxhIHJlcXVldGVcbiAqICAgICAgw6AgdXRpbGlzZXIgZGFucyBsZSBjYXMgZCd1bmUgcmVxdcOqdGUgWEhSIGVuIG1vZGUgUE9TVC5cbiAqICAgICAgTm9uIHByaXMgZW4gY29tcHRlIHNpICdwcm90b2NvbCcgdmF1dCBKU09OUCBldC9vdSBsYSBtw6l0aG9kZSBIVFRQIHZhdXQgR0VULlxuICogICAgICBQYXIgZMOpZmF1dCwgYydlc3QgbGEgbcOpdGhvZGUgR0VUIHF1aSBlc3QgdXRpbGlzw6llIGRvbmMgb24gbid1dGlsaXNlIHBhcyBkZSBDb250ZW50LVR5cGUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVPdXRdIC0gRMOpbGFpIGQnYXR0ZW50ZSBtYXhpbWFsIChlbiBtcykgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSAow6AgcGFydGlyIGRlIGwnZW52b2kgZGUgbGEgcmVxdcOqdGUpLlxuICogICAgICBQYXIgZMOpZmF1dCwgYXVjdW4gdGltZU91dCBuJ2VzdCBwcmlzIGVuIGNvbXB0ZSAodGltZW91dERlbGF5PSAwKS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3BvbnNlXSAtIEluZGlxdWUgc2kgbCdvbiBzb3VoYWl0ZSBxdWUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSBuZSBzb2l0IHBhcyBwYXJzw6llIHBhciBsJ0FQSSBhdmFudCBkJ8OqdHJlIHJlc3RpdHXDqWUuXG4gKiAgICAgIChDZi4gcGFyYW3DqHRyZSDCqyBvblN1Y2Nlc3MgwrsgcG91ciBwbHVzIGRlIGTDqXRhaWxzKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblN1Y2Nlc3NdIC0gRm9uY3Rpb24gYXBwZWzDqWUgbG9yc3F1ZSBsZSBzZXJ2aWNlIHLDqXBvbmQgY29ycmVjdGVtZW50IMOgIGxhIHJlcXXDqnRlXG4gKiAgICAgIChjb2RlIEhUVFAgMjAwLCBzYW5zIG1lc3NhZ2UgZCdlcnJldXIpLlxuICogICAgICBDZXR0ZSBmb25jdGlvbiBwcmVuZCBlbiBwYXJhbcOodHJlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UsXG4gKiAgICAgIHNvaXQgc291cyBsYSBmb3JtZSBkJ3VuIE9iamVjdCBKYXZhc2NyaXB0IGZvcm1hdMOpIHBhciBsZSBwYXJzZXVyIGTDqWRpw6kgw6AgbGEgc3ludGF4ZSBkdSBzZXJ2aWNlIChjb21wb3J0ZW1lbnQgcGFyIGTDqWZhdXQpIDtcbiAqICAgICAgc29pdCBicnV0ZSBhdSBmb3JtYXQgU3RyaW5nIG5vbiBwcsOpdHJhaXTDqSBzaSBsZSBwYXJhbcOodHJlIMKrIHJhd1Jlc3BvbnNlIMK7IGEgw6l0w6kgcHLDqWNpc8OpIGF2ZWMgbGEgdmFsZXVyIMKrIHRydWUgwrsuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25GYWlsdXJlXSAtIEZvbmN0aW9uIGFwcGVsw6llIGxvcnNxdWUgbGUgc2VydmljZSBuZSByw6lwb25kIHBhcyBjb3JyZWN0ZW1lbnRcbiAqICAgICAgKGNvZGUgSFRUUCBkZSByZXRvdXIgZGlmZsOpcmVudCBkZSAyMDAgb3UgcGFzIGRlIHLDqXBvbnNlKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJlZm9yZVBhcnNlXSAtIEZvbmN0aW9uIGFwcGVsw6llIGF2YW50IGxlIHBhcnNpbmcgZGUgbGEgcsOpcG9uc2VcbiAqICAgICAgUGVybWV0IGRlIG1vZGlmaWVyIGxhIHLDqXBvbnNlIGF2YW50IHBhcnNpbmcgc2kgbGEgZm9uY3Rpb24gcmV0b3VybmUgdW5lIFN0cmluZy5cbiAqICAgICAgQ2V0dGUgZm9uY3Rpb24gcHJlbmQgZW4gcGFyYW3DqHRyZSBsYSByw6lwb25zZSBYTUwgdGVsbGUgcXVlIHJlbnZvecOpZSBwYXIgbGUgc2VydmljZSxcbiAqICAgICAgc291cyBsYSBmb3JtZSBkJ3VuZSBjaGHDrm5lIGRlIGNhcmFjdMOocmVzIChjb21wb3J0ZW1lbnQgcGFyIGTDqWZhdXQpLlxuICogICAgICBTaSBsZSBwYXJhbcOodHJlIFwicmF3UmVzcG9uc2VcIiBhIMOpdMOpIHByw6ljaXPDqSBhdmVjIGxhIHZhbGV1ciBcInRydWVcIixcbiAqICAgICAgbGEgZm9uY3Rpb24gcHJlbmQgZW4gcGFyYW3DqHRyZSB1biBPYmplY3QgSmF2YVNjcmlwdCBjb250ZW5hbnQgbGEgcsOpcG9uc2UgWE1MLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBvcHRpb25zID0ge1xuICogICAgICBhcGlLZXkgOiBudWxsLFxuICogICAgICBzZXJ2ZXJVcmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zZXJ2aWNlLycsXG4gKiAgICAgIHByb3RvY29sIDogJ0pTT05QJywgLy8gSlNPTlB8WEhSXG4gKiAgICAgIHNzbCA6IGZhbHNlLFxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGNhbGxiYWNrTmFtZSA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICBvbkJlZm9yZVBhcnNlIDogZnVuY3Rpb24gKHJhd1Jlc3BvbnNlKSB7fVxuICogICB9O1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ29tbW9uU2VydmljZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21tb25TZXJ2aWNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiQ0xBU1NfQ09OU1RSVUNUT1JcIikpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJDb21tb25TZXJ2aWNlXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBDb21tb25TZXJ2aWNlIChvcHRpb25zKV1cIik7XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgb3B0aW9ucyBwYXIgZMOpZmF1dCBwb3VyIGxlcyBwYXJhbcOodHJlcyBvcHRpb25uZWxzXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIGR1IHNlcnZpY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgLy8gcHJvdG9jb2wgOiBcIkpTT05QXCIsXG4gICAgICAgIHByb3RvY29sIDogXCJYSFJcIixcbiAgICAgICAgc3NsIDogZmFsc2UsXG4gICAgICAgIHByb3h5VVJMIDogXCJcIixcbiAgICAgICAgLy8gY2FsbGJhY2tOYW1lIDogXCJcIixcbiAgICAgICAgY2FsbGJhY2tTdWZmaXggOiBudWxsLFxuICAgICAgICBodHRwTWV0aG9kIDogXCJHRVRcIixcbiAgICAgICAgdGltZU91dCA6IDAsXG4gICAgICAgIHJhd1Jlc3BvbnNlIDogZmFsc2UsXG4gICAgICAgIHNjb3BlIDogdGhpcyxcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxhIHJlcG9uc2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvblN1Y2Nlc3MgLSBsYSByZXBvbnNlIGVzdCBsYSBzdWl2YW50ZSA6IFwiLCByZXNwb25zZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGNhbGxiYWNrIHBhciBkZWZhdXQgcG91ciBsZXMgZXJyZXVyc1xuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciAtIGVycm9yXG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgb25GYWlsdXJlIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3Iuc3RhdHVzID09PSAyMDAgfHwgIWVycm9yLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25GYWlsdXJlIDogXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uRmFpbHVyZSAtIEVycmV1ciAoXCIsIGVycm9yLnN0YXR1cywgXCIpIDogXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGV0IG9uIGFqb3V0ZSBsZXMgb3B0aW9ucyBlbiBwYXJhbcOodHJlIGF1eCBvcHRpb25zIHBhciBkw6lmYXV0XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyBhbmFseXNlIGRlcyBvcHRpb25zXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICAvLyBnZXN0aW9uIGRlcyBjbGVmcyBBUElcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hcGlLZXkgJiYgIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcImFwaUtleVwiLCBcInNlcnZlclVybFwiKSk7XG4gICAgfVxuXG4gICAgLy8gbW9kaWZpY2F0aW9uIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIG9uU3VjY2VzcyBkYW5zIGxlIGNhcyBvw7kgbGEgcsOpcG9uc2UgYnJ1dGUgZXN0IGRlbWFuZMOpZVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UgJiYgIXRoaXMub3B0aW9ucy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2FsbGJhY2sgcGFyIGRlZmF1dCBwb3VyIGxhIHJlcG9uc2VcbiAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSByZXNwb25zZVxuICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib25TdWNjZXNzIC0gbGEgcsOpcG9uc2UgYnJ1dGUgZHUgc2VydmljZSBlc3QgbGEgc3VpdmFudGUgOiBcIiwgcmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgY2FsbGJhY2sgb25TdWNjZXNzXG4gICAgdmFyIGJPblN1Y2Nlc3MgPSAhISgodGhpcy5vcHRpb25zLm9uU3VjY2VzcyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSk7XG4gICAgaWYgKCFiT25TdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJvblN1Y2Nlc3MoKVwiKSk7XG4gICAgfVxuXG4gICAgLy8gZ2VzdGlvbiBkZSBsJ3VybCBkdSBzZXJ2aWNlIHBhciBkZWZhdXRcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBnZXN0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgcGFyIGRlZmF1dCBwb3VyIGxlcyBzZXJ2aWNlcyBxdWkgbmUgcG9zc8OoZGVudCBxdSd1bmUgc2V1bCB1cmwgcGFyIGRlZmF1dFxuICAgICAgICAvLyBsZXMgY2FzIHBhcnRpY3VsaWVycyBkZXMgc2VydmljZXMgYXZlYyBwbHVzaWV1cnMgdXJscyAoZXguIEFsdGkpIGRldnJvbnQgw6p0cmUgdHJhaXTDqSBkYW5zIGxhIGNsYXNzZSBkdSBjb21wb3NhbnRcbiAgICAgICAgLy8gZG9uYyBzaSBsJ3VybCBuJ2VzdCBwYXMgcmVuc2VpZ27DqWUsIGlsIGZhdXQgdXRpbGlzZXIgbGVzIHVybHMgcGFyIGRlZmF1dFxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0RlZmF1bHRVcmxTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uc3NsID0gdGhpcy5vcHRpb25zLnNzbDtcbiAgICAgICAgdmFyIHVybEJ5RGVmYXVsdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fRGVmYXVsdFVybFNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXVt0aGlzLkNMQVNTTkFNRV0udXJsKHRoaXMub3B0aW9ucy5hcGlLZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHVybEJ5RGVmYXVsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcnZlclVybCA9IHVybEJ5RGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiVVJMIHBhciBkZWZhdXQgw6AgZGV0ZXJtaW5lciBhdSBuaXZlYXUgZHUgY29tcG9zYW50Li4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUUgbmV0dG95YWdlIGRlcyBLVlAgZGFucyBsJ3VybCBkdSBzZXJ2aWNlXG4gICAgLy8gaWYgKHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAvLyAgICAgLy8gSU5GT1xuICAgIC8vICAgICAvLyBzaSBsJ3VybCBlc3QgcmVuc2VpZ27DqWUsIGlsIGZhdXQgbGEgbmV0dG95ZXIgZGUgdG91cyBzZXMgS1ZQXG4gICAgLy8gICAgIC8vIGV4LiBvbiBuZSB2ZXV0IHBhcyBkZSBwYXJhbXMuICdjYWxsYmFjaycgb3UgJ291dHB1dCcgY2FyIGNlY2kgZGVjbGVuY2hlcmFpdFxuICAgIC8vICAgICAvLyBkZXMgb3DDqXJhdGlvbnMgZCdlbmNhcHN1bGF0aW9ucyBkZXMgcmVwb25zZXMgbMOpZ8OocmVtZW50IGZhcmZlbHVlcyAuLi5cbiAgICAvLyAgICAgdmFyIHVybHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmw7XG4gICAgLy8gICAgIHZhciB1cmxwYXJ0cyA9IHVybHNvdXJjZS5zcGxpdChcIj9cIik7XG4gICAgLy8gICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSB1cmxwYXJ0c1swXTtcbiAgICAvLyB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGxhIG1ldGhvZGUgSFRUUFxuICAgIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID0gKHR5cGVvZiBvcHRpb25zLmh0dHBNZXRob2QgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5odHRwTWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBcIkdFVFwiO1xuXG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCkge1xuICAgICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICBjYXNlIFwiR0VUXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICBjYXNlIFwiREVMRVRFXCI6XG4gICAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9OT1RfU1VQUE9SVFwiLCBcImh0dHBNZXRob2RcIikpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fVU5LTk9XTlwiLCBcImh0dHBNZXRob2RcIikpO1xuICAgIH1cblxuICAgIC8vIGdlc3Rpb24gZHUgcHJvdG9jb2xlXG4gICAgLy8gdGhpcy5vcHRpb25zLnByb3RvY29sID0gKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSBcInN0cmluZ1wiICkgPyBvcHRpb25zLnByb3RvY29sLnRvVXBwZXJDYXNlKCkgOiBcIkpTT05QXCI7XG4gICAgdGhpcy5vcHRpb25zLnByb3RvY29sID0gKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSBcInN0cmluZ1wiKSA/IG9wdGlvbnMucHJvdG9jb2wudG9VcHBlckNhc2UoKSA6IFwiWEhSXCI7XG5cbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5wcm90b2NvbCkge1xuICAgICAgICBjYXNlIFwiSlNPTlBcIjpcbiAgICAgICAgY2FzZSBcIlhIUlwiOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwicHJvdG9jb2xcIikpO1xuICAgIH1cblxuICAgIC8vIG9uIGRldGVybWluZSBsJ2Vudmlyb25uZW1lbnQgZCdleGVjdXRpb24gOiBicm93c2VyIG91IG5vbiA/XG4gICAgLy8gZXQgb24gbGFuY2UgdW5lIGV4Y2VwdGlvbiBzdXIgbCd1dGlsaXNhdGlvbiBkdSBwcm90b2NvbGUgSlNPTlAgcG91ciBub2RlSlMuLi5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiSlNPTlBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9OT1RfU1VQUE9SVF9OT0RFSlNcIiwgXCJwcm90b2NvbD1KU09OUCAoaW5zdGVhZCB1c2UgWEhSKVwiKSk7XG4gICAgfVxuXG4gICAgLy8gbGUgcHJvdG9jb2xlIEpTT05QIG5lIGZvbmN0aW9ubmUgcXUnZW4gR0VULlxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiSlNPTlBcIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9IFwiR0VUXCI7XG4gICAgfVxuXG4gICAgLy8gZ2VzdGlvbiBkdSBjYWNoZVxuICAgIHRoaXMub3B0aW9ucy5ub2NhY2hlID0gb3B0aW9ucy5ub2NhY2hlIHx8IGZhbHNlO1xuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgLy8gYXR0cmlidXRzIGQnaW5zdGFuY2VzXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZGUgcsOpcG9uc2UgZHUgc2VydmljZVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucy5vdXRwdXRGb3JtYXQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFJlcXXDqnRlIGVudm95w6llIGF1IHNlcnZpY2VcbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFJlcG9uc2UgZHUgc2VydmljZVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6Q29tbW9uU2VydmljZVxuICovXG5Db21tb25TZXJ2aWNlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IENvbW1vblNlcnZpY2UsXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbCBkdSBzZXJ2aWNlIEfDqW9wb3J0YWlsXG4gICAgICovXG4gICAgY2FsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoganNoaW50IHZhbGlkdGhpcyA6IHRydWUgKi9cbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpjYWxsICgpXCIpO1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgLyoqIGZvbmN0aW9uIGQnZXhlY3V0aW9uICovXG4gICAgICAgIGZ1bmN0aW9uIHJ1biAoKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkNvbW1vblNlcnZpY2U6OnJ1biAoKVwiKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRSZXF1ZXN0LmNhbGwoY29udGV4dCwgb25FcnJvciwgb25CdWlsZFJlcXVlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcnVuLmNhbGwoY29udGV4dCk7XG5cbiAgICAgICAgLyoqIGNhbGxiYWNrIGRlIGZpbiBkZSBjb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUgKi9cbiAgICAgICAgZnVuY3Rpb24gb25CdWlsZFJlcXVlc3QgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkJ1aWxkUmVxdWVzdCA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jYWxsU2VydmljZS5jYWxsKGNvbnRleHQsIG9uRXJyb3IsIG9uQ2FsbFNlcnZpY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIGNhbGxiYWNrIGRlIGZpbiBkJ2FwcGVsIGF1IHNlcnZpY2UgKi9cbiAgICAgICAgZnVuY3Rpb24gb25DYWxsU2VydmljZSAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkNvbW1vblNlcnZpY2U6Om9uQ2FsbFNlcnZpY2UgOiBcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYW5hbHl6ZVJlc3BvbnNlLmNhbGwoY29udGV4dCwgb25FcnJvciwgb25BbmFseXplUmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIGNhbGxiYWNrIGRlIGZpbiBkZSBsZWN0dXJlIGRlIGxhIHJlcG9uc2UgKi9cbiAgICAgICAgZnVuY3Rpb24gb25BbmFseXplUmVzcG9uc2UgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkFuYWx5emVSZXNwb25zZSA6IFwiLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MuY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25FcnJvci5jYWxsKHRoaXMsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJBbmFseXNlIGRlIGxhIHJlcG9uc2UgZW4gw6ljaGVjICE/XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBjYWxsYmFjayBkZSBnZXN0aW9uIGRlcyBlcnJldXJzIDogcmVudm9pdCB1biBvYmpldCBkZSB0eXBlIEVycm9yU2VydmljZSAqL1xuICAgICAgICBmdW5jdGlvbiBvbkVycm9yIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJDb21tb25TZXJ2aWNlOjpvbkVycm9yKClcIik7XG4gICAgICAgICAgICAvLyBlcnJvciA6IGwnb2JqZXQgZXN0IGR1IHR5cGUgRXJyb3JTZXJ2aWNlIG91IEVycm9yXG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkpIHtcbiAgICAgICAgICAgICAgICBlID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkZhaWx1cmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgKi9cbiAgICBidWlsZFJlcXVlc3QgOiBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIm92ZXJ3cml0dGVuIG1ldGhvZCAhXCIpO1xuICAgICAgICAvLyByZXRvdXJuZSBsJ29iamV0ICd0aGlzLnJlcXVlc3QnXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBcIlRoaXMgbWV0aG9kIG11c3QgYmUgb3ZlcndyaXR0ZW4gIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdWNjZXNzLmNhbGwodGhpcywgXCJUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJ3cml0dGVuICFcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVsIGR1IHNlcnZpY2VcbiAgICAgKi9cbiAgICBjYWxsU2VydmljZSA6IGZ1bmN0aW9uIChlcnJvciwgc3VjY2Vzcykge1xuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIHJldG91cm5lIGwnb2JqZXQgJ3RoaXMucmVzcG9uc2UnXG5cbiAgICAgICAgLy8gTk9URVNcbiAgICAgICAgLy8gIFBvdXIgbGUgbW9kZSBYSFIsIG9uIHJlY3Vww6hyZSB1bmUgcmVwb25zZSBzb3VzIGZvcm1lIGQndW5lIHN0cmluZy4gTGUgY29udGVudFxuICAgICAgICAvLyAgZXN0IGRvbmMgZHUgSlNPTiBuYXRpZiBvdSBkdSBYTUwgZW4gZm9uY3Rpb24gZHUgc2VydmljZSBkZW1hbmTDqSAocGFzIGQnZW5jYXBzdWxhdGlvbiAhKS5cbiAgICAgICAgLy8gIFBvdXIgbGUgbW9kZSBKU09OUCwgb24gYSB0b3Vqb3VycyB1biBvYmpldCBKU09OIG1haXMgc291cyAyIGZvcm1hdHMgOlxuICAgICAgICAvLyAgICAgIC0gbmF0aWZcbiAgICAgICAgLy8gICAgICAtIFhNTCBlbmNhcHN1bMOpIDpcbiAgICAgICAgLy8gICAgICAgICAge2h0dHAgOiB7c3RhdHVzOjIwMCwgZXJyb3I6bnVsbH0seG1sIDoncsOpcG9uc2UgZHUgc2VydmljZSd9XG4gICAgICAgIC8vICAgICAgICAgIHtodHRwIDoge3N0YXR1czo0MDAsIGVycm9yOidyZXBvbnNlIGR1IHNlcnZpY2UnfSx4bWwgOm51bGx9XG4gICAgICAgIC8vICBFbiBYSFIsIGxhIHJlcG9uc2UgZXN0IGRpcmVjdGVtZW50IHNhdXZlZ2FyZMOpZSBkYW5zICd0aGlzLnJlc3BvbnNlJy5cbiAgICAgICAgLy8gIFBhciBjb250cmUsIGVuIEpTT05QLCBvbiBkb2l0IGFuYWx5c2VyIGxhIHJlcG9uc2UgKHN0YXR1cyBvdSBub24gdmlkZSksXG4gICAgICAgIC8vICBldCBuZSByZW52b3llciBxdWUgbGUgY29udGVudSAoeG1sIG91IGwnb2JqZXQpXG5cbiAgICAgICAgLy8gZ2VzdGlvbiBkZSBsYSBwcm94aWZpY2F0aW9uIGR1IHNlcnZpY2VcbiAgICAgICAgdmFyIHN0clVybFByb3hpZmllZCA9IG51bGw7XG4gICAgICAgIHZhciBzdHJEYXRhID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgICAgIC8vIGEgdCBvbiBtaXMgZW4gcGxhY2UgdW4gcHJveHkgP1xuICAgICAgICAvLyBsYSBwcm94eWZpY2F0aW9uIGVzdCB2YWxhYmxlIHVuaXF1ZW1lbnQgZW4gbW9kZSBYSFIgIVxuICAgICAgICB2YXIgYlVybFByb3hpZmllZCA9ICEhKCh0aGlzLm9wdGlvbnMucHJveHlVUkwgJiYgdGhpcy5vcHRpb25zLnByb3RvY29sID09PSBcIlhIUlwiKSk7XG5cbiAgICAgICAgLy8gcmFqb3V0IGRlIGwnb3B0aW9uIGdwYmliYWNjZXNzXG4gICAgICAgIC8vIEZJWE1FIDogYWNjZXMgYXUgbnVtZXJvIGRlIHZlcnNpb24gZGUgcGFja2FnZS5jb25mXG4gICAgICAgIC8qXG4gICAgICAgIHZhciBzY29wZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTtcbiAgICAgICAgdmFyIHNlcnZpY2VzVmVyc2lvbiA9IHNjb3BlLkdwID8gc2NvcGUuR3Auc2VydmljZXNWZXJzaW9uIDogXCIyLjAuMFwiO1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19IZWxwZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwge1xuICAgICAgICAgICAgXCJncC1hY2Nlc3MtbGliXCIgOiBcIjIuMC4wXCJcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIHNpIGxlIHByb3h5IGVzdCByZW5zZWlnbsOpLCBvbiBwcm94aWZpZSBsJ3VybCBkdSBzZXJ2aWNlXG4gICAgICAgIGlmIChiVXJsUHJveGlmaWVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJVcmxQcm94aWZpZWQgPSB0aGlzLm9wdGlvbnMucHJveHlVUkwgKyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX0hlbHBlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vcm1hbHl6ZVVybCh0aGlzLm9wdGlvbnMuc2VydmVyVXJsLCB0aGlzLnJlcXVlc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIHN0ckRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICAgICAgc3RyVXJsUHJveGlmaWVkID0gdGhpcy5vcHRpb25zLnByb3h5VVJMICsgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19IZWxwZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWx5emVVcmwodGhpcy5vcHRpb25zLnNlcnZlclVybCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3RyRGF0YSA9IHRoaXMucmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRleHRlIGR1IGNvbXBvc2FudCBzcMOpY2lmaXF1ZSAhXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybCA6IHN0clVybFByb3hpZmllZCB8fCB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLFxuICAgICAgICAgICAgbWV0aG9kIDogdGhpcy5vcHRpb25zLmh0dHBNZXRob2QsXG4gICAgICAgICAgICBwcm90b2NvbCA6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAgICAgICAgIHRpbWVPdXQgOiB0aGlzLm9wdGlvbnMudGltZU91dCB8fCAwLFxuICAgICAgICAgICAgZm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCwgLy8gY2VjaSBkZWNsZW5jaGUgbGUgcGFyc2luZyBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UsIG1haXMgb24gc291aGFpdGUgdG91am91cnMgdW5lIHJlcG9uc2UgYnJ1dGUgKHN0cmluZykgIVxuICAgICAgICAgICAgbm9jYWNoZSA6IHRoaXMub3B0aW9ucy5ub2NhY2hlIHx8IGZhbHNlLCAvLyBjZWNpIHBlcm1ldCBkJ2Fqb3V0ZXIgdW4gdGltZXN0YW1wIGRhbnMgbGEgcmVxdcOqdGVcbiAgICAgICAgICAgIHdyYXAgOiB0aGlzLm9wdGlvbnMucHJvdG9jb2wgIT09IFwiWEhSXCIsIC8vIGNlY2kgZGVjbGVuY2hlIGwnZW5jYXBzdWxhdGlvbiBkZSBsYSByZXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiwgbWFpcyBwYXMgZW4gbW9kZSBYSFIgIVxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tTdWZmaXgsXG4gICAgICAgICAgICAvLyBjYWxsYmFja05hbWUgOiB0aGlzLm9wdGlvbnMuY2FsbGJhY2tOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBkYXRhIDogc3RyRGF0YSxcbiAgICAgICAgICAgIGhlYWRlcnMgOiBudWxsLCAvLyBUT0RPLi4uXG4gICAgICAgICAgICBjb250ZW50IDogdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXMub3B0aW9ucy5zY29wZSB8fCB0aGlzLFxuICAgICAgICAgICAgLyoqIGNhbGxiYWNrIGRlIHJlcG9uc2UgKi9cbiAgICAgICAgICAgIG9uUmVzcG9uc2UgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxvZ2dlci50cmFjZShcImNhbGxTZXJ2aWNlOjpvblJlc3BvbnNlKClcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBsZSBjb250ZW51IGRlIGxhIHJlcG9uc2Ugw6AgcmVudm95ZXIgIVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIFhIUiA6IG9uIHJlbnZvaWUgbGEgcmVwb25zZSBicnV0ZSAoc3RyaW5nKVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiWEhSXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gbmUgcGV1dCBwYXMgc2F2b2lyIHNpIGxhIHJlcG9uc2UgZXN0IGVuIFhNTCBvdSBKU09OXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmMgb24gbGFpc3NlIGxlIGJvdWxvdCDDoCBsJ2FuYWx5c2UgZGUgbGEgcmVwb25zZSAhXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBKU09OUCA6IG9uIGRvaXQgYW5hbHlzZXIgbGUgY29udGVudSAoanNvbilcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIudHJhY2UoXCJSZXNwb25zZSBKU09OXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBvbnNlIGVuY2Fwc3Vsw6llIDoge2h0dHAgOiB7c3RhdHVzOjIwMCwgZXJyb3I6bnVsbH0seG1sIDoncsOpcG9uc2UgZHUgc2VydmljZSd9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaHR0cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5odHRwLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwoc2VsZiwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiByZXNwb25zZS5odHRwLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiByZXNwb25zZS5odHRwLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVzcG9uc2UueG1sOyAvLyBwYXIgZGVmYXV0ICFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLm9uQmVmb3JlUGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Jlc3BvbnNlID0gc2VsZi5vcHRpb25zLm9uQmVmb3JlUGFyc2UoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1Jlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IG5ld1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jYWxsKHNlbGYsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJMZSBjb250ZW51IGRlIGxhIHJlcG9uc2UgZXN0IHZpZGUgIT9cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2F1dmVnYXJkZSBkZSBsYSByZXBvbnNlIGRhbnMgbCdvYmpldCBwYXJlbnQgKENvbW1vblNlcnZpY2UpXG4gICAgICAgICAgICAgICAgc2VsZi5yZXNwb25zZSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBvbiByZW52b2llIGxhIHJlcG9uc2UuLi5cbiAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwoc2VsZiwgY29udGVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqIGNhbGxiYWNrIGRlcyBlcnJldXJzICovXG4gICAgICAgICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uRmFpbHVyZSgpXCIpO1xuICAgICAgICAgICAgICAgIC8vIG9uIGVzdCBmb3JjZW1lbnQgc3VyIHVuZSBlcnJldXIgbGV2w6llIHBhciB1biBzZXJ2aWNlICFcbiAgICAgICAgICAgICAgICBlLnR5cGUgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlI7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2FsbChzZWxmLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKGUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKiogY2FsbGJhY2sgZGUgdGltZU91dCAqL1xuICAgICAgICAgICAgb25UaW1lT3V0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLnRyYWNlKFwiY2FsbFNlcnZpY2U6Om9uVGltZU91dCgpXCIpO1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbGwoc2VsZiwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShcIlRpbWVPdXQhXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1Byb3RvY29sc19Qcm90b2NvbF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNlbmQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgZGUgbGEgcsOpcG9uc2VcbiAgICAgKi9cbiAgICBhbmFseXplUmVzcG9uc2UgOiBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIm92ZXJ3cml0dGVuIG1ldGhvZCAhXCIpO1xuICAgICAgICAvLyByZXRvdXJuZSBsJ29iamV0IHNww6ljaWZpcXVlIGF1IHR5cGUgZGUgY29tcG9zYW50IChqc29uKVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcywgXCJUaGlzIG1ldGhvZCBtdXN0IGJlIG92ZXJ3cml0dGVuICFcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIFwiVGhpcyBtZXRob2QgbXVzdCBiZSBvdmVyd3JpdHRlbiAhXCIpO1xuICAgIH1cblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb21tb25TZXJ2aWNlKTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENsYXNzZSB1dGlsaXRhaXJlXG4gKlxuICogQG1vZHVsZSBIZWxwZXJcbiAqIEBwcml2YXRlXG4gKiBAYWxpYXMgR3AuVXRpbHMuSGVscGVyXG4gKi9cbnZhciBIZWxwZXIgPSB7XG5cbiAgICAvKipcbiAgICAgKiBjb25jYXRlbmF0aW9uIGRlcyBwYXJhbWV0cmVzIGtleS92YWx1ZSBkYW5zIGxlcyB1cmxzXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5vcm1hbHl6ZVBhcmFtZXRlcnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHRhYmxlYXUgZGUgY2xlZi92YWxldXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVQYXJhbWV0ZXJzICh7XG4gICAgICogICAgICAgICBrZXkxOnZhbHVlMSxcbiAgICAgKiAgICAgICAgIGtleTI6dmFsdWUyLFxuICAgICAqICAgICAgICAga2V5Mzp2YWx1ZTNcbiAgICAgKiAgfSk7XG4gICAgICogIC8vIG91dCA6IFwia2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgbGVzIHBhcmFtw6h0cmVzIGNvbmNhdMOpbsOpc1xuICAgICAqL1xuICAgIG5vcm1hbHl6ZVBhcmFtZXRlcnMgOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHRhYlBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhYlBhcmFtcy5wdXNoKGtleSArIFwiPVwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlQYXJhbXMgPSB0YWJQYXJhbXMuam9pbihcIiZcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXlQYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdMOpbmF0aW9uIGV0IGVuY29kYWdlIGRlcyB1cmxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBub3JtYWx5emVVcmxcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcGFyYW1zIC0gdGFibGVhdSBkZSBjbGVmL3ZhbGV1ciBvdSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZSAtIHRydWV8ZmFsc2UsIGZhbHNlIHBhciBkZWZhdXRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEdwLlV0aWxzLkhlbHBlci5ub3JtYWx5emVVcmwgKHVybCwge1xuICAgICAqICAgICAgICAga2V5MTp2YWx1ZTEsXG4gICAgICogICAgICAgICBrZXkyPTp2YWx1ZTIsXG4gICAgICogICAgICAgICBrZXkzOnZhbHVlM1xuICAgICAqICB9KTtcbiAgICAgKiAgLy8gb3V0IDogXCJ1cmw/a2V5MT12YWx1ZTEma2V5Mj12YWx1ZTIma2V5Mz12YWx1ZTNcIlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIHVybCBub3JtYWxpc8OpZVxuICAgICAqL1xuICAgIG5vcm1hbHl6ZVVybCA6IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgZW5jb2RlKSB7XG4gICAgICAgIHZhciBteVVybCA9IHVybDtcblxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgayA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChrID09PSAtMSkgeyAvLyBwYXMgZGUgPyBldCBLVlBcbiAgICAgICAgICAgICAgICBteVVybCArPSBcIj9cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGsgIT09IC0xICYmIGsgIT09IHVybC5sZW5ndGggLSAxKSB7IC8vIEtWUFxuICAgICAgICAgICAgICAgIG15VXJsICs9IFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBteVVybCArPSBwYXJhbXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG15VXJsICs9IHRoaXMubm9ybWFseXplUGFyYW1ldGVycyhwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuY29kZSkge1xuICAgICAgICAgICAgLy8gRklYTUUgYm9ubmUgaWTDqWUgP1xuICAgICAgICAgICAgbXlVcmwgPSBlbmNvZGVVUklDb21wb25lbnQobXlVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG15VXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbiBkJ3VuZSBjaGFpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIC0gbm9tYnJlIGRlIHRhYnVsYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gY2hhaW5lXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEdwLlV0aWxzLkhlbHBlci5pbmRlbnQgKDIsIFwibWVzc2FnZSDDoCBpbmRlbnRlclwiKVxuICAgICAqIC8vIG91dFxuICAgICAqIC8vIC4uLi4uLi4ubWVzc2FnZSDDoCBpbmRlbnRlclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0b3VybmUgdW5lIGNoYWluZSBpbmRlbnTDqWVcbiAgICAgKi9cbiAgICBpbmRlbnQgOiBmdW5jdGlvbiAobiwgbXNnKSB7XG4gICAgICAgIHZhciBudW0gPSBuIHx8IDA7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkobnVtICsgMSkuam9pbihcIlxcdFwiKSArIG1zZztcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEhlbHBlcik7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gY2V0dGUgY2xhc3NlIGNvbnRpZW50IGxlcyBVUkxzIHBhciBkZWZhdXQgZGVzIHNlcnZpY2VzLlxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbZWxldmF0aW9uLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtlbGV2YXRpb24teG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbcHJvZmlsLWpzb25dXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoa2V5KVtwcm9maWwteG1sXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkFsdGkudXJsKGtleSlbd3BzXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlByb2Nlc3NJc29DdXJ2ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db21wbGV0ZS51cmwoa2V5KVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLlJldmVyc2VHZW9jb2RlLnVybChrZXkpXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYXBpS2V5XVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkF1dG9Db25mLnVybChrZXkpW2FwaUtleXNdXG4vLyAgRGVmYXVsdFVybFNlcnZpY2UuQXV0b0NvbmYudXJsKGtleSlbYWdncmVnYXRlXVxuLy8gIERlZmF1bHRVcmxTZXJ2aWNlLkdlb2NvZGUudXJsKGtleSlcbi8vICBEZWZhdWx0VXJsU2VydmljZS5Sb3V0ZS51cmwoa2V5KVxuXG4vLyBFeGFtcGxlIDpcbi8vXG4vLyBEZWZhdWx0VXJsU2VydmljZS5BbHRpLnVybCgnZWZlNHI1NHRqNHV5NWk3OG83NTQ1ZWF6N2U4N2EnKVtlbGV2YXRpb24tanNvbl1cbi8vICBvdXRwdXQge1N0cmluZ30gLT4gaHR0cDovL3d4cy5pZ24uZnIvZWZlNHI1NHRqNHV5NWk3OG83NTQ1ZWF6N2U4N2EvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXG4vL1xuLy8gRGVmYXVsdFVybFNlcnZpY2UuQWx0aS51cmwoJ2VmZTRyNTR0ajR1eTVpNzhvNzU0NWVhejdlODdhJylcbi8vIG91dHB1dCB7T2JqZWN0fFN0cmluZ31cbi8vIC0+IGh0dHA6Ly93eHMuaWduLmZyL2VmZTRyNTR0ajR1eTVpNzhvNzU0NWVhejdlODdhL2FsdGkvcmVzdC9lbGV2YXRpb24uanNvblxuLy8gLT4gaHR0cDovL3d4cy5pZ24uZnIvZWZlNHI1NHRqNHV5NWk3OG83NTQ1ZWF6N2U4N2EvYWx0aS9yZXN0L2VsZXZhdGlvbi54bWxcbi8vIC0+IGh0dHA6Ly93eHMuaWduLmZyL2VmZTRyNTR0ajR1eTVpNzhvNzU0NWVhejdlODdhL2FsdGkvcmVzdC9lbGV2YXRpb25MaW5lLmpzb25cbi8vIC0+IGh0dHA6Ly93eHMuaWduLmZyL2VmZTRyNTR0ajR1eTVpNzhvNzU0NWVhejdlODdhL2FsdGkvcmVzdC9lbGV2YXRpb25MaW5lLnhtbFxuLy8gLT4gaHR0cDovL3d4cy5pZ24uZnIvZWZlNHI1NHRqNHV5NWk3OG83NTQ1ZWF6N2U4N2EvYWx0aS93cHNcbi8vXG4vLyBGb3JjZSBzc2wgOlxuLy9cbi8vIERlZmF1bHRVcmxTZXJ2aWNlLnNzbCA9IHRydWU7XG4vLyBEZWZhdWx0VXJsU2VydmljZS5BdXRvQ29tcGxldGUudXJsKCdlZmU0cjU0dGo0dXk1aTc4bzc1NDVlYXo3ZTg3YScpXG4vLyBvdXRwdXQge09iamVjdHxTdHJpbmd9XG4vLyAtPiBodHRwczovL3d4cy5pZ24uZnIvZWZlNHI1NHRqNHV5NWk3OG83NTQ1ZWF6N2U4N2Evb2xzL2FwaXMvY29tcGxldGlvblxuXG4vLyBjb25zdGFudGVzIGludGVybmVzXG52YXIgSVNCUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IDEgOiAwO1xudmFyIEhPU1ROQU1FID0gXCJ3eHMuaWduLmZyXCI7XG5cbi8qKlxuICogRGVmYXVsdCBHZW9wb3J0YWwgd2ViIHNlcnZpY2VzIFVSTHMgYWNjZXNzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5EZWZhdWx0VXJsXG4gKi9cbnZhciBEZWZhdWx0VXJsU2VydmljZSA9IHtcblxuICAgIC8qKiBpZiBzZXQgdHJ1ZSwgcmVxdWlyZSB0aGUgdXNlIG9mIGh0dHBzIHByb3RvY29sIChleGNlcHQgYnJvd3NlcikgKi9cbiAgICBzc2wgOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICogYmFzZSB1cmwgb2Ygc2VydmljZXMgKHNzbCBwcm90b2NvbCBtYW5hZ2VtZW50KVxuICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAqL1xuICAgIHVybCA6IGZ1bmN0aW9uIChrZXksIHBhdGgpIHtcbiAgICAgICAgLy8gZW4gbW9kZSBicm93c2VyLCBjJ2VzdCBsZSBwcm90b2NvbGUgZHUgbmF2aWdhdGV1cixcbiAgICAgICAgLy8gc2lub24sIGlsIGVzdCBmaXjDqSBwYXIgbCdvcHRpb24gJ3NzbCcgKHBhciBkw6lmYXV0IMOgIGZhbHNlLCBjYWQgZW4gaHR0cClcbiAgICAgICAgdmFyIF9wcm90b2NvbCA9IChJU0JST1dTRVIpID8gKGxvY2F0aW9uICYmIGxvY2F0aW9uLnByb3RvY29sICYmIGxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwczpcIikgPT09IDAgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIikgOiAoRGVmYXVsdFVybFNlcnZpY2Uuc3NsID8gXCJodHRwczovL1wiIDogXCJodHRwOi8vXCIpO1xuICAgICAgICByZXR1cm4gX3Byb3RvY29sICsgSE9TVE5BTUUuY29uY2F0KFwiL1wiLCBrZXksIHBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbGV2YXRpb24gd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChrZXkpIC0gUmV0dXJucyBlbGV2YXRpb24gc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJlbGV2YXRpb24tanNvblwiLCBcImVsZXZhdGlvbi14bWxcIiwgXCJwcm9maWwtanNvblwiIG9yIFwicHJvZmlsLXhtbFwiKS5cbiAgICAgKi9cbiAgICBBbHRpIDoge1xuICAgICAgICBfa2V5IDoge1xuICAgICAgICAgICAgLy8gcmVzdFxuICAgICAgICAgICAgXCJlbGV2YXRpb24tanNvblwiIDogXCIvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXCIsXG4gICAgICAgICAgICBcImVsZXZhdGlvbi14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb24ueG1sXCIsXG4gICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBcIi9hbHRpL3Jlc3QvZWxldmF0aW9uTGluZS5qc29uXCIsXG4gICAgICAgICAgICBcInByb2ZpbC14bWxcIiA6IFwiL2FsdGkvcmVzdC9lbGV2YXRpb25MaW5lLnhtbFwiLFxuICAgICAgICAgICAgLy8gb3RoZXJcbiAgICAgICAgICAgIHdwcyA6IFwiL2FsdGkvd3BzXCJcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RcbiAgICAgICAgICAgICAgICBcImVsZXZhdGlvbi1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24tanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJlbGV2YXRpb24teG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJlbGV2YXRpb24teG1sXCJdKSxcbiAgICAgICAgICAgICAgICBcInByb2ZpbC1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwtanNvblwiXSksXG4gICAgICAgICAgICAgICAgXCJwcm9maWwteG1sXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJwcm9maWwteG1sXCJdKSxcbiAgICAgICAgICAgICAgICAvLyBvdGhlclxuICAgICAgICAgICAgICAgIHdwcyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcIndwc1wiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIElzb0N1cnZlIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgaXNvY3VydmUgc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJpc28tanNvblwiIG9yIFwiaXNvLXhtbFwiKS5cbiAgICAgKi9cbiAgICBQcm9jZXNzSXNvQ3VydmUgOiB7XG4gICAgICAgIF9rZXkgOiB7XG4gICAgICAgICAgICBcImlzby1qc29uXCIgOiBcIi9pc29jaHJvbmUvaXNvY2hyb25lLmpzb25cIiwgLy8gcmVzdCAoZ2VvY29uY2VwdClcbiAgICAgICAgICAgIFwiaXNvLXhtbFwiIDogXCIvaXNvY2hyb25lL2lzb2Nocm9uZS54bWxcIiAvLyByZXN0IChnZW9jb25jZXB0KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiB1cmxcbiAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5XG4gICAgICAgICogQHJldHVybnMge1N0cmluZ30gdXJsXG4gICAgICAgICovXG4gICAgICAgIHVybCA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgXCJpc28tanNvblwiIDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5W1wiaXNvLWpzb25cIl0pLFxuICAgICAgICAgICAgICAgIFwiaXNvLXhtbFwiIDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5W1wiaXNvLXhtbFwiXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEF1dG9jb21wbGV0aW9uIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgYXV0b2NvbXBsZXRlIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBBdXRvQ29tcGxldGUgOiB7XG4gICAgICAgIF9rZXkgOiBcIi9vbHMvYXBpcy9jb21wbGV0aW9uXCIsXG4gICAgICAgIC8qKlxuICAgICAgICAqIHVybFxuICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBrZXlcbiAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1cmxcbiAgICAgICAgKi9cbiAgICAgICAgdXJsIDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldmVyc2UgZ2VvY29kaW5nIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgcmV2ZXJzZSBnZW9jb2Rpbmcgc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgU3RyaW5nLlxuICAgICAqL1xuICAgIFJldmVyc2VHZW9jb2RlIDoge1xuICAgICAgICBfa2V5IDogXCIvZ2VvcG9ydGFpbC9vbHNcIixcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXV0b2NvbmZpZ3VyYXRpb24gd2ViIHNlcnZpY2UgYWNjZXNzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdXJsIChba2V5MSwuLi5dKSAtIFJldHVybnMgYXV0b2NvbmZpZ3VyYXRpb24gc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBnZW9wb3J0YWwgYWNjZXNzIGtleSAocykgZ2l2ZW4gYXMgYSBTdHJpbmcgYXJyYXkgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB0aGUgYWNjZXNzIG1vZGUgKFwiYXBpS2V5XCIsIFwiYXBpS2V5c1wiIG9yIFwiYWdncmVnYXRlXCIpLlxuICAgICAqL1xuICAgIEF1dG9Db25mIDoge1xuICAgICAgICBfa2V5IDoge1xuICAgICAgICAgICAgYXBpS2V5IDogXCIvYXV0b2NvbmZcIixcbiAgICAgICAgICAgIGFwaUtleXMgOiBcIi9hdXRvY29uZj9rZXlzPSVLRVlTJVwiLFxuICAgICAgICAgICAgYWdncmVnYXRlIDogXCIvYXV0b2NvbmYvaWQvXCJcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpICYmIGtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IGtleVswXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBrZXlzICs9IFwiLFwiICsga2V5W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXBpS2V5IDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5W1wiYXBpS2V5XCJdKSwgLy8gdW5lIHNldWxlIGNsw6lcbiAgICAgICAgICAgICAgICBhcGlLZXlzIDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleVswXSwgdGhpcy5fa2V5W1wiYXBpS2V5c1wiXSkucmVwbGFjZShcIiVLRVlTJVwiLCBrZXlzKSwgLy8gYXV0b2NvbmYgZGUgcGx1c2lldXJzIGNsw6lzXG4gICAgICAgICAgICAgICAgYWdncmVnYXRlIDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5W1wiYWdncmVnYXRlXCJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VvY29kaW5nIHdlYiBzZXJ2aWNlIGFjY2Vzc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVybCAoa2V5KSAtIFJldHVybnMgZ2VvY29kaW5nIHNlcnZpY2UgZGVmYXVsdCB1cmxzIHdpdGggb3Igd2l0aG91dCBnZW9wb3J0YWwgYWNjZXNzIGtleSBnaXZlbiBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc3VsdCBpcyBhIFN0cmluZy5cbiAgICAgKi9cbiAgICBHZW9jb2RlIDoge1xuICAgICAgICBfa2V5IDogXCIvZ2VvcG9ydGFpbC9vbHNcIixcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUm91dGluZyB3ZWIgc2VydmljZSBhY2Nlc3NcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cmwgKGtleSkgLSBSZXR1cm5zIHJvdXRpbmcgc2VydmljZSBkZWZhdWx0IHVybHMgd2l0aCBvciB3aXRob3V0IGdlb3BvcnRhbCBhY2Nlc3Mga2V5IGdpdmVuIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzdWx0IGlzIGEgamF2YXNjcmlwdCBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgdXJscyBnaXZlbiB1c2VkIHByb3RvY29scyAoXCJyb3V0ZS1qc29uXCIgb3IgXCJyb3V0ZS14bWxcIikuXG4gICAgICovXG4gICAgUm91dGUgOiB7XG4gICAgICAgIF9rZXkgOiB7XG4gICAgICAgICAgICBvbHMgOiBcIi9pdGluZXJhaXJlL29sc1wiLCAvLyBvcGVuTFNcbiAgICAgICAgICAgIFwicm91dGUtanNvblwiIDogXCIvaXRpbmVyYWlyZS9yZXN0L3JvdXRlLmpzb25cIiwgLy8gcmVzdCAoZ2VvY29uY2VwdClcbiAgICAgICAgICAgIFwicm91dGUteG1sXCIgOiBcIi9pdGluZXJhaXJlL3Jlc3Qvcm91dGUueG1sXCIgLy8gcmVzdCAoZ2VvY29uY2VwdClcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogdXJsXG4gICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGtleVxuICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVybFxuICAgICAgICAqL1xuICAgICAgICB1cmwgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9scyA6IERlZmF1bHRVcmxTZXJ2aWNlLnVybChrZXksIHRoaXMuX2tleVtcIm9sc1wiXSksXG4gICAgICAgICAgICAgICAgXCJyb3V0ZS1qc29uXCIgOiBEZWZhdWx0VXJsU2VydmljZS51cmwoa2V5LCB0aGlzLl9rZXlbXCJyb3V0ZS1qc29uXCJdKSxcbiAgICAgICAgICAgICAgICBcInJvdXRlLXhtbFwiIDogRGVmYXVsdFVybFNlcnZpY2UudXJsKGtleSwgdGhpcy5fa2V5W1wicm91dGUteG1sXCJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRGVmYXVsdFVybFNlcnZpY2UpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGdsb2JhbCByZXF1aXJlICovXG5cblxuLy8gaW1wb3J0IF9feG1sZG9tIGZyb20gXCJ4bWxkb21cIjtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQ2xhc3NlIHBlcm1ldHRhbnQgZCfDqWNyaXJlIG91IGRlIGxpcmUgZHUgWE1MLCBzb3VzIGZvcm1lIGRlIGRvY3VtZW50IERPTSxcbiAqIMOpdmVudHVlbGxlbWVudCBzZWxvbiBkZXMgY2zDqXMgZGUgbGVjdHVyZSAocmVhZGVycykgb3UgZCfDqWNyaXR1cmUgKHdyaXRlcnMpIHNww6ljaWZpcXVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5Gb3JtYXRzLlhNTFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGR1IGZvcm1hdCBYTUxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmVhZGVyXSAtIEluc3RhbmNlIGQndW4gUmVhZGVyIGRlIHNlcnZpY2UgKEFsdGlSZXNwb25zZVJlYWRlciwgR2VvY29kZVJlcXVlc3RSZWFkZXIsIGV0Yy4pXG4gKiAgICAgIHV0aWxlIHBvdXIgaW50ZXJwcsOpdGVyIGxlIFhNTCBsb3JzcXVlIHNhIHN0cnVjdHVyZSBlc3QgY29ubnVlLlxuICogICAgICBDZSByZWFkZXIgZG9pdCBjb21wb3J0ZXIgYXUgbW9pbnMgdW5lIGZvbmN0aW9uIHN0YXRpcXVlIHJlYWQgKHJvb3QpIHBlcm1ldHRhbnQgZCdpbml0aWFsaXNlciBsYSBsZWN0dXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZXJzXSAtIHdyaXRlcnNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMueG1sU3RyaW5nXSAtIGNoYcOubmUgZGUgY2FyYWN0w6hyZSBjb250ZW5hbnQgZHUgWE1MIMOgIGludGVycHLDqXRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBYTUwgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgWE1MKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWE1MIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gRklYTUUgOiBub3Rpb24gZGUgc2luZ2xldG9uXG5cbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFhNTCAoKV1cIik7XG5cbiAgICAvKipcbiAgICAgKiBDaGHDrm5lIGRlIGNhcmFjdMOocmVzIGNvbnRlbmFudCBsZSB0ZXh0ZSBYTUxcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMueG1sU3RyaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERPTSBFbGVtZW50IGNvcnJlc3BvbmRhbnQgw6AgbGEgc3RydWN0dXJlIGR1IFhNTC5cbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnhtbERvYyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPYmpldCBjb250ZW5hbnQgZGVzIGZvbmN0aW9ucyBkZSBsZWN0dXJlIGRlcyBkaWZmw6lyZW50ZXMgYmFsaXNlcyBYTUwuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IG51bGw7XG5cbiAgICAvLyB0cmFpdGVtZW50IGRlcyBwYXJhbcOodHJlcyBkJ29wdGlvbnMgcydpbCB5IGVuIGFcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy54bWxTdHJpbmcgJiYgdHlwZW9mIG9wdGlvbnMueG1sU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnhtbFN0cmluZyA9IG9wdGlvbnMueG1sU3RyaW5nO1xuICAgICAgICAgICAgLy8gU2kgdW5lIGNoYWluZSBkZSBjYXJhY3TDqHJlIGEgw6l0w6kgcGFzc8OpZSBlbiBlbnRyw6llIDogb24gbGEgdHJhbnNmb3JtZSBhdXNzaSBlbiBYTUwgZG9jdW1lbnRcbiAgICAgICAgICAgIHRoaXMueG1sRG9jID0gX19nZXRYTUxET0Mob3B0aW9ucy54bWxTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFkZXIob3B0aW9ucy5yZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5YTUwucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpYTUxcbiAgICAgKi9cblxuICAgIC8qXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IFhNTCxcblxuICAgIC8qKlxuICAgICAqIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgcsOpY3Vww6lyZXIgbGEgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBhc3NvY2nDqWUgYXUgZm9ybWF0IFhNTFxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30geG1sU3RyaW5nIC0gbGEgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBjb3JyZXNwb25kYW50IGF1IGZvcm1hdCBYTUxcbiAgICAgKi9cbiAgICBnZXRYTUxTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhtbFN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTcOpdGhvZGUgcGVybWV0dGFudCBkJ2F0dHJpYnVlciB1bmUgY2hhw65uZSBkZSBjYXJhY3TDqHJlcyBhdSBmb3JtYXQgWE1MIChhdHRyaWJ1dCB4bWxTdHJpbmcpLlxuICAgICAqIExhIG3DqXRob2RlIHZhIGF1c3NpIHRyYW5zZm9ybWVyIGNldHRlIGNoYcOubmUgZGUgY2FyYWN0w6hyZXMgZW4gZG9jdW1lbnQgWE1MLFxuICAgICAqIGFmaW4gZGUgcmVtcGxpciBsJ2F0dHJpYnV0IHhtbERvYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB4bWxTdHJpbmcgLSBsYSBjaGHDrm5lIGRlIGNhcmFjdMOocmVzIGNvcnJlc3BvbmRhbnQgYXUgZm9ybWF0IFhNTFxuICAgICAqL1xuICAgIHNldFhNTFN0cmluZyA6IGZ1bmN0aW9uICh4bWxTdHJpbmcpIHtcbiAgICAgICAgaWYgKHhtbFN0cmluZyAmJiB0eXBlb2YgeG1sU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnhtbFN0cmluZyA9IHhtbFN0cmluZztcbiAgICAgICAgICAgIHRoaXMueG1sRG9jID0gX19nZXRYTUxET0MoeG1sU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIHLDqWN1cMOpcmVyIGxlcyByZWFkZXJzIGFzc29jacOpcyBhdSBmb3JtYXQgWE1MLCBzJ2lscyBvbnQgw6l0w6kgZMOpZmluaXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVhZGVycyAtIGxlcyByZWFkZXJzIGFzc29jacOpcyBhdSBmb3JtYXQgWE1MLCBzJ2lscyBleGlzdGVudCxcbiAgICAgKiAgICAgIHNvdXMgZm9ybWUgZCd1bmUgY29sbGVjdGlvbiBkZSBmb25jdGlvbnNcbiAgICAgKi9cbiAgICBnZXRSZWFkZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTcOpdGhvZGUgcGVybWV0dGFudCBkJ2F0dHJpYnVlciBkZXMgcmVhZGVycywgc291cyBsYSBmb3JtZSBkJ3VuIG9iamV0IGRlIGZvbmN0aW9ucyAobm9kZSwgZGF0YSksXG4gICAgICogICAgICBsb3JzcXUnaWxzIG4nb250IHBhcyDDqXTDqSBkw6lmaW5pcyBsb3JzIGRlIGwnaW5zdGFuY2lhdGlvbiBwYXIgZXhlbXBsZSAobmV3IFhNTCAob3B0aW9ucykpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlYWRlciAtIEluc3RhbmNlIGQndW4gUmVhZGVyIGRlIHNlcnZpY2UgKEFsdGlSZXNwb25zZVJlYWRlciwgR2VvY29kZVJlcXVlc3RSZWFkZXIsIGV0Yy4pXG4gICAgICogICAgICB1dGlsZSBwb3VyIGludGVycHLDqXRlciBsZSBYTUwgbG9yc3F1ZSBzYSBzdHJ1Y3R1cmUgZXN0IGNvbm51ZS5cbiAgICAgKiAgICAgIENlIHJlYWRlciBkb2l0IGNvbXBvcnRlciBhdSBtb2lucyB1bmUgZm9uY3Rpb24gc3RhdGlxdWUgcmVhZCAocm9vdCkgcGVybWV0dGFudCBkJ2luaXRpYWxpc2VyIGxhIGxlY3R1cmUuXG4gICAgICovXG4gICAgc2V0UmVhZGVyIDogZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICAgICBpZiAocmVhZGVyICYmIHJlYWRlci5yZWFkICYmIHR5cGVvZiByZWFkZXIucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIHLDqWN1cMOpcmVyIGxlIGRvY3VtZW50IFhNTCBhc3NvY2nDqSBhdSBmb3JtYXQsIHMnaWwgZXhpc3RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH0geG1sRG9jIC0gbGUgZG9jdW1lbnQgWE1MIChET00gZG9jdW1lbnQgbm9kZSkgcydpbCBleGlzdGVcbiAgICAgKi9cbiAgICBnZXRYTUxEb2MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnhtbERvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyXG4gICAgICovXG4gICAgc2V0WE1MRG9jIDogZnVuY3Rpb24gKGRvYykge1xuICAgICAgICB0aGlzLnhtbERvYyA9IGRvYztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE3DqXRob2RlIGluaXRpYWxpc2FudCBsYSBsZWN0dXJlIGR1IFhNTCwgw6AgcGFydGlyIGQndW4gWE1MIERvY3VtZW50IDpcbiAgICAgKiAgICAgIGNyw6lhdGlvbiBkJ3VuIG9iamV0IEphdmFTY3JpcHQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZHUgWE1MLFxuICAgICAqICAgICAgc2F1ZiBkYW5zIGxlIGNhcyBvw7kgaWwgbidleGlzdGUgcGFzIGRlIFhNTCBEb2N1bWVudCDDoCBpbnRlcnByw6l0ZXIgKHJldG91cm5lIHVuIG9iamV0IHZpZGUpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBbcGFyc2VyT3V0cHV0XSAtIHVuIG9iamV0IEphdmFTY3JpcHQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZHUgWE1MIDpcbiAgICAgKiAtIHNvaXQgdG91dGVzIGxlcyBpbmZvcm1hdGlvbnMgc2kgYXVjdW4gcmVhZGVyIG4nYSDDqXTDqSBzcMOpY2lmacOpIMOgIGxhIGNyw6lhdGlvbiBkdSBmb3JtYXRcbiAgICAgKiAtIHNvaXQgbGVzIGluZm9ybWF0aW9ucyBzcMOpY2lmacOpZXMgZGFucyBsZSByZWFkZXIuXG4gICAgICovXG4gICAgcGFyc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGJ1aWxkIHhtbCBkb2N1bWVudCBmcm9tIHhtbFN0cmluZ1xuICAgICAgICBpZiAoIXRoaXMueG1sRG9jICYmIHRoaXMueG1sU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnhtbERvYyA9IF9fZ2V0WE1MRE9DKHRoaXMueG1sU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54bWxEb2MpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gX19nZXRSb290Tm9kZSh0aGlzLnhtbERvYyk7XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXJPdXRwdXQ7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCByZWFkZXIgaWYgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGVyICYmIHRoaXMucmVhZGVyLnJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyT3V0cHV0ID0gdGhpcy5yZWFkZXIucmVhZChyb290KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXJPdXRwdXQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyT3V0cHV0W3Jvb3Qubm9kZU5hbWVdID0gX19yZWFkRGVmYXVsdChyb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlck91dHB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIE3DqXRob2RlIGRlIGxhIGNsYXNzZSAocHJpdsOpZSkgcGVybWV0dGFudCBkZSBjcsOpZXIgdW4gWE1MIERvY3VtZW50IMOgIHBhcnRpciBkJ3VuZSBjaGHDrm5lIGRlIGNhcmFjdMOocmVzIFhNTCxcbiAqICAgICAgZW4gdXRpbGlzYW50IERPTVBhcnNlciAoKSBsb3JzcXVlIGMnZXN0IHBvc3NpYmxlLlxuICogICAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2R2Y3MudzMub3JnL2hnL2lubmVyaHRtbC9yYXctZmlsZS90aXAvaW5kZXguaHRtbCN0aGUtZG9tcGFyc2VyLWludGVyZmFjZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgWE1MXG4gKiBAbWV0aG9kIF9fZ2V0WE1MRE9DXG4gKiBAcGFyYW0ge1N0cmluZ30geG1sU3RyaW5nIC0geG1sIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgaW50byBET00gZWxlbWVudFxuICogQHJldHVybiB7RE9NRWxlbWVudH0gLSB0aGUgY29ycmVzcG9uZGluZyBYTUwgRG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gX19nZXRYTUxET0MgKHhtbFN0cmluZykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVudi4gbm9kZWpzXG4gICAgICAgIHZhciBET01QYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKS5ET01QYXJzZXI7IC8vIF9feG1sZG9tLkRPTVBhcnNlcjtcbiAgICAgICAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeG1sU3RyaW5nLCBcInRleHQveG1sXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVudi4gYnJvd3NlclxuXG4gICAgICAgIHZhciBwYXJzZXI7XG4gICAgICAgIHZhciB4bWxEb2M7XG4gICAgICAgIHZhciBlcnJvck1zZyA9IFwiRXJyZXVyIGxvcnMgZHUgcGFyc2luZyBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogWE1MIG5vbiBjb25mb3JtZVwiO1xuXG4gICAgICAgIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgPCA5XG4gICAgICAgICAgICB4bWxEb2MgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICB4bWxEb2MubG9hZFhNTCh4bWxTdHJpbmcpO1xuICAgICAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSB4bWxEb2MucGFyc2VFcnJvcjtcbiAgICAgICAgICAgIGlmIChwYXJzZUVycm9yLmVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUVycm9yLmxpbmUgJiYgcGFyc2VFcnJvci5saW5lcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9IFwiKCBsaWduZSBcIiArIHBhcnNlRXJyb3IubGluZSArIFwiLCBjb2xvbm5lIFwiICsgcGFyc2VFcnJvci5saW5lcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VFcnJvci5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz0gXCI6ICBcIiArIHBhcnNlRXJyb3IucmVhc29uICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgIC8vIGxlcyBhdXRyZXMgKENocm9tZSwgTW96aWxsYSwgSUUgPj0gOSlcbiAgICAgICAgICAgIHBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sU3RyaW5nLCBcInRleHQveG1sXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGJyb3dzZXIgcmFpc2VzIGV4Y2VwdGlvbiBpZiB4bWxTdHJpbmcgaXMgbm90IHZhbGlkIFhNTFxuICAgICAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UgPT09IFwiU3ludGF4RXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycmV1ciBsb3JzIGR1IHBhcnNpbmcgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSA6IFwiICsgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb29rIGZvciBwYXJzaW5nIGVycm9yIGluIGNhc2Ugbm8gZXhjZXB0aW9uIHdhcyByYWlzZWRcbiAgICAgICAgICAgIGlmICh4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlcmVycm9yID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZXJlcnJvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHBhcnNlcmVycm9yW2ldLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0IGluIGNhc2UgcGFyc2VyZXJyb3IgaXMganVzdCBiZWNhdXNlIG9mIGh1Z2UgeG1sLCBidXQgcGFyc2luZyBpcyBkb25lLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC5pbmRleE9mKFwiSHVnZSBpbnB1dCBsb29rdXBcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPSBcIihcIiArIGNvbnRlbnQgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF4bWxEb2MuZG9jdW1lbnRFbGVtZW50KSB7IC8vIG1heSBoYXBwZW4gaW4gY2hyb21lIGJyb3dzZXJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBhdGlibGUgRE9NIFBhcnNlciBwb3VyIGNlIG5hdmlnYXRldXIgIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBNw6l0aG9kZSBkZSBsYSBjbGFzc2UgKHByaXbDqWUpIHBlcm1ldHRhbnQgZGUgcsOpY3Vww6lyZXIgbGUgbm9ldWQgcmFjaW5lIGR1IGRvY3VtZW50LFxuICogICAgICDDoCBwYXJ0aXIgZCd1biBkb2N1bWVudCBub2RlIChub2RlVHlwZT05KSwgcHVpcyBsZWN0dXJlIGRlIGNlIG5vZXVkIChyZWFkTm9kZSlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFhNTFxuICogQG1ldGhvZCBfX2dldFJvb3ROb2RlXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IFt4bWxEb2NdIC0gYSBEb2N1bWVudCBOb2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSByb290IC0gdGhlIGRvY3VtZW50IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBfX2dldFJvb3ROb2RlICh4bWxEb2MpIHtcbiAgICB2YXIgcm9vdDtcbiAgICBpZiAoeG1sRG9jLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgIC8vIElORk8gOiBub2RlVHlwZSA5IHJlcHJlc2VudHMgdGhlIGVudGlyZSBkb2N1bWVudCAodGhlIHJvb3Qtbm9kZSBvZiB0aGUgRE9NIHRyZWUpXG4gICAgICAgIHJvb3QgPSB4bWxEb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSBpZiAoeG1sRG9jLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJvb3QgPSB4bWxEb2M7XG4gICAgfVxuICAgIHJldHVybiByb290O1xufVxuXG4vKipcbiAqIE3DqXRob2RlIGRlIGxhIGNsYXNzZSAocHJpdsOpZSkgcGVybWV0dGFudCBkZSBsaXJlIGF1dG9tYXRpcXVlbWVudCB1biBub2V1ZCBYTUwsXG4gKiAgICAgIGxvcnNxdSdhdWN1biByZWFkZXIgc3DDqWNpZmlxdWUgbidhIMOpdMOpIHNww6ljaWZpw6kgKHBhcnNlciBicnV0KVxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgWE1MXG4gKiBAbWV0aG9kIHJlYWREZWZhdWx0XG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBhIERPTSBlbGVtZW50IG5vZGVcbiAqIEBleGFtcGxlIGZpbmFsIGRhdGEgb2JqZWN0IGxvb2tzIGxpa2UgOlxuICogICAgICAgICAgZGF0YSA9IHtcbiAqICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBhdHRyaWJ1dGVWYWx1ZSxcbiAqICAgICAgICAgICAgICBjaGlsZE5hbWU6IHtcbiAqICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogYXR0cmlidXRlVmFsdWUsXG4gKiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IGF0dHJpYnV0ZVZhbHVlLFxuICogICAgICAgICAgICAgICAgICBjaGlsZE5hbWU6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRlbnRcIjogdGV4dENvbnRlbnRcbiAqICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICAgICAgY2hpbGROYW1lOiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5hbWU6IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOmF0dHJpYnV0ZVZhbHVlXG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICB9XG4gKi9cbmZ1bmN0aW9uIF9fcmVhZERlZmF1bHQgKG5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgLy8gaWYgZWxlbWVudCBub2RlIGhhcyBhdHRyaWJ1dGVzLCBzZXQgdGhlaXIgdmFsdWVzIHRvIGRhdGFcbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGRhdGFBdHRyaWJ1dGVzID0gX19nZXRBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgICBkYXRhW1wiYXR0cmlidXRlc1wiXSA9IGRhdGFBdHRyaWJ1dGVzO1xuICAgIH1cblxuICAgIC8vIGlmIGVsZW1lbnQgbm9kZSBoYXMgY2hpbGROb2RlcywgcmVhZCB0aGVtIGFuZCBzZXQgdGhlbSB0byBkYXRhXG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHZhciBjaGlsZERhdGEgPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzKSB7IC8vIFRFWFRfTk9ERVxuICAgICAgICAgICAgICAgIGRhdGFbXCJ0ZXh0Q29udGVudFwiXSA9IGNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEgPSBfX3JlYWREZWZhdWx0KGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmICghZGF0YVtjaGlsZC5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgY2hpbGREYXRhIGluIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBkYXRhW2NoaWxkLm5vZGVOYW1lXSA9IGNoaWxkRGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHNldmVyYWwgY2hpbGROb2RlcyBoYXMgdGhlIHNhbWUgbmFtZSA6IHN0b3JlIHRoZW0gaW4gYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGRhdGFbbm9kZU5hbWVdIGFscmVhZHkgZXhpc3RzIGJ1dCBpcyBub3QgYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGFbY2hpbGQubm9kZU5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZCA9IGRhdGFbY2hpbGQubm9kZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtjaGlsZC5ub2RlTmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbY2hpbGQubm9kZU5hbWVdLnB1c2gob2xkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2NoaWxkLm5vZGVOYW1lXS5wdXNoKGNoaWxkRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyA6IG1hbmFnZSBvdGhlciBub2RlIHR5cGVzICg0PUNEQVRBLCBldGMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNw6l0aG9kZSBkZSBsYSBjbGFzc2UgKHByaXbDqWUpIHBlcm1ldHRhbnQgZGUgcsOpY3Vww6lyZXIgbGVzIGF0dHJpYnV0cyBkJ3VuIG5vZXVkIMOpbMOpbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgWE1MXG4gKiBAbWV0aG9kIF9fZ2V0QXR0cmlidXRlc1xuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gbm9ldWQgY29udGVuYW50IGwnYXR0cmlidXQgcmVjaGVyY2jDqVxuICogQHJldHVybiB7T2JqZWN0fSBub2RlQXR0cmlidXRlcyAtIG9iamV0IGNvbnRlbmFudCBsZXMgbm9tcyBldCB2YWxldXJzIGRlcyBkaWZmw6lyZW50cyBhdHRyaWJ1dHNcbiAqL1xuZnVuY3Rpb24gX19nZXRBdHRyaWJ1dGVzIChub2RlKSB7XG4gICAgaWYgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBub2RlQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIG5vZGVBdHRyaWJ1dGVzW2F0dHJpYnV0ZS5ub2RlTmFtZV0gPSBhdHRyaWJ1dGUubm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlQXR0cmlidXRlcztcbiAgICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoWE1MKTtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIExpc3RlIGRlcyBhdHRyaWJ1dHMgZGVzIHRhYmxlcyBkZSBnZW9jb2RhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVxdWVzdC5HZW9jb2RlTG9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEdlb2NvZGVMb2NhdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdlb2NvZGVMb2NhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlb2NvZGVMb2NhdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9iamV0IHF1aSBwZXV0IHByZW5kcmUgY29tbWUgcHJvcHJpw6l0w6lzIGxlcyB2YWxldXJzIGR1IHRhYmxlYXUgc2VydmljZUF0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMucGxhY2VBdHRyaWJ1dGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUYWJsZWF1IHF1aSBsaXN0ZSBsZXMgYXR0cmlidXRzIHNww6ljaWZpcXVlcyBzZWxvbiBsZSB0eXBlIGRlIGxhIEdlb2NvZGVMb2NhdGlvbi5cbiAgICAgKiBDZXMgYXR0cmlidXRzIGNvcnJlc3BvbmRlbnQgw6AgY2V1eCBzYWlzaXMgcGFyIGwndXRpbGlzYXRldXIgKGzDqWfDqHJlbWVudCBkaWZmw6lyZW50cyBkZSBjZXV4IGR1IHNlcnZpY2UpXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRhYmxlYXUgcXVpIGxpc3RlIGxlcyBhdHRyaWJ1dHMgc3DDqWNpZmlxdWVzIHNlbG9uIGxlIHR5cGUgZGUgbGEgR2VvY29kZUxvY2F0aW9uXG4gICAgICogQ2VzIGF0dHJpYnV0cyBjb3JyZXNwb25kZW50IMOgIGNldXggaW50ZXJwcsOpdMOpcyBwYXIgbGUgc2VydmljZSAoYmFsaXNlcyBQbGFjZSkuXG4gICAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkdlb2NvZGVMb2NhdGlvblxuICovXG5HZW9jb2RlTG9jYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IEdlb2NvZGVMb2NhdGlvblxuXG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEdlb2NvZGVMb2NhdGlvbik7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogTGVjdHVyZSAvIEVjcml0dXJlIGR1IGZvcm1hdCBXS1RcbiAqXG4gKiBMZXMgYmVzb2lucyBzb250IGFzc2V6IHNpbXBsZXMgOlxuICogMS4gbGVjdHVyZSBkZXMgdHlwZXMgc3VpdmFudHMgOlxuICogIC0gTElORVNUUklOR1xuICogIC0gUE9MWUdPTlxuICogIC0gKFRPRE8pXG4gKiAyLiBjb252ZXJ0aXIgYXV4IGZvcm1hdHMgc3VpdmFudHMgOlxuICogIC0ganNvblxuICogIC0gKFRPRE8pXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gKiAgdmFyIHN0cldLVCA9IFwiTElORVNUUklORyAoMi40MTY5MDcgNDguODQ2NTc3LCAyLjQxNjkxNiA0OC44NDY2MTMpXCI7XG4gKiAgV0tULnRvSnNvbiAoc3RyV0tULFxuICogICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MgKGpzb24pIHtcbiAqICAgICAgICAgIC8vIHtcbiAqICAgICAgICAgIC8vICAgICAgdHlwZSA6ICdMSU5FU1RSSU5HJyxcbiAqICAgICAgICAgIC8vICAgICAgY29vcmRpbmF0ZXMgOiBbXG4gKiAgICAgICAgICAvLyAgICAgICAgICBbMi40MTY5MDcsIDQ4Ljg0NjU3N10sXG4gKiAgICAgICAgICAvLyAgICAgICAgICBbMi40MTY5MTYsIDQ4Ljg0NjYxM11cbiAqICAgICAgICAgIC8vICAgICAgXVxuICogICAgICAgICAgLy8gfVxuICogICAgICB9LFxuICogICAgICBmdW5jdGlvbiBvbkVycm9yIChlcnJvcikge1xuICogICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICogICAgICB9XG4gKiAgKTtcbiAqXG4gKiBAbW9kdWxlIFdLVFxuICogQGFsaWFzIEdwLkZvcm1hdHMuV0tUXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBXS1QgPSB7XG5cbiAgICAvKipcbiAgICAgKiBQYXJzaW5nIGQndW5lIGNoYWluZSBXS1RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgdG9Kc29uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cldrdCAtIGNoYWluZSBkZSB0eXBlIFdLVFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBmb25jdGlvbiBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBmb25jdGlvbiBjYWxsYmFja1xuICAgICAqL1xuICAgIHRvSnNvbiA6IGZ1bmN0aW9uIChzdHJXa3QsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuXG4gICAgICAgIHZhciBqc29uID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFzdHJXa3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBjaGFpbmUgV0tUIG4nZXN0IHBhcyByZW5zZWlnbsOpZSAhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAvKiogY2FsbGJhY2sgc3VjY2VzcyBwYXIgZGVmYXV0ICovXG4gICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGpzb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvKiogY2FsbGJhY2sgZXJyb3IgcGFyIGRlZmF1dCAqL1xuICAgICAgICAgICAgICAgIGVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlZ2V4O1xuICAgICAgICAgICAgdmFyIHN1YnN0O1xuXG4gICAgICAgICAgICAvLyByZWdleCBjb29yZGluYXRlc1xuICAgICAgICAgICAgcmVnZXggPSAvKC0/XFxkK1xcLj9bMC05XSopXFxzKC0/XFxkK1xcLj9bMC05XSspL2c7XG4gICAgICAgICAgICBzdWJzdCA9IFwiWyQxLCQyXVwiO1xuICAgICAgICAgICAgc3RyV2t0ID0gc3RyV2t0LnJlcGxhY2UocmVnZXgsIHN1YnN0KTtcblxuICAgICAgICAgICAgLy8gcmVnZXggdHlwZVxuICAgICAgICAgICAgcmVnZXggPSAvXihcXHcrKS87XG4gICAgICAgICAgICByZWdleC5leGVjKHN0cldrdCk7XG4gICAgICAgICAgICBpZiAoUmVnRXhwLiQxID09PSBcIlBPTFlHT05cIikge1xuICAgICAgICAgICAgICAgIHN1YnN0ID0gXCJ7XFxcInR5cGVcXFwiIDogXFxcIlBvbHlnb25cXFwiLFwiO1xuICAgICAgICAgICAgICAgIHN0cldrdCA9IHN0cldrdC5yZXBsYWNlKFJlZ0V4cC4kMSwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFuXG4gICAgICAgICAgICAgICAgLy8gKCggLS0+IGNvb3JkaW5hdGVzIDogW1tcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwoezJ9PykvO1xuICAgICAgICAgICAgICAgIHN1YnN0ID0gXCJcXFwiY29vcmRpbmF0ZXNcXFwiIDogW1tcIjtcbiAgICAgICAgICAgICAgICBzdHJXa3QgPSBzdHJXa3QucmVwbGFjZShyZWdleCwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIC8vICkpIC0tPiBdXX1cbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwpezJ9PykvO1xuICAgICAgICAgICAgICAgIHN1YnN0ID0gXCJdXX1cIjtcbiAgICAgICAgICAgICAgICBzdHJXa3QgPSBzdHJXa3QucmVwbGFjZShyZWdleCwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIC8vIGFsbCAoIC0tPiBbXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcKCkvZztcbiAgICAgICAgICAgICAgICBzdWJzdCA9IFwiW1wiO1xuICAgICAgICAgICAgICAgIHN0cldrdCA9IHN0cldrdC5yZXBsYWNlKHJlZ2V4LCBzdWJzdCk7XG4gICAgICAgICAgICAgICAgLy8gYWxsICkgLS0+IF1cbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwpKS9nO1xuICAgICAgICAgICAgICAgIHN1YnN0ID0gXCJdXCI7XG4gICAgICAgICAgICAgICAgc3RyV2t0ID0gc3RyV2t0LnJlcGxhY2UocmVnZXgsIHN1YnN0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUmVnRXhwLiQxID09PSBcIkxJTkVTVFJJTkdcIikge1xuICAgICAgICAgICAgICAgIHN1YnN0ID0gXCJ7XFxcInR5cGVcXFwiIDogXFxcIkxpbmVTdHJpbmdcXFwiLFwiO1xuICAgICAgICAgICAgICAgIHN0cldrdCA9IHN0cldrdC5yZXBsYWNlKFJlZ0V4cC4kMSwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFuXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcKFxcKD8pLztcbiAgICAgICAgICAgICAgICBzdWJzdCA9IFwiXFxcImNvb3JkaW5hdGVzXFxcIiA6IFtcIjtcbiAgICAgICAgICAgICAgICBzdHJXa3QgPSBzdHJXa3QucmVwbGFjZShyZWdleCwgc3Vic3QpO1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXClcXCk/KS87XG4gICAgICAgICAgICAgICAgc3Vic3QgPSBcIl19XCI7XG4gICAgICAgICAgICAgICAgc3RyV2t0ID0gc3RyV2t0LnJlcGxhY2UocmVnZXgsIHN1YnN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKHN0cldrdCk7XG5cbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHN0cldrdCk7XG5cbiAgICAgICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxlIEpTT04gZXN0IHZpZGUgIVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFqc29uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZSB0eXBlIGRlIGdlb21ldHJpZSBuJ2VzdCBwYXMgY29ubnUgIVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFqc29uLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGEgbGlzdGUgZGVzIHBvaW50cyBlc3QgdmlkZSAhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcywganNvbik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLm5hbWUgPT09IFwiU3ludGF4RXJyb3JcIikge1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcywgXCJFcnJldXIgZGUgcGFyc2luZyBKU09OICFcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV0tUKTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJlc3BvbnNlIG9iamVjdCBmb3Ige0BsaW5rIG1vZHVsZTpTZXJ2aWNlc35nZXRBbHRpdHVkZSBHcC5TZXJ2aWNlcy5nZXRBbHRpdHVkZSAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuQWx0aS5FbGV2YXRpb24+fSBlbGV2YXRpb25zIC0gRWxldmF0aW9ucyBhcnJheS5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aVJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIEFsdGlSZXNwb25zZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGlSZXNwb25zZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsdGlSZXNwb25zZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZWxldmF0aW9ucyA9IFtdO1xufVxuXG5BbHRpUmVzcG9uc2UucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBBbHRpUmVzcG9uc2VcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBbHRpUmVzcG9uc2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU2luZ2xlIGVsZXZhdGlvbiBvYmplY3QgcmV0dXJuZWQgYnkgdW5kZXJseWluZyB3ZWIgc2VydmljZS4gQ29udGFpbnMgYXQgbGVhc3QsIG9uZSBlbGV2YXRpb24gKHopLiBNYXkgYWxzbyBjb250YWluIHBvaW50IGNvb3JkaW5hdGVzIGFuZCBlbGV2YXRpb24gYWNjdXJhY3kgaWYgXCJ6b25seVwiIHBhcmFtZXRlciB3YXNuJ3Qgc2V0IHRvIHRydWUuXG4gKlxuICogQHByb3BlcnR5IHtGbG9hdH0gbGF0IC0gUG9pbnQgbGF0aXR1ZGUuIChvbmx5IGlmIHpvbmx5PWZhbHNlKVxuICogQHByb3BlcnR5IHtGbG9hdH0gbG9uIC0gUG9pbnQgbG9uZ2l0dWRlLiAob25seSBpZiB6b25seT1mYWxzZSlcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IHogLSBQb2ludCBlbGV2YXRpb24uXG4gKiBAcHJvcGVydHkge0Zsb2F0fSBhY2MgLSBBY2N1cmFjeSBvZiBlbGV2YXRpb24gZm9yIHRoaXMgcG9pbnQuIChvbmx5IGlmIHpvbmx5PWZhbHNlKVxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLkVsZXZhdGlvblxuICovXG5mdW5jdGlvbiBFbGV2YXRpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbGV2YXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbGV2YXRpb24gY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnogPSBudWxsO1xufVxuXG5FbGV2YXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBFbGV2YXRpb25cblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFbGV2YXRpb24pO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19YTFNfUmVxdWVzdEhlYWRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19YTFNfUmVxdWVzdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19YTFNfQWJzdHJhY3RTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBzdGFuZGFyZCBPcGVuTFNcbiAqIHN0YW5kYXJkIFhMU1xuICogKHZlcnNpb24gMS4yKVxuICpcbiAqIFLDqWZzIDpcbiAqICAgICAtIHtAbGluayBodHRwOi8vc2NoZW1hcy5vcGVuZ2lzLm5ldC9vbHMvMS4yL31cbiAqICAgICAtIHtAbGluayBodHRwOi8vd3d3Lm9wZW5nZW9zcGF0aWFsLm9yZy9zdGFuZGFyZHMvb2xzfVxuICogICAgIC0ge0BsaW5rIGh0dHA6Ly93eHMuaWduLmZyL3NjaGVtYXMvfVxuICpcbiAqXG4gKiBDcsOpYXRpb24gZHUgdGVtcGxhdGUgWExTIChhdmVjIGdlc3Rpb24gZGVzIG5hbWVzcGFjZXMpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGBgYFxuICogICBiYWxpc2UgeHNkIDogZWxlbWVudCBuYW1lPVwiWExTXCIgYXR0cmlidXRlIG5hbWU9XCJ2ZXJzaW9uXCIgWyhhdHRyaWJ1dGUgcmVmPVwibGFuZ1wiKV1cbiAqIGBgYFxuICpcbiAqIEV4ZW1wbGUgOlxuICogYGBgXG4gKiA8WExTIHhtbG5zPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gKiAgIDwgKHJlZi4gT0xTKSAvPlxuICogPC9YTFM+XG4gKiBgYGBcbiAqIGBgYFxuICogPHhsczpYTFMgeG1sbnM6eGxzPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gKiAgIDx4bHM6IChyZWYuIE9MUykgLz5cbiAqIDwveGxzOlhMUz5cbiAqIGBgYFxuICpcbiAqIENyw6lhdGlvbiBkZXMgdGVtcGxhdGVzIE9MUyBwb3VyIExvY2F0aW9uVXRpbGl0eVNlcnZpY2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIEV4ZW1wbGUgOlxuICpcbiAqIGBgYFxuICogPFJlcXVlc3RIZWFkZXIgc3JzTmFtZT1cImVwc2c6NDMyNlwiLz5cbiAqIDxSZXF1ZXN0IG1heGltdW1SZXNwb25zZXM9XCIyNlwiIG1ldGhvZE5hbWU9XCJHZW9jb2RlUmVxdWVzdFwiIHJlcXVlc3RJRD1cInVpZDEzNDkwODE0OTgzMTRfMzg4XCIgdmVyc2lvbj1cIjEuMlwiPlxuICogICAgICA8R2VvY29kZVJlcXVlc3Q+XG4gKiAgICAgICAgICA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlBvc2l0aW9uT2ZJbnRlcmVzdFwiPlxuICogICAgICAgICAgICAgIDxmcmVlRm9ybUFkZHJlc3M+c2FpbnQgbWFuZMOpPC9mcmVlRm9ybUFkZHJlc3M+XG4gKiAgICAgICAgICA8L0FkZHJlc3M+XG4gKiAgICAgIDwvR2VvY29kZVJlcXVlc3Q+XG4gKiAgPC9SZXF1ZXN0PlxuICogYGBgXG4gKiBgYGBcbiAqIDxSZXF1ZXN0SGVhZGVyIHNlc3Npb25JRD1cIlwiIC8+XG4gKiA8UmVxdWVzdCBtZXRob2ROYW1lPVwiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XCIgdmVyc2lvbj1cIjEuMlwiIHJlcXVlc3RJRD1cIlwiIG1heGltdW1SZXNwb25zZXM9XCIxMFwiPlxuICogICA8UmV2ZXJzZUdlb2NvZGVSZXF1ZXN0PlxuICogICAgIDxQb3NpdGlvbj5cbiAqICAgICAgIDxnbWw6UG9pbnQgeG1sbnM6Z21sPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcIj5cbiAqICAgICAgICAgICA8Z21sOnBvcz41MC4zNDc3NzUgMy4yMDUwOTg8L2dtbDpwb3M+XG4gKiAgICAgICA8L2dtbDpQb2ludD5cbiAqICAgICA8L1Bvc2l0aW9uPlxuICogICAgIDxSZXZlcnNlR2VvY29kZVByZWZlcmVuY2U+U3RyZWV0QWRkcmVzczwvUmV2ZXJzZUdlb2NvZGVQcmVmZXJlbmNlPlxuICogIDwvUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0PlxuICogPC9SZXF1ZXN0PlxuICogYGBgXG4gKiBgYGBcbiAqIEdlb2NvZGFnZSBkaXJlY3QgKGJhbGlzZSB4c2QpIDpcbiAqICAgZWxlbWVudCByZWY9XCJSZXF1ZXN0SGVhZGVyXCIgWyAoYXR0cmlidXRlIG5hbWU9XCJjbGllbnROYW1lXCIgYXR0cmlidXRlIG5hbWU9XCJjbGllbnRQYXNzd29yZFwiIGF0dHJpYnV0ZSBuYW1lPVwic2Vzc2lvbklEXCIgYXR0cmlidXRlIG5hbWU9XCJzcnNOYW1lXCIgYXR0cmlidXRlIG5hbWU9XCJNU0lEXCIpIF1cbiAqICAgICBlbGVtZW50IG5hbWU9XCJSZXF1ZXN0XCIgYXR0cmlidXRlIG5hbWU9XCJtZXRob2ROYW1lXCIgYXR0cmlidXRlIG5hbWU9XCJ2ZXJzaW9uXCIgYXR0cmlidXRlIG5hbWU9XCJyZXF1ZXN0SURcIiBbIGF0dHJpYnV0ZSBuYW1lPVwibWF4aW11bVJlc3BvbnNlc1wiIF1cbiAqICAgICAgIGVsZW1lbnQgbmFtZT1cIkdlb2NvZGVSZXF1ZXN0XCIgYXR0cmlidXRlIG5hbWU9XCJyZXR1cm5GcmVlRm9ybVwiXG4gKiAgICAgICAgIGVsZW1lbnQgcmVmPVwieGxzOkFkZHJlc3NcIlxuICogYGBgXG4gKiBgYGBcbiAqIEdlb2NvZGFnZSBpbnZlcnNlIChiYWxpc2UgeHNkKSA6XG4gKiAgIGVsZW1lbnQgcmVmPVwiUmVxdWVzdEhlYWRlclwiIFsgKGF0dHJpYnV0ZSBuYW1lPVwiY2xpZW50TmFtZVwiIGF0dHJpYnV0ZSBuYW1lPVwiY2xpZW50UGFzc3dvcmRcIiBhdHRyaWJ1dGUgbmFtZT1cInNlc3Npb25JRFwiIGF0dHJpYnV0ZSBuYW1lPVwic3JzTmFtZVwiIGF0dHJpYnV0ZSBuYW1lPVwiTVNJRFwiKSBdXG4gKiAgICAgZWxlbWVudCBuYW1lPVwiUmVxdWVzdFwiIGF0dHJpYnV0ZSBuYW1lPVwibWV0aG9kTmFtZVwiIGF0dHJpYnV0ZSBuYW1lPVwidmVyc2lvblwiIGF0dHJpYnV0ZSBuYW1lPVwicmVxdWVzdElEXCIgWyBhdHRyaWJ1dGUgbmFtZT1cIm1heGltdW1SZXNwb25zZXNcIiBdXG4gKiAgICAgICBlbGVtZW50IG5hbWU9XCJSZXZlcnNlR2VvY29kZVJlcXVlc3RcIlxuICogICAgICAgICBlbGVtZW50IHJlZj1cInhsczpQb3NpdGlvblwiXG4gKiAgICAgICAgIGVsZW1lbnQgbmFtZT1cIlJldmVyc2VHZW9jb2RlUHJlZmVyZW5jZVwiIChlbnVtZXJhdGlvbilcbiAqIGBgYFxuICpcbiAqIElsIGV4aXN0ZSAzIHNvdXMgZW5zZW1ibGVzIGQnb2JqZXRzIDpcbiAqICAgICAtIFJlcXVlc3RIZWFkZXJcbiAqICAgICAtIFJlcXVlc3RcbiAqICAgICAtIFJldmVyc2VHZW9jb2RlUmVxdWVzdCwgR2VvY29kZVJlcXVlc3RcbiAqXG4gKiBHZW9jb2RlUmVxdWVzdCBlc3QgY29tcG9zw6kgZCd1biBvYmpldCB7QGxpbmsgR3AuU2VydmljZXMuR2VvY29kZS5SZXNwb25zZS5HZW9jb2RlTG9jYXRpb259LlxuICogUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0IGVzdCBjb21wb3PDqSBkJ3VuIG9iamV0IHtAbGluayBHcC5TZXJ2aWNlcy5SZXZlcnNlR2VvY29kZS5SZXNwb25zZS5SZXZlcnNlR2VvY29kZUxvY2F0aW9ufS5cbiAqXG4gKiBMZXMgbG9jYXRpb25zIGZvbnQgYXBwZWxzIGF1eCBvYmpldHMgc3VpdmFudHMgcXVpIHBvc3PDqGRlbnQgZGVzIGF0dHJpYnV0cyBzcMOpY2lmaXF1ZXNcbiAqIGVuIGZvbmN0aW9uIGR1IHR5cGUgZGUgdGFibGUgZGUgZ2VvY29kYWdlIGludGVycm9nw6kgOlxuICogICAgIC0gU3RyZWV0QWRkcmVzc1xuICogICAgIC0gQ2FkYXN0cmFsUGFyY2VsXG4gKiAgICAgLSBQb3NpdGlvbk9mSW50ZXJlc3RcbiAqICAgICAtIEFkbWluaXN0cmF0aWZcbiAqXG4gKlxuICogZXQgZGVzIMOpbGVtZW50cyBzb3VzIGphY2VudHMgdGVscyBxdWUgOlxuICogICAgIC0gUmV2ZXJzZUdlb2NvZGVQcmVmZXJlbmNlIC0+IHRhYmxlcyBkZSBnZW9jb2RhZ2VzIDpcbiAqICAgICAgICAgLSBTdHJlZXRBZGRyZXNzXG4gKiAgICAgICAgIC0gQ2FkYXN0cmFsUGFyY2VsXG4gKiAgICAgICAgIC0gUG9zaXRpb25PZkludGVyZXN0XG4gKiAgICAgICAgIC0gQWRtaW5pc3RyYXRpZiAodW5lIGJhbGlzZSBwYXIgdGFibGUpXG4gKiAgICAgLSBQb3NpdGlvbiAtPiBzdGFuZGFyZCBHTUwgMy4yLjFcbiAqICAgICAtIEFkZHJlc3MgIC0+IGNmLiBjaS1kZXNzb3VzXG4gKlxuICogYGBgXG4gKiBQb3NpdGlvbiAoYmFsaXNlIHhzZCkgOlxuICogICBleC4gPFBvc2l0aW9uPjxnbWw6UG9pbnQgeG1sbnM6Z21sPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcIj48Z21sOnBvcz41MC4zNDc3NzUgMy4yMDUwOTg8L2dtbDpwb3M+PC9nbWw6UG9pbnQ+PC9Qb3NpdGlvbj5cbiAqICAgZXguIDxQb3NpdGlvbj48Z21sOkNpcmNsZUJ5Q2VudGVyUG9pbnQgeG1sbnM6Z21sPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcIj48Z21sOnBvcz40OC44NTk3ODU3MDYxNDY5MSAyLjI5MTM1NzI3NjExMjg4Nzg8L2dtbDpwb3M+PGdtbDpyYWRpdXM+MTAwMDwvZ21sOnJhZGl1cz48L2dtbDpDaXJjbGVCeUNlbnRlclBvaW50PjwvUG9zaXRpb24+XG4gKiAgIChhdSBjaG9peClcbiAqICAgZWxlbWVudCByZWY9XCJnbWw6UG9pbnRcIlxuICogICBlbGVtZW50IHJlZj1cImdtbDpDaXJjbGVCeUNlbnRlclBvaW50XCJcbiAqICAgZWxlbWVudCByZWY9XCJnbWw6UG9seWdvblwiXG4gKiAgIGVsZW1lbnQgcmVmPVwiZ21sOk11bHRpUG9seWdvblwiXG4gKiAgIGxlcyBhdXRyZXMgZWxlbWVubnRzIG5lIHNvbnQgcGFzIGltcGzDqW1lbnTDqXMgKFFvUCwgU3BlZWQsIERpcmVjdGlvbiwgVGltZSwgLi4uKVxuICpcbiAqIEFkZHJlc3MgKGJhbGlzZSB4c2QpIDpcbiAqICAgZXguIDxBZGRyZXNzIGNvdW50cnlDb2RlPVwiU3RyZWV0QWRkcmVzc1wiPjxmcmVlRm9ybUFkZHJlc3M+MSByIGRlIHBhcmlzIHNhaW50IGRlbmlzPC9mcmVlRm9ybUFkZHJlc3M+PC9BZGRyZXNzPlxuICogICBhdHRyaWJ1dGUgbmFtZT1cImNvdW50cnlDb2RlXCJcbiAqICAgICBlbGVtZW50IG5hbWU9XCJmcmVlRm9ybUFkZHJlc3NcIlxuICogICAgIGVsZW1lbnQgcmVmPVwieGxzOlBsYWNlXCJcbiAqICAgICBlbGVtZW50IHJlZj1cImdtbDpFbnZlbG9wZVwiXG4gKiAgb3VcbiAqICAgZXguIDxBZGRyZXNzIGNvdW50cnlDb2RlPVwiU3RyZWV0QWRkcmVzc1wiPjxTdHJlZXRBZGRyZXNzPjxTdHJlZXQ+MSBydWUgTWFyY29uaTwvU3RyZWV0PjwvU3RyZWV0QWRkcmVzcz48UGxhY2UgdHlwZT1cIk11bmljaXBhbGl0eVwiPk1ldHo8L1BsYWNlPjxQb3N0YWxDb2RlPjU3MDAwPC9Qb3N0YWxDb2RlPjwvQWRkcmVzcz5cbiAqICAgYXR0cmlidXRlIG5hbWU9XCJjb3VudHJ5Q29kZVwiXG4gKiAgICAgZWxlbWVudCByZWY9XCJ4bHM6U3RyZWV0QWRkcmVzc1wiXG4gKiAgICAgZWxlbWVudCByZWY9XCJ4bHM6UG9zdGFsQ29kZVwiXG4gKiAgICAgZWxlbWVudCByZWY9XCJ4bHM6UGxhY2VcIlxuICogICAgIGVsZW1lbnQgcmVmPVwiZ21sOkVudmVsb3BlXCJcbiAqXG4gKiBQbGFjZSAgKGJhbGlzZSB4c2QpIDpcbiAqICBleC4gPFBsYWNlIHR5cGU9XCJNdW5pY2lwYWxpdHlcIj5NZXR6PC9QbGFjZT5cbiAqICBhdHRyaWJ1dGUgbmFtZT1cInR5cGVcIlxuICogICBlbnVtZXJhdGlvbiB2YWx1ZT1cIkNvdW50cnlTdWJkaXZpc2lvblwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiQ291bnRyeVNlY29uZGFyeVN1YmRpdmlzaW9uXCJcbiAqICAgZW51bWVyYXRpb24gdmFsdWU9XCJNdW5pY2lwYWxpdHlcIlxuICogICBlbnVtZXJhdGlvbiB2YWx1ZT1cIk11bmljaXBhbGl0eVN1YmRpdmlzaW9uXCJcbiAqICAgZW51bWVyYXRpb24gdmFsdWU9XCJjaG91bWUtYmFuY2hpLWdvXCJcbiAqICAgZW51bWVyYXRpb24gdmFsdWU9XCJRdWFsaXRlXCJcbiAqICAgZW51bWVyYXRpb24gdmFsdWU9XCJEZXBhcnRlbWVudFwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiQmJveFwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiQ29tbXVuZVwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiVGVycml0b2lyZVwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiSW1wb3J0YW5jZVwiXG4gKiAgIGVudW1lcmF0aW9uIHZhbHVlPVwiTmF0dXJlXCJcbiAqICAgKGxhIGxpc3RlIG4nZXN0IHBhcyBleGhhdXN0aXZlcy4uLilcbiAqXG4gKiBTdHJlZXRBZGRyZXNzIChiYWxpc2UgeHNkKSA6XG4gKiAgIGV4LiA8U3RyZWV0QWRkcmVzcz48U3RyZWV0PjEgcnVlIE1hcmNvbmk8L1N0cmVldD48L1N0cmVldEFkZHJlc3M+XG4gKiAgIGF0dHJpYnV0ZSBuYW1lPVwibG9jYXRvclwiXG4gKiAgICBlbGVtZW50IG5hbWU9XCJ4bHM6QnVpbGRpbmdcIlxuICogICAgZWxlbWVudCByZWY9XCJ4bHM6U3RyZWV0XCJcbiAqXG4gKiBTdHJlZXQgKGJhbGlzZSB4c2QpIDpcbiAqICAgZXguIDxTdHJlZXQ+MSBydWUgTWFyY29uaTwvU3RyZWV0PlxuICogICBhdHRyaWJ1dGUgbmFtZT1cIm9mZmljaWFsTmFtZVwiICguLi4pXG4gKlxuICogQnVpbGRpbmcgKGJhbGlzZSB4c2QpIDpcbiAqICAgZXguIDxCdWlsZGluZyBudW1iZXI9XCI4MDBcIi8+XG4gKiAgIGF0dHJpYnV0ZSBuYW1lPVwibnVtYmVyXCIgYXR0cmlidXRlIG5hbWU9XCJzdWJkaXZpc2lvblwiIGF0dHJpYnV0ZSBuYW1lPVwiYnVpbGRpbmdOYW1lXCJcbiAqXG4gKiBQb3N0YWxDb2RlIChiYWxpc2UgeHNkKSA6XG4gKiAgIGV4LiA8UG9zdGFsQ29kZT43NzE4MjwvUG9zdGFsQ29kZT5cbiAqXG4gKiBgYGBcbiAqXG4gKiBSZXF1w6p0ZVxuICogLS0tLS0tLVxuICpcbiAqIDIgbW9kZXMgZGUgcmVxdcOqdGUgc3VyIGxlcyBzZXJ2aWNlcyA6IEdFVCBvdSBQT1NULlxuICpcbiAqIExlIG1vZGUgR0VUIG4nZXN0IHF1ZSBsJ2VuY29kYWdlIGR1IFhNTCBlbiBwYXJhbSAocXhtbCkgZGUgbGEgcmVxdcOqdGUgKGRvbmMgcGFzIGQnaW1wbGVtZW50YXRpb24gcGFydGljdWxpw6hyZSA/KVxuICpcbiAqIE1vZMOobGUgZGUgY2xhc3Nlc1xuICogLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBgYGBcbiAqICAgICAgICAgICAgICAgICBfX19fX19fXyAgWExTIF9fX19fX19fX19fX1xuICogICAgICAgICAgICAgICAvICAgICAgICAgICAgfCAgICAgICAgICAgICAgIFxcXG4gKiAgIFJlcXVlc3RIZWFkZXIgICAgICBBYnN0cmFjdFNlcnZpY2UgICAgUmVxdWVzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuICogICAgICAgICAgICAgICAgICAgICAgX19fX19ffF9fX19fX19fX19fX19fX19fX19fX19fX1xuICogICAgICAgICAgIChleHRlbmRzKSAvICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcIChleHRlbmRzKVxuICogICAgICAgICAgTG9jYXRpb25VdGlsaXR5U2VydmljZSAgICAgICAgICAgICAgICAgICAgUm91dGVTZXJ2aWNlXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgX19fX19fX19fX198X19fX19fX19fX18gICAgICAgICAgICAgICAgICAgICAgICguLi4pXG4gKiAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAqIEdlb2NvZGVSZXF1ZXN0ICAgICAgICAgIFJldmVyc2VHZW9jb2RlUmVxdWVzdFxuICogICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgICAgICAgICAgICBfX19fX3xfX19fX19cbiAqICAgICAgfCAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgIFxcXG4gKiAgIEFkZHJlc3MgICAgICAgICAgICAgIFByZWZlcmVuY2UgIFBvc2l0aW9uXG4gKiAgICAgIHxcbiAqICAgIC8gICBcXFxuICogUGxhY2UgICBTdHJlZXRBZGRyZXNzXG4gKiAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgIC8gICBcXFxuICogICAgICAgU3RyZWV0ICAgQnVpbGRpbmdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBlbmNhcHN1bGUgdW4gb2JqZXQgJ0xvY2F0aW9uVXRpbGl0eVNlcnZpY2UnXG4gKiAvLyBkYW5zIHVuZSBjb3F1aWxsZSBYU0wgKGF2ZWMvc2FucyBuYW1lc3BhY2UpXG4gKiB4c2wgPSBuZXcgWFNMICgpO1xuICogeHNsLm5hbWVzcGFjZSA9IGZhbHNlO1xuICogeHNsLnNyc05hbWUgPSBcImVwc2c6NDMyNlwiO1xuICogeHNsLm1heGltdW1SZXNwb25zZXMgPSAyNjtcbiAqIC8vICAgbWV0aG9kTmFtZSBmb3Vybml0IHBhciBsJ29iamV0ICdsdXMnXG4gKiAvLyAgIHJlcXVlc3RJRCBlc3QgY2FsY3Vsw6lcbiAqIHhzbC5zZXRTZXJ2aWNlIChsdXMpO1xuICogeHNsLmJ1aWxkICgpO1xuICogLy8gb3V0IC0+XG4gKiAvLyA8WExTIHhtbG5zPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gKiAvLyA8UmVxdWVzdEhlYWRlciBzcnNOYW1lPVwiZXBzZzo0MzI2XCIvPlxuICogLy8gPFJlcXVlc3QgbWF4aW11bVJlc3BvbnNlcz1cIjI2XCIgbWV0aG9kTmFtZT1cIkdlb2NvZGVSZXF1ZXN0XCIgcmVxdWVzdElEPVwidWlkMTM0OTA4MTQ5ODMxNF8zODhcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gKiAvLyAgIDwgKHJlZi4gTG9jYXRpb25VdGlsaXR5U2VydmljZSBvdSB2aWRlKSAvPlxuICogLy8gIDwvUmVxdWVzdD5cbiAqIC8vIDwvWExTPlxuICpcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5Gb3JtYXRzLlhMU1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGR1IGNvbnN0cnVjdGV1clxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc3JzTmFtZSAtIGlkZW50aWZpYW50IGR1IFN5c3RlbWUgZGUgQ29vcmRvbm5lZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMubWF4aW11bVJlc3BvbnNlcyAtIG5vbWJyZSBkZSByZXBvbnNlcyBtYXggZCd1bmUgcmVxdWV0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbnN1Y2Nlc3MgLSBmdW5jdGlvbiBjYWxsYmFjayBzdWNjZXNzIChUT0RPKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmVycm9yICAgLSBmdW5jdGlvbiBjYWxsYmFjayBlcnJvciAgIChUT0RPKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFhMUyAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgWExTKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFhMUykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlhMUyBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbnMgcGFyIGRlZmF1dFxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc3JzTmFtZSA6IFwiRVBTRzo0MzI2XCIsXG4gICAgICAgIG1heGltdW1SZXNwb25zZXMgOiAyNVxuICAgIH07XG5cbiAgICAvLyBldCBvbiBham91dGUgbGVzIG9wdGlvbnMgZW4gcGFyYW3DqHRyZSBhdXggb3B0aW9ucyBwYXIgZMOpZmF1dFxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zW29wdF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBWZXJzaW9uXG4gKi9cblhMUy5WRVJTSU9OID0gXCIxLjJcIjtcblxuWExTLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6WExTI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBuYW1lc3BhY2VcbiAgICAgKiBTdXJjaGFyZ2UgbGVzIGJhbGlzZXMgWExTIGQndW4gcHJlZml4ZS5cbiAgICAgKiBQYXIgZGVmYXV0LCBmYWxzZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIG5hbWVzcGFjZSA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT2JqZXQgU2VydmljZVxuICAgICAqIExvY2F0aW9uVXRpbGl0eVNlcnZpY2Ugb3UgUm91dGVTZXJ2aWNlXG4gICAgICogQHR5cGUge0Fic3RyYWN0U2VydmljZX1cbiAgICAgKi9cbiAgICBvU2VydmljZSA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogWExTLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICogc3Vic3RpdHV0aW9uIGRlcyB2YWxldXJzIHN1aXZhbnRlcyA6XG4gICAgICogX19WRVJTSU9OX18sIF9fTkFNRVNQQUNFX18sIF9fU0NIRU1BTE9DQVRJT05fX1xuICAgICAqIF9fUkVRVUVTVEhFQURFUl9fLCBfX1JFUVVFU1RfX1xuICAgICAqL1xuICAgIHRlbXBsYXRlIDogXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCI/PlxcblwiICtcbiAgICAgICAgXCI8WExTIHZlcnNpb249XFxcIl9fVkVSU0lPTl9fXFxcIlxcblwiICtcbiAgICAgICAgXCJfX05BTUVTUEFDRV9fIFxcblwiICtcbiAgICAgICAgXCJfX1NDSEVNQUxPQ0FUSU9OX18+XFxuXCIgK1xuICAgICAgICBcIl9fUkVRVUVTVEhFQURFUl9fXFxuXCIgK1xuICAgICAgICBcIl9fUkVRVUVTVF9fXFxuXCIgK1xuICAgICAgICBcIjwvWExTPlxcblwiLFxuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIHBhciBkZWZhdXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWVzcGFjZUJ5RGVmYXVsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zID0gW1xuICAgICAgICAgICAgXCJ4bWxuczp4c2k9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczp4bHM9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzXFxcIlwiLFxuICAgICAgICAgICAgXCJ4bWxuczpnbWw9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXFxcIlwiXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIG5zLmpvaW4oXCIgXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2hlbWFsb2NhdGlvbiBwYXIgZGVmYXV0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHNjaGVtYUxvY2F0aW9uQnlEZWZhdWx0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ4c2k6c2NoZW1hTG9jYXRpb249XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzIGh0dHA6Ly9zY2hlbWFzLm9wZW5naXMubmV0L29scy8xLjIvb2xzQWxsLnhzZFxcXCJcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dGVyIFNlcnZpY2VcbiAgICAgKiBBam91dCBkJ3VuIG9iamV0IGRlIHR5cGUgTG9jYXRpb25VdGlsaXR5U2VydmljZSAoTFVTKSBvdSBSb3V0ZVNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvU2VydmljZSAtIEdlb2Nlb2RlUmVxdWVzdCAvIFJldmVyc2VHZW9jb2RlUmVxdWVzdCBvdSBSb3V0ZVJlcXVlc3RcbiAgICAgKi9cbiAgICBzZXRTZXJ2aWNlIDogZnVuY3Rpb24gKG9TZXJ2aWNlKSB7XG4gICAgICAgIGlmICghb1NlcnZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiTCdvYmpldCBkZSB0eXBlIFNlcnZpY2UgWFNMIG4nZXN0IHBhcyBlbmNvcmUgZGVmaW5pICE/XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9TZXJ2aWNlIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19YTFNfQWJzdHJhY3RTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pIHtcbiAgICAgICAgICAgIHRoaXMub1NlcnZpY2UgPSBvU2VydmljZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTCdvYmpldCBuJ2VzdCBwYXMgZHUgdHlwZSAnTG9jYXRpb25VdGlsaXR5U2VydmljZScgb3UgJ1JvdXRlU2VydmljZScgIT9cIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0dGVyIFNlcnZpY2VcbiAgICAgKiBSZXRvdXJuZSB1biBvYmpldCBkZSB0eXBlIExvY2F0aW9uVXRpbGl0eVNlcnZpY2UgKExVUykgb3UgUm91dGVTZXJ2aWNlXG4gICAgICogZXguIEdlb2Nlb2RlUmVxdWVzdCAvIFJldmVyc2VHZW9jb2RlUmVxdWVzdCBvdSBSb3V0ZVJlcXVlc3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0U2VydmljZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub1NlcnZpY2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBam91dCBkJ3VuIHByZWZpeGUgZGUgbmFtZXNwYWNlXG4gKlxuICogQHRvZG8gaW1wbC4gbCdham91dCBkZSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBucyAtIGV4LiB7a2V5OnhscywgdXJsOmh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzfVxuICovXG5YTFMucHJvdG90eXBlLmFkZE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChucywgcmVxdWVzdCkge1xuICAgIC8vIElORk9cbiAgICAvLyBvbiByZWNoZXJjaGUgbGEgY2xlZiBkYW5zIGxlcyBuYW1lc3BhY2VzIHBhciBkZWZhdXQuXG4gICAgLy8gc2kgbGEgY2xlZiBuJ2V4aXN0ZSBwYXMgZGFucyBsZXMgbmFtZXNwYWNlQnlEZWZhdWx0ICgpLCBvbiBsJ2Fqb3V0ZS5cbiAgICAvLyBvbiBzdXJjaGFyZ2UgdG91dGVzIGxlcyBiYWxpc2VzLCBleC4gWExTIC0+IHhsczpYTFNcbiAgICAvLyBzYXVmIGNlbGxlcyBxdWkgc29udCBkw6lqw6AgcHJlZml4w6llcyAhXG5cbiAgICB2YXIga2V5TlMgPSBucy5rZXk7XG4gICAgLy8gdmFyIHVybE5TID0gbnMudXJsOyAvLyBUT0RPIG5vdCB5ZXQgaW1wbGVtZW50ZWQgIVxuXG4gICAgLy8gcmVjaGVyY2hlIGxhIGNsZWYgZGFucyBsZXMgbmFtZXNwYWNlcyBwYXIgZGVmYXV0XG4gICAgdmFyIGJGb3VuZCA9IGZhbHNlO1xuICAgIHZhciBhbGxOUyA9IHRoaXMubmFtZXNwYWNlQnlEZWZhdWx0KCkuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBhbGxOUy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBhbGxOU1tpbmRleF07XG4gICAgICAgIHZhciBtYXAgPSBlbGVtZW50LnNwbGl0KFwiPVwiKTtcbiAgICAgICAgdmFyIGtleSA9IG1hcFswXTtcbiAgICAgICAgLy8gdmFyIHVybCA9IG1hcFsxXTsgLy8gVE9ETyBub3QgeWV0IGltcGxlbWVudGVkICFcblxuICAgICAgICBpZiAoa2V5ID09PSBcInhtbG5zOlwiICsga2V5TlMpIHtcbiAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICAvLyBzaSBvbiBhIHVuZSBub3V2ZWxsZSBjbGVmLCBvbiBsJ2Fqb3V0ZS4uLlxuICAgIGlmICghYkZvdW5kKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJMJ2Fqb3V0IGQndW4gbm91dmVsIG5hbWVzcGFjZSBuJ2VzdCBwYXMgZW5jb3JlIGltcGzDqW1lbnTDqSAhXCIpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgICAvLyBzdXJjaGFyZ2UgdG91dGVzIGxlcyBiYWxpc2VzXG4gICAgdmFyIHJlZ2V4O1xuICAgIHZhciBzdWJzdDtcblxuICAgIC8vIHJlZ2V4IGJhbGlzZSBvdXZyYW50ZVxuICAgIHJlZ2V4ID0gLzwoXFx3K1tcXHM+XSkvZztcbiAgICBzdWJzdCA9IFwiPFwiICsga2V5TlMgKyBcIjokMVwiO1xuICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UocmVnZXgsIHN1YnN0KTtcblxuICAgIC8vIHJlZ2V4IGJhbGlzZSBmZXJtYW50ZVxuICAgIHJlZ2V4ID0gLzxcXC8oXFx3K1tcXHM+XSkvZztcbiAgICBzdWJzdCA9IFwiPC9cIiArIGtleU5TICsgXCI6JDFcIjtcbiAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKHJlZ2V4LCBzdWJzdCk7XG5cbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIm5hbWVzcGFjZVwiLCByZXF1ZXN0KTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGVcbiAqL1xuWExTLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBvdXQgLT5cbiAgICAvLyA8WExTIHhtbG5zPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gICAgLy8gPFJlcXVlc3RIZWFkZXIgc3JzTmFtZT1cImVwc2c6NDMyNlwiLz5cbiAgICAvLyA8UmVxdWVzdCBtYXhpbXVtUmVzcG9uc2VzPVwiMjZcIiBtZXRob2ROYW1lPVwiR2VvY29kZVJlcXVlc3RcIiByZXF1ZXN0SUQ9XCJ1aWQxMzQ5MDgxNDk4MzE0XzM4OFwiIHZlcnNpb249XCIxLjJcIj5cbiAgICAvLyAgIDwgKHJlZi4gTG9jYXRpb25VdGlsaXR5U2VydmljZSBvdSB2aWRlKSAvPlxuICAgIC8vICA8L1JlcXVlc3Q+XG4gICAgLy8gPC9YTFM+XG5cbiAgICAvLyBhcyB0IG9uIHVuIG9iamV0IGRlIHR5cGUgU2VydmljZSBYTFMgw6AgZGlzcG9zaXRpb24gP1xuICAgIHZhciBiU2VydmljZSA9ICEhdGhpcy5nZXRTZXJ2aWNlKCk7XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fVkVSU0lPTl9fL2csIFhMUy5WRVJTSU9OKTtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fTkFNRVNQQUNFX18vZywgdGhpcy5uYW1lc3BhY2VCeURlZmF1bHQpO1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19TQ0hFTUFMT0NBVElPTl9fL2csIHRoaXMuc2NoZW1hTG9jYXRpb25CeURlZmF1bHQpO1xuXG4gICAgLy8gaGVhZGVyXG4gICAgdmFyIG9IZWFkZXIgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19YTFNfUmVxdWVzdEhlYWRlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgc3JzTmFtZSA6IHRoaXMub3B0aW9ucy5zcnNOYW1lXG4gICAgfSk7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1JFUVVFU1RIRUFERVJfXy9nLCBvSGVhZGVyLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gcmVxdWVzdFxuICAgIHZhciBvUmVxdWVzdCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1hMU19SZXF1ZXN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICBtYXhpbXVtUmVzcG9uc2VzIDogdGhpcy5vcHRpb25zLm1heGltdW1SZXNwb25zZXMsXG4gICAgICAgIHZlcnNpb24gOiBYTFMuVkVSU0lPTiwgLy8gRklYTUUgbcOqbWUgdmVyc2lvbiA/XG4gICAgICAgIG1ldGhvZE5hbWUgOiBiU2VydmljZSA/IHRoaXMuZ2V0U2VydmljZSgpLkNMQVNTVFlQRSA6IG51bGxcbiAgICB9KTtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUkVRVUVTVF9fL2csIG9SZXF1ZXN0LnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gb2JqZXQgbHVzIG91IHJvdXRlXG4gICAgaWYgKGJTZXJ2aWNlKSB7IC8vIElORk8gOiBjbGVmIF9fUkVRVUVTVFNFUlZJQ0VfXyBkaXNwbyBkYW5zIGwnb2JqZXQgJ1JlcXVlc3QnXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvPCEtLSBfX1JFUVVFU1RTRVJWSUNFX18gLS0+L2csIHRoaXMuZ2V0U2VydmljZSgpLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRyYWR1Y3Rpb24gdG1wbCA6IGVtcHR5IHJlcXVlc3QgIT9cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBham91dCBkJ3VuIG5hbWVzcGFjZVxuICAgIGlmICh0aGlzLm5hbWVzcGFjZSkge1xuICAgICAgICAvLyBham91dCBkZSB4bHMgcGFyIGRlZmF1dFxuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMuYWRkTmFtZXNwYWNlKHtcbiAgICAgICAgICAgIGtleSA6IFwieGxzXCIsXG4gICAgICAgICAgICB1cmwgOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzXCJcbiAgICAgICAgfSwgdGVtcGxhdGUpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdFN0cmluZyA9IHRlbXBsYXRlO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwidHJhZHVjdGlvbiB0bXBsXCIsIHRlbXBsYXRlKTtcblxuICAgIC8vIG9uIHJldG91cm5lIHFxY2hvc2UgIVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdHJpbmc7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFhMUyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEBwcml2YXRlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuQWJzdHJhY3RTZXJ2aWNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQWJzdHJhY3RTZXJ2aWNlIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBBYnN0cmFjdFNlcnZpY2UgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFic3RyYWN0U2VydmljZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFic3RyYWN0U2VydmljZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbnMgcGFyIGRlZmF1dFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBldCBvbiBham91dGUgbGVzIG9wdGlvbnMgZW4gcGFyYW3DqHRyZSBhdXggb3B0aW9ucyBwYXIgZMOpZmF1dFxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6QWJzdHJhY3RTZXJ2aWNlI1xuICovXG5BYnN0cmFjdFNlcnZpY2UucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgc3RyUmVxdWVzdCA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBvYmpldCBSZXF1ZXN0XG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgb1JlcXVlc3QgOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyXG4gICAgICogQHR5cGUge0ZpbHRlckV4dGVuc2lvbn1cbiAgICAgKi9cbiAgICBvRmlsdGVyIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBBYnN0cmFjdFNlcnZpY2UsXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkJ3VuIG9iamV0IGRlIHR5cGUgUmVxdWVzdCA6IEdlb2NvZGVSZXF1ZXN0IC8gUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0IC8gUm91dGVSZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1JlcXVlc3QgLSBHZW9jb2RlUmVxdWVzdCAvIFJldmVyc2VHZW9jb2RlUmVxdWVzdCAvIFJvdXRlUmVxdWVzdFxuICAgICAqL1xuICAgIGFkZFJlcXVlc3QgOiBmdW5jdGlvbiAob1JlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZCd1biBvYmpldCBkZSB0eXBlIEZpbHRlckV4dGVuc2lvbiA6IEdlb2NvZGVGaWx0ZXJFeHRlbnNpb24gb3UgUm91dGVSZXF1ZXN0RXh0ZW5zaW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb0ZpbHRlciAtIEdlb2NvZGVGaWx0ZXJFeHRlbnNpb24gb3UgUm91dGVSZXF1ZXN0RXh0ZW5zaW9uXG4gICAgICovXG4gICAgYWRkRmlsdGVyIDogZnVuY3Rpb24gKG9GaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdG9TdHJpbmdcbiAgICAgKi9cbiAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJvdmVyd3JpdHRlbiBtZXRob2QgIVwiKTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFic3RyYWN0U2VydmljZSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIEFqb3V0ZXIgZGVzIGV4dGVuc2lvbnMgZGUgZmlsdHJlcyBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZSBkZSBnZW9jb2RhZ2UgZGUgbCdJR04uXG4gKiBDZWNpIHBlcm1ldCBkZSBjb250csO0bGVyIGxlcyBvcHRpb25zIHNww6ljaWZpcXVlcyBkZSBsYSB0YWJsZSBkZSBnZW9jb2RhZ2UgaW50w6lycm9nw6llcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dCA9ICBuZXcgR2VvY29kZUZpbHRlcnNFeHRlbnNpb24gKCk7XG4gKiAgICAgZXh0LmFkZCAobmV3IEFkbWluaXN0cmF0aWYgKCkpO1xuICogICAgIGV4dC5hZGQgKG5ldyBTdHJlZXRBZGRyZXNzICgpKTtcbiAqICAgICBleHQuYWRkIChuZXcgUG9zaXRpb25PZkludGVyZXN0ICgpKTtcbiAqICAgICBleHQuYWRkIChuZXcgQ2FkYXN0cmFsUGFyY2VsICgpKTtcbiAqXG4gKiBleHQuZ2V0TmFtZXMgKClcbiAqIC8vIC0tPiBvdXRcbiAqIC8vIFtBZG1pbmlzdHJhdGlmLCBTdHJlZXRBZGRyZXNzLCBQb3NpdGlvbk9mSW50ZXJlc3QsIENhZGFzdHJhbFBhcmNlbF1cbiAqXG4gKiBleHQuZ2V0RmlsdGVycyAoKVxuICogLy8gLS0+IG91dFxuICogLy8gW09iamVjdCwgT2JqZWN0LCBPYmplY3QsIE9iamVjdF0gPSB0YWJsZWF1IGQnb2JqZXQgR2VvY29kZUxvY2F0aW9uXG4gKlxuICogZXh0LmdldEZpbHRlciAoJ1N0cmVldEFkZHJlc3MnKVxuICogLy8gLS0+IG91dFxuICogLy8ge09iamVjdH0gPSBvYmpldCBHZW9jb2RlTG9jYXRpb25cbiAqXG4gKiBleHQuZ2V0QXR0cmlidXRzICgnU3RyZWV0QWRkcmVzcycpXG4gKiAvLyAtLT4gb3V0XG4gKiAvLyBbXCJiYm94XCIsIFwibnVtYmVyXCIsIFwiSURcIiwgXCJJRFRSXCIsIFwicG9zdGFsQ29kZVwiLCBcInF1YWxpdHlcIiwgXCJzdHJlZXRcIiwgXCJ0ZXJyaXRvaXJlXCIsIFwiY29tbXVuZVwiLCBcImRlcGFydG1lbnRcIiwgXCJpbnNlZVwiLCBcIm11bmljaXBhbGl0eVwiXVxuICpcbiAqIGV4dC5zZXRQbGFjZUF0dHJpYnV0cyAoJ1N0cmVldEFkZHJlc3MnLCB7bnVtYmVyOicnLCB0ZXJyaXRvaXJlOicnLCBxdWFsaXR5OicnLCBmYWtlOicnfSlcbiAqIC8vIC0tPiBvdXRcbiAqIC8vIChmYWtlIGVzdCDDqWNhcnTDqSBjYXIgaWwgbidhcHBhcnRpZW50IHBhcyDDoCBsYSBsaXN0ZSAhKVxuICpcbiAqIGV4dC5nZXRQbGFjZUF0dHJpYnV0cyAoJ1N0cmVldEFkZHJlc3MnKVxuICogLy8gLS0+IG91dFxuICogLy8ge251bWJlciA6ICcnLCB0ZXJyaXRvaXJlIDogJycsIHF1YWxpdHkgOiAnJ31cbiAqXG4gKiAvLyBDb21tZW50IGFqb3V0ZXIgZGVzIGZpbHRyZXMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgZGUgZ2VvY29kYWdlID9cbiAqIHZhciByZXEgPSBuZXcgR2VvY29kZVJlcXVlc3QgKHtcbiAqICAgICAgbG9jYXRpb24gOiBcInNhaW50IG1hbmTDqVwiLFxuICogICAgICByZXR1cm5GcmVlRm9ybSA6IHRydWUsXG4gKiAgICAgIGZpbHRlck9wdGlvbnMgOiB7XG4gKiAgICAgICAgICB0eXBlIDogWydQb3NpdGlvbk9mSW50ZXJlc3QnXSwgPC0tIGFqb3V0ZXIgdW5lIGV4dGVuc2lvbiBhZmluIGRlIGdlcmVyIGxlcyBhdHRyaWJ1dHMgZGUgY2V0dGUgdGFibGUgZGUgZ2VvY29kYWdlICFcbiAqICAgICAgICAgICguLi4pXG4gKiAgICAgIH1cbiAqICB9KVxuICogIHJlcS5hZGRGaWx0ZXIgKG5ldyBQb3NpdGlvbk9mSW50ZXJlc3QgKCkpO1xuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuTG9jYXRpb25VdGlsaXR5U2VydmljZS5HZW9jb2RlRmlsdGVyRXh0ZW5zaW9uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VvY29kZUZpbHRlckV4dGVuc2lvbiAoKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkdlb2NvZGVGaWx0ZXJFeHRlbnNpb25cIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEdlb2NvZGVGaWx0ZXJFeHRlbnNpb24gKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdlb2NvZGVGaWx0ZXJFeHRlbnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW9jb2RlRmlsdGVyRXh0ZW5zaW9uIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFibGVhdSBkZSBmaWx0cmVzICh0YWJsZSBkZSBnZW9jb2RhZ2UpXG4gICAgICovXG4gICAgdGhpcy5maWx0ZXJzID0gW107XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpHZW9jb2RlRmlsdGVyRXh0ZW5zaW9uI1xuICovXG5HZW9jb2RlRmlsdGVyRXh0ZW5zaW9uLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBHZW9jb2RlRmlsdGVyRXh0ZW5zaW9uLFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZCd1biBmaWx0cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvR2VvY29kZUxvY2F0aW9uIC0gb2JqZXQgZGUgdHlwZSAnR2VvY29kZUxvY2F0aW9uJ1xuICAgICAqL1xuICAgIGFkZEZpbHRlckV4dGVuc2lvbnMgOiBmdW5jdGlvbiAob0dlb2NvZGVMb2NhdGlvbikge1xuICAgICAgICAvLyBGSVhNRSB0ZXN0IHN1ciBsZSB0eXBlIGQnb2JqZXQgIVxuICAgICAgICBpZiAob0dlb2NvZGVMb2NhdGlvbikge1xuICAgICAgICAgICAgLy8gRklYTUUgb3UgdGVzdCBzdXIgc2VzIHByb3ByacOpdMOpcyAhXG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChvR2VvY29kZUxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBnZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIFRhYmxlYXUgZGUgbm9tcyAodGFibGVzIGRlIGdlb2NvZGFnZSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn1cbiAgICAgKi9cbiAgICBnZXROYW1lcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkeCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIG5hbWVzLnB1c2godGhpcy5maWx0ZXJzW2lkeF0uQ0xBU1NOQU1FKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShuYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3VybmUgdW5lIHRhYmxlIGRlIGdlb2NvZGFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBub20gZGUgbGEgdGFibGUgZGUgZ2VvY29kYWdlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXIgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZmlsdGVyID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaWR4IGluIHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpZHhdLkNMQVNTTkFNRSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIGZpbHRlciA9IHRoaXMuZmlsdGVyc1tpZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGZpbHRlcik7XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRhYmxlYXUgZCdvYmplY3RzICh0YWJsZXMgZGUgZ2VvY29kYWdlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIGdldEZpbHRlcnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFLDqWN1cMOocmUgbGEgbGlzdGUgZGVzIGF0dHJpYnV0cyAoZmlsdHJlcykgc3VyIHVuZSB0YWJsZSBkZSBnZW9jb2RhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbm9tIGRlIGxhIHRhYmxlIGRlIGdlb2NvZGFnZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dHMgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkeCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbaWR4XS5DTEFTU05BTUUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dHMgPSB0aGlzLmZpbHRlcnNbaWR4XS5hdHRyaWJ1dGVzTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShhdHRyaWJ1dHMpO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkZXMgYXR0cmlidXRzIChmaWx0cmVzKSBzdXIgdW5lIHRhYmxlIGRlIGdlb2NvZGFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBub20gZGUgbGEgdGFibGUgZGUgZ2VvY29kYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlIGxhIHRhYmxlIGRlIGdlb2NvZGFnZVxuICAgICAqL1xuICAgIHNldFBsYWNlQXR0cmlidXRzIDogZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ2V0RmlsdGVyKG5hbWUpO1xuICAgICAgICB2YXIgYXR0cmlidXRzID0gdGhpcy5nZXRBdHRyaWJ1dHMobmFtZSk7XG4gICAgICAgIGZvciAodmFyIGlkeCBpbiBhdHRyaWJ1dHMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0c1tpZHhdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyLnBsYWNlQXR0cmlidXRlc1t2YWx1ZV0gPSBvcHRpb25zW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRvdXJuZSBsZXMgYXR0cmlidXRzIChmaWx0cmVzKSBzdXIgdW5lIHRhYmxlIGRlIGdlb2NvZGFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBub20gZGUgbGEgdGFibGUgZGUgZ2VvY29kYWdlXG4gICAgICovXG4gICAgZ2V0UGxhY2VBdHRyaWJ1dHMgOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGxhY2VzID0ge307XG4gICAgICAgIGZvciAodmFyIGlkeCBpbiB0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbaWR4XS5DTEFTU05BTUUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICBwbGFjZXMgPSB0aGlzLmZpbHRlcnNbaWR4XS5wbGFjZUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UocGxhY2VzKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlcztcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEdlb2NvZGVGaWx0ZXJFeHRlbnNpb24pO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmVzcG9uc2Ugb2JqZWN0IGZvciB7QGxpbmsgbW9kdWxlOlNlcnZpY2Vzfmdlb2NvZGUgR3AuU2VydmljZXMuZ2VvY29kZSAoKX0gb3Ige0BsaW5rIG1vZHVsZTpTZXJ2aWNlc35yZXZlcnNlR2VvY29kZSBHcC5TZXJ2aWNlcy5yZXZlcnNlR2VvY29kZSAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuR2VvY29kZS5EaXJlY3RHZW9jb2RlZExvY2F0aW9ufEdwLlNlcnZpY2VzLkdlb2NvZGUuUmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24+fSBsb2NhdGlvbnMgLSBsb2NhdGlvbnMgYXJyYXkuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGVSZXNwb25zZVxuICovXG5mdW5jdGlvbiBHZW9jb2RlUmVzcG9uc2UgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW9jb2RlUmVzcG9uc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW9jb2RlUmVzcG9uc2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvY2F0aW9ucyA9IFtdO1xufVxuXG5HZW9jb2RlUmVzcG9uc2UucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBHZW9jb2RlUmVzcG9uc2VcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChHZW9jb2RlUmVzcG9uc2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTG9jYXRpb24gb2JqZWN0IGhvbGRpbmcgY29tbW9uIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgdGhlIHVuZGVybHlpbmcgZ2VvY29kaW5nIGFuZCByZXZlcnNlIGdlb2NvZGluZyB3ZWIgc2VydmljZS5cbiAqXG4gKiBAcHJvcGVydHkge0dwLlBvaW50fSBwb3NpdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSBsb2NhdGlvbiBnaXZlbiBpbiB0aGUgcmVxdWVzdGVkIGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIC0gbG9jYXRpb24gdHlwZSBcIlN0cmVldEFkZHJlc3NcIiAoZm9yIGFuIGFkZHJlc3MpLCBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiIChmb3IgYSBwbGFjZSBuYW1lKSBvciBcIkNhZGFzdHJhbFBhcmNlbFwiIChmb3IgY2FkYXN0cmFsIHBhcmNlbCkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWF0Y2hUeXBlIC0gaG93IGdlb2NvZGluZyBpcyBwZXJmb3JtZWQgOiBcInN0cmVldCBudW1iZXJcIiAoZXhhY3QgYWRkcmVzcyksIFwic3RyZWV0IGVuaGFuY2VkXCIgKHN0cmVldCBudW1iZXIgY2FsY3VsYXRlZCBieSBpbnRlcnBvbGF0aW9uKSwgXCJzdHJlZXRcIiAob25seSB0aGUgc3RyZWV0KSwgXCJjaXR5XCIgKG9ubHkgdGhlIGNpdHkpLlxuICogQHByb3BlcnR5IHtPYmplY3R9IHBsYWNlQXR0cmlidXRlcyAtIEFzc29jaWF0aXZlIGFycmF5IG1hdGNoaW5nIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyB3aXRoIHRoZWlyIHZhbHVlcyBnaXZlbiBieSB0aGUgdW5kZXJseWluZyB3ZWIgc2VydmljZSA6XG4gKlxuICogKkNvbW1vbiBhdHRyaWJ1dGVzIDogKlxuICpcbiAqIC0gKipmcmVlZm9ybSoqIC0gZnJlZWZvcm0gY29tcGxldGUgQWRkcmVzcy5cbiAqIC0gKipiYm94KiogLSBCb3VuZGluZyBCb3ggKntAbGluayBHcC5CQm94fSouXG4gKiAtICoqbXVuaWNpcGFsaXR5KiogLSBNdW5pY2lwYWxpdHlcbiAqXG4gKiAqaWYgdHlwZSA9PT0gXCJTdHJlZXRBZGRyZXNzXCIgOiAqXG4gKlxuICogLSAqKm51bWJlcioqIC0gU3RyZWV0IG51bWJlci5cbiAqIC0gKipJRCoqIC0gSWRlbnRpZmllciBvZiB0aGUgYWRkcmVzcyBpbiB0aGUgW0JEIEFEUkVTU0UgRGF0YWJhc2Vde0BsaW5rIGh0dHA6Ly9wcm9mZXNzaW9ubmVscy5pZ24uZnIvYmRhZHJlc3NlfS5cbiAqIC0gKipJRFRSKiogLSBJZGVudGlmaWVyIG9mIHRoZSBsaW5lU3RyaW5nIGluIHRoZSBbQkQgQURSRVNTRSBEYXRhYmFzZV17QGxpbmsgaHR0cDovL3Byb2Zlc3Npb25uZWxzLmlnbi5mci9iZGFkcmVzc2V9LlxuICogLSAqKnBvc3RhbENvZGUqKiAtIFBvc3RDb2RlXG4gKiAtICoqcXVhbGl0eSoqIC0gR2VvY29kaW5nIHF1YWxpdHkgKFtzZWVde0BsaW5rIGh0dHA6Ly9hcGkuaWduLmZyL3RlY2gtZG9jcy1qcy9kZXZlbG9wcGV1ci9zZWFyY2guaHRtbH0pXG4gKiAtICoqc3RyZWV0KiogLSBTdHJlZXQgbmFtZVxuICogLSAqKnRlcnJpdG9yeSoqIC0gRnJlbmNoIFRlcnJpdG9yeSBjb2RlXG4gKiAtICoqY29tbXVuZSoqIC0gQ2l0eVxuICogLSAqKmRlcGFydG1lbnQqKiAtIERlcGFydG1lbnRcbiAqIC0gKippbnNlZSoqIC0gSU5TRUUgQ29kZVxuICpcbiAqXG4gKiAqaWYgdHlwZSA9PT0gXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiA6KlxuICpcbiAqIC0gKippbXBvcnRhbmNlKiogLSBQbGFjZSBuYW1lIGltcG9ydGFuY2VcbiAqIC0gKipuYXR1cmUqKiAtIFBsYWNlIG5hbWUgbmF0dXJlXG4gKiAtICoqcG9zdGFsQ29kZSoqIC0gUG9zdENvZGVcbiAqIC0gKip0ZXJyaXRvcnkqKiAtIEZyZW5jaCBUZXJyaXRvcnkgY29kZVxuICogLSAqKmNvbW11bmUqKiAtIENpdHlcbiAqIC0gKipkZXBhcnRtZW50KiogLSBEZXBhcnRtZW50XG4gKiAtICoqaW5zZWUqKiAtIElOU0VFIENvZGVcbiAqXG4gKlxuICogKnNpIHR5cGUgPSBcIkNhZGFzdHJhbFBhcmNlbFwiIDoqXG4gKlxuICogLSAqKmFic29yYmVkQ2l0eSoqIC0gd2hlbiBhIHBhcmNlbCBjb21lcyBmcm9tIGEgY2l0eSB0aGF0IHdhcyBhYnNvcmJlZCBieSBhbm90aGVyLCBjb2RlIG9mIHRoYXQgb2xkIGNpdHkuIFwiMDAwXCIgb3RoZXJ3aXNlLlxuICogLSAqKmFycm9uZGlzc2VtZW50KiogLSBhcnJvbmRpc3NlbWVudFxuICogLSAqKmNhZGFzdHJhbFBhcmNlbCoqIC0gY2FkYXN0cmFsIHBhcmNlbCBjb2RlXG4gKiAtICoqZGlzdHJpY3QqKiAtIGRpc3RyaWN0XG4gKiAtICoqc2hlZXQqKiAtIFBhcmNlbCBTaGVldCAoZWcuIFwiMVwiKS5cbiAqIC0gKipudW1iZXIqKiAtIFBhcmNlbCBOdW1iZXIgKGVnLiBcIjAwNDFcIilcbiAqIC0gKipzZWN0aW9uKiogLSBQYXJjZWwgU2VjdGlvbiAoZWcuIFwiMERcIikuXG4gKiAtICoqY29tbXVuZSoqIC0gUGFyY2VsIG11bmljaXBhbGl0eS5cbiAqIC0gKipkZXBhcnRtZW50KiogLSBQYXJjZWwgRGVwYXJ0bWVudC5cbiAqIC0gKippbnNlZSoqIC0gSU5TRUUgQ29kZS5cbiAqIC0gKipvcmlnaW4qKiAtIFBhcmNlbCBvcmlnaW4gKHNlZSBcInR5cGVcIiBhdHRyaWJ1dGUgaW4gdGhlIFt1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIHJlc3BvbnNlXXtAbGluayBodHRwOi8vYXBpLmlnbi5mci90ZWNoLWRvY3MtanMvZGV2ZWxvcHBldXIvc2VhcmNoLmh0bWwjQ2FkYXN0cmFsX3BhcmNlbHNfc2VhcmNofSlcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5HZW9jb2RlZExvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIEdlb2NvZGVkTG9jYXRpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW9jb2RlZExvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZWRMb2NhdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgIHggOiBudWxsLFxuICAgICAgICB5IDogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLm1hdGNoVHlwZSA9IG51bGw7XG5cbiAgICB0aGlzLnBsYWNlQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgdGhpcy50eXBlID0gbnVsbDtcbn1cblxuR2VvY29kZWRMb2NhdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IEdlb2NvZGVkTG9jYXRpb25cblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChHZW9jb2RlZExvY2F0aW9uKTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXNwb25zZSBvYmplY3QgZm9yIHtAbGluayBtb2R1bGU6U2VydmljZXN+cm91dGUgR3AuU2VydmljZXMucm91dGUgKCl9IGludm9jYXRpb24gd2hlbiBzdWNjZXNzZnVsLiBSZWNlaXZlZCBhcyB0aGUgYXJndW1lbnQgb2Ygb25TdWNjZXNzIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7R3AuQkJveH0gYmJveCAtIEJvdW5kaW5nIEJveCBvZiB0aGUgcm91dGUuIEdpdmVuIHdoZW4gcHJvdmlkZUJCb3ggcGFyYW1ldGVyIGlzIHVzZWQgaW4gZnVuY3Rpb24gY2FsbC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByb3V0ZUdlb21ldHJ5IC0gR2VvbWV0cnkgKGV4cHJlc3NlZCBpbiBbR2VvSlNPTl17QGxpbmsgaHR0cDovL2dlb2pzb24ub3JnL30pIG9mIHRoZSByb3V0ZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLlJvdXRlLlJvdXRlSW5zdHJ1Y3Rpb24+fSByb3V0ZUluc3RydWN0aW9ucyAtIEluc3RydWN0aW9ucyBvZiB0aGUgcm91dGUuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdG90YWxEaXN0YW5jZSAtIExlbmd0aCBvZiB0aGUgcm91dGUuIElmIGRpc3RhbmNlVW5pdCBwYXJhbWV0ZXIgd2FzIHNldCB0byBcImttXCIgKGRlZmF1bHQpLCB0b3RhbERpc3RhbmNlIGlzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHRvdGFsIGRpc3RhbmNlIGV4cHJlc3NlZCBpbiBraWxvbWV0ZXJzLCBmb2xsb3dlZCBieSBcIiBLbVwiIChlLmcuIDogXCIxOS42IEttXCIpLiBJZiBkaXN0YW5jZVVuaXQgcGFyYW1ldGVyIHdhcyBzZXQgdG8gXCJtXCIsIHRvdGFsRGlzdGFuY2UgaXMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgdG90YWwgZGlzdGFuY2UgZXhwcmVzc2VkIGluIG1ldGVycyAoZS5nLiA6IFwiMTk1OTkuMTRcIikuXG4gKiBAcHJvcGVydHkge0Zsb2F0fSB0b3RhbFRpbWUgLSBSb3V0ZSBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Sb3V0ZVJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlUmVzcG9uc2UgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3V0ZVJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUm91dGVSZXNwb25zZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMudG90YWxUaW1lID0gbnVsbDtcblxuICAgIHRoaXMudG90YWxEaXN0YW5jZSA9IG51bGw7XG5cbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICAgIGxlZnQgOiBudWxsLFxuICAgICAgICByaWdodCA6IG51bGwsXG4gICAgICAgIHRvcCA6IG51bGwsXG4gICAgICAgIGJvdHRvbSA6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5yb3V0ZUdlb21ldHJ5ID0gbnVsbDsgLy8gRklYTUUgY2FuIGJlIG51bGwgaWYgb3B0aW9uICdnZW9tZXRyeUluSW5zdHJ1Y3Rpb25zJyBpcyB0cnVlICFcblxuICAgIHRoaXMucm91dGVJbnN0cnVjdGlvbnMgPSBbXTtcbn1cblxuUm91dGVSZXNwb25zZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IFJvdXRlUmVzcG9uc2VcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChSb3V0ZVJlc3BvbnNlKTtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNpbmdsZSBSb3V0ZSBJbnN0cnVjdGlvbiBvYmplY3QuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvZGUgLSBJbnN0cnVjdGlvbiBjb2RlIDpcbiAqXG4gKiAtIFwiRlwiIDogU3RyYWlnaHQgZm9yd2FyZFxuICogLSBcIkJcIiA6IFUtdHVyblxuICogLSBcIkxcIiA6IHR1cm4gbGVmdFxuICogLSBcIlJcIiA6IHR1cm4gcmlnaHRcbiAqIC0gXCJCTFwiIDogdHVybiBsZWZ0IHN0cm9uZ2x5XG4gKiAtIFwiQlJcIiA6IHR1cm4gcmlnaHQgc3Ryb25nbHlcbiAqIC0gXCJGTFwiIDogdHVybiBsaWdodGx5IHRvIHRoZSBsZWZ0XG4gKiAtIFwiRlJcIiA6IHR1cm4gbGlnaHRseSB0byB0aGUgcmlnaHRcbiAqIC0gXCJyb3VuZF9hYm91dF9lbnRyeVwiIDogcm91bmQgYWJvdXQgZW50cnlcbiAqIC0gXCJyb3VuZF9hYm91dF9leGl0XCIgOiByb3VuZCBhYm91dCBleGl0XG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGluc3RydWN0aW9uIC0gSW5zdHJ1Y3Rpb24gdGV4dCA6IHRyYW5zbGF0ZWQgY29kZSArIHN0cmVldCBuYW1lXG4gKiBAcHJvcGVydHkge09iamVjdH0gZ2VvbWV0cnkgLSBHZW9tZXRyeSAoZXhwcmVzc2VkIGluIFtHZW9KU09OXXtAbGluayBodHRwOi8vZ2VvanNvbi5vcmcvfSkgb2YgdGhlIHN0cmVldC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IGRpc3RhbmNlIC0gTGVuZ3RoIG9mIHRoZSBpbnN0cnVjdGlvbi4gRXhwcmVzc2VkIGluIGttIG9yIG0sIGRlcGVuZGluZyBvbiBkaXN0YW5jZVVuaXQgcGFyYW1ldGVyLlxuICogQHByb3BlcnR5IHtGbG9hdH0gZHVyYXRpb24gLSBJbnN0cnVjdGlvbiBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Sb3V0ZS5Sb3V0ZUluc3RydWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJvdXRlSW5zdHJ1Y3Rpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3V0ZUluc3RydWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUm91dGVJbnN0cnVjdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZHVyYXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy5kaXN0YW5jZSA9IG51bGw7XG5cbiAgICB0aGlzLmNvZGUgPSBudWxsO1xuXG4gICAgdGhpcy5pbnN0cnVjdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDsgLy8gRklYTUUgY2FuIGJlIG51bGwgaWYgb3B0aW9uICdnZW9tZXRyeUluSW5zdHJ1Y3Rpb25zJyBpcyBmYWxzZSAhXG59XG5cblJvdXRlSW5zdHJ1Y3Rpb24ucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBSb3V0ZUluc3RydWN0aW9uXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVJbnN0cnVjdGlvbik7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXNwb25zZSBvYmplY3QgZm9yIHtAbGluayBtb2R1bGU6U2VydmljZXN+aXNvQ3VydmUgR3AuU2VydmljZXMuaXNvQ3VydmUgKCl9IGludm9jYXRpb24gd2hlbiBzdWNjZXNzZnVsLiBSZWNlaXZlZCBhcyB0aGUgYXJndW1lbnQgb2Ygb25TdWNjZXNzIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IGRpc3RhbmNlIC0gZGlzdGFuY2UgKGV4cHJlc3NlZCBpbiBtZXRlcnMpIHVzZWQgZm9yIHRoZSByZXF1ZXN0LlxuICogQHByb3BlcnR5IHtGbG9hdH0gdGltZSAtIHRpbWUgKGV4cHJlc3NlZCBpbiBzZWNvbmRzKSB1c2VkIGZvciB0aGUgcmVxdWVzdC5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZW9tZXRyeSAtIEdlb21ldHJ5IChleHByZXNzZWQgaW4gW0dlb0pTT05de0BsaW5rIGh0dHA6Ly9nZW9qc29uLm9yZy99KSBvZiB0aGUgaXNvY3VydmUuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaWQgLSByZXF1ZXN0IGlkICh1c2VkIGJ5IHVuZGVybHlpbmcgd2Vic2VydmljZSkuXG4gKiBAcHJvcGVydHkge0dwLlBvaW50fSBsb2NhdGlvbiAtIFBvc2l0aW9uIG9mIHRoZSBzdGFydCBvciBlbmQgcG9pbnQgdXNlZCBmb3IgdGhlIHJlcXVlc3QgKGV4cHJlc3NlZCBpbiBcInNyc1wiIGNvb3JkaW5hdGVzIHN5c3RlbSkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzcnMgLSBJZGVudGlmaWVyIG9mIHRoZSBjb29yZGluYXRlcyBzeXN0ZW0gdXNlZCBmb3IgdGhlIGlzb2N1cnZlLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Jc29DdXJ2ZVJlc3BvbnNlXG4gKlxuICovXG5mdW5jdGlvbiBQcm9jZXNzSXNvQ3VydmVSZXNwb25zZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICB0aGlzLmxvY2F0aW9uID0ge307XG4gICAgdGhpcy5sb2NhdGlvbi54ID0gbnVsbDtcbiAgICB0aGlzLmxvY2F0aW9uLnkgPSBudWxsO1xuXG4gICAgdGhpcy5zcnMgPSBudWxsO1xuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG5cbiAgICB0aGlzLnRpbWUgPSBudWxsO1xuXG4gICAgdGhpcy5kaXN0YW5jZSA9IG51bGw7XG59XG5cblByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm9jZXNzSXNvQ3VydmVSZXNwb25zZSk7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX0hlbHBlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfZXM2X3Byb21pc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9lczZfcHJvbWlzZV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX2VzNl9wcm9taXNlX18pO1xuLyogZ2xvYmFsIFByb21pc2UsIHJlcXVpcmUgKi9cblxuXG5cblxuLy8gaW1wb3J0IF9fcmVxdWVzdCBmcm9tIFwicmVxdWVzdFwiO1xuLy8gaW1wb3J0IF9feG1sZG9tIGZyb20gXCJ4bWxkb21cIjtcblxuLyoqXG4gKiBSZXF1w6p0ZXMgQWpheCAodXRpbGlzYXRpb24gZGVzIFByb21pc2VzKVxuICogY2YuIGh0dHBzOi8veGhyLnNwZWMud2hhdHdnLm9yZy9cbiAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3RcbiAqXG4gKiBAbW9kdWxlIFhIUlxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5Qcm90b2NvbHMuWEhSXG4gKiBAc2VlIGRlcGVuZGFuY2UgJ3Byb21pc2UnXG4gKi9cblxudmFyIFhIUiA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZCdlbnZvaSBkJ3VuZSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2FsbFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgLSBvcHRpb25zIGdlbmVyYWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy51cmwgICAgLSB1cmwgZHUgc2VydmljZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5ncy5tZXRob2QgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmZvcm1hdCAtIGZvcm1hdCBkZSBsYSByZXBvbnNlIGR1IHNlcnZpY2UgOiBqc29uLCB4bWwgb3UgbnVsbCAoYnJ1dGUpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmRhdGEgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnByb3h5ICAtIHByb3h5IHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuaGVhZGVycyAtIChwb3N0KSBleC4gcmVmZXJlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2V0dGluZ3MuY29udGVudCAtIChwb3N0KSBleC4gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnRpbWVPdXQgLSB0aW1lb3V0ID0gMCBwYXIgZGVmYXV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLnNjb3BlIC0gdGhpc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uUmVzcG9uc2UgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRpbmdzLm9uRmFpbHVyZSAgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIGNhbGwgOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlhIUlwiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFwiW1hIUjo6Y2FsbCgpXVwiKTtcblxuICAgICAgICAvLyBGSVhNRVxuICAgICAgICAvLyBUbyBwb2x5ZmlsbCB0aGUgZ2xvYmFsIGVudmlyb25tZW50XG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9lczZfcHJvbWlzZV9fX2RlZmF1bHQuYS5wb2x5ZmlsbCgpO1xuXG4gICAgICAgIC8vIHRlc3Qgc3VyIGxlcyBzZXR0aW5ncyBvYmxpZ2F0b2lyZXNcbiAgICAgICAgaWYgKCFzZXR0aW5ncy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogdXJsIGlzIG5vdCBkZWZpbmVkICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBtZXRob2QgaXMgbm90IGRlZmluZWQgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuZm9ybWF0KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5mb3JtYXQgPSBcInRleHRcIjsgLy8gcmVwb25zZSBicnV0ZSAhXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgb3B0aW9ucy5kYXRhID0gc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsO1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IHNldHRpbmdzLm1ldGhvZDtcbiAgICAgICAgb3B0aW9ucy50aW1lT3V0ID0gc2V0dGluZ3MudGltZU91dCB8fCAwO1xuICAgICAgICBvcHRpb25zLnNjb3BlID0gc2V0dGluZ3Muc2NvcGUgfHwgdGhpcztcbiAgICAgICAgb3B0aW9ucy5wcm94eSA9IHNldHRpbmdzLnByb3h5IHx8IG51bGw7XG4gICAgICAgIG9wdGlvbnMuY29udGVudCA9IHNldHRpbmdzLmNvbnRlbnQgfHwgbnVsbDtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycyB8fCB7XG4gICAgICAgICAgICByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0ZXN0IHN1ciBsZXMgdmFsZXVycyBkZSAnc2V0dGluZ3MubWV0aG9kJ1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcIkRFTEVURVwiOlxuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlBVVFwiOlxuICAgICAgICAgICAgY2FzZSBcIlBPU1RcIjpcbiAgICAgICAgICAgICAgICAvLyBvbiBmb3JjZSBzdXIgY2VzIHBhcmFtcyBzcMOpY2lmaXF1ZXMgYXUgbW9kZSBQT1NUXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZW50ID0gc2V0dGluZ3MuY29udGVudCA/IHNldHRpbmdzLmNvbnRlbnQgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOyAvLyBGSVhNRSBlbiBhdHRlbnRlIGRlcyBzZXJ2aWNlcyA6IGJhc2N1bGUgZW4gXCJhcHBsaWNhdGlvbi94bWxcIiBvdSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnMgPyBzZXR0aW5ncy5oZWFkZXJzIDoge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVyIDogXCJodHRwOi8vbG9jYWxob3N0XCIgLy8gdG9kbyAuLi5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkhFQURcIjpcbiAgICAgICAgICAgIGNhc2UgXCJPUFRJT05TXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBtZXRob2Qgbm90IHlldCBzdXBwb3J0ZWQgIVwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBtZXRob2QgdW5rbm93biAhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVzdCBzdXIgbGVzIHZhbGV1cnMgZGUgJ3NldHRpbmdzLmZvcm1hdCdcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbGwob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25SZXNwb25zZS5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25GYWlsdXJlLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbGxKU09OKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uUmVzcG9uc2UuY2FsbCh0aGlzLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uRmFpbHVyZS5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbGxYTUwob3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25SZXNwb25zZS5jYWxsKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25GYWlsdXJlLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBvdXRwdXQgRm9ybWF0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkICFcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWV0ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBfX2NhbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb21pc2VcbiAgICAgKi9cbiAgICBfX2NhbGwgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJYSFJcIik7XG4gICAgICAgIGxvZ2dlci50cmFjZShcIltYSFI6Ol9fY2FsbCgpXVwiKTtcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIHRyYWl0ZW1lbnQgZHUgY29ycHMgZGUgbGEgcmVxdcOqdGVcbiAgICAgICAgICAgICAgICB2YXIgY29ycHMgPSAob3B0aW9ucy5tZXRob2QgPT09IFwiUE9TVFwiIHx8IG9wdGlvbnMubWV0aG9kID09PSBcIlBVVFwiKSA/IDEgOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V1bGVtZW50IHNpIG9wdGlvbnMuZGF0YSBuJ2VzdCBwYXMgdmlkZSAocGV1dCDDqnRyZSB1biBvYmpldCBvdSB1bmUgY2hhaW5lIGRlIGNhcmFjdMOocmVzKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgKCh0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKG9wdGlvbnMuZGF0YSkubGVuZ3RoKSB8fCAodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLmRhdGEubGVuZ3RoKSkgJiYgIWNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19IZWxwZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWx5emVVcmwob3B0aW9ucy51cmwsIG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiVVJMID0gXCIsIG9wdGlvbnMudXJsKTtcblxuICAgICAgICAgICAgICAgIHZhciBoWEhSID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHRlc3Qgb24gZW52LiBub2RlanMgb3IgYnJvd3NlclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFV0aWxpc2F0aW9uIGR1IG1vZHVsZSA6XG4gICAgICAgICAgICAgICAgICAgIC8vIGNmLiBodHRwOi8vYmxvZy5tb2R1bHVzLmlvL25vZGUuanMtdHV0b3JpYWwtaG93LXRvLXVzZS1yZXF1ZXN0LW1vZHVsZVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTsvLyBfX3JlcXVlc3RcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXBwaW5nIGRhdGEgYXZlYyBib2R5IHBhcmFtLiBwb3VyIGxlIG1vZGUgUE9TVCBvdSBQVVQgKD8pXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBjb3Jwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgRVJST1IgOiBzZWxmIHNpZ25lZCBjZXJ0aWZpY2F0ZSBpbiBjZXJ0aWZpY2F0ZSBjaGFpblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcShvcHRpb25zLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCAmJiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRXJyb3JzIE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IChub2RlanMpIDogXCIgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9wZW4ob3B0aW9ucy5tZXRob2QsIG9wdGlvbnMudXJsLCB0cnVlKTsgLy8gYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub3ZlcnJpZGVNaW1lVHlwZSA9IG9wdGlvbnMuY29udGVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2VzdGlvbiBkdSB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25UaW1lT3V0VHJpZ2dlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIGxlIHRpbWVvdXQgaW50ZXJuZSBuZSBtZSBwZXJtZXQgcGFzIGRlIGRlY2xlbmNoZXIgbGUgYm9uIG1lc3NhZ2UuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoWEhSLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVPdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiWEhSIC0gVGltZU91dCBhY3RpZiAhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9uVGltZU91dFRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVGltZU91dFRyaWdnZXIgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lT3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycywgZGF0YSwgY29udGVudCBvZiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZHZjcy53My5vcmcvaGcveGhyL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2RvbS14bWxodHRwcmVxdWVzdC1zZXRyZXF1ZXN0aGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiZGF0YSA9IFwiLCBvcHRpb25zLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBvcHRpb25zLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgY29udGVudC1sZW5ndGggamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhYSFIuc2V0UmVxdWVzdEhlYWRlciAoXCJDb250ZW50LWxlbmd0aFwiLCBvcHRpb25zLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoWEhSLnNldFJlcXVlc3RIZWFkZXIgKFwiUmVmZXJlclwiLCBvcHRpb25zLmhlYWRlcnMucmVmZXJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZJWE1FIG5lIHNlIGRlY2xlbmNoZSBwYXMgIT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIEV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9uZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkVycm9ycyBPY2N1cmVkIG9uIEh0dHAgUmVxdWVzdCB3aXRoIFhNTEh0dHBSZXF1ZXN0ICFcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBPbiBUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGSVhNRSBuZSBzZSBkZWNsZW5jaGUgcGFzICE/XG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvbnRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lT3V0IE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IHdpdGggWE1MSHR0cFJlcXVlc3QgIVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1ldGhvZCBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoWEhSLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gRE9ORVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaFhIUi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChvblRpbWVPdXRUcmlnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaFhIUi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXJyb3JzIE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IChzdGF0dXMgOiAnXCIgKyBoWEhSLnN0YXR1cyArIFwiJyB8IHJlc3BvbnNlIDogJ1wiICsgaFhIUi5yZXNwb25zZSArIFwiJylcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBoWEhSLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdlc3Rpb24gZHUgY29udGVudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTR4aHIgPSAob3B0aW9ucy5kYXRhICYmIGNvcnBzKSA/IG9wdGlvbnMuZGF0YSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIuc2VuZChkYXRhNHhocik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOOKAkzEwIG9ubHkgIVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiWERvbWFpblJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhYSFIub3BlbihvcHRpb25zLm1ldGhvZCwgb3B0aW9ucy51cmwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm92ZXJyaWRlTWltZVR5cGUgPSBvcHRpb25zLmNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbWVPdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcIlhIUiAtIFRpbWVPdXQgYWN0aWYgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycywgZGF0YSwgY29udGVudCBvZiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZHZjcy53My5vcmcvaGcveGhyL3Jhdy1maWxlL3RpcC9PdmVydmlldy5odG1sI2RvbS14bWxodHRwcmVxdWVzdC1zZXRyZXF1ZXN0aGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIG9wdGlvbnMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBjb250ZW50LWxlbmd0aCBqYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaFhIUi5zZXRSZXF1ZXN0SGVhZGVyIChcIkNvbnRlbnQtbGVuZ3RoXCIsIG9wdGlvbnMuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhYSFIuc2V0UmVxdWVzdEhlYWRlciAoXCJSZWZlcmVyXCIsIG9wdGlvbnMuaGVhZGVycy5yZWZlcmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcnMgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIG9udGltZW91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVPdXQgT2NjdXJlZCBvbiBIdHRwIFJlcXVlc3Qgd2l0aCBYTUxIdHRwUmVxdWVzdCAhXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogT24gTG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZXRob2Qgb25sb2FkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBoWEhSLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaFhIUi5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhYSFIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRXJyb3JzIE9jY3VyZWQgb24gSHR0cCBSZXF1ZXN0IChzdGF0dXMgOiAnXCIgKyBoWEhSLnN0YXR1cyArIFwiJyB8IHJlc3BvbnNlIDogJ1wiICsgaFhIUi5yZXNwb25zZVRleHQgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBoWEhSLnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhNHhkciA9IChvcHRpb25zLmRhdGEgJiYgY29ycHMpID8gb3B0aW9ucy5kYXRhIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaFhIUi5zZW5kKGRhdGE0eGRyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNPUlMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWV0ZSBhdmVjIHBhcnNlciBKU09OXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9fY2FsbEpTT05cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb21pc2VcbiAgICAgKi9cbiAgICBfX2NhbGxKU09OIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWxsKG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihKU09OLnBhcnNlKVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiX2NhbGxKU09OIGZhaWxlZCBvbiA6IFwiLCBvcHRpb25zLnVybCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBhcyBkJ2V4Y2VwdGlvbiwgbGFpc3NvbnMgbGUgZmlsIHNlIGRlcm91bGVyLi4uXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWV0ZSBhdmVjIHBhcnNlciBYTUxcbiAgICAgKlxuICAgICAqIEBtZXRob2QgX19jYWxsWE1MXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwcm9taXNlXG4gICAgICovXG4gICAgX19jYWxsWE1MIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWxsKG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgeG1sRG9jO1xuXG4gICAgICAgICAgICAgICAgLy8gdGVzdCBvbiBlbnYuIG5vZGVqcyBvciBicm93c2VyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIERPTVBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApLkRPTVBhcnNlcjsgLy8gX194bWxkb20uRE9NUGFyc2VyXG4gICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcocmVzcG9uc2UsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZXNwb25zZSwgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbERvYyA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxEb2MuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbERvYy5sb2FkWE1MKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiX19jYWxsWE1MIGZhaWxlZCBvbiA6IFwiLCBvcHRpb25zLnVybCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBhcyBkJ2V4Y2VwdGlvbiwgbGFpc3NvbnMgbGUgZmlsIHNlIGRlcm91bGVyLi4uXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoWEhSKTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yMF9fO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWx0aVJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcGFyYW0uIGRlcyByZXF1w6p0ZXMgZGUgdHlwZSBQT0lOVCBkdSBzZXJ2aWNlIGFsdGltZXRyaXF1ZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLlJlcXVlc3QuQWx0aUVsZXZhdGlvblJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy56b25seSAtIGZhbHNlfHRydWVcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBbHRpRWxldmF0aW9uUmVxdWVzdCAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbHRpRWxldmF0aW9uUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsdGlFbGV2YXRpb25SZXF1ZXN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkFsdGlFbGV2YXRpb25SZXF1ZXN0XCI7XG5cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgcGFyIGhlcml0YWdlXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19BbHRpUmVxdWVzdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEFsdGlFbGV2YXRpb25SZXF1ZXN0ICgpXVwiKTtcblxuICAgIC8qKlxuICAgICAqIFogdW5pcXVlbWVudC5cbiAgICAgKiB0cnVlfGZhbHNlXG4gICAgICovXG4gICAgdGhpcy56b25seSA9IHRoaXMub3B0aW9ucy56b25seSB8fCBmYWxzZTsgLy8gdGVzdCBkZXMgb3B0aW9ucyBow6lyaXTDqWVzICFcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkFsdGlFbGV2YXRpb25SZXF1ZXN0I1xuICovXG5cbkFsdGlFbGV2YXRpb25SZXF1ZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19BbHRpUmVxdWVzdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogU2V0dGVyL2dldHRlciBwb3VyIFwiem9ubHlcIlxuICAgICAqL1xuICAgIHpvbmx5IDoge1xuICAgICAgICAvKiogZ2V0dGVyICovXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25seTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIHNldHRlciAqL1xuICAgICAgICBzZXQgOiBmdW5jdGlvbiAoeikge1xuICAgICAgICAgICAgdGhpcy5fem9ubHkgPSB6O1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICovXG5BbHRpRWxldmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbHRpRWxldmF0aW9uUmVxdWVzdDtcblxuLyoqXG4gKiBUYWJsZWF1IGRlIGNsZWZzL3ZhbGV1cnMgcG91ciBwYXJhbS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbkFsdGlFbGV2YXRpb25SZXF1ZXN0LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHBhciBnbG9wLi4uLCBhcHBlbCBkZSBBbHRpUmVxdWVzdDo6Z2V0RGF0YSAoKSAhXG4gICAgdmFyIG1hcCA9IFtdO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwibG9uXCIsXG4gICAgICAgIHYgOiB0aGlzLmdldExvbigpXG4gICAgfSk7XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJsYXRcIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TGF0KClcbiAgICB9KTtcbiAgICAvLyBtYXAucHVzaCh7ayA6IFwiZGVsaW1pdGVyXCIsIHYgOiB0aGlzLmRlbGltaXRlcn0pOyAvLyBGSVhNRSBvbiByZXRpcmUgbGUgcGFyYW0gXCJkZWxpbWl0ZXJcIlxuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiaW5kZW50XCIsXG4gICAgICAgIHYgOiB0aGlzLmluZGVudFxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiY3JzXCIsXG4gICAgICAgIHYgOiB0aGlzLmNyc1xuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiem9ubHlcIixcbiAgICAgICAgdiA6IHRoaXMuem9ubHlcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImZvcm1hdFwiLFxuICAgICAgICB2IDogdGhpcy5mb3JtYXRcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFsdGlFbGV2YXRpb25SZXF1ZXN0KTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcGFyYW0uIGRlcyByZXF1w6p0ZXMgZHUgc2VydmljZSBhbHRpbWV0cmlxdWUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aS5SZXF1ZXN0LkFsdGlSZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMucG9zaXRpb25zIC0gdGFibGVhdSBkZSBjb29yZG9ubsOpZXMgbG9uL2xhdFxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5kZWxpbWl0ZXIgLSBcInxcIlxuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy5pbmRlbnQgLSBmYWxzZXx0cnVlXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLmNycyAtIFwiQ1JTOjg0XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuZm9ybWF0IC0gXCJKU09OfFhNTFwiXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQWx0aVJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWx0aVJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBbHRpUmVxdWVzdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgQWx0aVJlcXVlc3QgKCldXCIpO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBlbiBwYXJhbcOqdHJlcyBkdSBjb25zdHJ1Y3RldXIuXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBjb29yZG9ubsOpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgYyA9IFt7bG9uIDogXCJcIiwgbGF0IDogXCJcIn0sIHtsb24gOiBcIlwiLCBsYXQgOiBcIlwifV07XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25zIHx8IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKiBQYXIgZGVmYXV0LCBcInxcIi5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGltaXRlciA9IHRoaXMub3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCJ8XCI7XG5cbiAgICAvKipcbiAgICAgKiBJbmRlbnRhdGlvbi5cbiAgICAgKiB0cnVlfGZhbHNlXG4gICAgICovXG4gICAgdGhpcy5pbmRlbnQgPSB0aGlzLm9wdGlvbnMuaW5kZW50IHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUHJvamVjdGlvbi5cbiAgICAgKiBQYXIgZGVmYXV0LCBDUlM6ODQuXG4gICAgICovXG4gICAgdGhpcy5jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IFwiQ1JTOjg0XCI7XG5cbiAgICAvKipcbiAgICAgKiBmb3JtYXQgZGUgc29ydGllLlxuICAgICAqIFBhciBkZWZhdXQsIFwianNvblwiLlxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdCB8fCBcImpzb25cIjtcbn1cblxuLyoqXG4gKiBDTEFTU05BTUVcbiAqL1xuQWx0aVJlcXVlc3QuQ0xBU1NOQU1FID0gXCJBbHRpUmVxdWVzdFwiO1xuXG5BbHRpUmVxdWVzdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAbGVuZHMgbW9kdWxlOkFsdGlSZXF1ZXN0I1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IEFsdGlSZXF1ZXN0LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZFwidW5lIGxpc3RlIGRlIGNvb3Jkb25uw6llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGxzdFBvc2l0aW9uIC0gbGlzdGUgZGUgcG9zaXRpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvYmouc2V0UG9zaXRpb25zIChbe2xvbiA6IFwiMC4xNVwiLCBsYXQgOiBcIjAuMTVcIn0sIHtsb24gOiBcIjEuMTVcIiwgbGF0IDogXCIxLjE1XCJ9XSk7XG4gICAgICovXG4gICAgc2V0UG9zaXRpb25zIDogZnVuY3Rpb24gKGxzdFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RQb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBsc3RQb3NpdGlvbltpXTtcbiAgICAgICAgICAgIGlmIChvLmxvbiAmJiBvLmxhdCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBjb29yZG9ubsOpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ludH0gcG9zIC0gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7cG9zaXRpb25zfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogb2JqLmdldFBvc2l0aW9ucyAoKTsgIC8vIFt7bG9uIDogXCJcIiwgbGF0IDogXCJcIn0sIHtsb24gOiBcIlwiLCBsYXQgOiBcIlwifV1cbiAgICAgKiBvYmouZ2V0UG9zaXRpb25zICgwKTsgLy8gW3tsb24gOiBcIlwiLCBsYXQgOiBcIlwifV1cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbnMgOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIC8vIEZJWE1FIHRlc3QgaWYgbm90IGEgbnVtYmVyICE/XG4gICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBvc2l0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAocG9zID4gaW5kZXggfHwgcG9zIDwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJpbmRleCBvdXQgb2YgcmFuZ2UgIVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1twb3NdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkXCJ1bmUgbGlzdGUgZGUgY29vcmRvbm7DqWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gbHN0UG9zaXRpb24gLSBsaXN0ZSBkZSBwb3NpdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG9iai5hZGRQb3NpdGlvbnMgKFt7bG9uIDogXCIwLjE1XCIsIGxhdCA6IFwiMC4xNVwifSwge2xvbiA6IFwiMS4xNVwiLCBsYXQgOiBcIjEuMTVcIn1dKTtcbiAgICAgKi9cbiAgICBhZGRQb3NpdGlvbnMgOiBmdW5jdGlvbiAobHN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RQb3NpdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBsc3RQb3NpdGlvbltpXTtcbiAgICAgICAgICAgIGlmIChvLmxvbiAmJiBvLmxhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25zLnB1c2gobHN0UG9zaXRpb25baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBsb25naXR1ZGVzIGF2ZWMgdW4gY2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5lIGxpc3RlIGRlIGxvbmdpdHVkZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG91dCA6IDAuMjM2N3wyLjE1NzB8NDMuNzg5fC4uLlxuICAgICAqL1xuICAgIGdldExvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxzdExvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsc3RMb24ucHVzaCh0aGlzLnBvc2l0aW9uc1tpXS5sb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGxzdExvbik7XG4gICAgICAgIHJldHVybiBsc3RMb24uam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBsYXR0aXR1ZGVzIGF2ZWMgdW4gY2FyYWN0w6hyZSBkZSBzw6lwYXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5lIGxpc3RlIGRlIGxhdHRpdHVkZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG91dCA6IDAuMjM2N3wyLjE1NzB8NDMuNzg5fC4uLlxuICAgICAqL1xuICAgIGdldExhdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxzdExhdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsc3RMYXQucHVzaCh0aGlzLnBvc2l0aW9uc1tpXS5sYXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKGxzdExhdCk7XG4gICAgICAgIHJldHVybiBsc3RMYXQuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFRhYmxlYXUgZGUgY2xlZnMvdmFsZXVycyBwb3VyIHBhcmFtLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAqL1xuQWx0aVJlcXVlc3QucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJsb25cIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TG9uKClcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImxhdFwiLFxuICAgICAgICB2IDogdGhpcy5nZXRMYXQoKVxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZGVsaW1pdGVyXCIsXG4gICAgICAgIHYgOiB0aGlzLmRlbGltaXRlclxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiaW5kZW50XCIsXG4gICAgICAgIHYgOiB0aGlzLmluZGVudFxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiY3JzXCIsXG4gICAgICAgIHYgOiB0aGlzLmNyc1xuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZm9ybWF0XCIsXG4gICAgICAgIHYgOiB0aGlzLmZvcm1hdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQWx0aVJlcXVlc3QpO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19BbHRpUmVxdWVzdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHBhcmFtLiBkZXMgcmVxdcOqdGVzIGRlIHR5cGUgUFJPRklMIGR1IHNlcnZpY2UgYWx0aW1ldHJpcXVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUHJvZmlsUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuc2FtcGxpbmcgLSAzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQWx0aVByb2ZpbFJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWx0aVByb2ZpbFJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBbHRpUHJvZmlsUmVxdWVzdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vbSBkZSBsYSBjbGFzc2UgKGhlcml0YWdlKVxuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJBbHRpUHJvZmlsUmVxdWVzdFwiO1xuXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIHBhciBoZXJpdGFnZVxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWx0aVJlcXVlc3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBBbHRpUHJvZmlsUmVxdWVzdCAoKV1cIik7XG5cbiAgICAvKipcbiAgICAgKiBTYW1wbGluZ1xuICAgICAqIFBhciBkZWZhdXQsIDNcbiAgICAgKi9cbiAgICB0aGlzLnNhbXBsaW5nID0gdGhpcy5vcHRpb25zLnNhbXBsaW5nIHx8IDM7IC8vIHRlc3QgZGVzIG9wdGlvbnMgaMOpcml0w6llcyAhXG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpBbHRpUHJvZmlsUmVxdWVzdCNcbiAqL1xuXG5BbHRpUHJvZmlsUmVxdWVzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWx0aVJlcXVlc3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIFNldHRlci9nZXR0ZXIgcG91ciBcInNhbXBsaW5nXCJcbiAgICAgKi9cbiAgICBzYW1wbGluZyA6IHtcbiAgICAgICAgLyoqIGdldHRlciAqL1xuICAgICAgICBnZXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2FtcGxpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBzZXR0ZXIgKi9cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zYW1wbGluZyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAqL1xuQWx0aVByb2ZpbFJlcXVlc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWx0aVByb2ZpbFJlcXVlc3Q7XG5cbi8qKlxuICogVGFibGVhdSBkZSBjbGVmcy92YWxldXJzIHBvdXIgcGFyYW0uXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5BbHRpUHJvZmlsUmVxdWVzdC5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwYXIgZ2xvcC4uLiwgYXBwZWwgZGUgQWx0aVJlcXVlc3Q6OmdldERhdGEgKCkgIVxuICAgIHZhciBtYXAgPSBbXTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImxvblwiLFxuICAgICAgICB2IDogdGhpcy5nZXRMb24oKVxuICAgIH0pO1xuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwibGF0XCIsXG4gICAgICAgIHYgOiB0aGlzLmdldExhdCgpXG4gICAgfSk7XG4gICAgLy8gbWFwLnB1c2goe2sgOiBcImRlbGltaXRlclwiLCB2IDogdGhpcy5kZWxpbWl0ZXJ9KTsgLy8gRklYTUUgb24gcmV0aXJlIGxlIHBhcmFtIFwiZGVsaW1pdGVyXCJcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImluZGVudFwiLFxuICAgICAgICB2IDogdGhpcy5pbmRlbnRcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImNyc1wiLFxuICAgICAgICB2IDogdGhpcy5jcnNcbiAgICB9KTtcbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcInNhbXBsaW5nXCIsXG4gICAgICAgIHYgOiB0aGlzLnNhbXBsaW5nXG4gICAgfSk7XG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJmb3JtYXRcIixcbiAgICAgICAgdiA6IHRoaXMuZm9ybWF0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFwO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBbHRpUHJvZmlsUmVxdWVzdCk7XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZXNwb25zZSBvYmplY3QgZm9yIHtAbGluayBtb2R1bGU6U2VydmljZXN+Z2V0Q29uZmlnIEdwLlNlcnZpY2VzLmdldENvbmZpZyAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IGdlbmVyYWxPcHRpb25zIC0gR2VuZXJhbCBwcm9wZXJ0aWVzIGZvciBkZWZhdWx0IG1hcCBjb25maWd1cmF0aW9uIHJlc291cmNlcy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBnZW5lcmFsT3B0aW9ucy5hcGlLZXlzIC0gT2JqZWN0IHRoYXQgYXNzb2NpYXRlcyBhcGlLZXkgKHMpIHdpdGggYW4gYXJyYXkgb2YgcmVzb3VyY2VzIElEcyBhdmFpbGFibGVzIHdpdGggdGhhdCBrZXkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZ2VuZXJhbE9wdGlvbnMudGl0bGUgLSBVbmRlcmx5aW5nIHdlYiBzZXJ2aWNlIFRpdGxlLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGdlbmVyYWxPcHRpb25zLmRlZmF1bHRHTUxHRklTdHlsZSAtIFhTTCBVUkwgdXNlZCBieSBkZWZhdWx0IHRvIHRyYW5zbGF0ZSBhbiBYTUwgR2V0RmVhdHVyZUluZm8gcmVzcG9uc2UgaW50byBhbiBIVE1MIGFycmF5LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGdlbmVyYWxPcHRpb25zLnRoZW1lIC0gZGVmYXVsdCB0aGVtZSAoRklYTUUgOiBmb3Igd2hhdCA/KVxuICogQHByb3BlcnR5IHtBcnJheS48RmxvYXQ+fSBnZW5lcmFsT3B0aW9ucy53Z3M4NFJlc29sdXRpb25zIC0gZ2VvZ3JhcGhpY2FsIHJlc29sdXRpb25zIEFycmF5IGZvciBlYWNoIFt6b29tIGxldmVsIG9mIHRoZSBHZW9wb3J0YWwgcGxhdGZvcm1de0BsaW5rIGh0dHA6Ly9hcGkuaWduLmZyL3RlY2gtZG9jcy1qcy93ZWJtYXN0ZXIvbGF5ZXJzLmh0bWwjR2VvcG9ydGFsX3Jlc29sdXRpb25zfSBmcm9tIDAgdG8gMjEuIEV4cHJlc3NlZCBpbiBkZWdyZWVzL3BpeGVsLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGxheWVycyAtIEFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgcmVzb3VyY2VzIGF2YWlsYWJsZXMgSURzIChrZXlzKSB3aXRoIHRoZWlyIHByb3BlcnRpZXMgKHZhbHVlcyBnaXZlbiBhcyB7QGxpbmsgR3AuU2VydmljZXMuQ29uZmlnLkxheWVyfSkuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdGVycml0b3JpZXMgLSBBc3NvY2lhdGl2ZSBhcnJheSBtYXBwaW5nIGZyZW5jaCB0ZXJyaXRvcmllcyBJRHMgKGtleXMpIHdpdGggdGhlaXIgcHJvcGVydGllcyAodmFsdWVzIGdpdmVuIGFzIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuVGVycml0b3J5fSkuXG4gKiBAcHJvcGVydHkge09iamVjdH0gdGlsZU1hdHJpeFNldHMgLSBBc3NvY2lhdGl2ZSBBcnJheSBtYXBwaW5nIFRpbGVNYXRyaXhTZXRzIElEcyAoa2V5cykgYXZhaWxhYmxlcyB3aXRoIHRoZWlyIHByb3BlcnRpZXMgKHZhbHVlcyBnaXZlbiBhcyB7QGxpbmsgR3AuU2VydmljZXMuQ29uZmlnLlRpbGVNYXRyaXhTZXR9KS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZXJ2aWNlcyAtIEFzc29jaWF0aXZlIEFycmF5IG1hcHBpbmcgR2VvcG9ydGFsIHdlYiBzZXJ2aWNlcyBJRHMgKGtleXMpIGF2YWlsYWJsZXMgd2l0aCB0aGVpciBwcm9wZXJ0aWVzICh2YWx1ZXMgZ2l2ZW4gYXMge0BsaW5rIEdwLlNlcnZpY2VzLkNvbmZpZy5TZXJ2aWNlfSkuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdldENvbmZpZ1Jlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIEF1dG9Db25mUmVzcG9uc2UgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBdXRvQ29uZlJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXV0b0NvbmZSZXNwb25zZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZ2VuZXJhbE9wdGlvbnMgPSB7XG4gICAgICAgIGFwaUtleXMgOiB7fSxcbiAgICAgICAgdGl0bGUgOiBudWxsLFxuICAgICAgICBkZWZhdWx0R01MR0ZJU3R5bGUgOiBudWxsLFxuICAgICAgICB0aGVtZSA6IG51bGwsXG4gICAgICAgIHdnczg0UmVzb2x1dGlvbnMgOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLmxheWVycyA9IHt9O1xuXG4gICAgdGhpcy50ZXJyaXRvcmllcyA9IHt9O1xuXG4gICAgdGhpcy50aWxlTWF0cml4U2V0cyA9IHt9O1xuXG4gICAgdGhpcy5zZXJ2aWNlcyA9IHt9O1xufVxuXG5BdXRvQ29uZlJlc3BvbnNlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qXG4gICAgICogQ29uc3RydWN0b3IgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogQXV0b0NvbmZSZXNwb25zZSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNvbmZpZyBpcyBsb2FkZWQgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm1cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNDb25mTG9hZGVkIC0gdHJ1ZSBpZiBjb25maWcgaXMgYWxyZWFkeSBsb2FkZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQ29uZkxvYWRlZCA6IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZW5lcmFsT3B0aW9ucy5hcGlLZXlzW2FwaUtleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBHZW9wb3J0YWwgbGF5ZXJzIGlkZW50aWZpZXJzLCBjb3JyZXNwb25kaW5nIHRvIGFuIEFQSSBjb250cmFjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGFwaUtleXMgLSBBcnJheSBvZiBnZW9wb3J0YWwgbGF5ZXJzIGlkZW50aWZpZXJzXG4gICAgICovXG4gICAgZ2V0TGF5ZXJzSWQgOiBmdW5jdGlvbiAoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYWxPcHRpb25zLmFwaUtleXNbYXBpS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBHZW9wb3J0YWwgbGF5ZXJzIGNvbmZpZ3VyYXRpb25zLCBjb3JyZXNwb25kaW5nIHRvIGFuIEFQSSBjb250cmFjdCBrZXkuXG4gICAgICogSWYgbm8ga2V5IGlzIHNwZWNpZmllZCwgYWxsIGxheWVycyBmcm9tIGNvbmZpZ3VyYXRpb24gYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFwaUtleSAtIEFjY2VzcyBrZXkgdG8gR2VvcG9ydGFsIHBsYXRmb3JtXG4gICAgICogQHJldHVybnMge09iamVjdH0gbGF5ZXJzIC0gT2JqZWN0IHdoaWNoIHByb3BlcnRpZXMgYXJlIGxheWVycyBpZGVudGlmaWVycywgYW5kIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIDxHcC5TZXJ2aWNlcy5Db25maWcuTGF5ZXI+LlxuICAgICAqL1xuICAgIGdldExheWVyc0NvbmYgOiBmdW5jdGlvbiAoYXBpS2V5KSB7XG4gICAgICAgIHZhciBsYXllcnMgPSB7fTtcbiAgICAgICAgdmFyIGxheWVyc0lkQXJyYXkgPSB0aGlzLmdldExheWVyc0lkKGFwaUtleSk7XG4gICAgICAgIGlmIChsYXllcnNJZEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyc0lkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbHlySWQgPSBsYXllcnNJZEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyc1tseXJJZF0gPSB0aGlzLmxheWVyc1tseXJJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGdlb3BvcnRhbCBsYXllciBjb25maWd1cmF0aW9uLCBnaXZlbiBpdHMgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBHZW9wb3J0YWwgbGF5ZXIgaWRlbnRpZmllciAoZS5nLiBcIkdFT0dSQVBISUNBTEdSSURTWVNURU1TLk1BUFMkR0VPUE9SVEFJTDpPR0M6V01UU1wiKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gbGF5ZXIgLSBMYXllciBjb25maWd1cmF0aW9uIDogaW5zdGFuY2Ugb2Yge0BsaW5rIEdwLlNlcnZpY2VzLkNvbmZpZy5MYXllcn1cbiAgICAgKi9cbiAgICBnZXRMYXllckNvbmYgOiBmdW5jdGlvbiAobGF5ZXJJZCkge1xuICAgICAgICBpZiAoIXRoaXMubGF5ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzW2xheWVySWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIFRpbGUgTWF0cml4IFNldHMgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRpbGVNYXRyaXhTZXRzIC0gT2JqZWN0IHdoaWNoIHByb3BlcnRpZXMgYXJlIFRNUyBpZGVudGlmaWVycyxcbiAgICAgKiAgICAgIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuVGlsZU1hdHJpeFNldH0uXG4gICAgICovXG4gICAgZ2V0VGlsZU1hdHJpeFNldHMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVNYXRyaXhTZXRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgVGlsZSBNYXRyaXggU2V0cyBjb25maWd1cmF0aW9uLCBnaXZlbiBpdHMgaWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0bXNJRCAtIFRpbGUgTWF0cml4IFNldCBpZGVudGlmaWVyIChlLmcuIDogXCJQTVwiKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGlsZU1hdHJpeFNldCAtIFRpbGUgTWF0cml4IFNldCBjb25maWd1cmF0aW9uLCBpbnN0YW5jZSBvZiB7QGxpbmsgR3AuU2VydmljZXMuQ29uZmlnLlRpbGVNYXRyaXhTZXR9XG4gICAgICovXG4gICAgZ2V0VE1TQ29uZiA6IGZ1bmN0aW9uICh0bXNJRCkge1xuICAgICAgICBpZiAoIXRoaXMudGlsZU1hdHJpeFNldHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aWxlTWF0cml4U2V0c1t0bXNJRF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgdGVycml0b3JpZXMgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRlcnJpdG9yaWVzIC0gT2JqZWN0IHdoaWNoIHByb3BlcnRpZXMgYXJlIHRlcnJpdG9yeSBpZGVudGlmaWVycyxcbiAgICAgKiAgICAgIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuVGVycml0b3J5fS5cbiAgICAgKi9cbiAgICBnZXRUZXJyaXRvcmllcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVycml0b3JpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0ZXJyaXRvcnkgY29uZmlndXJhdGlvbiwgZ2l2ZW4gaXRzIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGVycml0b3J5SUQgLSB0ZXJyaXRvcnkgaWRlbnRpZmllciAoZS5nLiBcIkZYWFwiKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGVycml0b3J5IC0gVGVycml0b3J5IGNvbmZpZ3VyYXRpb24sIGluc3RhbmNlIG9mIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuVGVycml0b3J5fVxuICAgICAqL1xuICAgIGdldFRlcnJpdG9yeUNvbmYgOiBmdW5jdGlvbiAodGVycml0b3J5SUQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRlcnJpdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGVycml0b3JpZXNbdGVycml0b3J5SURdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHNlcnZpY2VzIGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzZXJ2aWNlcyAtIE9iamVjdCB3aGljaCBwcm9wZXJ0aWVzIGFyZSBzZXJ2aWNlcyBpZGVudGlmaWVycyxcbiAgICAgKiAgICAgIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuU2VydmljZX0uXG4gICAgICovXG4gICAgZ2V0U2VydmljZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2VydmljZSBjb25maWd1cmF0aW9uLCBnaXZlbiBpdHMgaWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlSUQgLSBzZXJ2aWNlIGlkZW50aWZpZXIgKGUuZy4gXCJPR0M6V01UU1wiKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc2VydmljZSAtIHNlcnZpY2UgY29uZmlndXJhdGlvbiwgaW5zdGFuY2Ugb2Yge0BsaW5rIEdwLlNlcnZpY2VzLkNvbmZpZy5TZXJ2aWNlfVxuICAgICAqL1xuICAgIGdldFNlcnZpY2VDb25mIDogZnVuY3Rpb24gKHNlcnZpY2VJRCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VydmljZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlc1tzZXJ2aWNlSURdO1xuICAgIH1cblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBdXRvQ29uZlJlc3BvbnNlKTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBPYmplY3QgdXNlZCB0byBleHByZXNzIGEgZ2VvZ3JhcGhpY2FsIChCQk9YLCBzY2FsZSkgYW5kIHRlbXBvcmFsIGNvbnN0cmFpbnQuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNycyAtIENvb3JkaW5hdGVzIFN5c3RlbSBJRCB1c2VkIHRvIGV4cHJlc3MgY29vcmRpbmF0ZXMgY29udHJhaW50cy5cbiAqIEBwcm9wZXJ0eSB7R3AuQkJveH0gYmJveCAtIENvbnN0cmFpbnQgQm91bmRpbmcgQm94LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pblNjYWxlRGVub21pbmF0b3IgLSBNaW5pbXVtIHNjYWxlIGRlbm9taW5hdG9yIHdoZXJlIGNvbnN0cmFpbnQgYXBwbGllcy5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhTY2FsZURlbm9taW5hdG9yIC0gTWF4aW11bSBzY2FsZSBkZW5vbWluYXRvciB3aGVyZSBjb25zdHJhaW50IGFwcGxpZXMuXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSB0ZW1wb3JhbEV4dGVudCAtIEFycmF5IGV4cHJlc3NpbmcgdGhlIHRpbWUgaW50ZXJ2YWwgb2YgdGhlIGNvbnN0cmFpbnQgW21pblQsIG1heFRdLiBEYXRlcyBhcmUgZXhwcmVzc2VkIGluIHRoZSBbSVNPLTg2MDFde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxfSB3YXkuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkNvbmZpZy5Db25zdHJhaW50XG4gKi9cblxuZnVuY3Rpb24gQ29uc3RyYWludCAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJhaW50IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5jcnMgPSBudWxsO1xuXG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgICBsZWZ0IDogbnVsbCxcbiAgICAgICAgcmlnaHQgOiBudWxsLFxuICAgICAgICB0b3AgOiBudWxsLFxuICAgICAgICBib3R0b20gOiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMubWluU2NhbGVEZW5vbWluYXRvciA9IG51bGw7XG5cbiAgICB0aGlzLm1heFNjYWxlRGVub21pbmF0b3IgPSBudWxsO1xuXG4gICAgdGhpcy50ZW1wb3JhbEV4dGVudCA9IFtudWxsLCBudWxsXTtcbn1cblxuQ29uc3RyYWludC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IENvbnN0cmFpbnRcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25zdHJhaW50KTtcblxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGEgZm9ybWF0IHRvIHVzZSB3aXRoIEdlb3BvcnRhbCByZXNvdXJjZXMuXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBjdXJyZW50IC0gSWYgdHJ1ZSwgdGhlbiB0aGlzIGZvcm1hdCBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSAtIEZvcm1hdCBtaW1lLXR5cGUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkNvbmZpZy5Gb3JtYXRcbiAqL1xuXG5mdW5jdGlvbiBGb3JtYXQgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGb3JtYXQgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuRm9ybWF0LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogRm9ybWF0XG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRm9ybWF0KTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGdlb3BvcnRhbCByZXNvdXJjZSAoV01UUywgV01TLCBXRlMgbGF5ZXJzLCBnZW9jb2RpbmcgcmVzb3VyY2VzIG9yIGVsZXZhdGlvbiBzZXJ2aWNlKSBwYXJhbWV0ZXJzLiBQcm9wZXJ0aWVzIG1heSBiZSB1c2VkIG9yIG5vdCBkZXBlbmRpbmcgb24gdGhlIHJlc291cmNlIHR5cGUuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSByZXNvdXJjZSB0byB1c2Ugd2l0aCB0aGUgd2Vic2VydmljZSB0aGF0IHNlcnZlcyBpdCAoZWcgOiBcIkdFT0dSQVBISUNBTEdSSURTWVNURU1TLk1BUFNcIikuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdGl0bGUgLSBIdW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgcmVzb3VyY2UuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVzY3JpcHRpb24gLSBSZXNvdXJjZSBkZXNjcmlwdGlvbi5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYXllcklkIC0gVW5pcXVlIHJlc291cmNlIElkZW50aWZpZXIgKGVnIDogXCJHRU9HUkFQSElDQUxHUklEU1lTVEVNUy5NQVBTJEdFT1BPUlRBSUw6T0dDOldNVFNcIilcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBxdWlja2xvb2tVcmwgLSBJbWFnZSBVUkwgZm9yIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZXJ2aWNlUGFyYW1zIC0gSW5mb3JtYXRpb25zIGFib3V0IHRoZSB3ZWJzZXJ2aWNlIHRoYXQgc2VydmVzIHRoZSByZXNvdXJjZSAoT3BlbkxTLCBXRlMsIFdNVFMpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc2VydmljZVBhcmFtcy5pZCAtIFdlYiBTZXJ2aWNlIGlkZW50aWZpZXIgKFwiT0dDOldNVFNcIiwgXCJPR0M6T1BFTkxTO1JldmVyc2VHZW9jb2RlXCIsIGV0Yy4uLilcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzZXJ2aWNlUGFyYW1zLnNlcnZlclVybCAtIEFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgKGtleXMpIHdpdGggdGhlaXIgcHJvcGVydGllcyAoVVJMcyBvZiB0aGUgd2ViIHNlcnZpY2UsIHdpdGggdGhlIGdlb3BvcnRhbCBhY2Nlc3Mga2V5KS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzZXJ2aWNlUGFyYW1zLnZlcnNpb24gLSB3ZWJzZXJ2aWNlIHZlcnNpb24uXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdFByb2plY3Rpb24gLSBjb29yZGluYXRlcyBzeXN0ZW0gSUQgdXNlZCBieSBkZWZhdWx0IGZvciB0aGUgcmVzb3VyY2UgKFdNUyBvciBXRlMgbGF5ZXIpIG9yIG9mIHRoZSBUaWxlTWF0cml4U2V0IHVzZWQgYnkgdGhlIFdNVFMgbGF5ZXIuXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBhZGRpdGlvbmFsUHJvamVjdGlvbnMgLSBhZGRpdGlvbmFsIGNvb3JkaW5hdGVzIHN5c3RlbXMgSURzIGF2YWlsYWJsZXMgZm9yIHRoZSByZXNvdXJjZSwgb3RoZXJzIHRoYW4gdGhlIGRlZmF1bHQgb25lIChzZWUgZGVmYXVsdFByb2plY3Rpb24pIChXTVMgYW5kIFdGUyBsYXllcnMgb25seSkuXG4gKiBAcHJvcGVydHkge0FycmF5LjxHcC5TZXJ2aWNlcy5Db25maWcuRm9ybWF0Pn0gZm9ybWF0cyAtIEZvcm1hdHMgYXZhaWxhYmxlcyBmb3IgdGhlIHJlc291cmNlLlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuQ29uZmlnLkxlZ2VuZD59IGxlZ2VuZHMgLSBJbmZvcm1hdGlvbnMgYWJvdXQgbGVnZW5kcyBhc3NvY2lhdGVkIHRvIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5NZXRhZGF0YT59IG1ldGFkYXRhIC0gSW5mb3JtYXRpb25zIGFib3V0IG1ldGFkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIHJlc291cmNlLlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuQ29uZmlnLlN0eWxlPn0gc3R5bGVzIC0gSW5mb3JtYXRpb25zIGFib3V0IHN0eWxlcyBhdmFpbGFibGVzIGZvciB0aGUgcmVzb3VyY2VzIChXTVMsIFdGUyBhbmQgV01UUyBvbmx5KS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5UaGVtYXRpYz59IHRoZW1hdGljcyAtIEluZm9ybWF0aW9ucyBhYm91dCB0aGVtYXRpY3MgYXNzb2NpYXRlZCB0byB0aGUgcmVzb3VyY2UuXG4gKiBAcHJvcGVydHkge0dwLlNlcnZpY2VzLkNvbmZpZy5Db25zdHJhaW50fSBnbG9iYWxDb25zdHJhaW50IC0gZ2VvZ3JhcGhpY2FsIGNvbnN0cmFpbnQgZm9yIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5Db25zdHJhaW50Pn0gY29uc3RyYWludHMgLSBhZGRpdGlvbm5hbCBnZW9ncmFwaGljYWwgY29uc3RyYWludHMgZm9yIHRoZSByZXNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5PcmlnaW5hdG9yPn0gb3JpZ2luYXRvcnMgLSBJbmZvcm1hdGlvbnMgYWJvdXQgb3JpZ2luYXRvciBvZiB0aGUgcmVzb3VyY2UuXG4gKiBAcHJvcGVydHkge09iamVjdH0gd210c09wdGlvbnMgLSBJbmZvcm1hdGlvbnMgYXNzb2NpYXRlZCB0byBXTVRTIHJlc291cmNlcy5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB3bXRzT3B0aW9ucy50aWxlTWF0cml4U2V0TGluayAtIFRpbGVNYXRyaXhTZXQgaWRlbnRpZmllciB1c2VkIGJ5IHRoZSByZXNvdXJjZSAoc2VlIHtAbGluayBHcC5TZXJ2aWNlcy5Db25maWcuVGlsZU1hdHJpeFNldH0pXG4gKiBAcHJvcGVydHkge0dwLlNlcnZpY2VzLkNvbmZpZy5UaWxlTWF0cml4TGltaXR9IHdtdHNPcHRpb25zLnRpbGVNYXRyaXhTZXRMaW1pdHMgLSBsaW1pdHMgb2YgdGhlIHJlc291cmNlIGZvciB0aGF0IFRpbGVNQXRyaXhTZXQuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHF1ZXJ5YWJsZSAtIHRydWUgaWYgYSBnZXRGZWF0dXJlSW5mbyByZXF1ZXN0IG1heSBiZSBkb25lIGZvciB0aGUgcmVzb3VyY2UgKFdNUyBvciBXTVRTIG9ubHkpLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBoaWRkZW4gLSB0cnVlIGlmIHRoZSByZXNvdXJjZSBpcyBub3QgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNBZ2dyZWdhdGUgLSB0cnVlIGlmIHRoZSByZXNvdXJjZSBpcyBhbiBhZ2dyZWdhdGUgb2Ygb3RoZXIgcmVzb3VyY2VzIChAc2VlIGFnZ3JlZ2F0ZWRMYXllcnMpLlxuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gYWdncmVnYXRlZExheWVycyAtIExheWVycyBJRHMgY29tcG9zaW5nIHRoZSBiZWluZyBkZXNjcmliZWQgYWdncmVnYXRlZCBsYXllci5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPFN0cmluZz59IGFwaUtleXMgLSBBcnJheSBvZiBhY2Nlc3Mga2V5cyB0aGF0IGdyYW50IGFjY2VzcyB0byB0aGF0IHJlc291cmNlLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGRpbWVuc2lvbnMgLSBEaW1lbnNpb25zIGluZm9ybWF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc291cmNlLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRpbWVuc2lvbnMudHlwZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRpbWVuc2lvbnMudmlzaWJpbGl0eVJhbmdlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGltZW5zaW9ucy52aXNpYmlsaXR5TW9kZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRpbWVuc2lvbnMubm9EYXRhVmFsdWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkaW1lbnNpb25zLmdlb21ldHJpY1R5cGVcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29uZmlnLkxheWVyXG4gKi9cbmZ1bmN0aW9uIExheWVyICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMYXllciBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIGluZm8gOiB1bmUgaW5zdGFuY2UgZGUgbGEgY2xhc3NlIExheWVyIG4nYSBhdWN1bmUgcHJvcHJpw6l0w6kgYXUgZMOpcGFydCwuXG4gICAgLy8gbGVzIGF0dHJpYnV0cyBwb3NzaWJsZXMgc29udCBkb2N1bWVudMOpcyBjaS1kZXNzdXMsXG4gICAgLy8gZXQgc2Vyb250IGltcGzDqW1lbnTDqXMgYXUgZnVyIGV0IMOgIG1lc3VyZSBkZSBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIGRlIGwnYXV0b2NvbmYsIGxvcnNxdWUgbCdpbmZvcm1hdGlvbiBlc3QgcmVuY29udHLDqWUuXG59XG5cbkxheWVyLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogTGF5ZXIsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXllciBuYW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgcmVzb3VyY2UgdG8gdXNlIHdpdGggdGhlIHdlYnNlcnZpY2UgdGhhdCBzZXJ2ZXMgaXQgKGVnIDogXCJHRU9HUkFQSElDQUxHUklEU1lTVEVNUy5NQVBTXCIpLlxuICAgICAqL1xuICAgIGdldE5hbWUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxheWVyIHRpdGxlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aXRsZSAtIEh1bWFuIHJlYWRhYmxlIG5hbWUgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRUaXRsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxheWVyIGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBkZXNjcmlwdGlvbiAtIFJlc291cmNlIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIGdldERlc2NyaXB0aW9uIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF5ZXIgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbGF5ZXJJZCAtIFVuaXF1ZSByZXNvdXJjZSBJZGVudGlmaWVyIChlZyA6IFwiR0VPR1JBUEhJQ0FMR1JJRFNZU1RFTVMuTUFQUyRHRU9QT1JUQUlMOk9HQzpXTVRTXCIpXG4gICAgICovXG4gICAgZ2V0TGF5ZXJJZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJJZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF5ZXIgcXVpY2tsb29rVXJsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBxdWlja2xvb2tVcmwgLSBJbWFnZSBVUkwgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRRdWlja2xvb2tVcmwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1aWNrbG9va1VybDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF5ZXIgZGVmYXVsdCBwcm9qZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBkZWZhdWx0UHJvamVjdGlvbiAtIGNvb3JkaW5hdGVzIHN5c3RlbSBJRCB1c2VkIGJ5IGRlZmF1bHQgZm9yIHRoZSByZXNvdXJjZSAoV01TIG9yIFdGUyBsYXllcikgb3Igb2YgdGhlIFRpbGVNYXRyaXhTZXQgdXNlZCBieSB0aGUgV01UUyBsYXllci5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvamVjdGlvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFByb2plY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxheWVyIHByb2plY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IHByb2plY3Rpb25zIC0gY29vcmRpbmF0ZXMgc3lzdGVtcyBJRHMgYXZhaWxhYmxlcyBmb3IgdGhlIHJlc291cmNlLCBpbmNsdWRpbmcgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqL1xuICAgIGdldFByb2plY3Rpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvamVjdGlvbnMgPSBbXTtcbiAgICAgICAgcHJvamVjdGlvbnMucHVzaCh0aGlzLmRlZmF1bHRQcm9qZWN0aW9uKTtcbiAgICAgICAgdmFyIHByb2ogPSBwcm9qZWN0aW9ucy5jb25jYXQodGhpcy5hZGRpdGlvbmFsUHJvamVjdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJvajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2xvYmFsIEJCT1hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtHcC5CQm94fSBiYm94IC0gdGhlIGxheWVyIGdsb2JhbCBib3VuZGluZyBib3gsIGV4cHJlc3NlZCBpbiBDUlMgc3lzdGVtLlxuICAgICAqL1xuICAgIGdldEJCT1ggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbG9iYWxDb25zdHJhaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsQ29uc3RyYWludC5iYm94O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXllciBtaW5pbXVtIHNjYWxlIGRlbm9taW5hdG9yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBtaW5TY2FsZURlbm9taW5hdG9yIC0gbWluaW11bSBzY2FsZSBkZW5vbWluYXRvciBmb3IgdGhpcyBsYXllclxuICAgICAqL1xuICAgIGdldE1pblNjYWxlRGVub21pbmF0b3IgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbG9iYWxDb25zdHJhaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsQ29uc3RyYWludC5taW5TY2FsZURlbm9taW5hdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXllciBtYXhpbXVtIHNjYWxlIGRlbm9taW5hdG9yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBtYXhTY2FsZURlbm9taW5hdG9yIC0gbWF4aW11bSBzY2FsZSBkZW5vbWluYXRvciBmb3IgdGhpcyBsYXllclxuICAgICAqL1xuICAgIGdldE1heFNjYWxlRGVub21pbmF0b3IgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5nbG9iYWxDb25zdHJhaW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsQ29uc3RyYWludC5tYXhTY2FsZURlbm9taW5hdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxheWVyIFRpbGUgTWF0cml4IFNldCBpZGVudGlmaWVyIGlmIGV4aXN0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGlsZU1hdHJpeFNldExpbmsgLSBUaWxlIE1hdHJpeCBTZXQgaWRlbnRpZmllciAoZm9yIGluc3RhbmNlIDogXCJQTVwiKVxuICAgICAqL1xuICAgIGdldFRNU0lEIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53bXRzT3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud210c09wdGlvbnMudGlsZU1hdHJpeFNldExpbms7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd2Vic2VydmljZSB0aGF0IHNlcnZlcyB0aGUgcmVzb3VyY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHNlcnZpY2VQYXJhbXMgLSBJbmZvcm1hdGlvbiBhYm91dCB0aGUgd2Vic2VydmljZSB0aGF0IHNlcnZlcyB0aGUgcmVzb3VyY2UgKE9wZW5MUywgV0ZTLCBXTVRTKVxuICAgICAqL1xuICAgIGdldFNlcnZpY2VQYXJhbXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VQYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgR2VvcG9ydGFsIHNlcnZlciB1cmwgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm1cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBzZXJ2ZXJVcmwgLSBnZW5lcmFsIFVSTCBvZiB0aGUgd2ViIHNlcnZpY2UgKHdpdGggdGhlIGdlb3BvcnRhbCBhY2Nlc3Mga2V5KVxuICAgICAqL1xuICAgIGdldFNlcnZlclVybCA6IGZ1bmN0aW9uIChhcGlLZXkpIHtcbiAgICAgICAgaWYgKCFhcGlLZXkgfHwgIXRoaXMuc2VydmljZVBhcmFtcyB8fCAhdGhpcy5zZXJ2aWNlUGFyYW1zLnNlcnZlclVybCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VQYXJhbXMuc2VydmVyVXJsW2FwaUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgbGVnZW5kcyBhc3NvY2lhdGVkIHRvIHRoZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48R3AuU2VydmljZXMuQ29uZmlnLkxlZ2VuZD59IGxlZ2VuZHMgLSBJbmZvcm1hdGlvbnMgYWJvdXQgbGVnZW5kcyBhc3NvY2lhdGVkIHRvIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRMZWdlbmRzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWdlbmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IG1ldGFkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxHcC5TZXJ2aWNlcy5Db25maWcuTWV0YWRhdGE+fSBtZXRhZGF0YSAtIEluZm9ybWF0aW9ucyBhYm91dCBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXRNZXRhZGF0YSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgc3R5bGVzIGF2YWlsYWJsZXMgZm9yIHRoZSByZXNvdXJjZXMgKFdNUywgV0ZTIGFuZCBXTVRTIG9ubHkpLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxHcC5TZXJ2aWNlcy5Db25maWcuU3R5bGU+fSBzdHlsZXMgLSBJbmZvcm1hdGlvbnMgYWJvdXQgc3R5bGVzIGF2YWlsYWJsZXMgZm9yIHRoZSByZXNvdXJjZXMgKFdNUywgV0ZTIGFuZCBXTVRTIG9ubHkpLlxuICAgICAqL1xuICAgIGdldFN0eWxlcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxheWVyIGRlZmF1bHQgc3R5bGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHN0eWxlTmFtZSAtIHN0eWxlIGlkZW50aWZpZXIgKGVnIDogXCJub3JtYWxcIiwgXCJiZHBhcmNlbGxhaXJlXCIsIC4uLilcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0U3R5bGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3R5bGU7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdHlsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNbaV0uY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGVtYXRpY3MgYXNzb2NpYXRlZCB0byB0aGUgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5UaGVtYXRpYz59IHRoZW1hdGljcyAtIEluZm9ybWF0aW9ucyBhYm91dCB0aGVtYXRpY3MgYXNzb2NpYXRlZCB0byB0aGUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgZ2V0VGhlbWF0aWNzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVtYXRpY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGF5ZXIgZGVmYXVsdCBmb3JtYXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvcm1hdE5hbWUgLSBGb3JtYXQgbWltZS10eXBlLiAoZWcuIFwiaW1hZ2UvanBlZ1wiKVxuICAgICAqL1xuICAgIGdldERlZmF1bHRGb3JtYXQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5mb3JtYXRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdDtcbiAgICAgICAgdmFyIGYgPSB0aGlzLmZvcm1hdHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZbaV0uY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IGdlb2dyYXBoaWNhbCBvciB0ZW1wb3JhbCBjb25zdHJhaW50cyBmb3IgdGhlIHJlc291cmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5Db25zdHJhaW50Pn0gY29uc3RyYWludHMgLSBJbmZvcm1hdGlvbnMgYWJvdXQgZ2VvZ3JhcGhpY2FsIG9yIHRlbXBvcmFsIGNvbnN0cmFpbnRzIGZvciB0aGUgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBnZXRDb25zdHJhaW50cyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgb3JpZ2luYXRvcnMgb2YgdGhpcyByZXNvdXJjZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5LjxHcC5TZXJ2aWNlcy5Db25maWcuT3JpZ2luYXRvcj59IG9yaWdpbmF0b3JzIC0gSW5mb3JtYXRpb25zIGFib3V0IG9yaWdpbmF0b3JzIG9mIHRoaXMgcmVzb3VyY2VcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hdG9ycyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYXRvcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgZGltZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXNvdXJjZVxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gZGltZW5zaW9ucyAtIERpbWVuc2lvbnMgaW5mb3JtYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgZ2V0RGltZW5zaW9ucyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBhZ2dyZWdhdGVkIGxheWVycyBjb21wb3NpbmcgdGhlIGJlaW5nIGRlc2NyaWJlZCBsYXllciwgaW4gY2FzZSB0aGUgcmVzb3VyY2UgaXMgYW4gYWdncmVnYXRlIG9mIG90aGVyIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFnZ3JlZ2F0ZWRMYXllcnMgLSBMYXllcnMgSURzIGNvbXBvc2luZyB0aGUgYmVpbmcgZGVzY3JpYmVkIGFnZ3JlZ2F0ZWQgbGF5ZXIuXG4gICAgICovXG4gICAgZ2V0QWdncmVnYXRlZExheWVycyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFnZ3JlZ2F0ZWRMYXllcnM7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChMYXllcik7XG5cblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIGxlZ2VuZCBmaWxlIGFzc29jaWF0ZWQgd2l0aCBhIGdlb3BvcnRhbCByZXNvdXJjZSAoV01UUywgV01TLCBXRlMgbGF5ZXJzKS5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9ybWF0IC0gbWltZS10eXBlIG9mIHRoZSBsZWdlbmQgZmlsZS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1cmwgLSBsZWdlbmQgZmlsZSBVUkxcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5TY2FsZURlbm9taW5hdG9yIC0gbWluaW11bSBzY2FsZSBkZW5vbWluYXRvciB3aGVyZSB0aGlzIGxlZ2VuZCBhcHBsaWVzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Db25maWcuTGVnZW5kXG4gKi9cblxuZnVuY3Rpb24gTGVnZW5kICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGVnZW5kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTGVnZW5kIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQgPSBudWxsO1xuXG4gICAgdGhpcy51cmwgPSBudWxsO1xuXG4gICAgdGhpcy5taW5TY2FsZURlbm9taW5hdG9yID0gbnVsbDtcbn1cblxuTGVnZW5kLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogTGVnZW5kXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTGVnZW5kKTtcblxuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGEgbWV0YWRhdGEgZmlsZSBhc3NvY2lhdGVkIHdpdGggYSBnZW9wb3J0YWwgcmVzb3VyY2UuXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IGZvcm1hdCAtIG1pbWUtdHlwZSBvZiB0aGUgbWV0YWRhdGEgZmlsZS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1cmwgLSBtZXRhZGF0YSBmaWxlIFVSTFxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Db25maWcuTWV0YWRhdGFcbiAqL1xuXG5mdW5jdGlvbiBNZXRhZGF0YSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1ldGFkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWV0YWRhdGEgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCA9IG51bGw7XG5cbiAgICB0aGlzLnVybCA9IG51bGw7XG59XG5cbk1ldGFkYXRhLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogTWV0YWRhdGFcblxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChNZXRhZGF0YSk7XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhbiBPcmlnaW5hdG9yIG9mIGdlb3BvcnRhbCByZXNvdXJjZS5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSAtIG9yaWdpbmF0b3IgbmFtZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGF0dHJpYnV0aW9uIC0gb3JpZ2luYXRvciBmdWxsIG5hbWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsb2dvIC0gb3JpZ2luYXRvciBsb2dvIGZpbGUgVVJMXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdXJsIC0gb3JpZ2luYXRvciB3ZWIgc2l0ZSBVUkxcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5Db25zdHJhaW50Pn0gY29uc3RyYWludHMgLSB3aGVyZSBhbmQgd2hlbiB0aGUgb3JpZ2luYXRvciBhcHBsaWVzIGZvciB0aGUgcmVzc291cmNlLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Db25maWcuT3JpZ2luYXRvclxuICovXG5cbmZ1bmN0aW9uIE9yaWdpbmF0b3IgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcmlnaW5hdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT3JpZ2luYXRvciBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IG51bGw7XG5cbiAgICB0aGlzLmF0dHJpYnV0aW9uID0gbnVsbDtcblxuICAgIHRoaXMubG9nbyA9IG51bGw7XG5cbiAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG59XG5cbk9yaWdpbmF0b3IucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBPcmlnaW5hdG9yXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoT3JpZ2luYXRvcik7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIHdlYiBzZXJ2aWNlIG9mIHRoZSBnZW9wb3J0YWwgcGxhdGZvcm0uXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHRpdGxlIC0gV2ViIHNlcnZpY2UgbmFtZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHNlcnZlclVybCAtIEFzc29jaWF0aXZlIGFycmF5IG1hcHBpbmcgZ2VvcG9ydGFsIGFjY2VzcyBrZXkgKGtleXMpIHdpdGggdGhlaXIgcHJvcGVydGllcyAoVVJMcyBvZiB0aGUgd2ViIHNlcnZpY2UsIHdpdGggdGhlIGdlb3BvcnRhbCBhY2Nlc3Mga2V5KS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2ZXJzaW9uIC0gd2ViIHNlcnZpY2UgdmVyc2lvbi5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29uZmlnLlNlcnZpY2VcbiAqL1xuZnVuY3Rpb24gU2VydmljZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlcnZpY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTZXJ2aWNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy50aXRsZSA9IG51bGw7XG5cbiAgICB0aGlzLnNlcnZlclVybCA9IG51bGw7XG5cbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xufVxuXG5TZXJ2aWNlLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogU2VydmljZVxuXG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFNlcnZpY2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogT2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgYSBzdHlsZSB0aGF0IG1heSBiZSB1c2VkIGZvciBhIGdlb3BvcnRhbCByZXNvdXJjZS5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSAtIFN0eWxlIGlkZW50aWZpZXIgKGVnIDogXCJub3JtYWxcIiwgXCJiZHBhcmNlbGxhaXJlXCIsIC4uLilcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0aXRsZSAtIGh1bWFuIHJlYWRhYmxlIG5hbWUgb2YgdGhlIHN0eWxlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBjdXJyZW50IC0gdHJ1ZSBpZiB0aGlzIGlzIHRoZSBkZWZhdWx0IHN0eWxlLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Db25maWcuU3R5bGVcbiAqL1xuXG5mdW5jdGlvbiBTdHlsZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3R5bGUgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuXG4gICAgdGhpcy50aXRsZSA9IG51bGw7XG5cbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IFN0eWxlXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoU3R5bGUpO1xuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogT2JqZWN0IHVzZWQgdG8gZGVzY3JpYmUgcHJvcGVydGllcyBvZiBhIGZyZW5jaCB0ZXJyaXRvcnkgY292ZXJlZCBieSBnZW9wb3J0YWwgcmVzb3VyY2VzLlxuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNEZWZhdWx0IC0gaWYgdGhpcyB0ZXJyaXRvcnkgaXMgdG8gdXNlIGJ5IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdENSUyAtIElkZW50aWZpZXIgb2YgdGhlIGNvb3JkaW5hdGVzIHN5c3RlbSB0byB1c2UgYnkgZGVmYXVsdCBmb3IgdGhhdCB0ZXJyaXRvcnkuXG4gKiBAcHJvcGVydHkge0FycmF5LjxTdHJpbmc+fSBhZGRpdGlvbmFsQ1JTIC0gSWRlbnRpZmllcnMgb2YgYWRkaXRpb25hbCBjb29yZGluYXRlcyBzeXN0ZW1zIGF2YWlsYWJsZXMgZm9yIHRoYXQgdGVycml0b3J5LlxuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gZGVmYXVsdExheWVycyAtIElkZW50aWZpZXJzIG9mIGxheWVycyB0byBsb2FkIGJ5IGRlZmF1bHQgZm9yIHRoYXQgdGVycml0b3J5LlxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgYnkgZGVmYXVsdCBmb3IgdGhhdCB0ZXJyaXRvcnkuXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMucmVzb2x1dGlvbiAtIHJlc29sdXRpb24gdG8gdXNlIGJ5IGRlZmF1bHQgZm9yIHRoYXQgdGVycml0b3J5IChpbiBtZXRlciBwZXIgcGl4ZWwpLlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLm1pblNjYWxlRGVub21pbmF0b3IgLSBtaW5pbXVtIHNjYWxlRGVub21pbmF0b3IgYWNjZXNzaWJsZSBmb3IgdGhhdCB0ZXJyaXRvcnkuXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMubWF4U2NhbGVEZW5vbWluYXRvciAtIG1heGltdW0gc2NhbGVEZW5vbWluYXRvciBhY2Nlc3NpYmxlIGZvciB0aGF0IHRlcnJpdG9yeS5cbiAqIEBwcm9wZXJ0eSB7R3AuQkJveH0gZ2VvQkJveCAtIEJvdW5kaW5nIEJveCBvZiB0aGUgdGVycml0b3J5IChleHByZXNzZWQgaW4gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGdlb0NlbnRlciAtIGNlbnRlciBvZiB0aGUgdGVycml0b3J5IChleHByZXNzZWQgaW4gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzKVxuICogQHByb3BlcnR5IHtGbG9hdH0gZ2VvQ2VudGVyLmxvbiAtIGNlbnRlciBsb25naXR1ZGVcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IGdlb0NlbnRlci5sYXQgLSBjZW50ZXIgbGF0aXR1ZGVcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29uZmlnLlRlcnJpdG9yeVxuICovXG5mdW5jdGlvbiBUZXJyaXRvcnkgKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXJyaXRvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUZXJyaXRvcnkgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzRGVmYXVsdCA9IG51bGw7XG5cbiAgICB0aGlzLmRlZmF1bHRDUlMgPSBudWxsO1xuXG4gICAgdGhpcy5hZGRpdGlvbmFsQ1JTID0gW107XG5cbiAgICB0aGlzLmdlb0JCT1ggPSB7XG4gICAgICAgIGxlZnQgOiBudWxsLFxuICAgICAgICByaWdodCA6IG51bGwsXG4gICAgICAgIHRvcCA6IG51bGwsXG4gICAgICAgIGJvdHRvbSA6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5nZW9DZW50ZXIgPSB7XG4gICAgICAgIGxvbiA6IG51bGwsXG4gICAgICAgIGxhdCA6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgcmVzb2x1dGlvbiA6IG51bGwsXG4gICAgICAgIG1pblNjYWxlRGVub21pbmF0b3IgOiBudWxsLFxuICAgICAgICBtYXhTY2FsZURlbm9taW5hdG9yIDogbnVsbFxuICAgIH07XG5cbiAgICB0aGlzLmRlZmF1bHRMYXllcnMgPSBbXTtcbn1cblxuVGVycml0b3J5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogVGVycml0b3J5XG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVGVycml0b3J5KTtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGEgdGhlbWF0aWNcbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZSAtIFRoZW1hdGljIG5hbWVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaW5zcGlyZSAtIHRydWUgaWYgdGhlIHRoZW1hdGljIG5hbWUgaXMgYW4gW0lOU1BJUkUgb25lXXtAbGluayBodHRwOi8vaW5zcGlyZS5lYy5ldXJvcGEuZXUvaW5kZXguY2ZtL3BhZ2VpZC8yL2xpc3QvN30uXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkNvbmZpZy5UaGVtYXRpY1xuICovXG5cbmZ1bmN0aW9uIFRoZW1hdGljICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhlbWF0aWMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVtYXRpYyBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuaW5zcGlyZSA9IG51bGw7XG5cbiAgICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG5UaGVtYXRpYy5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IFRoZW1hdGljXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVGhlbWF0aWMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICpcbiAqIE9iamVjdCB1c2VkIHRvIGRlc2NyaWJlIGEgVGlsZU1hdHJpeCBzZXQgKGZvciBXTVRTIHVzZSkuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48U3RyaW5nPn0gbWF0cml4SWRzIC0gQXJyYXkgb2YgSURzIGZvciBlYWNoIFRpbGVNYXRyaXggb2YgdGhlIHNldC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5UaWxlTWF0cml4Pn0gdGlsZU1hdHJpY2VzIC0gQXJyYXkgb2YgVGlsZU1hdHJpeCBkZXNjcmlwdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5LjxGbG9hdD59IG5hdGl2ZVJlc29sdXRpb25zIC0gQXJyYXkgb2YgcmVzb2x1dGlvbnMgKGluIG1ldGVyIHBlciBwaXhlbCkgYXBwbHlpbmcgZm9yIGVhY2ggVGlsZU1hdHJpeCBvZiB0aGUgc2V0LlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb2plY3Rpb24gLSBJZGVudGlmaWVyIG9mIHRoZSBDb3JkaW5hdGVzIFN5c3RlbSB1c2VkIGZvciB0aGUgdGlsZU1hdHJpeFNldC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29uZmlnLlRpbGVNYXRyaXhTZXRcbiAqL1xuZnVuY3Rpb24gVGlsZU1hdHJpeFNldCAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRpbGVNYXRyaXhTZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaWxlTWF0cml4U2V0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gbnVsbDtcblxuICAgIHRoaXMubmF0aXZlUmVzb2x1dGlvbnMgPSBbXTtcblxuICAgIHRoaXMubWF0cml4SWRzID0gW107XG5cbiAgICB0aGlzLnRpbGVNYXRyaWNlcyA9IHt9O1xufVxuXG5UaWxlTWF0cml4U2V0LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogVGlsZU1hdHJpeFNldCxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgVGlsZSBNYXRyaXggU2V0IHJlc29sdXRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG5hdGl2ZVJlc29sdXRpb25zIC0gQXJyYXkgb2YgcmVzb2x1dGlvbnMgKGluIG1ldGVyIHBlciBwaXhlbCkgYXBwbHlpbmcgZm9yIGVhY2ggVGlsZU1hdHJpeCBvZiB0aGUgc2V0LlxuICAgICAqL1xuICAgIGdldFJlc29sdXRpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSZXNvbHV0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBUaWxlIE1hdHJpeCBTZXQgaWRlbnRpZmllcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbWF0cml4SWRzIC0gQXJyYXkgb2YgSURzIGZvciBlYWNoIFRpbGVNYXRyaXggb2YgdGhlIHNldC5cbiAgICAgKi9cbiAgICBnZXRNYXRyaXhJZHMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeElkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBUaWxlIE1hdHJpeCBTZXQgcHJvamVjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcHJvamVjdGlvbiAtIElkZW50aWZpZXIgb2YgdGhlIENvcmRpbmF0ZXMgU3lzdGVtIHVzZWQgZm9yIHRoZSB0aWxlTWF0cml4U2V0LlxuICAgICAqL1xuICAgIGdldFByb2plY3Rpb24gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2plY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgVGlsZSBNYXRyaWNlcyBkZXNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEdwLlNlcnZpY2VzLkNvbmZpZy5UaWxlTWF0cml4Pn0gdGlsZU1hdHJpY2VzIC0gQXJyYXkgb2YgVGlsZU1hdHJpeCBkZXNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VGlsZU1hdHJpY2VzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlTWF0cmljZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdG9wIGxlZnQgY29ybmVyIHBvaW50IG9mIG1hdHJpY2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7R3AuUG9pbnR9IHRvcExlZnRDb3JuZXIgLSBUb3AgTGVmdCBDb3JuZXIgUG9pbnQgb2YgVE1TIG1hdHJpY2VzLCBleHByZXNzZWQgaW4gdGhlIHRpbGVNYXRyaXhTZXQgY29vcmRpbmF0ZXMgc3lzdGVtLlxuICAgICAqL1xuICAgIGdldFRvcExlZnRDb3JuZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b3BMZWZ0Q29ybmVyO1xuICAgICAgICB2YXIgbWF0cmljZXMgPSB0aGlzLmdldFRpbGVNYXRyaWNlcygpO1xuICAgICAgICBpZiAobWF0cmljZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIG1hdHJpY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpY2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0Q29ybmVyID0gbWF0cmljZXNbaWRdLnRvcExlZnRDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wTGVmdENvcm5lcjtcbiAgICB9XG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVGlsZU1hdHJpeFNldCk7XG5cblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIFRpbGVNYXRyaXguXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IG1hdHJpeElkIC0gbWF0cml4IElkZW50aWZpZXJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXRyaXhIZWlnaHQgLSBOdW1iZXIgb2YgdGlsZXMgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20gb2YgdGhlIG1hdHJpeC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXRyaXhXaWR0aCAtIE51bWJlciBvZiB0aWxlcyBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCBvZiB0aGUgbWF0cml4LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHNjYWxlRGVub21pbmF0b3IgLSBTY2FsZSBkZW5vbWluYXRvciBhc3NvY2lhdGVkIHRvIHRoYXQgbWF0cml4LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpbGVIZWlnaHQgLSB0aWxlIGhlaWdodCBpbiBudW1iZXIgb2YgcGl4ZWxzXG4gKiBAcHJvcGVydHkge051bWJlcn0gdGlsZVdpZHRoIC0gdGlsZSB3aWR0aCBpbiBudW1iZXIgb2YgcGl4ZWxzXG4gKiBAcHJvcGVydHkge0dwLlBvaW50fSB0b3BMZWZ0Q29ybmVyIC0gVG9wIExlZnQgQ29ybmVyIFBvaW50IG9mIHRoZSBtYXRyaXggZXhwcmVzc2VkIGluIHRoZSB0aWxlTWF0cml4U2V0IGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQ29uZmlnLlRpbGVNYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBUaWxlTWF0cml4ICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGlsZU1hdHJpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRpbGVNYXRyaXggY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLm1hdHJpeElkID0gbnVsbDtcblxuICAgIHRoaXMubWF0cml4SGVpZ2h0ID0gbnVsbDtcblxuICAgIHRoaXMubWF0cml4V2lkdGggPSBudWxsO1xuXG4gICAgdGhpcy5zY2FsZURlbm9taW5hdG9yID0gbnVsbDtcblxuICAgIHRoaXMudGlsZUhlaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnRpbGVXaWR0aCA9IG51bGw7XG5cbiAgICB0aGlzLnRvcExlZnRDb3JuZXIgPSBudWxsO1xufVxuXG5UaWxlTWF0cml4LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogVGlsZU1hdHJpeCxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdG9wIGxlZnQgY29ybmVyIHBvaW50IG9mIHRoZSBtYXRyaXhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtHcC5Qb2ludH0gdG9wTGVmdENvcm5lciAtIFRvcCBMZWZ0IENvcm5lciBQb2ludCBvZiB0aGUgbWF0cml4IGV4cHJlc3NlZCBpbiB0aGUgdGlsZU1hdHJpeFNldCBjb29yZGluYXRlcyBzeXN0ZW0uXG4gICAgICovXG4gICAgZ2V0VG9wTGVmdENvcm5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdENvcm5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTY2FsZSBkZW5vbWluYXRvciBhc3NvY2lhdGVkIHRvIHRoYXQgbWF0cml4LlxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gc2NhbGVEZW5vbWluYXRvciAtIFNjYWxlIGRlbm9taW5hdG9yIGFzc29jaWF0ZWQgdG8gdGhhdCBtYXRyaXguXG4gICAgICovXG4gICAgZ2V0U2NhbGVEZW5vbWluYXRvciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVEZW5vbWluYXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aWxlIGhlaWdodCBvZiBtYXRyaXhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRpbGVIZWlnaHQgLSB0aWxlIGhlaWdodCBpbiBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICovXG4gICAgZ2V0VGlsZUhlaWdodCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZUhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aWxlIHdpZHRoIG9mIG1hdHJpeFxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gdGlsZVdpZHRoIC0gdGlsZSB3aWR0aCBpbiBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICovXG4gICAgZ2V0VGlsZVdpZHRoIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWF0cml4IGhlaWdodCAobnVtYmVyIG9mIHRpbGVzKVxuICAgICAqXG4gICAgICogQHJldHVybnMge051bWJlcn0gbWF0cml4SGVpZ2h0IC0gTnVtYmVyIG9mIHRpbGVzIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tIG9mIHRoZSBtYXRyaXguXG4gICAgICovXG4gICAgZ2V0TWF0cml4SGVpZ2h0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXhIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWF0cml4IHdpZHRoIChudW1iZXIgb2YgdGlsZXMpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBtYXRyaXhXaWR0aCAtIE51bWJlciBvZiB0aWxlcyBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCBvZiB0aGUgbWF0cml4LlxuICAgICAqL1xuICAgIGdldE1hdHJpeFdpZHRoIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXhXaWR0aDtcbiAgICB9XG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVGlsZU1hdHJpeCk7XG5cblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBkZXNjcmliZSBhIGxheWVyIGV4dGVudCBvbiBhIFRpbGUgTWF0cml4LlxuICpcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtaW5UaWxlQ29sIC0gbWluaW11bSBjb2x1bW4gaW5kZXggd2hlcmUgdGlsZSBjYW4gYmUgZm91bmQgb24gdGhlIFRpbGUgbWF0cml4LlxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG1heFRpbGVDb2wgLSBtYXhpbXVtIGNvbHVtbiBpbmRleCB3aGVyZSB0aWxlIGNhbiBiZSBmb3VuZCBvbiB0aGUgVGlsZSBtYXRyaXguXG4gKiBAcHJvcGVydHkge051bWJlcn0gbWluVGlsZVJvdyAtIG1pbmltdW0gcm93IGluZGV4IHdoZXJlIHRpbGUgY2FuIGJlIGZvdW5kIG9uIHRoZSBUaWxlIG1hdHJpeC5cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhUaWxlQ29sIC0gbWF4aW11bSByb3cgaW5kZXggd2hlcmUgdGlsZSBjYW4gYmUgZm91bmQgb24gdGhlIFRpbGUgbWF0cml4LlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Db25maWcuVGlsZU1hdHJpeExpbWl0XG4gKi9cblxuZnVuY3Rpb24gVGlsZU1hdHJpeExpbWl0ICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGlsZU1hdHJpeExpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGlsZU1hdHJpeExpbWl0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5taW5UaWxlUm93ID0gbnVsbDtcblxuICAgIHRoaXMubWF4VGlsZVJvdyA9IG51bGw7XG5cbiAgICB0aGlzLm1pblRpbGVDb2wgPSBudWxsO1xuXG4gICAgdGhpcy5tYXhUaWxlQ29sID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkF1dG9jb25mL1Jlc3BvbnNlL1RpbGVNYXRyaXhMaW1pdFxuICovXG5UaWxlTWF0cml4TGltaXQucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3IgOiBUaWxlTWF0cml4TGltaXRcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoVGlsZU1hdHJpeExpbWl0KTtcblxuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWJzdHJhY3RTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0xvY2F0aW9uVXRpbGl0eVNlcnZpY2VfR2VvY29kZVJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fTG9jYXRpb25VdGlsaXR5U2VydmljZV9SZXZlcnNlR2VvY29kZVJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fTG9jYXRpb25VdGlsaXR5U2VydmljZV9HZW9jb2RlRmlsdGVyRXh0ZW5zaW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIFJlcXXDqnRlIGRlIHR5cGUgTG9jYXRpb25VdGlsaXR5U2VydmljZSAoTFVTKVxuICogKEZhY3RvcnkpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVuY2Fwc3VsZSB1biBvYmpldCBkYW5zIHVuZSBjb3F1aWxsZSBYU0wsIEZhY3Rvcnkgc3VyIGxlcyBvYmpldHMgR2VvY29kZS9SZXZlcnNlR2VvY29kZVxuICogbHVzID0gbmV3IExvY2F0aW9uVXRpbGl0eVNlcnZpY2UgKCk7XG4gKiBsdXMuYWRkUmVxdWVzdCAocmVxKTtcbiAqIGx1cy50b1N0cmluZygpO1xuICogIG91XG4gKiBsdXMgPSBuZXcgTG9jYXRpb25VdGlsaXR5U2VydmljZSAoe1xuICogICAgICBsb2NhdGlvbiA6IFwic2FpbnQgbWFuZMOpXCIsXG4gKiAgICAgIHJldHVybkZyZWVGb3JtIDogdHJ1ZSxcbiAqICAgICAgZmlsdGVyT3B0aW9ucyA6IHtcbiAqICAgICAgICAgIHR5cGUgOiAgWydQb3NpdGlvbk9mSW50ZXJlc3QnXVxuICogICAgICB9XG4gKiB9KTtcbiAqIGx1cy50b1N0cmluZygpO1xuICpcbiAqIC8vIG91dCAtPlxuICogLy8gPEdlb2NvZGVSZXF1ZXN0PlxuICogLy8gICA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlBvc2l0aW9uT2ZJbnRlcmVzdFwiPlxuICogLy8gICAgIDxmcmVlRm9ybUFkZHJlc3M+c2FpbnQgbWFuZMOpPC9mcmVlRm9ybUFkZHJlc3M+XG4gKiAvLyAgIDwvQWRkcmVzcz5cbiAqIC8vIDwvR2VvY29kZVJlcXVlc3Q+XG4gKlxuICogLy8gY3JlYXRpb24gZGUgbCdvYmpldCBHZW9jb2RlXG4gKiByZXEgPSBuZXcgR2VvY29kZVJlcXVlc3QgKCk7XG4gKiByZXEuYWRkQWRkcmVzcyAobmV3IEFkZHJlc3MgKC8qdG9kby8qKSk7XG4gKiByZXEudG9TdHJpbmcoKTtcbiAqIC8vIG91dCAtPlxuICogLy8gPEdlb2NvZGVSZXF1ZXN0PlxuICogLy8gICA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlBvc2l0aW9uT2ZJbnRlcmVzdFwiPlxuICogLy8gICAgIDxmcmVlRm9ybUFkZHJlc3M+c2FpbnQgbWFuZMOpPC9mcmVlRm9ybUFkZHJlc3M+XG4gKiAvLyAgIDwvQWRkcmVzcz5cbiAqIC8vIDwvR2VvY29kZVJlcXVlc3Q+XG4gKlxuICogLy8gY3JlYXRpb24gZGUgbCdvYmpldCBSZXZlcnNlR2VvY29kZVxuICogcmVxID0gbmV3IFJldmVyc2VHZW9jb2RlUmVxdWVzdCAoKTtcbiAqIHJlcS5hZGRQb3NpdGlvbiAobmV3IFBvc2l0aW9uIChwb3NpdGlvbjp7eDogLCB5OiB9KSk7XG4gKiByZXEuYWRkUHJlZmVyZW5jZSAoWydTdHJlZXRBZGRyZXNzJ10pO1xuICogcmVxLnRvU3RyaW5nKCk7XG4gKiAvLyBvdXQgLT5cbiAqIC8vIDxSZXZlcnNlR2VvY29kZVJlcXVlc3Q+XG4gKiAvLyAgICAgPFBvc2l0aW9uPlxuICogLy8gICAgICAgPGdtbDpQb2ludCB4bWxuczpnbWw9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiPlxuICogLy8gICAgICAgICAgIDxnbWw6cG9zPjUwLjM0Nzc3NSAzLjIwNTA5ODwvZ21sOnBvcz5cbiAqIC8vICAgICAgIDwvZ21sOlBvaW50PlxuICogLy8gICAgIDwvUG9zaXRpb24+XG4gKiAvLyAgICAgPFJldmVyc2VHZW9jb2RlUHJlZmVyZW5jZT5TdHJlZXRBZGRyZXNzPC9SZXZlcnNlR2VvY29kZVByZWZlcmVuY2U+XG4gKiAvLyAgPC9SZXZlcnNlR2VvY29kZVJlcXVlc3Q+XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuTG9jYXRpb25VdGlsaXR5U2VydmljZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLmxvY2F0aW9uIC0gbG9jYXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucG9zaXRpb24gLSBwb3NpdGlvbiA6IHt4IDogXCJcIiwgeSA6IFwiXCJ9XG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnJldHVybkZyZWVGb3JtIC0gdHJ1ZXxmYWxzZVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5maWx0ZXJPcHRpb25zIC0gZmlsdHJlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbnN1Y2Nlc3MgLSBmdW5jdGlvbiBjYWxsYmFjayBzdWNjZXNzIChUT0RPKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmVycm9yICAgLSBmdW5jdGlvbiBjYWxsYmFjayBlcnJvciAgIChUT0RPKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExvY2F0aW9uVXRpbGl0eVNlcnZpY2UgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIExvY2F0aW9uVXRpbGl0eVNlcnZpY2UgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExvY2F0aW9uVXRpbGl0eVNlcnZpY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMb2NhdGlvblV0aWxpdHlTZXJ2aWNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZVxuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJMb2NhdGlvblV0aWxpdHlTZXJ2aWNlXCI7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIGRlIGNsYXNzZSBkZSBnZW9jb2RhZ2VcbiAgICAgKiBleC4gR2VvY29kZVJlcXVlc3Qgb3UgUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XG4gICAgICovXG4gICAgdGhpcy5DTEFTU1RZUEUgPSBudWxsO1xuXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIHBhciBoZXJpdGFnZVxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWJzdHJhY3RTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIG9uIGRldGVybWluZSBsZSB0eXBlIGRlIGdlb2NvZGFnZSBzaSBsZXMgb3B0aW9ucyBzb250IHJlbnNlaWduw6llc1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5DTEFTU1RZUEUgPSAodGhpcy5vcHRpb25zLmxvY2F0aW9uKSA/IFwiR2VvY29kZVJlcXVlc3RcIiA6ICh0aGlzLm9wdGlvbnMucG9zaXRpb24pID8gXCJSZXZlcnNlR2VvY29kZVJlcXVlc3RcIiA6IG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6TG9jYXRpb25VdGlsaXR5U2VydmljZSNcbiAqL1xuTG9jYXRpb25VdGlsaXR5U2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWJzdHJhY3RTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLCB7XG4gICAgLy8gdG9kb1xuICAgIC8vIGdldHRlci9zZXR0ZXJcbn0pO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkxvY2F0aW9uVXRpbGl0eVNlcnZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9jYXRpb25VdGlsaXR5U2VydmljZTtcblxuLyoqXG4gKiAob3ZlcndyaXRlKSBBam91dCBkJ3VuIG9iamV0IGRlIHR5cGUgTFVTIDogR2VvY29kZVJlcXVlc3Qgb3UgUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9MVVNSZXF1ZXN0IC0gb2JqZXQgZGUgdHlwZSBMVVNcbiAqL1xuTG9jYXRpb25VdGlsaXR5U2VydmljZS5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIChvTFVTUmVxdWVzdCkge1xuICAgIC8vIG9uIGRldGVybWluZSBsZSB0eXBlIGRlIGdlb2NvZGFnZVxuICAgIHRoaXMuQ0xBU1NUWVBFID0gb0xVU1JlcXVlc3QuQ0xBU1NOQU1FO1xuXG4gICAgLy8gb24gY29udHJvbGUgbGVzIHR5cGVzIGFjY2VwdMOpc1xuICAgIHN3aXRjaCAodGhpcy5DTEFTU1RZUEUpIHtcbiAgICAgICAgY2FzZSBcIkdlb2NvZGVSZXF1ZXN0XCI6XG4gICAgICAgIGNhc2UgXCJSZXZlcnNlR2VvY29kZVJlcXVlc3RcIjpcbiAgICAgICAgICAgIHRoaXMub1JlcXVlc3QgPSBvTFVTUmVxdWVzdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Ugbidlc3QgcGFzIHVuIG9iamV0IGRlIHR5cGUgJ0xVUyBSZXF1ZXN0JyAhP1wiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIChvdmVyd3JpdGUpIEFqb3V0IGQndW4gb2JqZXQgZGUgdHlwZSBHZW9jb2RlRmlsdGVyRXh0ZW5zaW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9GaWx0ZXIgLSBvYmpldCBkZSB0eXBlIEZpbHRyZVxuICovXG5Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlLnByb3RvdHlwZS5hZGRGaWx0ZXIgPSBmdW5jdGlvbiAob0ZpbHRlcikge1xuICAgIC8vIEZJWE1FIGdlc3Rpb24gZGVzIGZpbHRyZXMgw6AgcGFydGlyIGRlcyB0YWJsZXMgZGUgZ2VvY29kYWdlc1xuICAgIGlmIChvRmlsdGVyIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlX0dlb2NvZGVGaWx0ZXJFeHRlbnNpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSkge1xuICAgICAgICB0aGlzLm9GaWx0ZXIgPSBvRmlsdGVyO1xuICAgIH1cbn07XG5cbi8qKlxuICogKG92ZXJ3cml0ZSkgdG9TdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzb2l0LCBvbiBhIHVuIG9iamV0IExVUyBSZXF1ZXN0IGTDqWrDoCBpbnN0YW5jacOpXG4gICAgLy8gc2lub24sIGlsIGZhdXQgbGUgY29uc3RydWlyZSDDoCBwYXJ0aXIgZGVzIG9wdGlvbnMgw6AgZGlzcG9zaXRpb25cbiAgICBpZiAoIXRoaXMub1JlcXVlc3QpIHtcbiAgICAgICAgLy8gaWwgbm91cyBmYXV0IGRlcyBvcHRpb25zXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMZXMgb3B0aW9ucyBuZSBzb250IHBhcyByZW5zZWlnbsOpZXMsIGltcG9zc2libGUgZGUgY29uc3RydWlyZSBsYSByZXF1w6p0ZSAhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgbGVzIG9wdGlvbnMgJ2xvY2F0aW9uJyBldCAncG9zaXRpb24nIHNvbnQgcmVuc2VpZ27DqWVzLFxuICAgICAgICAvLyBvbiBwcmVuZHJhIHBhciBkZWZhdXQgbGUgY2hvaXggZHUgZ2VvY29kYWdlIGRpcmVjdFxuICAgICAgICBpZiAodGhpcy5DTEFTU1RZUEUgPT09IFwiR2VvY29kZVJlcXVlc3RcIikge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzRGlyZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uIDogdGhpcy5vcHRpb25zLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHJldHVybkZyZWVGb3JtIDogdGhpcy5vcHRpb25zLnJldHVybkZyZWVGb3JtLFxuICAgICAgICAgICAgICAgIGZpbHRlck9wdGlvbnMgOiB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucyB8fCB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub1JlcXVlc3QgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlX0dlb2NvZGVSZXF1ZXN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10oc2V0dGluZ3NEaXJlY3QpO1xuICAgICAgICAgICAgLy8gYWpvdXQgZGVzIGZpbHRyZXMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgZHUgZ2VvY29kYWdlIGRpcmVjdCBkZSBsJ0lHTlxuICAgICAgICAgICAgaWYgKHRoaXMub0ZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMub1JlcXVlc3QuYWRkRmlsdGVyKHRoaXMub0ZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5DTEFTU1RZUEUgPT09IFwiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XCIpIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5nc0ludiA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICByZXR1cm5GcmVlRm9ybSA6IHRoaXMub3B0aW9ucy5yZXR1cm5GcmVlRm9ybSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJPcHRpb25zIDogdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMgfHwge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9SZXF1ZXN0ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fTG9jYXRpb25VdGlsaXR5U2VydmljZV9SZXZlcnNlR2VvY29kZVJlcXVlc3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXShzZXR0aW5nc0ludik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcImltcG9zc2libGUgZGUgZGV0ZXJtaW5lciBsZSB0eXBlIGRlIGdlb2NvZGFnZSA6IERpcmVjdCBvdSBJbnZlcnNlICE/XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gb2JqZXQgaW5kZWZpbmkgIT9cbiAgICBpZiAoIXRoaXMub1JlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBkZSBHZW9jb2RhZ2UgaW5kZWZpbmkgIVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0clJlcXVlc3QgPSB0aGlzLm9SZXF1ZXN0LnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyUmVxdWVzdDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTG9jYXRpb25VdGlsaXR5U2VydmljZSk7XG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0dlb2NvZGVkTG9jYXRpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5cblxuLyoqXG4gKiBTaW5nbGUgbG9jYXRpb24gb2JqZWN0IHJldHVybmVkIGJ5IHRoZSB1bmRlcmx5aW5nIGdlb2NvZGluZyB3ZWIgc2VydmljZS5cbiAqXG4gKiBAcHJvcGVydHkge0Zsb2F0fSBhY2N1cmFjeSAtIEFjY3VyYWN5IG9mIHRoZSByZXNwb25zZSB0b3dhcmRzIHRoZSByZXF1ZXN0ZWQgbG9jYXRpb24gYmV0d2VlbiAwICh1bmFjY3VyYXRlKSBhbmQgMSAoZXhhY3QgbWF0Y2gpLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBleHRlbmRzIHtHcC5TZXJ2aWNlcy5HZW9jb2RlLkdlb2NvZGVkTG9jYXRpb259XG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5EaXJlY3RHZW9jb2RlZExvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIERpcmVjdEdlb2NvZGVkTG9jYXRpb24gKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEaXJlY3RHZW9jb2RlZExvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGlyZWN0R2VvY29kZWRMb2NhdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIElORk9cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgZGUgbGEgY2xhc3NlIG3DqHJlXG4gICAgLy8gYXZlYyBwYXNzYWdlIGRlIHBhcmFtLlxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZWRMb2NhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSkgOiBcIkRpcmVjdEdlb2NvZGVkTG9jYXRpb25cIlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkRpcmVjdEdlb2NvZGVkTG9jYXRpb25cIjtcblxuICAgIHRoaXMuYWNjdXJhY3kgPSBudWxsO1xufVxuXG5EaXJlY3RHZW9jb2RlZExvY2F0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlZExvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlKTtcblxuRGlyZWN0R2VvY29kZWRMb2NhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3RHZW9jb2RlZExvY2F0aW9uO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKERpcmVjdEdlb2NvZGVkTG9jYXRpb24pO1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlZExvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuXG5cbi8qKlxuICogU2luZ2xlIGxvY2F0aW9uIG9iamVjdCByZXR1cm5lZCBieSB0aGUgdW5kZXJseWluZyByZXZlcnNlIGdlb2NvZGluZyB3ZWIgc2VydmljZS5cbiAqXG4gKiBAcHJvcGVydHkge0Zsb2F0fSBzZWFyY2hDZW50ZXJEaXN0YW5jZSAtIERpc3RhbmNlIGJldHdlZW4gdGhlIHJlcXVlc3RlZCBwb2ludCBhbmQgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBleHRlbmRzIHtHcC5TZXJ2aWNlcy5HZW9jb2RlLkdlb2NvZGVkTG9jYXRpb259XG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5SZXZlcnNlR2VvY29kZWRMb2NhdGlvblxuICovXG5mdW5jdGlvbiBSZXZlcnNlR2VvY29kZWRMb2NhdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24gY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBJTkZPXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIGRlIGxhIGNsYXNzZSBtw6hyZVxuICAgIC8vIGF2ZWMgcGFzc2FnZSBkZSBwYXJhbS5cbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0dlb2NvZGVkTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpIDogXCJSZXZlcnNlR2VvY29kZWRMb2NhdGlvblwiXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiUmV2ZXJzZUdlb2NvZGVkTG9jYXRpb25cIjtcblxuICAgIHRoaXMuc2VhcmNoQ2VudGVyRGlzdGFuY2UgPSBudWxsO1xufVxuXG5SZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZWRMb2NhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSk7XG5cblJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJldmVyc2VHZW9jb2RlZExvY2F0aW9uO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJldmVyc2VHZW9jb2RlZExvY2F0aW9uKTtcblxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZXNwb25zZSBvYmplY3QgZm9yIHtAbGluayBtb2R1bGU6U2VydmljZXN+YXV0b0NvbXBsZXRlIEdwLlNlcnZpY2VzLmF1dG9Db21wbGV0ZSAoKX0gaW52b2NhdGlvbiB3aGVuIHN1Y2Nlc3NmdWwuIFJlY2VpdmVkIGFzIHRoZSBhcmd1bWVudCBvZiBvblN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48R3AuU2VydmljZXMuQXV0b0NvbXBsZXRlLlN1Z2dlc3RlZExvY2F0aW9uPn0gc3VnZ2VzdGVkTG9jYXRpb25zIC0gU3VnZ2VzdGVkTG9jYXRpb25zIGFycmF5LlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BdXRvQ29tcGxldGVSZXNwb25zZVxuICovXG5mdW5jdGlvbiBBdXRvQ29tcGxldGVSZXNwb25zZSAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEF1dG9Db21wbGV0ZVJlc3BvbnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXV0b0NvbXBsZXRlUmVzcG9uc2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1Z2dlc3RlZExvY2F0aW9ucyA9IFtdO1xufVxuXG5BdXRvQ29tcGxldGVSZXNwb25zZS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvciA6IEF1dG9Db21wbGV0ZVJlc3BvbnNlXG5cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQXV0b0NvbXBsZXRlUmVzcG9uc2UpO1xuXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU2luZ2xlIFN1Z2dlc3RlZExvY2F0aW9uIE9iamVjdCByZXR1cm5lZCBieSB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlLlxuICogRWFjaCBzdWdnZXN0ZWQgbG9jYXRpb24gcmVwcmVzZW50cyBhIHN0cmVldCBhZGRyZXNzIChcIlN0cmVldEFkZHJlc3NcIikgb3IgYSBwbGFjZSBuYW1lIChcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiKS5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSAtIFN1Z2dlc3RlZCBsb2NhdGlvbiB0eXBlIDogXCJTdHJlZXRBZGRyZXNzXCIgb3UgXCJQb3NpdGlvbk9mSW50ZXJlc3RcIlxuICogQHByb3BlcnR5IHtHcC5Qb2ludH0gcG9zaXRpb24gLSBQb3NpdGlvbiBvZiB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uIGdpdmVuIGluIHJlcXVlc3RlZCBjb29yZGluYXRlcyBzeXN0ZW0uXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29tbXVuZSAtIFN1Z2dlc3RlZCBtdW5pY2lwYWxpdHlcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmdWxsVGV4dCAtIEZ1bGwgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHBvc3RhbENvZGUgLSBTdWdnZXN0ZWQgbG9jYXRpb24gcG9zdGNvZGVcbiAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gY2xhc3NpZmljYXRpb24gLSBOdW1iZXIgdXNlZCB0byBjbGFzc2lmeSB0aGUgaW1wb3J0YW5jZSBvZiB0aGUgcGxhY2Ugd2hlcmUgaXMgdGhlIHN1Z2dlc3RlZCBsb2NhdGlvbiBmcm9tIDEgKG1vc3QgaW1wb3J0YW50KSB0byA3IChsZXNzIGltcG9ydGFudCkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gc3RyZWV0IC0gU3RyZWV0IG5hbWUgb2YgdGhlIHN1Z2dlc3RlZCBsb2NhdGlvbiAoXCJTdHJlZXRBZGRyZXNzXCIgb25seSkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2luZCAtIE5hdHVyZSBvZiB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uIDogXCJwcmVmZWN0dXJlXCIsIFwibW9udW1lbnRcIiwgXCJjb21tdW5lXCIsIC4uLiBmb3IgaW5zdGFuY2UgKFwiUG9zaXRpb25PZkludGVyZXN0XCIgb25seSkuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkF1dG9Db21wbGV0ZS5TdWdnZXN0ZWRMb2NhdGlvblxuICovXG5mdW5jdGlvbiBTdWdnZXN0ZWRMb2NhdGlvbiAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN1Z2dlc3RlZExvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VnZ2VzdGVkTG9jYXRpb24gY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvKiBSRVBPTlNFIDpcbiAgICAgICAge1xuICAgICAgICAgICBcInN0YXR1c1wiIDogXCJPS1wiLFxuICAgICAgICAgICBcInJlc3VsdHNcIiA6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICBcImNvdW50cnlcIjpcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiLFxuICAgICAgICAgICAgICAgICBcInhcIjotMS41NTkxODUsXG4gICAgICAgICAgICAgICAgIFwieVwiOjQ3Ljk1MjYwMyxcbiAgICAgICAgICAgICAgICAgXCJjaXR5XCI6XCJCcmllXCIsXG4gICAgICAgICAgICAgICAgIFwiemlwY29kZVwiOlwiMzUxNTBcIixcbiAgICAgICAgICAgICAgICAgXCJzdHJlZXRcIjpcImNvcmJlXCIsXG4gICAgICAgICAgICAgICAgIFwia2luZFwiOlwiTGlldS1kaXQgaGFiaXTDqVwiLFxuICAgICAgICAgICAgICAgICBcImZ1bGx0ZXh0XCI6XCJjb3JiZSwgMzUxNTAgQnJpZVwiLFxuICAgICAgICAgICAgICAgICBcImNsYXNzaWZpY2F0aW9uXCI6NlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgIFwiY291bnRyeVwiOlwiU3RyZWV0QWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICBcInhcIjoxLjUzODI5NSxcbiAgICAgICAgICAgICAgICAgXCJ5XCI6NDMuMTk2NDYsXG4gICAgICAgICAgICAgICAgIFwiY2l0eVwiOlwiQnJpZVwiLFxuICAgICAgICAgICAgICAgICBcInppcGNvZGVcIjpcIjA5NzAwXCIsXG4gICAgICAgICAgICAgICAgIFwic3RyZWV0XCI6XCJjb3VycmVzdGVcIixcbiAgICAgICAgICAgICAgICAgXCJraW5kXCI6XCJcIixcbiAgICAgICAgICAgICAgICAgXCJmdWxsdGV4dFwiOlwiY291cnJlc3RlLCAwOTcwMCBCcmllXCIsXG4gICAgICAgICAgICAgICAgIFwiY2xhc3NpZmljYXRpb25cIjo3XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgKi9cblxuICAgIC8qIFJFUE9OU0UgRU4gRVJSRVVSXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXR1cyA6IFwiRVJST1JcIixcbiAgICAgICAgICAgIHJlc3VsdHMgOiBbIF1cbiAgICAgICAgfVxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTdWdnZXN0ZWQgbG9jYXRpb24gdHlwZSA6IFwiU3RyZWV0QWRkcmVzc1wiIG91IFwiUG9zaXRpb25PZkludGVyZXN0XCJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uIGdpdmVuIGluIHJlcXVlc3RlZCBjb29yZGluYXRlcyBzeXN0ZW0uXG4gICAgICogQHR5cGUge0dwLlBvaW50fVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgIHggOiBudWxsLFxuICAgICAgICB5IDogbnVsbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWdnZXN0ZWQgbXVuaWNpcGFsaXR5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvbW11bmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRnVsbCB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdWdnZXN0ZWQgbG9jYXRpb24uXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmZ1bGxUZXh0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFN1Z2dlc3RlZCBsb2NhdGlvbiBwb3N0Y29kZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3N0YWxDb2RlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE51bWJlciB1c2VkIHRvIGNsYXNzaWZ5IHRoZSBpbXBvcnRhbmNlIG9mIHRoZSBwbGFjZSB3aGVyZSBpcyB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uIGZyb20gMSAobW9zdCBpbXBvcnRhbnQpIHRvIDcgKGxlc3MgaW1wb3J0YW50KS5cbiAgICAgKiBAdHlwZSB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzaWZpY2F0aW9uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFN0cmVldCBuYW1lIG9mIHRoZSBzdWdnZXN0ZWQgbG9jYXRpb24gKFwiU3RyZWV0QWRkcmVzc1wiIG9ubHkpLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHJlZXQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGxhY2UgbmFtZSBvZiB0aGUgc3VnZ2VzdGVkIGxvY2F0aW9uIChcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiIG9ubHkpLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wb2kgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogTmF0dXJlIG9mIHRoZSBzdWdnZXN0ZWQgbG9jYXRpb24gOiBcInByZWZlY3R1cmVcIiwgXCJtb251bWVudFwiLCBcImNvbW11bmVcIiwgLi4uIGZvciBpbnN0YW5jZSAoXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiBvbmx5KS5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2luZCA9IG51bGw7XG59XG5cblN1Z2dlc3RlZExvY2F0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yIDogU3VnZ2VzdGVkTG9jYXRpb25cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoU3VnZ2VzdGVkTG9jYXRpb24pO1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fU2VydmljZXNfU2VydmljZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fU2VydmljZXNfRGVmYXVsdFVybFNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19TZXJ2aWNlc19BbHRpX1Jlc3BvbnNlX21vZGVsX0FsdGlSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1NlcnZpY2VzX0FsdGlfUmVzcG9uc2VfbW9kZWxfRWxldmF0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1NlcnZpY2VzX0F1dG9Db21wbGV0ZV9SZXNwb25zZV9tb2RlbF9BdXRvQ29tcGxldGVSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19TZXJ2aWNlc19BdXRvQ29tcGxldGVfUmVzcG9uc2VfbW9kZWxfU3VnZ2VzdGVkTG9jYXRpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfQXV0b0NvbmZSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9Db25zdHJhaW50X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX0Zvcm1hdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9MYXllcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfTGVnZW5kX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9NZXRhZGF0YV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfT3JpZ2luYXRvcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfU3R5bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX1RlcnJpdG9yeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfVGhlbWF0aWNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX1RpbGVNYXRyaXhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX1RpbGVNYXRyaXhMaW1pdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOV9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfVGlsZU1hdHJpeFNldF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9fU2VydmljZXNfR2VvY29kZV9SZXNwb25zZV9tb2RlbF9HZW9jb2RlUmVzcG9uc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX1NlcnZpY2VzX0dlb2NvZGVfUmVzcG9uc2VfbW9kZWxfR2VvY29kZWRMb2NhdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fU2VydmljZXNfR2VvY29kZV9SZXNwb25zZV9tb2RlbF9EaXJlY3RHZW9jb2RlZExvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX19TZXJ2aWNlc19HZW9jb2RlX1Jlc3BvbnNlX21vZGVsX1JldmVyc2VHZW9jb2RlZExvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI0X19TZXJ2aWNlc19Qcm9jZXNzSXNvQ3VydmVfUmVzcG9uc2VfbW9kZWxfUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjVfX1NlcnZpY2VzX1JvdXRlX1Jlc3BvbnNlX21vZGVsX1JvdXRlUmVzcG9uc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjZfX1NlcnZpY2VzX1JvdXRlX1Jlc3BvbnNlX21vZGVsX1JvdXRlSW5zdHJ1Y3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX1Byb3RvY29sc19YSFJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjhfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjlfX1V0aWxzX0hlbHBlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIEdwID0ge1xuICAgIHNlcnZpY2VzVmVyc2lvbiA6IFwiMi4wLjBcIixcbiAgICBzZXJ2aWNlc0RhdGUgOiBcIjIwMTgtMDQtMDVcIixcbiAgICAvKipcbiAgICAgKiBNZXRob2RlIHBvdXIgcmFqb3V0ZXIgdW5lIGNsYXNzZSAvIG9iamV0IGF1IG5hbWVzcGFjZSBnbG9iYWwuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJOUyAtIG5vbSBzb3VzIGxlcXVlbCBvbiB2ZXV0IHByw6lzZW50ZXIgbGFcbiAgICAgKiAgICAgICAgY2xhc3NlIC8gb2JqZXQgKEdwLlwic3RyTlNcIikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gbGEgY2xhc3NlIC8gb2JqZXQgw6AgcmFqb3V0ZXIgYXUgTlMgZ2xvYmFsLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoaXNcbiAgICAgKi9cbiAgICBleHRlbmQgOiBmdW5jdGlvbiAoc3RyTlMsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0ck5TLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBwbDtcblxuICAgICAgICBwbCA9IHBhcnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHByb3BlcnR5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyZW50W3BhcnRzW2ldXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHBhcmVudFtwYXJ0c1tpXV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSBwbCAtIDE7XG4gICAgICAgICAgICBpZiAoaSA9PT0gbikge1xuICAgICAgICAgICAgICAgIHBhcmVudFtwYXJ0c1tpXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W3BhcnRzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIG9uIGRlY2xhcmUgbGVzIG5zIGRhbnMgcm9vdCBnbG9iYWxcbkdwLmV4dGVuZChcIlByb3RvY29sc1wiLCB7fSk7XG5HcC5leHRlbmQoXCJQcm90b2NvbHMuWEhSXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX1Byb3RvY29sc19YSFJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlc1wiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1NlcnZpY2VzX1NlcnZpY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuLy8gRXhwb3J0IEFsdGlcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkFsdGlSZXNwb25zZVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1NlcnZpY2VzX0FsdGlfUmVzcG9uc2VfbW9kZWxfQWx0aVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQWx0aS5FbGV2YXRpb25cIiwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19TZXJ2aWNlc19BbHRpX1Jlc3BvbnNlX21vZGVsX0VsZXZhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbi8vIEV4cG9ydCBBdXRvY29tcGxldGVcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkF1dG9Db21wbGV0ZVJlc3BvbnNlXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fU2VydmljZXNfQXV0b0NvbXBsZXRlX1Jlc3BvbnNlX21vZGVsX0F1dG9Db21wbGV0ZVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQXV0b0NvbXBsZXRlLlN1Z2dlc3RlZExvY2F0aW9uXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fU2VydmljZXNfQXV0b0NvbXBsZXRlX1Jlc3BvbnNlX21vZGVsX1N1Z2dlc3RlZExvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuLy8gRXhwb3J0IEF1dG9jb25mXG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5HZXRDb25maWdSZXNwb25zZVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX0F1dG9Db25mUmVzcG9uc2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuQ29uc3RyYWludFwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX0NvbnN0cmFpbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuRm9ybWF0XCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfRm9ybWF0X19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQ29uZmlnLkxheWVyXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfTGF5ZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuTGVnZW5kXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX0xlZ2VuZF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkNvbmZpZy5NZXRhZGF0YVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9NZXRhZGF0YV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkNvbmZpZy5PcmlnaW5hdG9yXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX09yaWdpbmF0b3JfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuU2VydmljZVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQ29uZmlnLlN0eWxlXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfX1NlcnZpY2VzX0F1dG9Db25mX1Jlc3BvbnNlX21vZGVsX1N0eWxlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQ29uZmlnLlRlcnJpdG9yeVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9UZXJyaXRvcnlfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuVGhlbWF0aWNcIiwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fU2VydmljZXNfQXV0b0NvbmZfUmVzcG9uc2VfbW9kZWxfVGhlbWF0aWNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuVGlsZU1hdHJpeFwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9UaWxlTWF0cml4X19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuQ29uZmlnLlRpbGVNYXRyaXhMaW1pdFwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9UaWxlTWF0cml4TGltaXRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Db25maWcuVGlsZU1hdHJpeFNldFwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE5X19TZXJ2aWNlc19BdXRvQ29uZl9SZXNwb25zZV9tb2RlbF9UaWxlTWF0cml4U2V0X19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuLy8gRXhwb3J0IEdlb2NvZGVcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkdlb2NvZGVSZXNwb25zZVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIwX19TZXJ2aWNlc19HZW9jb2RlX1Jlc3BvbnNlX21vZGVsX0dlb2NvZGVSZXNwb25zZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkdlb2NvZGUuR2VvY29kZWRMb2NhdGlvblwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIxX19TZXJ2aWNlc19HZW9jb2RlX1Jlc3BvbnNlX21vZGVsX0dlb2NvZGVkTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5HZW9jb2RlLkRpcmVjdEdlb2NvZGVkTG9jYXRpb25cIiwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMl9fU2VydmljZXNfR2VvY29kZV9SZXNwb25zZV9tb2RlbF9EaXJlY3RHZW9jb2RlZExvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuR2VvY29kZS5SZXZlcnNlR2VvY29kZWRMb2NhdGlvblwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIzX19TZXJ2aWNlc19HZW9jb2RlX1Jlc3BvbnNlX21vZGVsX1JldmVyc2VHZW9jb2RlZExvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuLy8gRXhwb3J0IElzb0N1cnZlXG5HcC5leHRlbmQoXCJTZXJ2aWNlcy5Jc29DdXJ2ZVJlc3BvbnNlXCIsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX1NlcnZpY2VzX1Byb2Nlc3NJc29DdXJ2ZV9SZXNwb25zZV9tb2RlbF9Qcm9jZXNzSXNvQ3VydmVSZXNwb25zZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbi8vIEV4cG9ydCBSb3V0ZVxuR3AuZXh0ZW5kKFwiU2VydmljZXMuUm91dGVSZXNwb25zZVwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI1X19TZXJ2aWNlc19Sb3V0ZV9SZXNwb25zZV9tb2RlbF9Sb3V0ZVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuR3AuZXh0ZW5kKFwiU2VydmljZXMuUm91dGUuUm91dGVJbnN0cnVjdGlvblwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI2X19TZXJ2aWNlc19Sb3V0ZV9SZXNwb25zZV9tb2RlbF9Sb3V0ZUluc3RydWN0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuLy8gRXhwb3J0IEVycmV1cnMgZXQgT3V0aWxzXG5HcC5leHRlbmQoXCJFcnJvclwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI4X19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcbkdwLmV4dGVuZChcIkhlbHBlclwiLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI5X19VdGlsc19IZWxwZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XG4vLyBFeHBvcnQgRGVmYXVsdFVybHNcbkdwLmV4dGVuZChcIlNlcnZpY2VzLkRlZmF1bHRVcmxcIiwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19TZXJ2aWNlc19EZWZhdWx0VXJsU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChHcCk7IC8vID0gZXhwb3J0IHsgR3AgYXMgZGVmYXVsdCB9O1xuXG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19BbHRpX0FsdGlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQXV0b0NvbmZfQXV0b0NvbmZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fR2VvY29kZV9HZW9jb2RlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0dlb2NvZGVfUmV2ZXJzZUdlb2NvZGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fQXV0b0NvbXBsZXRlX0F1dG9Db21wbGV0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19Sb3V0ZV9Sb3V0ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19Qcm9jZXNzSXNvQ3VydmVfUHJvY2Vzc0lzb0N1cnZlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwicG9pbnR8Y2lyY2xlfGJib3hcIiB9XSAqL1xuXG4vKipcbiogR2VvcG9ydGFsIHdlYiBzZXJ2aWNlcyBpbnZvY2F0aW9uIG5hbWVzcGFjZS5cbipcbiogQG1vZHVsZSBTZXJ2aWNlc1xuKiBAYWxpYXMgR3AuU2VydmljZXNcbiovXG5cblxuXG5cblxuXG5cblxudmFyIFNlcnZpY2VzID0ge1xuICAgIC8qKlxuICAgICAqIEFjY2VzcyB0byBHZW9wb3J0YWwgcmVzb3VyY2VzIG1ldGFkYXRhIGF2YWlsYWJsZXMgd2l0aCBvbmUgb3JlIHNldmVyYWwga2V5cywgdXNpbmcgW0F1dG8tY29uZmlndXJhdGlvbiBzZXJ2aWNlXXtAbGluayBodHRwczovL3d4cy5pZ24uZnIvQVBJS0VZL2F1dG9jb25mfSBvZiB0aGUgR2VvcG9ydGFsIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDb25maWdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm0sIG9idGFpbmVkIFtoZXJlXXtAbGluayBodHRwOi8vcHJvZmVzc2lvbm5lbHMuaWduLmZyL2lnbi9jb250cmF0c30uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblN1Y2Nlc3MgLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZ2V0dGluZyBzdWNjZXNzZnVsIHNlcnZpY2UgcmVzcG9uc2UuIFRha2VzIGEge0BsaW5rIEdwLlNlcnZpY2VzLkdldENvbmZpZ1Jlc3BvbnNlfSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgZXhjZXB0IGlmIFwicmF3UmVzcG9uc2VcIiBwYXJhbWV0ZXIgaXMgc2V0IHRvIHRydWUgOiBhIFN0cmluZyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmFpbHVyZV0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgdW5zdWNjZXNzZnVsIHNlcnZpY2UgcmVzcG9uc2VzICh0aW1lT3V0LCBtaXNzaW5nIHJpZ2h0cywgLi4uKS4gVGFrZXMgYSB7QGxpbmsgR3AuRXJyb3J9IG9iamVjdCBhcyBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVPdXQ9MF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFib3ZlIHdoaWNoIGEgdGltZU91dCByZXNwb25zZSB3aWxsIGJlIHJldHVybmVkIHdpdGggb25GYWlsdXJlIGNhbGxiYWNrIChzZWUgYWJvdmUpLiBEZWZhdWx0IHZhbHVlIGlzIDAgd2hpY2ggbWVhbnMgdGltZU91dCB3aWxsIG5vdCBiZSBoYW5kbGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmw9aHR0cCAocyk6Ly93eHMuaWduLmZyL0FQSUtFWS9hdXRvY29uZl0gLSBXZWIgc2VydmljZSBVUkwuIElmIHVzZWQsIG9wdGlvbnMuYXBpS2V5IHBhcmFtZXRlciBpcyBpZ25vcmVkLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9SlNPTlBdIC0gUHJvdG9jb2wgdXNlZCB0byBoYW5kbGUgZGlhbG9nIHdpdGggd2ViIHNlcnZpY2UuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0pTT05QJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pTT05QfSkgYW5kICdYSFInICh7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWE1MSHR0cFJlcXVlc3R9KS4gT25seSBYSFIgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGluIGEgTm9kZUpTIGVudmlyb25tZW50LiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJveHlVUkxdIC0gUHJveHkgVVJMIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgYW4gdW5kZXJseWluZyB3ZWIgc2VydmljZS4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeF0gLSBDYWxsYmFjayBmdW5jdGlvbiBuYW1lIHN1ZmZpeCB0byB1c2UgaW4gY2FzZSBvZiBhIEpTT05QIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSwgdG8gc2V0IHlvdXIgb3duIHN1ZmZpeCBpbnN0ZWFkIG9mIGF1dG8taW5jcmVtZW50LiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5odHRwTWV0aG9kPUdFVF0gLSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgaW4gY2FzZSBvZiBhIFhIUiBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSkuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0dFVCcgYW5kICdQT1NUJy4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi94bWxcIl0gLSBDb250ZW50LVR5cGUgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpIGFuZCBpZiBtZXRob2QgSFRUUCBpcyBQT1NULiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ0pTT05QJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzcG9uc2U9ZmFsc2VdIC0gU2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGltcGxpZXMgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBzZXJ2aWNlIHJlc3BvbnNlIGJ5IHlvdXJzZWxmIDogaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiB1bnBhcnNlZCBTdHJpbmcgaW4gb25TdWNjZXNzIGNhbGxiYWNrIHBhcmFtZXRlci4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQmVmb3JlUGFyc2VdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHNlcnZpY2UgcmVzcG9uc2UgYmVmb3JlIHBhcnNpbmcgKGFzIGFuIHVucGFyc2VkIFN0cmluZykuIFRha2VzIGEgU3RyaW5nIGFzIGEgcGFyYW1ldGVyICh0aGUgcmF3IHNlcnZpY2UgcmVzcG9uc2UpLiBSZXR1cm5zIGEgU3RyaW5nIHRoYXQgd2lsbCBiZSBwYXJzZWQgYXMgdGhlIHNlcnZpY2UgcmVzcG9uc2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnWEhSJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqL1xuICAgIGdldENvbmZpZyA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBhdXRvY29uZlNlcnZpY2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19BdXRvQ29uZl9BdXRvQ29uZl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG9wdGlvbnMpO1xuICAgICAgICBhdXRvY29uZlNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXR0aW5nIGVsZXZhdGlvbnMgaW4gb3IgYWxvbmcgb2Ygb25lIG9yIHNldmVyYWwgcG9pbnRzIG9uIGZyZW5jaCB0ZXJyaXRvcmllcyB1c2luZyB0aGUgW2VsZXZhdGlvbiBzZXJ2aWNlcyBvZiB0aGUgR2VvcG9ydGFsIFBsYXRmb3JtXXtAbGluayBodHRwczovL2dlb3NlcnZpY2VzLmlnbi5mci9kb2N1bWVudGF0aW9uL2dlb3NlcnZpY2VzL2FsdGkuaHRtbH0uPGJyLz5cbiAgICAgKiBUd28gdXNlIGNhc2VzIGFyZSBhdmFpbGFibGVzIDo8YnIvPlxuICAgICAqIDEuIGdldHRpbmcgZWxldmF0aW9ucyBvZiB0aGUgZ2l2ZW4gcG9pbnRzIDogZG9uJ3QgdXNlIHRoZSBvcHRpb25zLnNhbXBsaW5nIHBhcmFtZXRlciA7PGJyLz5cbiAgICAgKiAyLiBnZXR0aW5nIGEgcmVndWxhciBzZXQgb2YgZWxldmF0aW9ucyBhbG9uZyB0aGUgZ2l2ZW4gcG9pbnRzIDogdXNlIHRoZSBvcHRpb25zLnNhbXBsaW5nIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QWx0aXR1ZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm0sIG9idGFpbmVkIFtoZXJlXXtAbGluayBodHRwOi8vcHJvZmVzc2lvbm5lbHMuaWduLmZyL2lnbi9jb250cmF0c30uXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gb3B0aW9ucy5wb3NpdGlvbnMgLSBBcnJheSBvZiBwb3NpdGlvbnMgKHtsb246ZmxvYXQsIGxhdDpmbG9hdH0pIGV4cHJlc3NlZCBpbiBDUlM6ODQgY29vcmRpbmF0ZXMgc3lzdGVtLCB3aGVyZSB0byBnZXQgZWxldmF0aW9ucy4gNTAgcG9zaXRpb25zIG1heGltdW0gbWF5IGJlIGdpdmVuLiAyIHBvc2l0aW9ucyBtaW5pbXVtIGFyZSByZXF1aXJlZCBpZiB5b3UgdXNlIHRoZSBvcHRpb25zLnNhbXBsaW5nIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2FtcGxpbmddIC0gTnVtYmVyIG9mIHBvaW50cyB0byB1c2UgKGJldHdlZW4gMiBhbmQgNTAwMCkgaW4gb3JkZXIgdG8gY29tcHV0ZSBhbiBlbGV2YXRpb24gcGF0aC4gVGhlIHBvaW50cyBnaXZlbiB3aXRoIHRoZSBvcHRpb25zLnBvc2l0aW9ucyBwYXJhbWV0ZXIgYXJlIHVzZWQgdG8gZml4IHRoZSBwbGFuaW1ldHJpYyBwYXRoIGFsb25nIHdoaWNoIHRoZSBlbGV2YXRpb25zIHdpbGwgYmUgY29tcHV0ZWQuPGJyLz5cbiAgICAgKiBJZiBub3QgdXNlZCwgb25seSBlbGV2YXRpb25zIG9mIHRoZXNlIHBvc2l0aW9ucyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuem9ubHk9ZmFsc2VdIC0gU2V0IHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaWYgeW91IG9ubHkgd2FudCB0byBoYXZlIGVsZXZhdGlvbnMgcmV0dXJuZWQgd2l0aG91dCBjb3JyZXNwb25kaW5nIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdWNjZXNzIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGdldHRpbmcgc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlLiBUYWtlcyBhIHtAbGluayBHcC5TZXJ2aWNlcy5BbHRpUmVzcG9uc2V9IG9iamVjdCBhcyBhIHBhcmFtZXRlciwgZXhjZXB0IGlmIFwicmF3UmVzcG9uc2VcIiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHVuc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlcyAodGltZU91dCwgbWlzc2luZyByaWdodHMsIC4uLikuIFRha2VzIGEge0BsaW5rIEdwLkVycm9yfSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lT3V0PTBdIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhYm92ZSB3aGljaCBhIHRpbWVPdXQgcmVzcG9uc2Ugd2lsbCBiZSByZXR1cm5lZCB3aXRoIG9uRmFpbHVyZSBjYWxsYmFjayAoc2VlIGFib3ZlKS4gRGVmYXVsdCB2YWx1ZSBpcyAwIHdoaWNoIG1lYW5zIHRpbWVPdXQgd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2VydmVyVXJsPWh0dHAgKHMpOi8vd3hzLmlnbi5mci9BUElLRVkvYWx0aS9yZXN0L2VsZXZhdGlvbi5qc29uXSAtIFdlYiBzZXJ2aWNlIFVSTC4gSWYgdXNlZCwgb3B0aW9ucy5hcGlLZXkgcGFyYW1ldGVyIGlzIGlnbm9yZWQuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbD1YSFJdIC0gUHJvdG9jb2wgdXNlZCB0byBoYW5kbGUgZGlhbG9nIHdpdGggd2ViIHNlcnZpY2UuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0pTT05QJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pTT05QfSkgYW5kICdYSFInICh7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWE1MSHR0cFJlcXVlc3R9KS4gT25seSBYSFIgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGluIGEgTm9kZUpTIGVudmlyb25tZW50LiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJveHlVUkxdIC0gUHJveHkgVVJMIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZS4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeF0gLSBDYWxsYmFjayBmdW5jdGlvbiBuYW1lIHN1ZmZpeCB0byB1c2UgaW4gY2FzZSBvZiBhIEpTT05QIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSwgdG8gc2V0IHlvdXIgb3duIHN1ZmZpeCBpbnN0ZWFkIG9mIGF1dG8taW5jcmVtZW50LiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5odHRwTWV0aG9kPUdFVF0gLSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgaW4gY2FzZSBvZiBhIFhIUiBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSkuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0dFVCcgYW5kICdQT1NUJy4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi94bWxcIl0gLSBDb250ZW50LVR5cGUgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpIGFuZCBpZiBtZXRob2QgSFRUUCBpcyBQT1NULiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ0pTT05QJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzcG9uc2U9ZmFsc2VdIC0gU2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGltcGxpZXMgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBzZXJ2aWNlIHJlc3BvbnNlIGJ5IHlvdXJzZWxmIDogaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiB1bnBhcnNlZCBTdHJpbmcgaW4gb25TdWNjZXNzIGNhbGxiYWNrIHBhcmFtZXRlci4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQmVmb3JlUGFyc2VdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHNlcnZpY2UgcmVzcG9uc2UgYmVmb3JlIHBhcnNpbmcgKGFzIGFuIHVucGFyc2VkIFN0cmluZykuIFRha2VzIGEgU3RyaW5nIGFzIGEgcGFyYW1ldGVyICh0aGUgcmF3IHNlcnZpY2UgcmVzcG9uc2UpLiBSZXR1cm5zIGEgU3RyaW5nIHRoYXQgd2lsbCBiZSBwYXJzZWQgYXMgdGhlIHNlcnZpY2UgcmVzcG9uc2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnWEhSJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hcGk9J1JFU1QnXSAtIFdoYXQgQVBJIHRvIHVzZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIDogJ1JFU1QnIG9yICdXUFMnLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm91dHB1dEZvcm1hdD0neG1sJ10gLSBPdXRwdXQgZm9ybWF0IGZvciB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIHJlc3BvbnNlIDogJ3htbCcgb3IgJ2pzb24nLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICovXG4gICAgZ2V0QWx0aXR1ZGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0aVNlcnZpY2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19BbHRpX0FsdGlfX1tcImFcIiAvKiBkZWZhdWx0ICovXShvcHRpb25zKTtcbiAgICAgICAgYWx0aVNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0dGluZyBwb3NpdG9uIG9mIGEgZ2VvZ3JhcGhpYyBpZGVudGlmaWVyIChwbGFjZXMgbmFtZXMsIGFkZHJlc3MsIGNhZGFzdHJhbCBwYXJjZWwsIG90aGVyLi4uKSB1c2luZyB0aGUgW2dlb2NvZGluZyB3ZWIgc2VydmljZSBvZiB0aGUgR2VvcG9ydGFsIFBsYXRmb3JtXXtAbGluayBodHRwczovL2dlb3NlcnZpY2VzLmlnbi5mci9kb2N1bWVudGF0aW9uL2dlb3NlcnZpY2VzL2dlb2NvZGFnZS5odG1sfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogR3AuU2VydmljZXMuZ2VvY29kZSAoe1xuICAgICAqICAgICBhcGlLZXkgOiBcImpoeXZpMGZnbW51eHZmdjB6anpvcnZkblwiLFxuICAgICAqICAgICBsb2NhdGlvbiA6IFwiNzMgYXZlbnVlIGRlIFBhcmlzLCBTYWludC1NYW5kw6lcIixcbiAgICAgKiAgICAgLy8gdHJhaXRlbWVudCBkZXMgcmVzdWx0YXRzXG4gICAgICogICAgIG9uU3VjY2VzcyAgOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhcImZvdW5kICh4OlwiK3Jlc3VsdC5wb3NpdGlvbi54K1wiLCB5OlwiK3Jlc3VsdC5wb3NpdGlvbi55K1wiKVwiKSA7XG4gICAgICogICAgIH1cbiAgICAgKiB9KSA7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2VvY29kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZnVuY3Rpb24gY2FsbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBBY2Nlc3Mga2V5IHRvIEdlb3BvcnRhbCBwbGF0Zm9ybSwgb2J0YWluZWQgW2hlcmVde0BsaW5rIGh0dHA6Ly9wcm9mZXNzaW9ubmVscy5pZ24uZnIvaWduL2NvbnRyYXRzfS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG9wdGlvbnMubG9jYXRpb24gLSBHZW9ncmFwaGljIGlkZW50aWZpZXIgdG8gbG9jYXRlLiBNYXkgYmUgcHJvdmlkZWQgYXMgYSBzaW5nbGUgU3RyaW5nIG9yIGEgc3RydWN0dXJlZCBPYmplY3QgZm9yIGFuIGFkZHJlc3Mgc2VhcmNoLiBJbiB0aGlzIGxhc3QgY2FzZSwgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBhdmFpbGFpYmxlcy5cbiAgICAgKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sb2NhdGlvbi5udW1iZXJdIC0gU3RyZWV0IG51bWJlci5cbiAgICAgKiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sb2NhdGlvbi5zdHJlZXRdIC0gU3RyZWV0IG5hbWUuXG4gICAgICogICAgICBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubG9jYXRpb24uY2l0eV0gLSBDaXR5IG5hbWUuXG4gICAgICogICAgICBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9jYXRpb24ucG9zdGFsQ29kZV0gLSBQb3N0YWwgQ29kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zXSAtIEFkZGl0aW9uYWwgZmlsdGVycyB0byBhcHBseSB0byBzZWFyY2guIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBtYXkgYmUgZ2l2ZW4uXG4gICAgICogICAgICBAcGFyYW0ge0dwLkJCb3h9IFtvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveF0gLSBCb3VuZGluZyBib3ggd2hlcmUgdG8gcGVyZm9ybSB0aGUgc2VhcmNoLiBQcm9wZXJ0aWVzIGV4cHJlc3NlZCBpbiBvcHRpb25zLnNycyBjb29yZGluYXRlcyBzeXN0ZW0uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGVdIC0gR2VvZ3JhcGhpY2FsIGlkZW50aWZpZXIgdHlwZXMgdG8gc2VhcmNoLiBWYWx1ZXMgY3VycmVudGx5IGF2YWlsYWJsZXMgYXJlIDogXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiBmb3IgcGxhY2UgbmFtZXMsIFwiU3RyZWV0QWRkcmVzc1wiIGZvciBhZGRyZXNzIHNlYXJjaCwgXCJDYWRhc3RyYWxQYXJjZWxcIiBmb3IgQ2FkYXN0cmFsIHBhcmNlbHMgc2VhcmNoLiBEZWZhdWx0IGlzIFwiU3RyZWV0QWRkcmVzc1wiLlxuICAgICAqXG4gICAgICogICAgICBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy5bcHJvcF1dIC0gQWRkaXRpb25uYWwgcHJvcGVydGllcyB0byBmaWx0ZXIgc2VhcmNoLiBQcm9wZXJ0aWVzIGRlcGVuZHMgb24gb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUsIGFuZCB2YWx1ZXMgdHlwZSBzaG91bGQgYmUgXCJTdHJpbmdcIi5cbiAgICAgKiAgICAgIDxici8+PGJyLz5cbiAgICAgKiAgICAgIENvbW1vbiBQcm9wZXJ0aWVzIGF2YWlsYWJsZXMgZm9yIGFsbCBzZWFyY2ggdHlwZXMgOjxici8+XG4gICAgICogICAgICBcIm11bmljaXBhbGl0eVwiLCBcImluc2VlXCIsIFwiZGVwYXJ0bWVudFwiLlxuICAgICAqICAgICAgPGJyLz48YnIvPlxuICAgICAqICAgICAgUHJvcGVydGllcyBhdmFpbGFibGVzIGZvciBhZGRyZXNzIHNlYXJjaCA6PGJyLz5cbiAgICAgKiAgICAgIFwicXVhbGl0eVwiLCBcIklEXCIsIFwiSURfVFJcIiBhbmQgXCJ0ZXJyaXRvcnlcIi5cbiAgICAgKiAgICAgIDxici8+PGJyLz5cbiAgICAgKiAgICAgIFByb3BlcnRpZXMgYXZhaWxhYmxlcyBmb3IgcGxhY2UgbmFtZXMgc2VhcmNoIDo8YnIvPlxuICAgICAqICAgICAgXCJpbXBvcnRhbmNlXCIsIFwibmF0dXJlXCIgYW5kIFwidGVycml0b3J5XCIuXG4gICAgICogICAgICA8YnIvPjxici8+XG4gICAgICogICAgICBQcm9wZXJ0aWVzIGF2YWlsYWJsZXMgZm9yIGNhZGFzdHJhbCBwYXJjZWxzIHNlYXJjaCA6PGJyLz5cbiAgICAgKiAgICAgIFwic2hlZXRcIiwgXCJzZWN0aW9uXCIsIGFuZCBcImFic29yYmVkY2l0eVwiLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzID0gMjVdIC0gTWF4aW11bSBudW1iZXIgb2YgcmVzcG9uc2VzLiBEZWZhdWx0IHVuZGVybHlpbmcgc2VydmljZSB2YWx1ZSBhcHBsaWVzICgyNSkgaWYgbm90IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV0dXJuRnJlZUZvcm0gPSBmYWxzZV0gLSBTZXQgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpZiB5b3Ugd2lzaCB0byBoYXZlIGFuIGFkZHJlc3MgcmV0dXJuZWQgaW4gYSBzaW5nbGUgU3RyaW5nICh1bnN0cnVjdHVyZWQpLiBJZiB1bnNldCwgZGVmYXVsdCB1bmRlcmx5aW5nIHNlcnZpY2UgdmFsdWUgKGZhbHNlKSBhcHBsaWVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zcnMgPSBFUFNHOjQzMjZdIC0gQ29vcmRpbmF0ZXMgU3lzdGVtIHVzZWQgdG8gZXhwcmVzIGNvb3JkaW5hdGVzIGZvciBwYXJhbWV0ZXJzIGFuZCByZXNwb25zZXMuIERlZmF1bHQgdW5kZXJseWluZyBzZXJ2aWNlIHZhbHVlIChFUFNHOjQzMjYpIGFwcGxpZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblN1Y2Nlc3MgLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZ2V0dGluZyBzdWNjZXNzZnVsIHNlcnZpY2UgcmVzcG9uc2UuIFRha2VzIGEge0BsaW5rIEdwLlNlcnZpY2VzLkdlb2NvZGVSZXNwb25zZX0gb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGV4Y2VwdCBpZiBcInJhd1Jlc3BvbnNlXCIgaXMgc2V0IHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25GYWlsdXJlXSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBoYW5kbGluZyB1bnN1Y2Nlc3NmdWwgc2VydmljZSByZXNwb25zZXMgKHRpbWVPdXQsIG1pc3NpbmcgcmlnaHRzLCAuLi4pLiBUYWtlcyBhIHtAbGluayBHcC5FcnJvcn0gb2JqZWN0IGFzIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dD0wXSAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWJvdmUgd2hpY2ggYSB0aW1lT3V0IHJlc3BvbnNlIHdpbGwgYmUgcmV0dXJuZWQgd2l0aCBvbkZhaWx1cmUgY2FsbGJhY2sgKHNlZSBhYm92ZSkuIERlZmF1bHQgdmFsdWUgaXMgMCB3aGljaCBtZWFucyB0aW1lT3V0IHdpbGwgbm90IGJlIGhhbmRsZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNlcnZlclVybD1odHRwIChzKTovL3d4cy5pZ24uZnIvQVBJS0VZL2dlb3BvcnRhaWwvb2xzXSAtIFdlYiBzZXJ2aWNlIFVSTC4gSWYgdXNlZCwgb3B0aW9ucy5hcGlLZXkgcGFyYW1ldGVyIGlzIGlnbm9yZWQuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm90b2NvbD1YSFJdIC0gUHJvdG9jb2wgdXNlZCB0byBoYW5kbGUgZGlhbG9nIHdpdGggd2ViIHNlcnZpY2UuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0pTT05QJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0pTT05QfSkgYW5kICdYSFInICh7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWE1MSHR0cFJlcXVlc3R9KS4gT25seSBYSFIgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGluIGEgTm9kZUpTIGVudmlyb25tZW50LiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJveHlVUkxdIC0gUHJveHkgVVJMIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZS4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeF0gLSBDYWxsYmFjayBmdW5jdGlvbiBuYW1lIHN1ZmZpeCB0byB1c2UgaW4gY2FzZSBvZiBhIEpTT05QIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSwgdG8gc2V0IHlvdXIgb3duIHN1ZmZpeCBpbnN0ZWFkIG9mIGF1dG8taW5jcmVtZW50LiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5odHRwTWV0aG9kPUdFVF0gLSBIVFRQIG1ldGhvZCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgaW4gY2FzZSBvZiBhIFhIUiBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSkuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ0dFVCcgYW5kICdQT1NUJy4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGU9XCJhcHBsaWNhdGlvbi94bWxcIl0gLSBDb250ZW50LVR5cGUgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpIGFuZCBpZiBtZXRob2QgSFRUUCBpcyBQT1NULiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ0pTT05QJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzcG9uc2U9ZmFsc2VdIC0gU2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGltcGxpZXMgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBzZXJ2aWNlIHJlc3BvbnNlIGJ5IHlvdXJzZWxmIDogaXQgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiB1bnBhcnNlZCBTdHJpbmcgaW4gb25TdWNjZXNzIGNhbGxiYWNrIHBhcmFtZXRlci4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQmVmb3JlUGFyc2VdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHNlcnZpY2UgcmVzcG9uc2UgYmVmb3JlIHBhcnNpbmcgKGFzIGFuIHVucGFyc2VkIFN0cmluZykuIFRha2VzIGEgU3RyaW5nIGFzIGEgcGFyYW1ldGVyICh0aGUgcmF3IHNlcnZpY2UgcmVzcG9uc2UpLiBSZXR1cm5zIGEgU3RyaW5nIHRoYXQgd2lsbCBiZSBwYXJzZWQgYXMgdGhlIHNlcnZpY2UgcmVzcG9uc2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnWEhSJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqL1xuICAgIGdlb2NvZGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZ2VvY29kZVNlcnZpY2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19HZW9jb2RlX0dlb2NvZGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXShvcHRpb25zKTtcbiAgICAgICAgZ2VvY29kZVNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0cmlldmluZyBnZW9ncmFwaGljYWwgaWRlbnRpZmllcnMgKHBsYWNlIG5hbWVzLCBhZGRyZXNzLCBjYWRhc3RyYWwgcGFyY2VscywgLi4uKSBuZWFyIGEgZ2l2ZW4gcG9zaXRpb24sIHVzaW5nIHRoZSBbcmV2ZXJzZSBnZW9jb2Rpbmcgd2ViIHNlcnZpY2Ugb2YgdGhlIEdlb3BvcnRhbCBQbGF0Zm9ybV17QGxpbmsgaHR0cHM6Ly9nZW9zZXJ2aWNlcy5pZ24uZnIvZG9jdW1lbnRhdGlvbi9nZW9zZXJ2aWNlcy9nZW9jb2RhZ2UtaW52ZXJzZS5odG1sfS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmV2ZXJzZUdlb2NvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm0sIG9idGFpbmVkIFtoZXJlXXtAbGluayBodHRwOi8vcHJvZmVzc2lvbm5lbHMuaWduLmZyL2lnbi9jb250cmF0c30uXG4gICAgICogQHBhcmFtIHtHcC5Qb2ludH0gb3B0aW9ucy5wb3NpdGlvbiAtIFJlZmVyZW5jZSBwb3NpdGlvbiB3aGVyZSB0byBzZWFyY2ggZ2VvZ3JhcGhpY2FsIGlkZW50aWZpZXJzLiBJdHMgY29vcmRpbmF0ZXMgYXJlIGV4cHJlc3NlZCBpbiB0aGUgY29vcmRpbmF0ZXMgc3lzdGVtIGdpdmVuIHdpdGggb3B0aW9ucy5zcnMgcGFyYW1ldGVyLiAoZGVmYXVsdCBpcyBDUlM6ODQsIHRoYXQgbWVhbnMgcG9zaXRpb24ueCBpcyB0aGUgbG9uZ2l0dWRlIGFuZCBwb3NpdGlvbi55IHRoZSBsYXRpdHVkZSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmlsdGVyT3B0aW9uc10gLSBBZGRpdGlvbmFsIGZpbHRlcnMgdG8gYXBwbHkgdG8gc2VhcmNoLiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgbWF5IGJlIGdpdmVuLlxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlXSAtIEdlb2dyYXBoaWNhbCBpZGVudGlmaWVyIHR5cGVzIHRvIHNlYXJjaC4gVmFsdWVzIGN1cnJlbnRseSBhdmFpbGFibGVzIGFyZSA6IFwiUG9zaXRpb25PZkludGVyZXN0XCIgZm9yIHBsYWNlIG5hbWVzLCBcIlN0cmVldEFkZHJlc3NcIiBmb3IgYWRkcmVzcyBzZWFyY2gsIFwiQ2FkYXN0cmFsUGFyY2VsXCIgZm9yIENhZGFzdHJhbCBwYXJjZWxzIHNlYXJjaC4gRGVmYXVsdCBpcyBcIlN0cmVldEFkZHJlc3NcIi5cbiAgICAgKiAgICAgIEBwYXJhbSB7R3AuQkJveH0gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy5iYm94XSAtIEJvdW5kaW5nIGJveCB3aGVyZSB0byBwZXJmb3JtIHRoZSBzZWFyY2guIEV4cHJlc3NlZCBpbiBvcHRpb25zLnNycyBjb29yZGluYXRlcyBzeXN0ZW0uXG4gICAgICogICAgICBAcGFyYW0ge0dwLkNpcmNsZX0gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGVdIC0gQ2lyY2xlIHdoZXJlIHRvIHBlcmZvcm0gdGhlIHNlYXJjaC4gRXhwcmVzc2VkIGluIG9wdGlvbnMuc3JzIGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxHcC5Qb2ludD59IFtvcHRpb25zLmZpbHRlck9wdGlvbnMucG9seWdvbl0gLSBQb2x5Z29uIHdoZXJlIHRvIHBlcmZvcm0gdGhlIHNlYXJjaC4gRXhwcmVzc2VkIGluIG9wdGlvbnMuc3JzIGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bVJlc3BvbnNlc10gLSBNYXhpbXVtIG51bWJlciBvZiByZXNwb25zZXMuIERlZmF1bHQgdW5kZXJseWluZyBzZXJ2aWNlIHZhbHVlIGFwcGxpZXMgKDI1KSBpZiBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXR1cm5GcmVlRm9ybSA9IGZhbHNlXSAtIFNldCB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlmIHlvdSB3aXNoIHRvIGhhdmUgYW4gYWRkcmVzcyByZXR1cm5lZCBpbiBhIHNpbmdsZSBTdHJpbmcgKHVuc3RydWN0dXJlZCkuIElmIHVuc2V0LCBkZWZhdWx0IHVuZGVybHlpbmcgc2VydmljZSB2YWx1ZSAoZmFsc2UpIGFwcGxpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNycyA9IENSUzo4NF0gLSBDb29yZGluYXRlcyBTeXN0ZW0gdXNlZCB0byBleHByZXNzIGNvb3JkaW5hdGVzIGZvciBwYXJhbWV0ZXJzIGFuZCByZXNwb25zZXMuIE9ubHkgV0dTIDg0IGdlb2dyYXBoaWNhbCBwb3NpdGlvbmluZyBpcyBzdXBwb3J0ZWQuIFRoZXJlZm9yZSwgdHdvIHZhbHVlcyBhcmUgYWxsb3dlZCA6IFwiQ1JTOjg0XCIgKHBvc2l0aW9uLnggaXMgdGhlIGxvbmdpdHVkZSBhbmQgcG9zaXRpb24ueSB0aGUgbGF0aXR1ZGUpIGFuZCBcIkVQU0c6NDMyNlwiIChwb3NpdGlvbi54IGlzIHRoZSBsYXRpdHVkZSBhbmQgcG9zaXRpb24ueSB0aGUgbG9uZ2l0dWRlKSAuIERlZmF1bHQgaXMgQ1JTOjg0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdWNjZXNzIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGdldHRpbmcgc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlLiBUYWtlcyBhIHtAbGluayBHcC5TZXJ2aWNlcy5HZW9jb2RlUmVzcG9uc2V9IG9iamVjdCBhcyBhIHBhcmFtZXRlciBleGNlcHQgaWYgXCJyYXdSZXNwb25zZVwiIGlzIHNldCB0byB0cnVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmFpbHVyZV0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgdW5zdWNjZXNzZnVsIHNlcnZpY2UgcmVzcG9uc2VzICh0aW1lT3V0LCBtaXNzaW5nIHJpZ2h0cywgLi4uKS4gVGFrZXMgYSB7QGxpbmsgR3AuRXJyb3J9IG9iamVjdCBhcyBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVPdXQ9MF0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFib3ZlIHdoaWNoIGEgdGltZU91dCByZXNwb25zZSB3aWxsIGJlIHJldHVybmVkIHdpdGggb25GYWlsdXJlIGNhbGxiYWNrIChzZWUgYWJvdmUpLiBEZWZhdWx0IHZhbHVlIGlzIDAgd2hpY2ggbWVhbnMgdGltZU91dCB3aWxsIG5vdCBiZSBoYW5kbGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmw9aHR0cCAocyk6Ly93eHMuaWduLmZyL0FQSUtFWS9nZW9wb3J0YWlsL29sc10gLSBXZWIgc2VydmljZSBVUkwuIElmIHVzZWQsIG9wdGlvbnMuYXBpS2V5IHBhcmFtZXRlciBpcyBpZ25vcmVkLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9WEhSXSAtIFByb3RvY29sIHVzZWQgdG8gaGFuZGxlIGRpYWxvZyB3aXRoIHdlYiBzZXJ2aWNlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdKU09OUCcgKHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUH0pIGFuZCAnWEhSJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hNTEh0dHBSZXF1ZXN0fSkuIE9ubHkgWEhSIHByb3RvY29sIGlzIHN1cHBvcnRlZCBpbiBhIE5vZGVKUyBlbnZpcm9ubWVudC4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3h5VVJMXSAtIFByb3h5IFVSTCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FsbGJhY2tTdWZmaXhdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBzdWZmaXggdG8gdXNlIGluIGNhc2Ugb2YgYSBKU09OUCBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSksIHRvIHNldCB5b3VyIG93biBzdWZmaXggaW5zdGVhZCBvZiBhdXRvLWluY3JlbWVudC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdYSFInIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaHR0cE1ldGhvZD1HRVRdIC0gSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdHRVQnIGFuZCAnUE9TVCcuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCJdIC0gQ29udGVudC1UeXBlIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIGEgWEhSIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSBhbmQgaWYgbWV0aG9kIEhUVFAgaXMgUE9TVC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3BvbnNlPWZhbHNlXSAtIFNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpbXBsaWVzIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgc2VydmljZSByZXNwb25zZSBieSB5b3Vyc2VsZiA6IGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gdW5wYXJzZWQgU3RyaW5nIGluIG9uU3VjY2VzcyBjYWxsYmFjayBwYXJhbWV0ZXIuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJlZm9yZVBhcnNlXSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBzZXJ2aWNlIHJlc3BvbnNlIGJlZm9yZSBwYXJzaW5nIChhcyBhbiB1bnBhcnNlZCBTdHJpbmcpLiBUYWtlcyBhIFN0cmluZyBhcyBhIHBhcmFtZXRlciAodGhlIHJhdyBzZXJ2aWNlIHJlc3BvbnNlKS4gUmV0dXJucyBhIFN0cmluZyB0aGF0IHdpbGwgYmUgcGFyc2VkIGFzIHRoZSBzZXJ2aWNlIHJlc3BvbnNlLiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICByZXZlcnNlR2VvY29kZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXZlcnNlR2VvY29kZVNlcnZpY2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19HZW9jb2RlX1JldmVyc2VHZW9jb2RlX19bXCJhXCIgLyogZGVmYXVsdCAqL10ob3B0aW9ucyk7XG4gICAgICAgIHJldmVyc2VHZW9jb2RlU2VydmljZS5jYWxsKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXR0aW5nIHN1Z2dlc3Rpb25zIG9mIHByb2JhYmxlIHBsYWNlcyBuYW1lcyBvciBhZGRyZXNzIGJhc2VkIG9uIHVuY29tcGxldGUgdGV4dHMsIHVzaW5nIHRoZSBbYXV0b2NvbXBsZXRpb24gc2VydmljZSBvZiB0aGUgR2VvcG9ydGFsIFBsYXRmb3JtXXtAbGluayBodHRwczovL2dlb3NlcnZpY2VzLmlnbi5mci9kb2N1bWVudGF0aW9uL2dlb3NlcnZpY2VzL2F1dG9jb21wbGV0aW9uLmh0bWx9XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGF1dG9Db21wbGV0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZnVuY3Rpb24gY2FsbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBBY2Nlc3Mga2V5IHRvIEdlb3BvcnRhbCBwbGF0Zm9ybSwgb2J0YWluZWQgW2hlcmVde0BsaW5rIGh0dHA6Ly9wcm9mZXNzaW9ubmVscy5pZ24uZnIvaWduL2NvbnRyYXRzfS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50ZXh0IC0gVGV4dCBpbnB1dCB0byBjb21wbGV0ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUgPSBcIlN0cmVldEFkZHJlc3NcIl0gLSBTdWdnZXN0aW9uIHR5cGVzIHRvIHByb3ZpZGUgOiBhZGRyZXNzIChcIlN0cmVldEFkZHJlc3NcIikgYW5kL29yIHBsYWNlIG5hbWUgKFwiUG9zaXRpb25PZkludGVyZXN0XCIpLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5XSAtIFBsYWNlcyB3aGVyZSB0byBsaW1pdCB0aGUgc2VhcmNoIG9mIHN1Z2dlc3Rpb25zIDogXCJNRVRST1BPTEVcIiAoQ29yc2ljYSBhbmQgbWV0cm9wb2xpdGFuIEZyYW5jZSksIFwiRE9NVE9NXCIgKEZyZW5jaCBvdmVyc2VhcyBkZXBhcnRtZW50cyBhbmQgdGVycml0b3JpZXMpLCBvciBhbiBJTlNFRSBjb2RlIG9mIGEgZGVwYXJ0bWVudC4gTm8gbGltaXRhdGlvbiBieSBkZWZhdWx0LiBGb3IgaW5zdGFuY2UgOiBbJ01FVFJPUE9MRScsICczMSddXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heGltdW1SZXNwb25zZXMgPSAxMF0gLSBNYXhpbXVtIG51bWJlciBvZiByZXNwb25zZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblN1Y2Nlc3MgLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZ2V0dGluZyBzdWNjZXNzZnVsIHNlcnZpY2UgcmVzcG9uc2UuIFRha2VzIGEge0BsaW5rIEdwLlNlcnZpY2VzLkF1dG9Db21wbGV0ZVJlc3BvbnNlfSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgZXhjZXB0IGlmIFwicmF3UmVzcG9uc2VcIiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHVuc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlcyAodGltZU91dCwgbWlzc2luZyByaWdodHMsIC4uLikuIFRha2VzIGEge0BsaW5rIEdwLkVycm9yfSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lT3V0PTBdIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhYm92ZSB3aGljaCBhIHRpbWVPdXQgcmVzcG9uc2Ugd2lsbCBiZSByZXR1cm5lZCB3aXRoIG9uRmFpbHVyZSBjYWxsYmFjayAoc2VlIGFib3ZlKS4gRGVmYXVsdCB2YWx1ZSBpcyAwIHdoaWNoIG1lYW5zIHRpbWVPdXQgd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc2VydmVyVXJsPWh0dHAgKHMpOi8vd3hzLmlnbi5mci9BUElLRVkvb2xzL2FwaXMvY29tcGxldGlvbl0gLSBXZWIgc2VydmljZSBVUkwuIElmIHVzZWQsIG9wdGlvbnMuYXBpS2V5IHBhcmFtZXRlciBpcyBpZ25vcmVkLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9WEhSXSAtIFByb3RvY29sIHVzZWQgdG8gaGFuZGxlIGRpYWxvZyB3aXRoIHdlYiBzZXJ2aWNlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdKU09OUCcgKHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUH0pIGFuZCAnWEhSJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hNTEh0dHBSZXF1ZXN0fSkuIE9ubHkgWEhSIHByb3RvY29sIGlzIHN1cHBvcnRlZCBpbiBhIE5vZGVKUyBlbnZpcm9ubWVudC4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3h5VVJMXSAtIFByb3h5IFVSTCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FsbGJhY2tTdWZmaXhdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBzdWZmaXggdG8gdXNlIGluIGNhc2Ugb2YgYSBKU09OUCBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSksIHRvIHNldCB5b3VyIG93biBzdWZmaXggaW5zdGVhZCBvZiBhdXRvLWluY3JlbWVudC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdYSFInIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaHR0cE1ldGhvZD1HRVRdIC0gSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdHRVQnIGFuZCAnUE9TVCcuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCJdIC0gQ29udGVudC1UeXBlIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIGEgWEhSIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSBhbmQgaWYgbWV0aG9kIEhUVFAgaXMgUE9TVC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3BvbnNlPWZhbHNlXSAtIFNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpbXBsaWVzIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgc2VydmljZSByZXNwb25zZSBieSB5b3Vyc2VsZiA6IGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gdW5wYXJzZWQgU3RyaW5nIGluIG9uU3VjY2VzcyBjYWxsYmFjayBwYXJhbWV0ZXIuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJlZm9yZVBhcnNlXSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBzZXJ2aWNlIHJlc3BvbnNlIGJlZm9yZSBwYXJzaW5nIChhcyBhbiB1bnBhcnNlZCBTdHJpbmcpLiBUYWtlcyBhIFN0cmluZyBhcyBhIHBhcmFtZXRlciAodGhlIHJhdyBzZXJ2aWNlIHJlc3BvbnNlKS4gUmV0dXJucyBhIFN0cmluZyB0aGF0IHdpbGwgYmUgcGFyc2VkIGFzIHRoZSBzZXJ2aWNlIHJlc3BvbnNlLiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBhdXRvQ29tcGxldGUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgYXV0b0NvbXBsZXRlU2VydmljZSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0F1dG9Db21wbGV0ZV9BdXRvQ29tcGxldGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXShvcHRpb25zKTtcbiAgICAgICAgYXV0b0NvbXBsZXRlU2VydmljZS5jYWxsKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXR0aW5nIGEgcm91dGUgZnJvbSBvbmUgcG9pbnQgdG8gYW5vdGhlciB1c2luZyB0aGUgW3JvdXRlIHNlcnZpY2Ugb2YgdGhlIEdlb3BvcnRhbCBQbGF0Zm9ybV17QGxpbmsgaHR0cHM6Ly9nZW9zZXJ2aWNlcy5pZ24uZnIvZG9jdW1lbnRhdGlvbi9nZW9zZXJ2aWNlcy9pdGluZXJhaXJlcy5odG1sfS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgcm91dGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBpS2V5IC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm0sIG9idGFpbmVkIFtoZXJlXXtAbGluayBodHRwOi8vcHJvZmVzc2lvbm5lbHMuaWduLmZyL2lnbi9jb250cmF0c30uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJvdXRlUHJlZmVyZW5jZSA9IFwiZmFzdGVzdFwiXSAtIEluZGljYXRlcyB0aGUgd2F5IHRvIGNvbXB1dGUgdGhlIHJvdXRlIDogXCJmYXN0ZXN0XCIgKHRpbWUgb3B0aW1pc2F0aW9uKSBvciBcInNob3J0ZXN0XCIgKGRpc3RhbmNlIG9wdGltaXNhdGlvbikuXG4gICAgICogQHBhcmFtIHtHcC5Qb2ludH0gb3B0aW9ucy5zdGFydFBvaW50IC0gU3RhcnQgcG9pbnQgb2YgdGhlIHJvdXRlLiBFeHByZXNzZWQgaW4gQ1JTOjg0IGNvb3JkaW5hdGVzIHN5c3RlbSAoc3RhcnRQb2ludC54IGNvcnJlc3BvbmRzIHRvIGxvbmdpdHVkZSwgc3RhcnRQb2ludC55IGNvcnJlc3BvbmRzIHRvIGxhdGl0dWRlKS5cbiAgICAgKiBAcGFyYW0ge0dwLlBvaW50fSBvcHRpb25zLmVuZFBvaW50IC0gRW5kIHBvaW50IG9mIHRoZSByb3V0ZS4gRXhwcmVzc2VkIGluIENSUzo4NCBjb29yZGluYXRlcyBzeXN0ZW0gKGVuZFBvaW50LnggY29ycmVzcG9uZHMgdG8gbG9uZ2l0dWRlLCBlbmRQb2ludC55IGNvcnJlc3BvbmRzIHRvIGxhdGl0dWRlKS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxHcC5Qb2ludD59IFtvcHRpb25zLnZpYVBvaW50c10gLSBPcmRlcmVkIHZpYSBQb2ludHMgb2YgdGhlIHJvdXRlLiBFeHByZXNzZWQgaW4gQ1JTOjg0IGNvb3JkaW5hdGVzIHN5c3RlbSAodmlhUG9pbnRzW2ldLnggY29ycmVzcG9uZHMgdG8gbG9uZ2l0dWRlLCB2aWFQb2ludHNbaV0ueSBjb3JyZXNwb25kcyB0byBsYXRpdHVkZSkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmdyYXBoID0gXCJWb2l0dXJlXCJdIC0gVXNlciBwcm9maWxlIHRvIHVzZSB0byBjb21wdXRlIHRoZSByb3V0ZSA6IFwiVm9pdHVyZVwiICh1c2luZyBhIHZlaGljdWxlKSBvciBcIlBpZXRvblwiIChwZWRlc3RyaWFuKS4gSGFzIGFuIGluZmx1ZW5jZSBvbiB0aGUga2luZCBvZiByb2FkcyB0aGUgcm91dGUgbWF5IHVzZSBhbmQgdGhlIGF2ZXJhZ2Ugc3BlZWQuXG4gICAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMuZXhjbHVzaW9uc10gLSBJbmRpY2F0ZXMgaWYgcm91dGUgaGFzIHRvIGF2b2lkIHNvbWUgZmVhdHVyZXMgKFwidG9sbFwiLCBcImJyaWRnZVwiIG9yIFwidHVubmVsXCIpLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ2VvbWV0cnlJbkluc3RydWN0aW9ucyA9IGZhbHNlXSAtIEluZGljYXRlcyBpZiByb3V0ZSBnZW9tZXRyeSBoYXMgdG8gYmUgYWxzbyByZXR1cm5lZCB3aXRoIHJvdXRlIGluc3RydWN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnByb3ZpZGVCb3VuZGluZ0JveCA9IHRydWVdIC0gSW5kaWNhdGVzIGlmIHJvdXRlIGluc3RydWN0aW9ucyBoYXMgdG8gYmUgbG9jYWxpc2VkIHdpdGggYSBCQk9YIGluIHRoZSByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGlzdGFuY2VVbml0ID0gXCJrbVwiXSAtIFRoZSB1bml0IHVzZWQgdG8gcHJvdmlkZSBkaXN0YW5jZXMgaW4gdGhlIHJlc3BvbnNlIChcIm1cIiBvciBcImttXCIpLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdWNjZXNzIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGdldHRpbmcgc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlLiBUYWtlcyBhIHtAbGluayBHcC5TZXJ2aWNlcy5Sb3V0ZVJlc3BvbnNlfSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgZXhjZXB0IGlmIFwicmF3UmVzcG9uc2VcIiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHVuc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlcyAodGltZU91dCwgbWlzc2luZyByaWdodHMsIC4uLikuIFRha2VzIGEge0BsaW5rIEdwLkVycm9yfSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lT3V0PTBdIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhYm92ZSB3aGljaCBhIHRpbWVPdXQgcmVzcG9uc2Ugd2lsbCBiZSByZXR1cm5lZCB3aXRoIG9uRmFpbHVyZSBjYWxsYmFjayAoc2VlIGFib3ZlKS4gRGVmYXVsdCB2YWx1ZSBpcyAwIHdoaWNoIG1lYW5zIHRpbWVPdXQgd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3V0cHV0Rm9ybWF0PSdqc29uJ10gLSBPdXRwdXQgZm9ybWF0IChcImpzb25cIiBvciBcInhtbFwiKSB0byB1c2UgZm9yIHVuZGVybHlpbmcgd2ViU2VydmljZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmw9aHR0cCAocyk6Ly93eHMuaWduLmZyL0FQSUtFWS9pdGluZXJhaXJlL3Jlc3Qvcm91dGUuanNvbl0gLSBXZWIgc2VydmljZSBVUkwuIElmIHVzZWQsIG9wdGlvbnMuYXBpS2V5IHBhcmFtZXRlciBpcyBpZ25vcmVkLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvdG9jb2w9WEhSXSAtIFByb3RvY29sIHVzZWQgdG8gaGFuZGxlIGRpYWxvZyB3aXRoIHdlYiBzZXJ2aWNlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdKU09OUCcgKHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUH0pIGFuZCAnWEhSJyAoe0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1hNTEh0dHBSZXF1ZXN0fSkuIE9ubHkgWEhSIHByb3RvY29sIGlzIHN1cHBvcnRlZCBpbiBhIE5vZGVKUyBlbnZpcm9ubWVudC4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3h5VVJMXSAtIFByb3h5IFVSTCB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FsbGJhY2tTdWZmaXhdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gbmFtZSBzdWZmaXggdG8gdXNlIGluIGNhc2Ugb2YgYSBKU09OUCBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSksIHRvIHNldCB5b3VyIG93biBzdWZmaXggaW5zdGVhZCBvZiBhdXRvLWluY3JlbWVudC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdYSFInIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaHR0cE1ldGhvZD1HRVRdIC0gSFRUUCBtZXRob2QgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2YgYSBYSFIgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICdHRVQnIGFuZCAnUE9TVCcuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCJdIC0gQ29udGVudC1UeXBlIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIGEgWEhSIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKSBhbmQgaWYgbWV0aG9kIEhUVFAgaXMgUE9TVC4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdKU09OUCcgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJhd1Jlc3BvbnNlPWZhbHNlXSAtIFNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpbXBsaWVzIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgc2VydmljZSByZXNwb25zZSBieSB5b3Vyc2VsZiA6IGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gdW5wYXJzZWQgU3RyaW5nIGluIG9uU3VjY2VzcyBjYWxsYmFjayBwYXJhbWV0ZXIuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJlZm9yZVBhcnNlXSAtIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBzZXJ2aWNlIHJlc3BvbnNlIGJlZm9yZSBwYXJzaW5nIChhcyBhbiB1bnBhcnNlZCBTdHJpbmcpLiBUYWtlcyBhIFN0cmluZyBhcyBhIHBhcmFtZXRlciAodGhlIHJhdyBzZXJ2aWNlIHJlc3BvbnNlKS4gUmV0dXJucyBhIFN0cmluZyB0aGF0IHdpbGwgYmUgcGFyc2VkIGFzIHRoZSBzZXJ2aWNlIHJlc3BvbnNlLiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ1hIUicgdmFsdWUuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICByb3V0ZSA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciByb3V0ZVNlcnZpY2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19Sb3V0ZV9Sb3V0ZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG9wdGlvbnMpO1xuICAgICAgICByb3V0ZVNlcnZpY2UuY2FsbCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29tcHV0aW5nIGEgc2V0IG9mIHBsYWNlcyAoY3VydmUpIHJlYWNoYWJsZSBmcm9tIGEgZ2l2ZW4gcG9pbnQgKG9yIGZyb20gd2hlcmUgdG8gc3RhcnQgdG8gcmVhY2ggYSBnaXZlbiBwb2ludCkgd2l0aGluIGEgdGltZSBvciBkaXN0YW5jZSBjb25zdHJhaW50IHVzaW5nIHRoZSBbaXNvY2hyb25lIHNlcnZpY2Ugb2YgdGhlIEdlb3BvcnRhbCBQbGF0Zm9ybV17QGxpbmsgaHR0cHM6Ly9nZW9zZXJ2aWNlcy5pZ24uZnIvZG9jdW1lbnRhdGlvbi9nZW9zZXJ2aWNlcy9pc29jaHJvbmVzLmh0bWx9LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpc29DdXJ2ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZnVuY3Rpb24gY2FsbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBBY2Nlc3Mga2V5IHRvIEdlb3BvcnRhbCBwbGF0Zm9ybSwgb2J0YWluZWQgW2hlcmVde0BsaW5rIGh0dHA6Ly9wcm9mZXNzaW9ubmVscy5pZ24uZnIvaWduL2NvbnRyYXRzfS5cbiAgICAgKiBAcGFyYW0ge0dwLlBvaW50fSBvcHRpb25zLnBvc2l0aW9uIC0gU3RhcnQgb3IgQXJyaXZhbCAob3B0aW9ucy5yZXZlcnNlPT09dHJ1ZSkgUG9pbnQgZm9yIHRoZSBjb21wdXRpbmcuIEV4cHJlc3NlZCBpbiBDUlM6ODQgY29vcmRpbmF0ZXMgc3lzdGVtIChwb3NpdGlvbi54IGNvcnJlc3BvbmRzIHRvIGxvbmdpdHVkZSwgcG9zaXRpb24ueSBjb3JyZXNwb25kcyB0byBsYXRpdHVkZSkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmdyYXBoID0gXCJWb2l0dXJlXCJdIC0gVXNlciBwcm9maWxlIHRvIHVzZSB0byBjb21wdXRlIHRoZSBpc29DdXJ2ZSA6IFwiVm9pdHVyZVwiICh1c2luZyBhIHZlaGljdWxlKSBvciBcIlBpZXRvblwiIChwZWRlc3RyaWFuKS4gSGFzIGFuIGluZmx1ZW5jZSBvbiB0aGUga2luZCBvZiByb2FkcyB0byB1c2UgYW5kIHRoZSBhdmVyYWdlIHNwZWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLmV4Y2x1c2lvbnNdIC0gSW5kaWNhdGVzIGlmIHJvdXRlIGhhcyB0byBhdm9pZCBzb21lIGZlYXR1cmVzIChcInRvbGxcIiwgXCJicmlkZ2VcIiBvciBcInR1bm5lbFwiKS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kID0gXCJ0aW1lXCJdIC0gQ29tcHV0aW5nIG1ldGhvZCB0byB1c2UgOiBcInRpbWVcIiAodXNpbmcgYSBkdXJhdGlvbiBhcyBhIGNvbnN0cmFpbnQpIG9yIFwiZGlzdGFuY2VcIiAodXNpbmcgYSBkaXN0YW5jZSBhcyBhIGNvbnN0cmFpbnQpLlxuICAgICAqIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMudGltZSAtIE1heGltdW0gZHVyYXRpb24gKGV4cHJlc3NlZCBpbiBzZWNvbmRzKSB0byB1c2Ugd2hlbiBvcHRpb25zLm1ldGhvZCBpcyBzZXQgdG8gXCJ0aW1lXCIuXG4gICAgICogQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5kaXN0YW5jZSAtIE1heGltdW0gZGlzdGFuY2UgKGV4cHJlc3NlZCBpbiBtZXRlcnMpIHRvIHVzZSB3aGVuIG9wdGlvbnMubWV0aG9kIGlzIHNldCB0byBcImRpc3RhbmNlXCIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXZlcnNlID0gZmFsc2VdIC0gU2V0IHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaWYgeW91IHdhbnQgb3B0aW9ucy5wb3NpdGlvbiB0byBiZSB0aGUgZGVzdGluYXRpb24gKGluc3RlYWQgb2YgZGVwYXJ0dXJlKSBmb3IgdGhlIGNvbXB1dGluZy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNtb290aGluZyA9IGZhbHNlXSAtIFNldCB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSByZXN1bHRpbmcgZ2VvbWV0cnkgdG8gYmUgc21vb3RoZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ob2xlcyA9IGZhbHNlXSAtIFNldCB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSByZXN1bHRpbmcgZ2VvbWV0cnkgKHBvbHlnb24pIHRvIGhhdmUgaG9sZXMgaWYgcGVydGluZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdWNjZXNzIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGdldHRpbmcgc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlLiBUYWtlcyBhIHtAbGluayBHcC5TZXJ2aWNlcy5Jc29DdXJ2ZVJlc3BvbnNlfSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgZXhjZXB0IGlmIFwicmF3UmVzcG9uc2VcIiBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkZhaWx1cmVdIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIHVuc3VjY2Vzc2Z1bCBzZXJ2aWNlIHJlc3BvbnNlcyAodGltZU91dCwgbWlzc2luZyByaWdodHMsIC4uLikuIFRha2VzIGEge0BsaW5rIEdwLkVycm9yfSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lT3V0PTBdIC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhYm92ZSB3aGljaCBhIHRpbWVPdXQgcmVzcG9uc2Ugd2lsbCBiZSByZXR1cm5lZCB3aXRoIG9uRmFpbHVyZSBjYWxsYmFjayAoc2VlIGFib3ZlKS4gRGVmYXVsdCB2YWx1ZSBpcyAwIHdoaWNoIG1lYW5zIHRpbWVPdXQgd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3V0cHV0Rm9ybWF0PSdqc29uJ10gLSBPdXRwdXQgZm9ybWF0IChcImpzb25cIiBvciBcInhtbFwiKSB0byB1c2UgZm9yIHVuZGVybHlpbmcgd2ViU2VydmljZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zZXJ2ZXJVcmw9aHR0cCAocyk6Ly93eHMuaWduLmZyL0FQSUtFWS9pc29jaHJvbmUvaXNvY2hyb25lLmpzb25dIC0gV2ViIHNlcnZpY2UgVVJMLiBJZiB1c2VkLCBvcHRpb25zLmFwaUtleSBwYXJhbWV0ZXIgaXMgaWdub3JlZC4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByb3RvY29sPVhIUl0gLSBQcm90b2NvbCB1c2VkIHRvIGhhbmRsZSBkaWFsb2cgd2l0aCB3ZWIgc2VydmljZS4gUG9zc2libGUgdmFsdWVzIGFyZSAnSlNPTlAnICh7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTlB9KSBhbmQgJ1hIUicgKHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9YTUxIdHRwUmVxdWVzdH0pLiBPbmx5IFhIUiBwcm90b2NvbCBpcyBzdXBwb3J0ZWQgaW4gYSBOb2RlSlMgZW52aXJvbm1lbnQuIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm94eVVSTF0gLSBQcm94eSBVUkwgdG8gdXNlIHdoZW4gcmVxdWVzdGluZyB1bmRlcmx5aW5nIHdlYiBzZXJ2aWNlLiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ0pTT05QJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNhbGxiYWNrU3VmZml4XSAtIENhbGxiYWNrIGZ1bmN0aW9uIG5hbWUgc3VmZml4IHRvIHVzZSBpbiBjYXNlIG9mIGEgSlNPTlAgcHJvdG9jb2wgdXNlIChzZWUgYWJvdmUpLCB0byBzZXQgeW91ciBvd24gc3VmZml4IGluc3RlYWQgb2YgYXV0by1pbmNyZW1lbnQuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnWEhSJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmh0dHBNZXRob2Q9R0VUXSAtIEhUVFAgbWV0aG9kIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdW5kZXJseWluZyB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIGEgWEhSIHByb3RvY29sIHVzZSAoc2VlIGFib3ZlKS4gUG9zc2libGUgdmFsdWVzIGFyZSAnR0VUJyBhbmQgJ1BPU1QnLiBJZ25vcmVkIHdoZW4gb3B0aW9ucy5wcm90b2NvbCBpcyBzZXQgdG8gJ0pTT05QJyB2YWx1ZS4gT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3htbFwiXSAtIENvbnRlbnQtVHlwZSB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHVuZGVybHlpbmcgd2ViIHNlcnZpY2UgaW4gY2FzZSBvZiBhIFhIUiBwcm90b2NvbCB1c2UgKHNlZSBhYm92ZSkgYW5kIGlmIG1ldGhvZCBIVFRQIGlzIFBPU1QuIElnbm9yZWQgd2hlbiBvcHRpb25zLnByb3RvY29sIGlzIHNldCB0byAnSlNPTlAnIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXNwb25zZT1mYWxzZV0gLSBTZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaW1wbGllcyB5b3Ugd2FudCB0byBoYW5kbGUgdGhlIHNlcnZpY2UgcmVzcG9uc2UgYnkgeW91cnNlbGYgOiBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGFuIHVucGFyc2VkIFN0cmluZyBpbiBvblN1Y2Nlc3MgY2FsbGJhY2sgcGFyYW1ldGVyLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25CZWZvcmVQYXJzZV0gLSBDYWxsYmFjayBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgc2VydmljZSByZXNwb25zZSBiZWZvcmUgcGFyc2luZyAoYXMgYW4gdW5wYXJzZWQgU3RyaW5nKS4gVGFrZXMgYSBTdHJpbmcgYXMgYSBwYXJhbWV0ZXIgKHRoZSByYXcgc2VydmljZSByZXNwb25zZSkuIFJldHVybnMgYSBTdHJpbmcgdGhhdCB3aWxsIGJlIHBhcnNlZCBhcyB0aGUgc2VydmljZSByZXNwb25zZS4gSWdub3JlZCB3aGVuIG9wdGlvbnMucHJvdG9jb2wgaXMgc2V0IHRvICdYSFInIHZhbHVlLiBPbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAgICovXG4gICAgaXNvQ3VydmUgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvY2Vzc0lzb0N1cnZlU2VydmljZSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Byb2Nlc3NJc29DdXJ2ZV9Qcm9jZXNzSXNvQ3VydmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXShvcHRpb25zKTtcbiAgICAgICAgcHJvY2Vzc0lzb0N1cnZlU2VydmljZS5jYWxsKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQb2ludCBvYmplY3QuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQGFsaWFzIEdwLlBvaW50XG4gKlxuICogQHByb3BlcnR5IHtGbG9hdH0geCAtIFBvaW50IGFic2Npc3NhXG4gKiBAcHJvcGVydHkge0Zsb2F0fSB5IC0gUG9pbnQgb3JkaW5hdGVcbiAqL1xudmFyIHBvaW50ID0ge307XG5cbi8qKlxuICogQ2lyY2xlIG9iamVjdC5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAYWxpYXMgR3AuQ2lyY2xlXG4gKlxuICogQHByb3BlcnR5IHtGbG9hdH0geCAtIENpcmNsZSBjZW50ZXIgYWJzY2lzc2EuXG4gKiBAcHJvcGVydHkge0Zsb2F0fSB5IC0gQ2lyY2xlIGNlbnRlciBvcmRpbmF0ZS5cbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IHJhZGl1cyAtIENpcmNsZSByYWRpdXMuXG4gKi9cbnZhciBjaXJjbGUgPSB7fTtcblxuLyoqXG4gKiBCb3VuZGluZyBib3ggb2JqZWN0LCBleHByZXNzZWQgd2l0aCBmb3VyIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBhbGlhcyBHcC5CQm94XG4gKlxuICogQHByb3BlcnR5IHtGbG9hdH0gbGVmdCAtIG1pbmltdW0gYWJzY2lzc2FcbiAqIEBwcm9wZXJ0eSB7RmxvYXR9IHJpZ2h0IC0gbWF4aW11bSBhYnNjaXNzYVxuICogQHByb3BlcnR5IHtGbG9hdH0gYm90dG9tIC0gbWluaW11bSBvcmRpbmF0ZVxuICogQHByb3BlcnR5IHtGbG9hdH0gdG9wIC0gbWF4aW11bSBvcmRpbmF0ZVxuICovXG52YXIgYmJveCA9IHt9O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFNlcnZpY2VzKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0NvbW1vblNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19EZWZhdWx0VXJsU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1JlcXVlc3RfQWx0aVJlcXVlc3RGYWN0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Jlc3BvbnNlX0FsdGlSZXNwb25zZUZhY3RvcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xuXG5cblxuXG5cblxuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogQXBwZWwgZHUgc2VydmljZSBkJ2FsdGltw6l0cmllIGR1IEfDqW9wb3J0YWlsXG4gKlxuICogQHRvZG8gZ2VzdGlvbiBkdSBwYXJtYS4gb3V0cHV0IGV0IGNhbGxiYWNrXG4gKiBAdG9kbyBvdXRwdXRGb3JtYXQgKFJFU1QpIGV0IGZvcm1hdCAoV1BTKVxuICogQHRvZG8gTGEgcmVwb25zZSBKU09OIHBldXQgZW5jYXBzdWxlciB1biBYTUwgIVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0dwLlNlcnZpY2VzLkNvbW1vblNlcnZpY2V9XG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQWx0aVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlICgrIGxlcyBvcHRpb25zIGhlcml0w6llcylcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBvcHRpb25zLnBvc2l0aW9ucyAtIFRhYmxlYXUgKHtsb246ZmxvYXQsbGF0OmZsb2F0fSkgY29udGVuYW50IGxlcyBjb29yZG9ubsOpZXMgZGVzIHBvaW50cyAoQ1JTOjg0KVxuICogICAgICBkb250IG9uIHZldXQgY29ubmHDrnRyZSBsZXMgYWx0aXR1ZGVzIChvdSDDoCBwYXJ0aXIgZGVzcXVlbGxlcyBvbiB2YSBjYWxjdWxlciBsZSBwcm9maWwpLlxuICogICAgICBDaGFxdWUgw6lsw6ltZW50IGR1IHRhYmxlYXUgZXN0IHVuIG9iamV0IEphdmFTY3JpcHQgYXZlYyBkZXV4IGF0dHJpYnV0cyA6IGxvbiBldCBsYXQsIHF1aSBzb250IGRlcyBmbG90dGFudHMuXG4gKiAgICAgIE1pbmltdW0gMiDDqWzDqW1lbnRzIHNpIG9uIHNvdWhhaXRlIGNhbGN1bGVyIHVuIHByb2ZpbCBhbHRpbcOpdHJpcXVlIChFbGV2YXRpb25MaW5lKS5cbiAqICAgICAgTWF4aW11bSA1MCDDqWzDqW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLm91dHB1dEZvcm1hdCAtIExlIGZvcm1hdCBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIGFsdGkgOiAneG1sJyBvdSAnanNvbicuXG4gKiAgICAgIENlIHBhcmFtw6h0cmUgZMOpdGVybWluZXJhIGwnZXh0ZW5zaW9uICcueG1sJyBvdSAnLmpzb24nIGR1IHNlcnZpY2UgZGFucyBsZSBjYXMgZGUgbCdBUEkgUkVTVCxcbiAqICAgICAgb3UgbGEgdmFsZXVyIGR1IHBhcmFtw6h0cmUgJ2Zvcm1hdCcgZGFucyBsZSBjYXMgZGUgbGEgbm9ybWUgV1BTLlxuICogICAgICBOw6ljZXNzYWlyZSBzaSBzZXJ2ZXJVcmwgZXN0IHJlbnNlaWduw6ksIGV0IHF1J29uIHNvdWhhaXRlIHBhc3NlciBwYXIgbCdBUEkgUkVTVCxcbiAqICAgICAgcG91ciBjb25uYcOudHJlIGxlIGZvcm1hdCBkYW5zIGxlcXVlbCBzZXJhIGZvdXJuaWUgbGEgcsOpcG9uc2UgKHBvdXIgc29uIHRyYWl0ZW1lbnQpLlxuICogICAgICBOb24gbsOpY2Vzc2FpcmUgcG91ciBsYSBub3JtZSBXUFMuIFBhciBkw6lmYXV0LCBjZSBwYXJhbcOodHJlIHZhdXQgJ2pzb24nLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYW1wbGluZ10gLSBOb21icmUgZGUgcG9pbnRzIMOgIHV0aWxpc2VyIHBvdXIgZMOpdGVybWluZXIgbGUgdHJhY8OpIGQndW4gcHJvZmlsIGFsdGltw6l0cmlxdWUsIGNvbXByaXMgZW50cmUgMiBldCA1MDAwLlxuICogICAgICBBIHNww6ljaWZpZXIgbG9yc3F1J29uIHNvdWhhaXRlIGFjY8OpZGVyIMOgIGNldHRlIGZvbmN0aW9ubmFsaXTDqS5cbiAqICAgICAgRGFucyBjZSBjYXMsIGxlcyBwb2ludHMgZm91cm5pcyBlbiBlbnRyw6llIChhdSBtaW5pbXVtIGRlIGRldXgpIHNlcnZlbnQgw6AgZMOpdGVybWluZXIgbCdheGUgcGxhbmltw6l0cmlxdWVcbiAqICAgICAgbGUgbG9uZyBkdXF1ZWwgbGUgcHJvZmlsIGRvaXQgw6p0cmUgY2FsY3Vsw6kuXG4gKiAgICAgIFNpIGxlIHBhcmFtw6h0cmUgc2FtcGxpbmcgbidlc3QgcGFzIHNww6ljaWZpw6kgb3UgbW9pbnMgZGUgZGV1eCBwb2ludHMgc29udCBmb3VybmlzLFxuICogICAgICBjJ2VzdCBsZSBzZXJ2aWNlIEVsZXZhdGlvbiBxdWkgc2VyYSBpbnRlcnJvZ8OpIChhbHRpdHVkZXMgc2ltcGxlcyBjYWxjdWzDqWVzIHBvdXIgbGVzIHBvaW50cyBmb3VybmlzKS5cbiAqICAgICAgVW5lIHZhbGV1ciBkZSBzYW1wbGluZyBzdHJpY3RlbWVudCBpbmbDqXJpZXVyZSDDoCAyIGTDqWNsZW5jaGVyYSB1biDDqWNoYW50aWxsb25uYWdlIGF2ZWMgbGEgdmFsZXVyIHBhciBkw6lmYXV0IGR1IHNlcnZpY2UgKDMgcG9pbnRzKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXBpXSAtIE1hbmnDqHJlIGQnYWNjw6lkZXIgYXUgc2VydmljZSA6ICdSRVNUJyAodmlhIGwnQVBJIFJFU1QpIG91ICdXUFMnICh2aWEgbGEgbm9ybWUgV1BTKS5cbiAqICAgICAgUGFyIGTDqWZhdXQsIG9uIHV0aWxpc2UgbCdBUEkgUkVTVC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnpvbmx5XSAtIFBlcm1ldCBkZSBuZSByw6ljdXDDqXJlciBxdWUgbGVzIGFsdGl0dWRlcyBlbiBzb3J0aWUgcydpbCB2YXV0ICd0cnVlJy5cbiAqICAgICAgVmF1dCAnZmFsc2UnIHBhciBkw6lmYXV0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBvcHRpb25zID0ge1xuICogICAgICBhcGlLZXkgOiBudWxsLFxuICogICAgICBzZXJ2ZXJVcmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zZXJ2aWNlLycsXG4gKiAgICAgIHByb3RvY29sIDogJ0pTT05QJywgLy8gSlNPTlB8WEhSXG4gKiAgICAgIHByb3h5VVJMIDogbnVsbCxcbiAqICAgICAgaHR0cE1ldGhvZCA6ICdHRVQnLCAvLyBHRVR8UE9TVFxuICogICAgICB0aW1lT3V0IDogMTAwMDAsIC8vIG1zXG4gKiAgICAgIHJhd1Jlc3BvbnNlIDogZmFsc2UsIC8vIHRydWV8ZmFsc2VcbiAqICAgICAgc2NvcGUgOiBudWxsLCAvLyB0aGlzXG4gKiAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXNwb25zZSkge30sXG4gKiAgICAgIG9uRmFpbHVyZSA6IGZ1bmN0aW9uIChlcnJvcikge30sXG4gKiAgICAgIC8vIHNww6ljaWZpcXVlIGF1IHNlcnZpY2VcbiAqICAgICAgcG9zaXRpb25zIDogW3tsb246LCBsYXQ6fSwge2xvbjosIGxhdDp9XSxcbiAqICAgICAgb3V0cHV0Rm9ybWF0IDogJ2pzb24nIC8vIGpzb258eG1sXG4gKiAgICAgIHNhbXBsaW5nIDogMyxcbiAqICAgICAgYXBpIDogJ1JFU1QnLCAvLyBSRVNUfFdQU1xuICogICAgICB6b25seSA6IGZhbHNlIC8vIGZhbHNlfHRydWVcbiAqICAgfTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBbHRpIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIkFsdGlcIikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vbSBkZSBsYSBjbGFzc2UgKGhlcml0YWdlKVxuICAgICAqIEZJWE1FIGluc3RhbmNlIG91IGNsYXNzZSA/XG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkFsdGlcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0NvbW1vblNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkdwLlNlcnZpY2VzLkFsdGlcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEFsdGkgKG9wdGlvbnMpXVwiKTtcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgIC8vIGFuYWx5c2UgZGVzIG9wdGlvbnNcbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAgIGlmICghb3B0aW9ucy5wb3NpdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInBvc2l0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcInBvc2l0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgLy8gYWpvdXQgZGVzIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2VcbiAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zID0gb3B0aW9ucy5wb3NpdGlvbnM7XG5cbiAgICAvLyBmb3JtYXQgZGUgcsOpcG9uc2UgZHUgc2VydmljZSA6IFwianNvblwiIG91IFwieG1sXCIgKHZhbGV1ciBwYXIgZMOpZmF1dCksIGVuIG1pbnVzY3VsZSAhXG4gICAgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCA9ICh0eXBlb2Ygb3B0aW9ucy5vdXRwdXRGb3JtYXQgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5vdXRwdXRGb3JtYXQudG9Mb3dlckNhc2UoKSA6IFwieG1sXCI7XG5cbiAgICAvLyBzYW1wbGluZ1xuICAgIHRoaXMub3B0aW9ucy5zYW1wbGluZyA9IG9wdGlvbnMuc2FtcGxpbmcgfHwgbnVsbDtcblxuICAgIC8vIHR5cGUgZCdhcGkgdXRpbGlzw6kgcG91ciByZXF1ZXRlciBsZSBzZXJ2aWNlLCBlbiBtYWp1c2N1bGUgIVxuICAgIHRoaXMub3B0aW9ucy5hcGkgPSAodHlwZW9mIG9wdGlvbnMuYXBpID09PSBcInN0cmluZ1wiKSA/IG9wdGlvbnMuYXBpLnRvVXBwZXJDYXNlKCkgOiBcIlJFU1RcIjtcblxuICAgIC8vIGwnYXBpIG5lIHBldXQgw6p0cmUgaW50ZXJyb2fDqWUgcXUnZW4gR0VULlxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXBpID09PSBcIlJFU1RcIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9IFwiR0VUXCI7XG4gICAgfVxuXG4gICAgLy8gcGFyYW0uIHpvbmx5XG4gICAgdGhpcy5vcHRpb25zLnpvbmx5ID0gb3B0aW9ucy56b25seSB8fCBmYWxzZTtcblxuICAgIC8vIGdlc3Rpb24gZGUgbCd1cmwgZHUgc2VydmljZSBwYXIgZGVmYXV0XG4gICAgLy8gc2kgbCd1cmwgbidlc3QgcGFzIHJlbnNlaWduw6llLCBpbCBmYXV0IHV0aWxpc2VyIGxlcyB1cmxzIHBhciBkZWZhdXRcbiAgICAvLyBlbiBmb25jdGlvbiBkdSB0eXBlIGQnYXBpLCBSRVNUIG91IFdQUywgZHUgZm9ybWF0IGRlIHJlcG9uc2UgZGVtYW5kw6kgKG91dHB1dEZvcm1hdClcbiAgICAvLyBhaW5zaSBxdWUgc3VyIGxlIHR5cGUgZGUgc2VydmljZSAocHJvZmlsIG91IGVsZXZhdGlvbilcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgdmFyIGxzdFVybEJ5RGVmYXVsdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRGVmYXVsdFVybFNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5BbHRpLnVybCh0aGlzLm9wdGlvbnMuYXBpS2V5KTtcbiAgICAgICAgdmFyIHVybEZvdW5kID0gbnVsbDtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuYXBpKSB7XG4gICAgICAgICAgICBjYXNlIFwiV1BTXCI6XG4gICAgICAgICAgICAgICAgdXJsRm91bmQgPSBsc3RVcmxCeURlZmF1bHQud3BzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJFU1RcIjpcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gKG9wdGlvbnMuc2FtcGxpbmcgPyBcInByb2ZpbFwiIDogXCJlbGV2YXRpb25cIikgKyBcIi1cIiArIHRoaXMub3B0aW9ucy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgICAgICAgICAgdXJsRm91bmQgPSBsc3RVcmxCeURlZmF1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fVU5LTk9XTlwiLCBcImFwaVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcmwgYnkgZGVmYXVsdCBub3QgZm91bmQgIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gdXJsRm91bmQ7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmVyIFVSTCBieSBkZWZhdWx0IDogXCIgKyB0aGlzLm9wdGlvbnMuc2VydmVyVXJsKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGR1IHR5cGUgZGUgc2VydmljZVxuICAgIC8vIHNpIGwnZXh0ZW5zaW9uIGRlIGwndXJsIGVzdCAuanNvbiBvdSAueG1sLCBvbiBzdXJjaGFyZ2UgbGUgZm9ybWF0IGRlIHNvcnRpZSAob3V0cHV0Rm9ybWF0KVxuICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLnNlcnZlclVybC5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmxlbmd0aCA8IDUpIHsgLy8gRklYTUUgZXh0ZW5zaW9uIGRlIG1vaW5zIGRlIDQgY2FyLiAuLi5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmVyIEV4dGVuc2lvbiBVUkwgOiBcIiArIGV4dGVuc2lvbik7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vdXRwdXRGb3JtYXQgPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBvZiBzZXJ2aWNlIDogdW5rbm93biBvciB1bnN1cHBvcnRlZCAoanNvbiBvciB4bWwpICFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpBbHRpI1xuICovXG5BbHRpLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Db21tb25TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLCB7XG4gICAgLy8gdG9kb1xuICAgIC8vIGdldHRlci9zZXR0ZXJcbn0pO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkFsdGkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWx0aTtcblxuLyoqXG4gKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGUgKG92ZXJ3cml0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5BbHRpLnByb3RvdHlwZS5idWlsZFJlcXVlc3QgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICAvLyB1dGlsaXNhdGlvbiBlbiBtb2RlIGNhbGxiYWNrXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBNZXRob2QgOiB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCxcbiAgICAgICAgLyoqIGNhbGxiYWNrICovXG4gICAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIHNhdXZlZ2FyZGUgZGUgbGEgcmVxdWV0ZSAhXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvciA6IGVycm9yLFxuICAgICAgICBzY29wZSA6IHRoaXMsXG4gICAgICAgIC8vIHNww6ljaWZpcXVlIGF1IHNlcnZpY2UgOlxuICAgICAgICBwb3NpdGlvbnMgOiB0aGlzLm9wdGlvbnMucG9zaXRpb25zLFxuICAgICAgICBvdXRwdXRGb3JtYXQgOiB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0LFxuICAgICAgICBzYW1wbGluZyA6IHRoaXMub3B0aW9ucy5zYW1wbGluZyxcbiAgICAgICAgYXBpIDogdGhpcy5vcHRpb25zLmFwaSxcbiAgICAgICAgem9ubHkgOiB0aGlzLm9wdGlvbnMuem9ubHlcbiAgICB9O1xuXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXF1ZXN0X0FsdGlSZXF1ZXN0RmFjdG9yeV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJ1aWxkKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2UgKG92ZXJ3cml0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5BbHRpLnByb3RvdHlwZS5hbmFseXplUmVzcG9uc2UgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICAvLyBJTkZPXG4gICAgLy8gRmFjdG9yeSBwb3VyIG1hc3F1ZXIgbGEgY29tcGxleGl0w6kgZHUgcmV0b3VyIGR1IHNlcnZpY2UgcXVpIHJlbnZvaWUgc29pdFxuICAgIC8vICAtIHVuZSAnc3RyaW5nJyBxdWkgY29udGllbnQgZHUgWE1MIG91IEpTT04gbmF0aWYgZW4gbW9kZSBYSFJcbiAgICAvLyAgLSB1biBvYmpldCBKU09OIHF1aSBlc3QgbmF0aWYgb3UgZW5jYXBzdWzDqVxuXG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZXNwb25zZSA6IHRoaXMucmVzcG9uc2UsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXQgOiB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0LCAvLyB1dGlsZSBwb3VyIHBhcnNlciBsYSBzdHJpbmcgZW4gbW9kZSBYSFIgOiBKU09OIG91IFhNTCAhXG4gICAgICAgICAgICByYXdSZXNwb25zZSA6IHRoaXMub3B0aW9ucy5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgIG9uRXJyb3IgOiBlcnJvcixcbiAgICAgICAgICAgIG9uU3VjY2VzcyA6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Jlc3BvbnNlX0FsdGlSZXNwb25zZUZhY3RvcnlfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5idWlsZChvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5jYWxsKHRoaXMsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VNUFRZXCIpKSk7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBbHRpKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0cnVlKSB7XG4gICAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGRlZmluaXRpb24pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpIDpcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfSGVscGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWEhSX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0pTT05QX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcbi8qKlxuICogUHJvdG9jb2xzIDogSW50ZXJmYWNlIGRlIGRpYWxvZ3VlIGF2ZWMgbGVzIHdlYnNlcnZpY2VzXG4gKlxuICogQG1vZHVsZSBQcm90b2NvbHNcbiAqIEBwcml2YXRlXG4gKiBAYWxpYXMgR3AuUHJvdG9jb2xzLlByb3RvY29sc1xuICovXG5cblxuXG5cbnZhciBQcm90b2NvbCA9IHtcblxuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB1bmlxdWUgZFwiZW52b2kgZFwidW5lIHJlcXXDqnRlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBnZW5lcmFsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgICAgICAtIHVybCBkdSBzZXJ2aWNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubWV0aG9kICAgLSBHRVQsIFBPU1QsIFBVVCwgREVMRVRFXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvdG9jb2wgLSBYSFIgfCBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZvcm1hdCAgIC0gZm9ybWF0IGRlIGxhIHJlcG9uc2UgZHUgc2VydmljZSA6IGpzb24sIHhtbCBvdSBudWxsIChicnV0ZSkuLi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy53cmFwICAgICAtIGVuY2Fwc3VsZXIgbGEgcmVwb25zZSBkdSBzZXJ2aWNlIGRhbnMgZHUgSlNPTiA6IHRydWV8ZmFsc2UgKHRydWUgcGFyIGRlZmF1dCBzdXIgbGUgcHJvdG9jb2xlIEpTT05QKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNhbGxiYWNrU3VmZml4IC0gc3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayAoSlNPTlAgdW5pcXVlbWVudCkgKGV4OiBzaSBjYWxsYmFja1N1ZmZpeD1cIlwiLCBsYSBmb25jdGlvbiBzJ2FwcGVsbGVyYSBcImNhbGxiYWNrXCIpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZU91dCAgLSAwIG1zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm5vY2FjaGUgIC0gdHJ1ZXxmYWxzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gb3B0aW9ucy5kYXRhICAgICAgICAtIGNvbnRlbnQgKHBvc3QpIG91IHBhcmFtIChnZXQpXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmhlYWRlcnMgICAgIC0gKHBvc3QpIGV4LiByZWZlcmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmNvbnRlbnQgLSAocG9zdCkgZXguIFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc2NvcGUgICAgICAgLSB0aGlzIChUT0RPKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25SZXNwb25zZSAtIGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbkZhaWx1cmUgLSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25UaW1lT3V0IC0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcm94eVVybCAtICAoVE9ETylcbiAgICAgKi9cbiAgICBzZW5kIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBcIm91dHB1dFwiIC0gcGFyYW0gZXN0IGludGVybmUgw6AgbGEgY2xhc3NlIFwiUHJvdG9jb2xcIiAocGFyYW1ldHJhYmxlIHZpYSBcIndyYXBcIiksIGV0IMOgIGFqb3V0ZXIgw6AgbFwidXJsXG4gICAgICAgIC8vICAgICAgY2UgcGFyYW0gZXN0IGluZGVwZW5kYW50IGR1IHNlcnZpY2UgY2FyIGlsIGVzdCBnw6lyw6kgcGFyIGxlIGZpbHRyZSBMVUEgOlxuICAgICAgICAvLyAgICAgICAgICBleC4ganNvbnx4bWwgKGpzb24gcGFyIGRlZmF1dCkuXG4gICAgICAgIC8vICAgICAgICAgIENlIHBhcmFtLiBwZXJtZXQgZFwiZW5jYXBzdWxlciBkdSBYTUwgZGFucyBkdSBKU09OIDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIHtodHRwIDoge3N0YXR1czoyMDAsIGVycm9yOm51bGx9LHhtbCA6XCJyw6lwb25zZSBkdSBzZXJ2aWNlXCJ9XG4gICAgICAgIC8vICAgICAgICAgIFV0aWxlIHBvdXIgbGVzIHNlcnZpY2VzIHF1aSBuZSByZXBvbmRlbnQgcXVlIGR1IFhNTCAoZXguIEdlb2NvZGFnZSlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAgICBcXHNlcnZpY2UgfCAgICAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgLy8gfCBvdXRwdXRcXCBmb3JtYXR8IGpzb24gfCB4bWwgfCAgICAgcmVtYXJxdWVzICAgICAgfFxuICAgICAgICAvLyB8LS0tLS0tLS1cXC0tLS0tLXwtLS0tLS18LS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgIC8vIHwgICAganNvbiAgICAgICB8IGpzb24gfCBqc29ufCBqc29uL3htbCBlbmNhcHN1bMOpIHxcbiAgICAgICAgLy8gfCAgICB4bWwgICAgICAgIHwganNvbiB8IHhtbCB8IHBhcmFtIGluYWN0aWYgICAgICB8XG4gICAgICAgIC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAvLyBleC4gbGUgc2VydmljZSBkZW1hbmRlIHVuZSByZXBvbnNlIG5hdGl2ZSBhdSBcImZvcm1hdFwiIGpzb24gZXQgYXZlYyB1biBcIm91dHB1dFwiIGpzb24uXG4gICAgICAgIC8vIG9uIGEgZG9uYyB1bmUgcmVwb25zZSBqc29uIGVuY2Fwc3Vsw6kgZGFucyB1biBqc29uIDogY2UgcXUnb24gbmUgc291aGFpdGUgcGFzICFcbiAgICAgICAgLy8gZGFucyBjZSBjYXMgb24gbmUgcmVuc2VpZ25lIHBhcyBvdXRwdXQ9anNvblxuXG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gXCJ3cmFwXCIgLSBjaG9peCBkXCJlbmNhcHN1bGVyIG91IG5vbiBsZXMgcmVwb25zZXMgZGFucyBkdSBKU09OLlxuICAgICAgICAvLyAgICAgIFBhciBkZWZhdXQsIG9uIGVuY2Fwc3VsZSB1bmlxdWVtZW50IGxlcyByZXBvbnNlcyBzdXIgbGUgcHJvdG9jb2xlIEpTT05QIChldCBxdWkgc29udCBlbiB4bWwpICFcblxuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIFwiY2FsbGJhY2tcIiAtIHBhcmFtIGVzdCBpbnRlcm5lIMOgIGxhIGNsYXNzZSBcIlByb3RvY29sXCIgKG5vbiBwYXJhbWV0cmFibGUpLCBldCDDoCBham91dGVyIMOgIGxcInVybFxuICAgICAgICAvLyAgICAgIGNlIHBhcmFtIGVzdCBpbmRlcGVuZGFudCBkdSBzZXJ2aWNlIGNhciBpbCBlc3QgZ8OpcsOpIGF1c3NpIHBhciBsZSBmaWx0cmUgTFVBIDpcbiAgICAgICAgLy8gICAgICAgICAgZXguIGNhbGxiYWNrfG51bGxcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIHBlcm1ldCBkZSByZW52b3llciB1bmUgcmVwb25zZSBqYXZhc2NyaXB0IDpcbiAgICAgICAgLy8gICAgICAgICAgICAgIGNhbGxiYWNrICh7aHR0cCA6IHtzdGF0dXM6MjAwLCBlcnJvcjpudWxsfSx4bWwgOlwicsOpcG9uc2UgZHUgc2VydmljZVwifSlcbiAgICAgICAgLy8gICAgICAgICAgQ2UgcGFyYW0uIGVzdCBub24gcmVuc2VpZ27DqSBwYXIgZGVmYXV0IGNhciBwb3VyIGR1IEpTT05QLCBvbiB1dGlsaXNlIGxlXG4gICAgICAgIC8vICAgICAgICAgIGxlIHByb3RvY29sIEpTT05QLCBldCBjZSBkZXJuaWVyIGltcGxlbWVudGUgZMOpasOgIGxlIGNhbGxiYWNrICFcblxuICAgICAgICAvLyBzZXR0aW5ncyBwYXIgZGVmYXV0XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbWV0aG9kIDogXCJHRVRcIixcbiAgICAgICAgICAgIC8vIHByb3RvY29sIDogXCJKU09OUFwiLFxuICAgICAgICAgICAgcHJvdG9jb2wgOiBcIlhIUlwiLFxuICAgICAgICAgICAgdGltZU91dCA6IDAsXG4gICAgICAgICAgICBmb3JtYXQgOiBudWxsLFxuICAgICAgICAgICAgd3JhcCA6IHRydWUsXG4gICAgICAgICAgICBub2NhY2hlIDogdHJ1ZSxcbiAgICAgICAgICAgIG91dHB1dCA6IFwianNvblwiLFxuICAgICAgICAgICAgY2FsbGJhY2sgOiBudWxsLFxuICAgICAgICAgICAgY2FsbGJhY2tTdWZmaXggOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gb24gZGV0ZXJtaW5lIGwnZW52aXJvbm5lbWVudCBkJ2V4ZWN1dGlvbiA6IGJyb3dzZXIgb3Ugbm9uID9cbiAgICAgICAgLy8gZXQgb24gc3RvcHBlIHBvdXIgbm9kZUpTLi4uIHN1ciB1biBwcm90b2NvbGUgSlNPTlAgIVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmFsdWUgKHMpIGZvciBwYXJhbWV0ZXIgKHMpICdwcm90b2NvbD1KU09OUCAoaW5zdGVhZCB1c2UgWEhSKScgbm90IHN1cHBvcnRlZCB0byBOb2RlSlNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIiB8fCBvcHRpb25zLmZvcm1hdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3RvY29sID09PSBcIkpTT05QXCIgJiYgb3B0aW9ucy5mb3JtYXQgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLndyYXAgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2sgPSAob3B0aW9ucy5wcm90b2NvbCA9PT0gXCJKU09OUFwiKSA/IG51bGwgOiBudWxsOyAvLyBGSVhNRSBub24gZ8OpcsOpICE/XG4gICAgICAgIHNldHRpbmdzLm91dHB1dCA9IHNldHRpbmdzLndyYXAgPyBcImpzb25cIiA6IG51bGw7XG5cbiAgICAgICAgLy8gb24gZW5jYXBzdWxlIGxlcyByZXBvbnNlcyBkYW5zIHVuIG9iamV0IEpTT05cbiAgICAgICAgaWYgKHNldHRpbmdzLndyYXApIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHBhcmFtcy5vdXRwdXQgPSBzZXR0aW5ncy5vdXRwdXQ7XG4gICAgICAgICAgICBwYXJhbXMuY2FsbGJhY2sgPSBzZXR0aW5ncy5jYWxsYmFjaztcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY2FsbGJhY2s7IC8vIEZJWE1FIG5vbiBnw6lyw6kgIT9cbiAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfSGVscGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFseXplVXJsKG9wdGlvbnMudXJsLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hvaXggZGUgbFwiaW1wbGVtZW50YXRpb24gOlxuICAgICAgICAvLyBYSFIgb3UgSlNPTlBcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5wcm90b2NvbCkge1xuICAgICAgICAgICAgY2FzZSBcIlhIUlwiOlxuICAgICAgICAgICAgICAgIC8vIG9uIG5vcm1hbGlzZSBsJ3VybCAoZ2VzdGlvbiBkdSBjYWNoZSlcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgJiYgb3B0aW9ucy5ub2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfSGVscGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFseXplVXJsKHNldHRpbmdzLnVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBlbCBkdSBzZXJ2aWNlIGVuIFhIUlxuICAgICAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWEhSX19bXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbChzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSlNPTlBcIjpcblxuICAgICAgICAgICAgICAgIC8vIG9uIG5vcm1hbGlzZSBsJ3VybCBzaSBsZXMgcGFyYW1zLiBzb250IHJlbnNlaWduw6lzIGRhbnMgbGEgc3RyaW5nfG9iamVjdCBcImRhdGFcIlxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnVybCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfSGVscGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFseXplVXJsKHNldHRpbmdzLnVybCwgc2V0dGluZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYXBwZWwgZHUgc2VydmljZSBlbiBKU09OUFxuICAgICAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fSlNPTlBfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvdG9jb2wgbm90IHN1cHBvcnRlZCAoWEhSfEpTT05QKSAhXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb3RvY29sKTtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzLCBnbG9iYWwpIHsvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNCszMTRlNDgzMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdCB0cnVlID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiBcImZ1bmN0aW9uXCIgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1MSkpKVxuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiA1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNTJfXztcblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKlxuICogSlNPTlAgOiBJbXBsw6ltZW50YXRpb24gZHUgcHJvdG9jb2xlIEpTT05QIGRlIGxhIHBsYXRlZm9ybWUgR8Opb3BvcnRhaWwgKGNmLiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3NvYnN0ZWwvanNvbnAuanN9KS5cbiAqXG4gKiBAbW9kdWxlIEpTT05QXG4gKiBAcHJpdmF0ZVxuICogQGFsaWFzIEdwLlByb3RvY29scy5KU09OUFxuICovXG5cblxudmFyIEpTT05QID0ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0aW9uIGQndW4gaWRlbnRpZmlhbnQgc3RhdGlxdWUgYmFzw6kgc3VyIGxlIHRpbWVzdGFtcCxcbiAgICAgKiBldCBxdWkgcydpbmNyZW1lbnRlIGRlICsxIMOgIGNoYXF1ZSBhcHBlbFxuICAgICAqL1xuICAgIHV1aWQgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSBNYXRoLmZsb29yKERhdGUubm93KCkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKys7XG4gICAgICAgIH07XG4gICAgfSkoKSxcblxuICAgIC8qKlxuICAgICAqIENldHRlIGZvbmN0aW9uIHLDqWFsaXNlIGwnYXBwZWwgZHUgc2VydmljZSBmb3VybmkgdmlhIGxlIHBhcmFtw6h0cmUgXCJvcHRpb25zLnVybFwiXG4gICAgICogZW4gbWV0dGFudCBlbiDFk3V2cmUgbGUgcHJvdG9jb2xlIEpTT05QLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjYWxsXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gcGFyYW1ldHJlcyBkJ2ludm9jYXRpb24gZHUgc2VydmljZSBlbiBKU09OUFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCAtIFVSTCBkdSBzZXJ2aWNlIMOgIGludm9xdWVyIChpbmTDqXBlbmRhbW1lbnQgZHUgcHJvdG9jb2xlIEpTT05QKS5cbiAgICAgKiAgQ2V0dGUgVVJMIGNvbnRpZW50IGTDqWrDoCBsZXMgcGFyYW3DqHRyZXMgZHUgc2VydmljZS5cbiAgICAgKiAgU2kgbGUgcGFyYW3DqHRyZSBkw6lkacOpIMOgIGxhIG1pc2UgZW4gb2V1dnJlIGR1IHByb3RvY29sZSBKU09OUCAoY2FsbGJhY2s9eHh4KSBuJ2VzdCBwYXMgcHLDqXNlbnQsIGlsIGVzdCByYWpvdXTDqSBwYXIgbGEgZm9uY3Rpb24gO1xuICAgICAqICBzYSB2YWxldXIgZXN0IGTDqXRlcm1pbsOpZSBlbiBmb25jdGlvbiBkdSBwYXJhbcOodHJlIGNhbGxiYWNrTmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZU91dCA9IDBdIC0gTm9tYnJlIGRlIG1zIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdS5cbiAgICAgKiAgVW5lIHZhbGV1ciBkZSAwIHBvdXIgY2UgcGFyYW3DqHRyZSBwZXJtZXQgZGUgZMOpc2FjdGl2ZXIgbGEgZ2VzdGlvbiBkdSB0aW1lT3V0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IG51bGxdIC0gU3VmZml4ZSBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayDDoCByYWpvdXRlciBzdXIgbCdVUkwuXG4gICAgICogIFNpIGF1Y3VuIHN1ZmZpeGUgbidlc3Qgc3DDqWNpZmnDqSAoY2FzIHBhciBkw6lmYXV0KSwgb24gdXRpbGlzZXJhIGwnaWRlbnRpZmlhbnQgdGhpcy51dWlkICgpIGNvbW1lIHN1ZmZpeGUuIEV4OiBcImNhbGxiYWNrMTQ1ODU3NDM5NjU4MiAoKVwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNhbGxiYWNrTmFtZSA9IGdwLnByb3RvY29sLmpzb25wXSAtIFZhbGV1ciBkdSBwYXJhbcOodHJlIGNhbGxiYWNrIMOgIHJham91dGVyIHN1ciBsJ1VSTC5cbiAgICAgKiAgU2kgbCdVUkwgZm91cm5pZSBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjaywgbGUgcGFyYW3DqHRyZSBjYWxsYmFja05hbWUgbmUgc2VyYSBwYXMgcHJpcyBlbiBjb21wdGUuXG4gICAgICogIExhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIGVzdCBjcsOpw6llIGR5bmFtaXF1ZW1lbnQgcGFyIGxhIGZvbmN0aW9uIEpTT05QIDtcbiAgICAgKiAgZWxsZSBhIGRldXggZm9uY3Rpb25zIDpcbiAgICAgKiAgICBlbGxlIGFubnVsZSBsYSBjb25kaXRpb24gZGUgdGltZU91dFxuICAgICAqICAgIHB1aXMgYXBwZWxsZSBsYSBmb25jdGlvbiBmb3VybmllIHBhciBsJ3V0aWxpc2F0ZXVyIHZpYSBsZSBwYXJhbcOodHJlIG9uUmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblJlc3BvbnNlIC0gTm9tIGRlIGxhIGZvbmN0aW9uIHF1aSBzZXJhIGFwcGVsw6llIGxvcnMgZGUgbGEgcsOpY2VwdGlvbiBkZXMgcsOpc3VsdGF0cyBkdSBzZXJ2aWNlLlxuICAgICAqICBDZSBwYXJhbcOodHJlIHNlcmEgaWdub3LDqSBzaSBsJ1VSTCBjb250aWVudCBkw6lqw6AgbGUgcGFyYW3DqHRyZSBjYWxsYmFjay5cbiAgICAgKiAgTGEgZm9uY3Rpb24gZGUgcmFwcGVsIGFwcGVsw6llIHNlcmEgYWxvcnMgY2VsbGUgYXlhbnQgcG91ciBub20gbGEgdmFsZXVyIGRlIGNlIHBhcmFtw6h0cmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25UaW1lT3V0XSAtIE5vbSBkZSBsYSBmb25jdGlvbiBxdWkgc2VyYSBhcHBlbMOpZSBlbiBjYXMgZGUgbm9uIHLDqXBvbnNlIGR1IHNlcnZpY2UuXG4gICAgICogIExlIHRlbXBzIGF1IGJvdXQgZHVxdWVsIG9uIGNvbnNpZMOocmUgcXVlIGxlIHNlcnZpY2UgbidhIHBhcyByw6lwb25kdSBlc3QgZMOpdGVybWluw6kgcGFyIGxlIHBhcmFtw6h0cmUgdGltZU91dC5cbiAgICAgKiAgQGV4YW1wbGVcbiAgICAgKiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICB1cmwgOiAnaHR0cDovL2xvY2FsaG9zdC9zb21lL3Rlc3QuanNvbiZjYWxsYmFjaz1teVJlc3VsdHMnLFxuICAgICAqICAgICAgdGltZU91dCA6IDEwMCxcbiAgICAgKiAgICAgIGNhbGxiYWNrTmFtZSA6ICdteVJlc3VsdHMnLFxuICAgICAqICAgICAgY2FsbGJhY2tTdWZmaXggOiBcIlwiLFxuICAgICAqICAgICAgb25SZXNwb25zZSA6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzIDogJywgcmVzcG9uc2UpO1xuICAgICAqICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgfTtcbiAgICAgKiAgIEpTT05QLmNhbGwob3B0aW9ucyk7XG4gICAgICovXG4gICAgY2FsbCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJKU09OUFwiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFwiW0pTT05QOjpjYWxsICgpXVwiKTtcblxuICAgICAgICAvLyBhbmFseXNlIHBhcmFtZXRyZXNcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIm1pc3NpbmcgcGFyYW1ldGVyIDogb3B0aW9ucyAhXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBvcHRpb25zICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMudXJsKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMudXJsICFcIik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMudXJsICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMudGltZU91dCkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLnRpbWVPdXQnIGRlZmF1bHQgdmFsdWVcIik7XG4gICAgICAgICAgICBvcHRpb25zLnRpbWVPdXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRklYTUUgc2kgdW4gY2FsbGJhY2sgY290w6kgY2xpZW50IGEgw6l0w6kgbWlzIGVuIHBsYWNlLFxuICAgICAgICAvLyBjZXR0ZSBjb25kaXRpb24gc3VyIGNldHRlIG1ldGhvZGUgbidhIHBhcyBkZSBzZW5zICE/XG4gICAgICAgIGlmICghb3B0aW9ucy5vblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJtaXNzaW5nIHBhcmFtZXRlciA6IG9wdGlvbnMub25SZXNwb25zZSAhXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBwYXJhbWV0ZXIgOiBvcHRpb25zLm9uUmVzcG9uc2UgIVwiKTtcbiAgICAgICAgICAgIC8vIEZJWE1FIGRvaXQgb24gZGVmaW5pciB1biBjYWxsYmFjayBpbnRlcm5lIHBhciBkZWZhdXQgIT9cbiAgICAgICAgICAgIC8vIG9wdGlvbnMub25SZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLmxvZyhcInJlc3BvbnNlIGNhbGxiYWNrIChpbm5lcikgOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAvLyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUQgZHUgY2FsbGJhY2sgw6AgdXRpbGlzZXIgOiBudWxsIG91IHN0cmluZy5cbiAgICAgICAgLy8gc2kgbCd1dGlsaXNhdGV1ciBhIHNww6ljaWZpw6kgdW4gc3VmZml4ZSBwb3VyIGxlIGNhbGxiYWNrLCBvbiBsZSByw6ljdXDDqHJlIGNvbW1lIHVuIElEIChleDogb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IFwiXCIpXG4gICAgICAgIC8vIHNpbm9uLCBvbiB1dGlsaXNlIHVuIHRpbWVzdGFtcCA6IHRoaXMudXVpZCAoKVxuICAgICAgICB2YXIgY2FsbGJhY2tJZCA9ICh0eXBlb2Ygb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9PT0gXCJzdHJpbmdcIikgPyBvcHRpb25zLmNhbGxiYWNrU3VmZml4IDogdGhpcy51dWlkKCk7XG5cbiAgICAgICAgLy8gb24gcmVjaGVyY2hlIGxlIHBhcmFtZXRyZSBjYWxsYmFjayBldCBzb24gbm9tIGRlIGZvbmN0aW9uIGRhbnMgbCd1cmxcbiAgICAgICAgdmFyIHVybEhhc0NhbGxiYWNrS2V5ID0gZmFsc2U7XG4gICAgICAgIHZhciB1cmxIYXNDYWxsYmFja05hbWUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgaWR4ID0gb3B0aW9ucy51cmwuaW5kZXhPZihcImNhbGxiYWNrPVwiKTtcblxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdXJsSGFzQ2FsbGJhY2tLZXkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZXh0cmFjdGlvbiBjYWxsYmFja05hbWUgZGUgbCd1cmwgOiBlbnRyZSBcImNhbGxiYWNrPVwiIGV0IFwiJlwiIG91IGZpbiBkZSBsaWduZVxuICAgICAgICAgICAgdmFyIGogPSBvcHRpb25zLnVybC5pbmRleE9mKFwiJlwiLCBpZHgpO1xuICAgICAgICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaiA9IG9wdGlvbnMudXJsLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb24gZWNyYXNlIGxlIHBhcmFtZXRyZSBvcHRpb25zLmNhbGxiYWNrTmFtZSBzJ2lsIGF2YWl0IMOpdMOpIGTDqWZpbmlcbiAgICAgICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBvcHRpb25zLnVybC5zdWJzdHJpbmcoaWR4ICsgOSwgaik7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFja05hbWUpIHtcbiAgICAgICAgICAgICAgICB1cmxIYXNDYWxsYmFja05hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tOYW1lID0gY2FsbGJhY2tOYW1lO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwic2V0dGluZyAnb3B0aW9ucy5jYWxsYmFja05hbWUnIHZhbHVlIChcIiArIG9wdGlvbnMuY2FsbGJhY2tOYW1lICsgXCIpIGZyb20gJ29wdGlvbnMudXJsJyBwYXJhbWV0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbiBham91dGUgbGUgcGFyYW1ldHJlIGNhbGxiYWNrIGRhbnMgbCdVUkwgcydpbCBuJ2V4aXN0ZSBwYXNcbiAgICAgICAgaWYgKCF1cmxIYXNDYWxsYmFja0tleSkge1xuICAgICAgICAgICAgLy8gZ2VzdGlvbiBkZXMgYXV0cmVzIHBhcmFtLiBldCBcIj9cIlxuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25zLnVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChrID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGF1Y3VuIHBhcmFtLiwgbmkgZGUgJz8nXG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cmwgPSBvcHRpb25zLnVybCArIFwiP1wiICsgXCJjYWxsYmFjaz1cIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gb3B0aW9ucy51cmwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5pcXVlbWVudCBsZSAnPydcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgXCJjYWxsYmFjaz1cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbGUgJz8nIGV0IGxlcyBwYXJhbS4gZXhpc3RlbnRcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsICsgXCImXCIgKyBcImNhbGxiYWNrPVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nIGNhbGxiYWNrIGRlZmF1bHQga2V5IGluICdvcHRpb25zLnVybCcgOiBcIiArIG9wdGlvbnMudXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHV0aWxpc2F0aW9uIGRlIGxhIGZvbmN0aW9uIGNhbGxiYWNrIGNvdMOpIGNsaWVudCA/XG4gICAgICAgIHZhciBIYXNDYWxsYmFja05hbWUgPSBvcHRpb25zLmNhbGxiYWNrTmFtZSA/IHRydWUgOiB1cmxIYXNDYWxsYmFja05hbWU7XG5cbiAgICAgICAgLy8gb24gYWpvdXRlIGxlIG5vbSBkZSBsYSBmb25jdGlvbiBjYWxsYmFjayBkYW5zIGwnVVJMIHNpIGVsbGUgbidleGlzdGUgcGFzXG4gICAgICAgIGlmICghdXJsSGFzQ2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICAvLyBmb25jdGlvbiBjYWxsYmFjayBwYXIgZGVmYXV0XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nICdvcHRpb25zLmNhbGxiYWNrTmFtZScgZGVmYXVsdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrTmFtZSA9IFwiY2FsbGJhY2tcIjsgLy8gb3UgXCJncC5wcm90b2NvbC5qc29ucFwiID9cbiAgICAgICAgICAgICAgICAvLyBpbmZvIDogc2kgb24gbmUgdmV1dCBwYXMgZ2VyZXIgZCdJRCBkYW5zIGxlIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMuY2FsbGJhY2tTdWZmaXggPSBcIlwiXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrSWQgfHwgY2FsbGJhY2tJZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrTmFtZSArPSBjYWxsYmFja0lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwucmVwbGFjZShcImNhbGxiYWNrPVwiLCBcImNhbGxiYWNrPVwiICsgb3B0aW9ucy5jYWxsYmFja05hbWUpO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJzZXR0aW5nIGNhbGxiYWNrIGZ1bmN0aW9uIG5hbWUgaW4gJ29wdGlvbnMudXJsJyA6IFwiICsgb3B0aW9ucy51cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZU91dCBwYXIgZGVmYXV0XG4gICAgICAgIGlmICghb3B0aW9ucy5vblRpbWVPdXQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwic2V0dGluZyAnb3B0aW9ucy5vblRpbWVPdXQnIGRlZmF1bHQgdmFsdWVcIik7XG4gICAgICAgICAgICAvKiogY2FsbGJhY2sgdGltZW91dCBwYXIgZGVmYXV0ICovXG4gICAgICAgICAgICBvcHRpb25zLm9uVGltZU91dCA9IGZ1bmN0aW9uICgvKiBlcnJvciAqLykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGltZU91dCB3aGlsZSBpbnZva2luZyB1cmwgOiBcIiArIG9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUhhc0NhbGxiYWNrTmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBldmVudCBkdSB0aW1lb3V0XG4gICAgICAgICAgICB2YXIgb25UaW1lT3V0VHJpZ2dlciA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGRlY2xlbmNoZSBsZSB0aW1lb3V0IHNpID4gw6AgMCAhXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aW1lT3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIG9uVGltZU91dFRyaWdnZXIgPSB3aW5kb3cuc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIGZvbmN0aW9uIGRlIHJlcG9uc2UgZHUgc2VydmljZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93W29wdGlvbnMuY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblRpbWVPdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlbGV0ZVNjcmlwdChjYWxsYmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lT3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRklYTUUgbGUgbm9tIGRlIGxhIGZvbmN0aW9uIG4nYWNjZXB0ZSBwYXMgZGUgbmFtZXNwYWNlICFcbiAgICAgICAgICAgIC8vIGV4LiBHcC5GdW5jdGlvbi5jYWxsYmFja1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIGZvbmN0aW9uIGRlIHJlcG9uc2UgZHUgc2VydmljZVxuICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGRhdGFcbiAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB3aW5kb3dbb3B0aW9ucy5jYWxsYmFja05hbWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KG9uVGltZU91dFRyaWdnZXIpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZXNwb25zZShkYXRhKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWxldGVTY3JpcHQoY2FsbGJhY2tJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlU2NyaXB0KGNhbGxiYWNrSWQsIG9wdGlvbnMudXJsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBjcmVhdGUgU2NyaXB0XG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2FsbGJhY2tJZCAtIGNhbGxiYWNrIElkXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gdXJsXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2NyZWF0ZVNjcmlwdCA6IGZ1bmN0aW9uIChjYWxsYmFja0lkLCB1cmwpIHtcbiAgICAgICAgdmFyIHNjcmlwdHU7XG4gICAgICAgIHZhciBzY3JpcHRvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzXCIgKyBjYWxsYmFja0lkKTtcblxuICAgICAgICBzY3JpcHR1ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgc2NyaXB0dS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9qYXZhc2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcInNyY1wiLCB1cmwpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcImNoYXJzZXRcIiwgXCJVVEYtOFwiKTtcbiAgICAgICAgc2NyaXB0dS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInJlc3VsdHNcIiArIGNhbGxiYWNrSWQpO1xuICAgICAgICBzY3JpcHR1LnNldEF0dHJpYnV0ZShcImFzeW5jXCIsIFwidHJ1ZVwiKTsgLy8gRklYTUUgYXN5bmMgP1xuICAgICAgICAvLyBoZWFkIG91IGJvZHkgb3UgYXV0cmVzID9cbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICBpZiAoc2NyaXB0byA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChzY3JpcHR1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHMnaWwgZXhpc3RlIGTDqWrDoCwgb24gbGUgcmVtcGxhY2UgIVxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0dSwgc2NyaXB0byk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBkZWxldGUgU2NyaXB0XG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2FsbGJhY2tJZCAtIGNhbGxiYWNrIElkXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgX2RlbGV0ZVNjcmlwdCA6IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc3VsdHNcIiArIGNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHNjcmlwdC5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoSlNPTlApO1xuXG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0FsdGlSZXF1ZXN0UkVTVF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19BbHRpUmVxdWVzdFdQU19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG4vKipcbiAqIENyZWF0aW9uIGQndW5lIHJlcXXDqnRlIGVuIFJFU1Qgb3UgV1BTXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEFsdGlSZXF1ZXN0RmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdEZhY3RvcnlcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5cblxuXG52YXIgQWx0aVJlcXVlc3RGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgQWx0aVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgaHR0cE1ldGhvZCA6ICdHRVQnLCAvLyBHRVR8UE9TVFxuICAgICAqICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7fSxcbiAgICAgKiAgICAgIG9uRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICAgICAqICAgICAgc2NvcGUgOiB0aGlzLFxuICAgICAqICAgICAgcG9zaXRpb25zIDogW3tsb246LCBsYXQ6fSwge2xvbjosIGxhdDp9XSxcbiAgICAgKiAgICAgIG91dHB1dEZvcm1hdCA6ICdqc29uJyAvLyBqc29ufHhtbFxuICAgICAqICAgICAgc2FtcGxpbmcgOiAzLFxuICAgICAqICAgICAgYXBpIDogJ1JFU1QnLCAvLyBSRVNUfFdQU1xuICAgICAqICAgICAgem9ubHkgOiBmYWxzZSAvLyBmYWxzZXx0cnVlXG4gICAgICogICB9O1xuICAgICAqXG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKFwiQWx0aVJlcXVlc3RGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQWx0aVJlcXVlc3RGYWN0b3J5OjpidWlsZCgpXCJdKTtcblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gb24gZmFjdG9yaXNlIGxlcyBvcHRpb25zIHBhciBncm91cGU7XG4gICAgICAgIC8vIC0gZ2xvYmFsLFxuICAgICAgICAvLyAtIHBhcmFtLCBsZXMgcGFyYW1zIHBvdXIgbGVzIGRhdGEgaW5wdXRzXG4gICAgICAgIC8vIC0gd3BzLCBsZXMgcGFyYW0gZHUgc2VydmljZVxuICAgICAgICAvLyAtIGNhbGxiYWNrXG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgLy8gYWpvdXQgZGVzIHZhbGV1cnMgcGFyIGRlZmF1dCBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZVxuICAgICAgICAgICAgdHlwZSA6IG9wdGlvbnMuc2FtcGxpbmcgPyBcIlByb2ZpbFwiIDogXCJFbGV2YXRpb25cIixcbiAgICAgICAgICAgIG1ldGhvZCA6IG9wdGlvbnMuaHR0cE1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtIDoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyIDogbnVsbCwgLy8gRklYTUUgcGFyIGRlZmF1dCwgb24gbmUgbGUgbWV0IHBhcyBlbiBwbGFjZSBjYXIgw6dhIGZhaXQgcGxhbnRlciBsYSByZXF1w6p0ZSAhP1xuICAgICAgICAgICAgICAgIGluZGVudCA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICBjcnMgOiBudWxsLCAvLyBwYXIgZGVmYXV0XG4gICAgICAgICAgICAgICAgZm9ybWF0IDogbnVsbCwgLy8gKG9ubHkgdG8gUE9TVClcbiAgICAgICAgICAgICAgICBzYW1wbGluZyA6IG51bGwsIC8vIChvbmx5IHVzZSBieSBQcm9maWwpXG4gICAgICAgICAgICAgICAgem9ubHkgOiBudWxsIC8vIChvbmx5IHVzZSBieSBFbGV2YXRpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3VyY2hhcmdlIGRlcyB2YWxldXJzIG9ibGlnYXRvaXJlc1xuICAgICAgICBzZXR0aW5ncy5wYXJhbS5wb3NpdGlvbnMgPSBvcHRpb25zLnBvc2l0aW9ucztcbiAgICAgICAgc2V0dGluZ3MucGFyYW0uZm9ybWF0ID0gb3B0aW9ucy5vdXRwdXRGb3JtYXQ7XG4gICAgICAgIHNldHRpbmdzLnBhcmFtLnNhbXBsaW5nID0gb3B0aW9ucy5zYW1wbGluZztcbiAgICAgICAgc2V0dGluZ3MucGFyYW0uem9ubHkgPSBvcHRpb25zLnpvbmx5O1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGVzIGNhbGxiYWNrXG4gICAgICAgIHZhciBiT25FcnJvciA9ICEhKChvcHRpb25zLm9uRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMub25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSk7XG4gICAgICAgIHZhciBiT25TdWNjZXNzID0gISEoKG9wdGlvbnMub25TdWNjZXNzICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25zLm9uU3VjY2VzcyA9PT0gXCJmdW5jdGlvblwiKSk7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMuYXBpKSB7XG4gICAgICAgICAgICBjYXNlIFwiUkVTVFwiOlxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIGxlcyBleGNlcHRpb25zIG5lIHNvbnQgcGFzICdjYXRjaMOpZXMnIHN1ciBsZSBjb25zdHJ1Y3RldXIgIVxuICAgICAgICAgICAgICAgIHZhciBteVJlcSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0FsdGlSZXF1ZXN0UkVTVF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW15UmVxLnByb2Nlc3NSZXF1ZXN0U3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiRXJyb3IgaW4gcHJvY2VzcyByZXF1ZXN0IChyZXN0KSAhXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbXlSZXEucmVxdWVzdFN0cmluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXUFNcIjpcbiAgICAgICAgICAgICAgICAvLyBham91dCBkZXMgdmFsZXVycyBwYXIgZGVmYXV0IHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlIFdQU1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLndwcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZSA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICAgICAgcmF3ZGF0YW91dHB1dCA6IG51bGwsIC8vIHBhciBkZWZhdXRcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA6IG51bGwgLy8gcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19BbHRpUmVxdWVzdFdQU19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJ1aWxkKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiRXJyb3IgaW4gcHJvY2VzcyByZXF1ZXN0ICh3cHMpICFcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJUeXBlIG9mIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZpY2UgKFJFU1Qgb3IgV1BTKSAhXCI7XG4gICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10obWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiT25TdWNjZXNzKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uU3VjY2Vzcy5jYWxsKG9wdGlvbnMuc2NvcGUsIHJlcXVlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBbHRpUmVxdWVzdEZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21vZGVsX0FsdGlFbGV2YXRpb25SZXF1ZXN0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX21vZGVsX0FsdGlQcm9maWxSZXF1ZXN0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbi8qIGpzaGludCBtdWx0aXN0ciA6IHRydWUgKi9cblxuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFJFU1Qgc3VyIGxlIHNlcnZpY2UgYWx0aW1ldHJpcXVlLlxuICpcbiAqIEB0b2RvIExlIHNlcnZpY2UgQWx0aSBuJ2ltcGxlbWVudGUgcGFzIGxlIFBPU1QgIT9cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFJFU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5wYXJhbS5wb3NpdGlvbnMgLSB0YWJsZWF1IGRlIGNvb3Jkb25uw6llcyBsb24vbGF0XG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmRlbGltaXRlciAtICd8J1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy5wYXJhbS5pbmRlbnQgLSBmYWxzZXx0cnVlXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmNycyAtICdDUlM6ODQnXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnNhbXBsaW5nIC0gM1xuICogQHBhcmFtIHtCb29sZWFufSAgb3B0aW9ucy5wYXJhbS56b25seSAtIGZhbHNlfHRydWVcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uZm9ybWF0IC0gXCJKU09OfFhNTFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnR5cGUgLSBcIlByb2ZpbHxFbGV2YXRpb25cIlxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5tZXRob2QgLSBHRVR8UE9TVFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgIHZhciBvcHRpb25zID0ge1xuICogICAgICAgICAgIHR5cGUgOiAnUHJvZmlsJywgLy8gRWxldmF0aW9uXG4gKiAgICAgICAgICAgbWV0aG9kIDogJ0dFVCcsICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgcGFyYW0gOiB7XG4gKiAgICAgICAgICAgICAgIHBvc2l0aW9ucyA6IFtcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTEnLCBsYXQ6JzEuMTEnfSxcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTAnLCBsYXQ6JzEuMTAnfSxcbiAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTInLCBsYXQ6JzEuMTInfVxuICogICAgICAgICAgICAgICBdLFxuICogICAgICAgICAgICAgICBkZWxpbWl0ZXIgOiBcIjtcIiwgICAgICAgICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGluZGVudCAgICA6IHRydWUsICAgICAgICAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGNycyAgICAgICA6ICdFUFNHOjQzMjYnLCAvLyBwYXIgZGVmYXV0XG4gKiAgICAgICAgICAgICAgIGZvcm1hdCAgICA6ICdqc29uJywgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHRvIFBPU1QpXG4gKiAgICAgICAgICAgICAgIHNhbXBsaW5nICA6IDMgLCAgICAgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHVzZSBieSBQcm9maWwpXG4gKiAgICAgICAgICAgICAgIHpvbmx5ICAgICA6IGZhbHNlICAgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHVzZSBieSBFbGV2YXRpb24pXG4gKiAgICAgICAgICAgfVxuICogICAgICB9O1xuICpcbiAqICAgICAgdmFyIHJlc3VsdDtcbiAqICAgICAgdHJ5IHtcbiAqICAgICAgICAgIHZhciBvYmogPSBuZXcgQWx0aVJlcXVlc3RSRVNUIChvcHRpb25zKTtcbiAqICAgICAgICAgIGlmICghIG9iai5wcm9jZXNzUmVxdWVzdFN0cmluZyAoKSkge1xuICogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgZW1wdHkgIT9cIilcbiAqICAgICAgICAgIH1cbiAqICAgICAgICAgIHJlc3VsdCA9IG9iai5yZXF1ZXN0U3RyaW5nO1xuICogICAgICB9IGNhdGNoIChlKSB7XG4gKiAgICAgICAgICAvLyBleGNlcHRpb25zLi4uXG4gKiAgICAgIH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEFsdGlSZXF1ZXN0UkVTVCAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJBbHRpUmVxdWVzdFJFU1RcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEFsdGlSZXF1ZXN0UkVTVCAoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWx0aVJlcXVlc3RSRVNUKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQWx0aVJlcXVlc3RSRVNUIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIGV4aXN0YW5jZSBkZXMgb3B0aW9uc1xuICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwib3B0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBkZSByZXF1ZXRlIDogQWx0aXR1ZGUgb3UgUHJvZmlsXG4gICAgLy8gKHBhcmFtLiDDoCBkZXRlcm1pbmVyIGVuIGZvbmN0aW9uIGRlcyBwYXJhbWV0cmVzIGQnZW50csOpZSlcbiAgICBpZiAoIXRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwidHlwZSAoRWxldmF0aW9uIG9yIFByb2ZpbClcIikpO1xuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdGlvbiBkdSBtb2RlbGUgZGUgcmVxdcOqdGVcbiAgICAvLyAodGVzdCBkdSB0eXBlIGQnb2JqZXQgY2FuZGlkYXQpXG4gICAgdGhpcy5EYXRhT2JqZWN0ID0gbnVsbDtcbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJFbGV2YXRpb25cIjpcbiAgICAgICAgICAgIHRoaXMuRGF0YU9iamVjdCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21vZGVsX0FsdGlFbGV2YXRpb25SZXF1ZXN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10odGhpcy5vcHRpb25zLnBhcmFtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUHJvZmlsXCI6XG4gICAgICAgICAgICB0aGlzLkRhdGFPYmplY3QgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19tb2RlbF9BbHRpUHJvZmlsUmVxdWVzdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHRoaXMub3B0aW9ucy5wYXJhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX1RZUEVcIiwgXCJ0eXBlIChFbGV2YXRpb24gb3IgUHJvZmlsKVwiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWV0aG9kZS5cbiAgICAgKiBQYXIgZGVmYXV0LCBcIkdFVFwiLlxuICAgICAqL1xuICAgIHRoaXMubWV0aG9kID0gdGhpcy5vcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiO1xufVxuXG5BbHRpUmVxdWVzdFJFU1QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogQWx0aVJlcXVlc3RSRVNULFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIGdldCA6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FIG9uIHJldGlyZSBsZSBwYXJhbSAnZGVsaW1pdGVyJyA6ICZkZWxpbWl0ZXI9J19fREVMSU1JVEVSX18nXG4gICAgICAgICAgICB2YWx1ZSA6IFwibG9uPV9fTE9OX18mbGF0PV9fTEFUX18maW5kZW50PV9fSU5ERU5UX18mY3JzPSdfX0NSU19fJ1wiLFxuICAgICAgICAgICAgaW5wdXQgOiB7XG4gICAgICAgICAgICAgICAgcG9pbnQgOiBcIiZ6b25seT1fX1pPTkxZX19cIixcbiAgICAgICAgICAgICAgICBwcm9maWwgOiBcIiZzYW1wbGluZz1fX1NBTVBMSU5HX19cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwb3N0IDoge1xuICAgICAgICAgICAgLy8gRklYTUUgb24gcmV0aXJlIGxlIHBhcmFtICdkZWxpbWl0ZXInIDogZGVsaW1pdGVyPSdfX0RFTElNSVRFUl9fJ1xcblxcXG4gICAgICAgICAgICB2YWx1ZSA6IFwibG9uPV9fTE9OX19cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJsYXQ9X19MQVRfX1xcblwiICtcbiAgICAgICAgICAgICAgICBcImluZGVudD1fX0lOREVOVF9fXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiY3JzPSdfX0NSU19fJ1xcblwiLFxuICAgICAgICAgICAgaW5wdXQgOiB7XG4gICAgICAgICAgICAgICAgcG9pbnQgOiBcInpvbmx5PV9fWk9OTFlfX1wiLFxuICAgICAgICAgICAgICAgIHByb2ZpbCA6IFwic2FtcGxpbmc9X19TQU1QTElOR19fXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdFVCAgb3V0IDogbG9uPTAuMjM2NywyLjE1NzAmbGF0PTQ4LjA1NTEsNDYuNjA3NyZkZWxpbWl0ZXI9LCZpbmRlbnQ9dHJ1ZSZ6b25seT10cnVlJmNycz0nQ1JTOjg0J1xuICAgICAqIC8vIFBPU1Qgb3V0IDogTm90IHlldCBzdXBwb3J0ZWQgbWV0aG9kIFBPU1QgIVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiQWx0aVJlcXVlc3RSRVNUOjpwcm9jZXNzUmVxdWVzdFN0cmluZyAoKVwiKTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucG9zdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19MT05fXy9nLCB0aGlzLkRhdGFPYmplY3QuZ2V0TG9uKCkpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fTEFUX18vZywgdGhpcy5EYXRhT2JqZWN0LmdldExhdCgpKTtcbiAgICAgICAgLy8gRklYTUUgb24gcmV0aXJlIGxlIHBhcmFtICdkZWxpbWl0ZXInXG4gICAgICAgIC8vIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19ERUxJTUlURVJfXy9nLCB0aGlzLkRhdGFPYmplY3QuZGVsaW1pdGVyKTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0lOREVOVF9fL2csIHRoaXMuRGF0YU9iamVjdC5pbmRlbnQpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fQ1JTX18vZywgdGhpcy5EYXRhT2JqZWN0LmNycyk7XG5cbiAgICAgICAgLy8gYWpvdXQgK1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlICsgdGhpcy5fX2FkZERhdGFJbnB1dHMoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJ0cmFkdWN0aW9uIHRtcGxcIiwgdGVtcGxhdGUpO1xuXG4gICAgICAgIC8vIHNhdXZlZ2FyZGVcbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RyaW5nID0gdGVtcGxhdGU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZGUgcGFyYW1ldHJlcyBzcMOpY2lmaXF1ZXMgKGV4LiB6b25seSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgX19hZGREYXRhSW5wdXRzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIkFsdGlSZXF1ZXN0UkVTVDo6YWRkRGF0YUlucHV0ICgpXCIpO1xuXG4gICAgICAgIHZhciBteVRlbXBsYXRlO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICBteVRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5wb3N0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICBteVRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5nZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdGhlciBIVFRQIG1ldGhvZCBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZpY2UgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0bXBsID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuRGF0YU9iamVjdC5DTEFTU05BTUUgPT09IFwiQWx0aUVsZXZhdGlvblJlcXVlc3RcIikge1xuICAgICAgICAgICAgdG1wbCA9IG15VGVtcGxhdGUuaW5wdXQucG9pbnQ7XG4gICAgICAgICAgICByZXR1cm4gdG1wbC5yZXBsYWNlKC9fX1pPTkxZX18vZywgdGhpcy5EYXRhT2JqZWN0Lnpvbmx5KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLkRhdGFPYmplY3QuQ0xBU1NOQU1FID09PSBcIkFsdGlQcm9maWxSZXF1ZXN0XCIpIHtcbiAgICAgICAgICAgIHRtcGwgPSBteVRlbXBsYXRlLmlucHV0LnByb2ZpbDtcbiAgICAgICAgICAgIHJldHVybiB0bXBsLnJlcGxhY2UoL19fU0FNUExJTkdfXy9nLCB0aGlzLkRhdGFPYmplY3Quc2FtcGxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3RoZXIgb2JqZWN0IHN1cHBvcnRlZCB0aGFuIGVsZXZhdGlvbiBvciBwcm9maWwgIT9cIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFsdGlSZXF1ZXN0UkVTVCk7XG5cblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRm9ybWF0c19XUFNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fbW9kZWxfQWx0aUVsZXZhdGlvblJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fbW9kZWxfQWx0aVByb2ZpbFJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuLyoqXG4gKiBDbGFzc2UgZCdpbnRlcmZhY2UgZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFdQUyBzdXIgbGUgc2VydmljZSBhbHRpbWV0cmlxdWUuXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFdQU1xuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuUmVxdWVzdC5BbHRpUmVxdWVzdFdQU1xuICogQHByaXZhdGVcbiAqL1xuXG5cblxuXG5cblxudmFyIEFsdGlSZXF1ZXN0V1BTID0ge1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJmYWNlIHVuaXF1ZSBkZSBjb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5wYXJhbS5wb3NpdGlvbnMgLSB0YWJsZWF1IGRlIGNvb3Jkb25uw6llcyBsb24vbGF0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5kZWxpbWl0ZXIgLSAnfCdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICBvcHRpb25zLnBhcmFtLmluZGVudCAtIGZhbHNlfHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLmNycyAtICdDUlM6ODQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5zYW1wbGluZyAtIDNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICBvcHRpb25zLnBhcmFtLnpvbmx5IC0gZmFsc2V8dHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uZm9ybWF0IC0gXCJKU09OfFhNTFwiIChvbmx5IHRvIFBPU1QpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy53cHMuc2VydmljZSAtIFwiV1BTXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLndwcy52ZXJzaW9uIC0gXCIxLjAuMFwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy53cHMuaWRlbnRpZmllciAtIFwiZ3M6V1BTRWxldmF0aW9ufGdzOldQU0xpbmVFbGV2YXRpb25cIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMud3BzLnJhd2RhdGFvdXRwdXQgLSBcInJlc3VsdFwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy53cHMucmVxdWVzdCAtIFwiRXhlY3V0ZVwiXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy50eXBlIC0gXCJQcm9maWx8RWxldmF0aW9uXCJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLm1ldGhvZCAtIEdFVHxQT1NUXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgICAgICB0eXBlIDogJ1Byb2ZpbCcsIC8vIEVsZXZhdGlvblxuICAgICAqICAgICAgICAgICBtZXRob2QgOiAnR0VUJywgIC8vIHBhciBkZWZhdXRcbiAgICAgKiAgICAgICAgICAgcGFyYW0gOiB7XG4gICAgICogICAgICAgICAgICAgICBwb3NpdGlvbnMgOiBbXG4gICAgICogICAgICAgICAgICAgICAgICAge2xvbjonMS4xMScsIGxhdDonMS4xMSd9LFxuICAgICAqICAgICAgICAgICAgICAgICAgIHtsb246JzEuMTAnLCBsYXQ6JzEuMTAnfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICB7bG9uOicxLjEyJywgbGF0OicxLjEyJ31cbiAgICAgKiAgICAgICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgICAgICBkZWxpbWl0ZXIgOiBcIjtcIiwgICAgICAgICAvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgICAgICBpbmRlbnQgICAgOiB0cnVlLCAgICAgICAgLy8gcGFyIGRlZmF1dFxuICAgICAqICAgICAgICAgICAgICAgY3JzICAgICAgIDogJ0VQU0c6NDMyNicsIC8vIHBhciBkZWZhdXRcbiAgICAgKiAgICAgICAgICAgICAgIGZvcm1hdCAgICA6ICdqc29uJywgICAgICAvLyBwYXIgZGVmYXV0IChvbmx5IHRvIFBPU1QpXG4gICAgICogICAgICAgICAgICAgICBzYW1wbGluZyAgOiAzICwgICAgICAgICAgLy8gcGFyIGRlZmF1dCAob25seSB1c2UgYnkgUHJvZmlsKVxuICAgICAqICAgICAgICAgICAgICAgem9ubHkgICAgIDogZmFsc2UsICAgICAgIC8vIHBhciBkZWZhdXQgKG9ubHkgdXNlIGJ5IEVsZXZhdGlvbilcbiAgICAgKiAgICAgICAgICAgfSxcbiAgICAgKiAgICAgICAgICAgd3BzIDoge1xuICAgICAqICAgICAgICAgICAgICAgICBzZXJ2aWNlIDogJ1dQUycsICAgICAgICAgLy8gcGFyIGRlZmF1dFxuICAgICAqICAgICAgICAgICAgICAgICB2ZXJzaW9uIDogJzEuMC4wJywgICAgICAgLy8gcGFyIGRlZmF1dFxuICAgICAqICAgICAgICAgICAgICAgICBpZGVudGlmaWVyIDogJ2dzOldQUycsICAgLy8gcGFyIGRlZmF1dCwgRWxldmF0aW9uID0gZ3M6V1BTRWxldmF0aW9uLCBQcm9maWwgPSBnczpXUFNMaW5lRWxldmF0aW9uXG4gICAgICogICAgICAgICAgICAgICAgIHJhd2RhdGFvdXRwdXQgOiAncmVzdWx0JywvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgICAgICAgIHJlcXVlc3QgOiAnRXhlY3V0ZScgICAgICAvLyBwYXIgZGVmYXV0XG4gICAgICogICAgICAgICAgIH1cbiAgICAgKiAgICAgICB9O1xuICAgICAqL1xuICAgIGJ1aWxkIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkFsdGlSZXF1ZXN0V1BTXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQWx0aVJlcXVlc3RXUFM6OmJ1aWxkKClcIl0pO1xuXG4gICAgICAgIC8vIGV4aXN0YW5jZSBkZXMgb3B0aW9uc1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwib3B0aW9uc1wiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0eXBlIGRlIHJlcXVldGUgOiBBbHRpdHVkZSBvdSBQcm9maWxcbiAgICAgICAgLy8gKHBhcmFtLiDDoCBkZXRlcm1pbmVyIGVuIGZvbmN0aW9uIGRlcyBwYXJhbWV0cmVzIGQnZW50csOpZSlcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwidHlwZSAoRWxldmF0aW9uIG9yIFByb2ZpbClcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3RydWN0aW9uIGR1IG1vZGVsZSBkZSByZXF1w6p0ZVxuICAgICAgICAvLyAodGVzdCBkdSB0eXBlIGQnb2JqZXQgY2FuZGlkYXQpXG4gICAgICAgIHZhciBEYXRhT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFbGV2YXRpb25cIjpcbiAgICAgICAgICAgICAgICAvLyBzdXJjaGFyZ2VcbiAgICAgICAgICAgICAgICBvcHRpb25zLndwcy5pZGVudGlmaWVyID0gXCJnczpXUFNFbGV2YXRpb25cIjtcbiAgICAgICAgICAgICAgICBEYXRhT2JqZWN0ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fbW9kZWxfQWx0aUVsZXZhdGlvblJlcXVlc3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXShvcHRpb25zLnBhcmFtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQcm9maWxcIjpcbiAgICAgICAgICAgICAgICAvLyBzdXJjaGFyZ2VcbiAgICAgICAgICAgICAgICBvcHRpb25zLndwcy5pZGVudGlmaWVyID0gXCJnczpXUFNMaW5lRWxldmF0aW9uXCI7XG4gICAgICAgICAgICAgICAgRGF0YU9iamVjdCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX21vZGVsX0FsdGlQcm9maWxSZXF1ZXN0X19bXCJhXCIgLyogZGVmYXVsdCAqL10ob3B0aW9ucy5wYXJhbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX1RZUEVcIiwgXCJ0eXBlIChFbGV2YXRpb24gb3IgUHJvZmlsKVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUgV1BTXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGRhdGEgOiBEYXRhT2JqZWN0LFxuICAgICAgICAgICAgbWV0aG9kIDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBwYXJhbSA6IG9wdGlvbnMud3BzXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJxc3RXUFMgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Gb3JtYXRzX1dQU19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHNldHRpbmdzKTtcblxuICAgICAgICBpZiAoIXJxc3RXUFMucHJvY2Vzc1JlcXVlc3RTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5hYmxlIHRvIHByb2Nlc3MgcmVxdWVzdCAhXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJxc3RXUFMucmVxdWVzdFN0cmluZztcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFsdGlSZXF1ZXN0V1BTKTtcblxuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU3RhbmRhcmQgV1BTXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5XUFNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5kYXRhIC0gb2JqZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMubWV0aG9kIC0gUE9TVHxHRVRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0uc2VydmljZSAtIFwiV1BTXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucGFyYW0udmVyc2lvbiAtIFwiMS4wLjBcIlxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5wYXJhbS5pZGVudGlmaWVyIC0gXCJnczpXUFNFbGV2YXRpb258Z3M6V1BTTGluZUVsZXZhdGlvblwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnJhd2RhdGFvdXRwdXQgLSBcInJlc3VsdFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnBhcmFtLnJlcXVlc3QgLSBcIkV4ZWN1dGVcIlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbnN1Y2Nlc3MgLSBmdW5jdGlvbiBjYWxsYmFjayBzdWNjZXNzIChUT0RPKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmVycm9yICAgLSBmdW5jdGlvbiBjYWxsYmFjayBlcnJvciAgIChUT0RPKVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gV1BTIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBXUFMoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV1BTKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV1BTIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIE9iamV0IERBVEFcbiAgICAgKi9cbiAgICB0aGlzLkRhdGFPYmplY3QgPSB0aGlzLm9wdGlvbnMuZGF0YTtcblxuICAgIGlmICghdGhpcy5EYXRhT2JqZWN0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIGRhdGEgb2JqZWN0IGlzIG5vdCBkZWZpbmVkICFcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGFyYW0gc2VydmljZS5cbiAgICAgKiBQYXIgZGVmYXV0LCBcIldQU1wiLlxuICAgICAqL1xuICAgIHRoaXMucGFyYW1zZXJ2aWNlID0gdGhpcy5vcHRpb25zLnBhcmFtLnNlcnZpY2UgfHwgXCJXUFNcIjtcblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHZlcnNpb24uXG4gICAgICogUGFyIGRlZmF1dCwgXCIxLjAuMFwiLlxuICAgICAqL1xuICAgIHRoaXMucGFyYW12ZXJzaW9uID0gdGhpcy5vcHRpb25zLnBhcmFtLnZlcnNpb24gfHwgXCIxLjAuMFwiO1xuXG4gICAgLyoqXG4gICAgICogcGFyYW0gaWRlbnRpZmllclxuICAgICAqIFBhciBkZWZhdXQsIFwiZ3M6V1BTXCJcbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtaWRlbnRpZmllciA9IHRoaXMub3B0aW9ucy5wYXJhbS5pZGVudGlmaWVyIHx8IFwiZ3M6V1BTXCI7XG5cbiAgICAvKipcbiAgICAgKiBwYXJhbSByYXdkYXRhb3V0cHV0XG4gICAgICogUGFyIGRlZmF1dCwgXCJyZXN1bHRcIi5cbiAgICAgKi9cbiAgICB0aGlzLnBhcmFtcmF3ZGF0YW91dHB1dCA9IHRoaXMub3B0aW9ucy5wYXJhbS5yYXdkYXRhb3V0cHV0IHx8IFwicmVzdWx0XCI7XG5cbiAgICAvKipcbiAgICAgKiBwYXJhbSByZXF1ZXN0XG4gICAgICogUGFyIGRlZmF1dCwgXCJFeGVjdXRlXCIuXG4gICAgICovXG4gICAgdGhpcy5wYXJhbXJlcXVlc3QgPSB0aGlzLm9wdGlvbnMucGFyYW0ucmVxdWVzdCB8fCBcIkV4ZWN1dGVcIjtcblxuICAgIC8qKlxuICAgICAqIG1ldGhvZGUuXG4gICAgICogUGFyIGRlZmF1dCwgXCJHRVRcIi5cbiAgICAgKi9cbiAgICB0aGlzLm1ldGhvZCA9IHRoaXMub3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIjtcbn1cblxuV1BTLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6V1BTI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogV1BTLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIGdldCA6IHtcbiAgICAgICAgICAgIHZhbHVlIDogXCJzZXJ2aWNlPV9fU0VSVklDRV9fXCIgK1xuICAgICAgICAgICAgICAgIFwiJnZlcnNpb249X19WRVJTSU9OX19cIiArXG4gICAgICAgICAgICAgICAgXCImcmF3ZGF0YW91dHB1dD1fX1JBV0RBVEFPVVRQVVRfX1wiICtcbiAgICAgICAgICAgICAgICBcIiZpZGVudGlmaWVyPV9fSURFTlRJRklFUl9fXCIgK1xuICAgICAgICAgICAgICAgIFwiJnJlcXVlc3Q9X19SRVFVRVNUX19cIiArXG4gICAgICAgICAgICAgICAgXCImZGF0YWlucHV0cz08IS0tIF9fREFUQUlOUFVUU19fIC0tPlwiLFxuXG4gICAgICAgICAgICBpbnB1dCA6IFwiX19LRVlfXz1fX0RBVEFfX1wiXG5cbiAgICAgICAgfSxcbiAgICAgICAgcG9zdCA6IHtcblxuICAgICAgICAgICAgdmFsdWUgOiBcIjw/eG1sIHZlcnNpb249XFxcIjEuMFxcXCIgZW5jb2Rpbmc9XFxcIlVURi04XFxcIj8+XCIgK1xuICAgICAgICAgICAgICAgIFwiPHdwczpfX1JFUVVFU1RfXyB2ZXJzaW9uPVxcXCJfX1ZFUlNJT05fX1xcXCIgc2VydmljZT1cXFwiX19TRVJWSUNFX19cXFwiIFwiICtcbiAgICAgICAgICAgICAgICBcIl9fTkFNRVNQQUNFX18gX19TQ0hFTUFMT0NBVElPTl9fPlwiICtcbiAgICAgICAgICAgICAgICBcIjxvd3M6SWRlbnRpZmllcj5fX0lERU5USUZJRVJfXzwvb3dzOklkZW50aWZpZXI+XCIgK1xuICAgICAgICAgICAgICAgIFwiPHdwczpEYXRhSW5wdXRzPlwiICtcbiAgICAgICAgICAgICAgICBcIjwhLS0gX19EQVRBSU5QVVRTX18gLS0+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC93cHM6RGF0YUlucHV0cz5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOlJlc3BvbnNlRm9ybT5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOlJhd0RhdGFPdXRwdXQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiPG93czpJZGVudGlmaWVyPl9fUkFXREFUQU9VVFBVVF9fPC9vd3M6SWRlbnRpZmllcj5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpSYXdEYXRhT3V0cHV0PlwiICtcbiAgICAgICAgICAgICAgICBcIjwvd3BzOlJlc3BvbnNlRm9ybT5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpfX1JFUVVFU1RfXz5cIixcblxuICAgICAgICAgICAgaW5wdXQgOiBcIjx3cHM6SW5wdXQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiPG93czpJZGVudGlmaWVyPl9fS0VZX188L293czpJZGVudGlmaWVyPlwiICtcbiAgICAgICAgICAgICAgICBcIjx3cHM6RGF0YT5cIiArXG4gICAgICAgICAgICAgICAgXCI8d3BzOkxpdGVyYWxEYXRhPl9fREFUQV9fPC93cHM6TGl0ZXJhbERhdGE+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC93cHM6RGF0YT5cIiArXG4gICAgICAgICAgICAgICAgXCI8L3dwczpJbnB1dD5cIlxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBwYXIgZGVmYXV0IGRlIGxhIHJlcXVldGUgUE9TVC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgbmFtZXNwYWNlQnlEZWZhdWx0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnMgPSBbXG4gICAgICAgICAgICBcInhtbG5zOnhzaT1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dwcy8xLjAuMFxcXCJcIixcbiAgICAgICAgICAgIFwieG1sbnM6d2ZzPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmc1xcXCJcIixcbiAgICAgICAgICAgIFwieG1sbnM6d3BzPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dwcy8xLjAuMFxcXCJcIixcbiAgICAgICAgICAgIFwieG1sbnM6b3dzPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L293cy8xLjFcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOmdtbD1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOm9nYz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOndjcz1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC93Y3MvMS4xLjFcXFwiXCIsXG4gICAgICAgICAgICBcInhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIlwiXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIG5zLmpvaW4oXCIgXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2hlbWFsb2NhdGlvbiBwYXIgZGVmYXV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBzY2hlbWFMb2NhdGlvbkJ5RGVmYXVsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwieHNpOnNjaGVtYUxvY2F0aW9uPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dwcy8xLjAuMCBodHRwOi8vc2NoZW1hcy5vcGVuZ2lzLm5ldC93cHMvMS4wLjAvd3BzQWxsLnhzZFxcXCJcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0aW9uIGRlIGxhIHJlcXXDqnRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHRVQgIG91dCA6XG4gICAgICogLy8gIHNlcnZpY2U9X19TRVJWSUNFX19cbiAgICAgKiAvLyAgJnZlcnNpb249X19WRVJTSU9OX19cbiAgICAgKiAvLyAgJnJhd2RhdGFvdXRwdXQ9X19SQVdEQVRBT1VUUFVUX19cbiAgICAgKiAvLyAgJmlkZW50aWZpZXI9X19JREVOVElGSUVSX19cbiAgICAgKiAvLyAgJnJlcXVlc3Q9X19SRVFVRVNUX19cbiAgICAgKiAvLyAgJmRhdGFpbnB1dHM9XCJfX0RBVEFJTlBVVFNfX1wiXG4gICAgICogLy8gIGF2ZWMgX19EQVRBSU5QVVRTX18gPSBfX0tFWV9fPV9fREFUQV9fOy4uLlxuICAgICAqXG4gICAgICogLy8gUE9TVCBvdXQgOlxuICAgICAqIC8vICAgICAgPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz5cbiAgICAgKiAvLyAgICAgIDx3cHM6X19SRVFVRVNUX18gdmVyc2lvbj1cXFwiX19WRVJTSU9OX19cXFwiIHNlcnZpY2U9XFxcIl9fU0VSVklDRV9fXFxcIlxuICAgICAqIC8vICAgICAgICAgX19OQU1FU1BBQ0VfXyBfX1NDSEVNQUxPQ0FUSU9OX18+XG4gICAgICogLy8gICAgICAgICAgPG93czpJZGVudGlmaWVyPl9fSURFTlRJRklFUl9fPC9vd3M6SWRlbnRpZmllcj5cbiAgICAgKiAvLyAgICAgICAgICA8d3BzOkRhdGFJbnB1dHM+XG4gICAgICogLy8gICAgICAgICAgICAgIDwhLS0gX19EQVRBSU5QVVRTX18gLS0+XG4gICAgICogLy8gICAgICAgICAgPC93cHM6RGF0YUlucHV0cz5cbiAgICAgKiAvLyAgICAgICAgICA8d3BzOlJlc3BvbnNlRm9ybT5cbiAgICAgKiAvLyAgICAgICAgICAgICAgPHdwczpSYXdEYXRhT3V0cHV0PlxuICAgICAqIC8vICAgICAgICAgICAgICA8b3dzOklkZW50aWZpZXI+X19SQVdEQVRBT1VUUFVUX188L293czpJZGVudGlmaWVyPlxuICAgICAqIC8vICAgICAgICAgICAgICA8L3dwczpSYXdEYXRhT3V0cHV0PlxuICAgICAqIC8vICAgICAgICAgIDwvd3BzOlJlc3BvbnNlRm9ybT5cbiAgICAgKiAvLyAgICAgIDwvd3BzOl9fUkVRVUVTVF9fPlwiLFxuICAgICAqIC8vICAgICAgYXZlYyBfX0RBVEFJTlBVVFNfX1xuICAgICAqIC8vICAgICAgICAgICAgIDx3cHM6SW5wdXQ+XG4gICAgICogLy8gICAgICAgICAgICAgICAgICA8b3dzOklkZW50aWZpZXI+X19LRVlfXzwvb3dzOklkZW50aWZpZXI+XG4gICAgICogLy8gICAgICAgICAgICAgICAgICA8d3BzOkRhdGE+XG4gICAgICogLy8gICAgICAgICAgICAgICAgICAgIDx3cHM6TGl0ZXJhbERhdGE+X19EQVRBX188L3dwczpMaXRlcmFsRGF0YT5cbiAgICAgKiAvLyAgICAgICAgICAgICAgICAgIDwvd3BzOkRhdGE+XG4gICAgICogLy8gICAgICAgICAgICAgIDwvd3BzOklucHV0PlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiV1BTOjpwcm9jZXNzUmVxdWVzdFN0cmluZyAoKVwiKTtcblxuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucG9zdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLmdldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTm8gb3RoZXIgbWV0aG9kIHN1cHBvcnRlZCBieSB0aGUgc2VydmljZSAhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1NFUlZJQ0VfXy9nLCB0aGlzLnBhcmFtc2VydmljZSk7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19WRVJTSU9OX18vZywgdGhpcy5wYXJhbXZlcnNpb24pO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUkFXREFUQU9VVFBVVF9fL2csIHRoaXMucGFyYW1yYXdkYXRhb3V0cHV0KTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0lERU5USUZJRVJfXy9nLCB0aGlzLnBhcmFtaWRlbnRpZmllcik7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19SRVFVRVNUX18vZywgdGhpcy5wYXJhbXJlcXVlc3QpO1xuXG4gICAgICAgIC8vIGFqb3V0ICtcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX05BTUVTUEFDRV9fL2csIHRoaXMubmFtZXNwYWNlQnlEZWZhdWx0KTtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19TQ0hFTUFMT0NBVElPTl9fL2csIHRoaXMuc2NoZW1hTG9jYXRpb25CeURlZmF1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWpvdXQgZGVzIGRhdGFpbnB1dHNcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC88IS0tIF9fREFUQUlOUFVUU19fIC0tPi9nLCB0aGlzLl9fYWRkRGF0YUlucHV0cygpKTtcblxuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidHJhZHVjdGlvbiB0bXBsIDogZW1wdHkgcmVxdWVzdCAhP1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVxdWVzdFN0cmluZyA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcInRyYWR1Y3Rpb24gdG1wbFwiLCB0ZW1wbGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFqb3V0IGRlcyBkb25uw6llc1xuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBfX2FkZERhdGFJbnB1dHMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiV1BTOjpfX2FkZERhdGFJbnB1dHMgKClcIik7XG5cbiAgICAgICAgLy8gYydlc3QgdW4gcGV1IGdyb3NzaWVyLi4uXG4gICAgICAgIHZhciB0bXBsID0gdGhpcy5tZXRob2QgPT09IFwiR0VUXCIgPyB0aGlzLnRlbXBsYXRlLmdldC5pbnB1dCA6IHRoaXMudGVtcGxhdGUucG9zdC5pbnB1dDtcbiAgICAgICAgdmFyIHNlcCA9IHRoaXMubWV0aG9kID09PSBcIkdFVFwiID8gXCI7XCIgOiBcIlwiO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLkRhdGFPYmplY3QuZ2V0RGF0YSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gRklYTUUgY2xvc3VyZSA/XG4gICAgICAgICAgICAoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9IChqID09PSBtYXAubGVuZ3RoIC0gMSkgPyBcIlwiIDogXCI7XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhhdC5fX2FkZERhdGFJbnB1dCh0bXBsLCBtYXBbal0uaywgbWFwW2pdLnYpLCBzZXApO1xuICAgICAgICAgICAgfSkoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkJ3VuZSBkb25uw6llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0bXBsIC0gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gY2xlZlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gdmFsZXVyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBfX2FkZERhdGFJbnB1dCA6IGZ1bmN0aW9uICh0bXBsLCBrZXksIGRhdGEpIHtcbiAgICAgICAgdmFyIHRtcCA9IHRtcGw7XG4gICAgICAgIHRtcCA9IHRtcC5yZXBsYWNlKC9fX0tFWV9fL2csIGtleSk7XG4gICAgICAgIHRtcCA9IHRtcC5yZXBsYWNlKC9fX0RBVEFfXy9nLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pciBsZSBtb2RlIGRlIHJlcXXDqnRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gR0VUfFBPU1RcbiAgICAgKi9cbiAgICBzZXRNZXRob2QgOiBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgbWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwic3VwcG9ydCBvbmx5IEdFVCBhbmQgUE9TVCBtZXRob2QgIVwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRvdXJuZSBsZSBtb2RlIGRlIHJlcXVldGUgKEdFVHxQT1NUKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBbHRpUmVxdWVzdC5vcHRpb25zLm1vZGV8U3RyaW5nfVxuICAgICAqL1xuICAgIGdldE1ldGhvZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV1BTKTtcblxuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0Zvcm1hdHNfWE1MX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRm9ybWF0c19BbHRpUmVzcG9uc2VSZWFkZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fbW9kZWxfQWx0aVJlc3BvbnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fbW9kZWxfRWxldmF0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbi8qKlxuICogRmFjdG9yeSBwb3VyIGfDqW7DqXJlciB1bmUgcmVwb25zZSBKU09OIMOgIHBhcnRpciBkJ3VuIFhNTCBvdSBkJ3VuIEpTT05cbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgQWx0aVJlc3BvbnNlRmFjdG9yeVxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BbHRpLlJlc3BvbnNlLkFsdGlSZXNwb25zZUZhY3RvcnlcbiAqL1xuXG5cblxuXG5cblxuXG5cbnZhciBBbHRpUmVzcG9uc2VGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgQWx0aVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgcmVzcG9uc2UgOlxuICAgICAqICAgICAgb3V0cHV0Rm9ybWF0IDpcbiAgICAgKiAgICAgIHJhd1Jlc3BvbnNlIDpcbiAgICAgKiAgICAgIHNjb3BlIDpcbiAgICAgKiAgICAgIG9uU3VjY2VzcyA6XG4gICAgICogICAgICBvbkVycm9yIDpcbiAgICAgKiAgIH07XG4gICAgICpcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJBbHRpUmVzcG9uc2VGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQWx0aVJlc3BvbnNlRmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImFuYWx5emUgcmVzcG9uc2UgOiByYXdcIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5vdXRwdXRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IHhtbFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0Zvcm1hdHNfWE1MX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0Zvcm1hdHNfQWx0aVJlc3BvbnNlUmVhZGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTFN0cmluZyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTERvYyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcC5wYXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRVhDRVBUSU9OXzJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJhbmFseXplIHJlc3BvbnNlIDoganNvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImFuYWx5emUgcmVzcG9uc2UgOiBcIiwgdHlwZW9mIG9wdGlvbnMucmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgSlNPTlJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTlJlc3BvbnNlID0gSlNPTi5wYXJzZShvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTlJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGUgc2VydmljZSByZW52b2llIHQgaWwgdW5lIGVycmV1ciA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSlNPTlJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXguIHtcImVycm9yXCI6IHtcImNvZGVcIjogXCJCQURfUEFSQU1FVEVSXCIsXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB2YWx1ZXMgKCkgY2Fubm90IGJlIHBhcnNlZCBhcyBhIHZhbGlkIGxvbmdpdHVkZSAoZG91YmxlIHZhbHVlIHN1Y2ggYXMgLTE4MCA8IGxhdCA8IDE4MCkuXCJ9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBKU09OUmVzcG9uc2UuZXJyb3IuZGVzY3JpcHRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmFseXNlIGRlIGxhIHJlcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxldmF0aW9ucyA9IEpTT05SZXNwb25zZS5lbGV2YXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHRpUmVzcG9uc2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19tb2RlbF9BbHRpUmVzcG9uc2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGV2YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxldmF0aW9ucykgJiYgZWxldmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGV2YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGV2YXRpb24gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19tb2RlbF9FbGV2YXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZXZhdGlvbnNbaV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGV2YXRpb25zW2ldIGVzdCB1biBvYmpldCBlbGV2YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmxvbiA9IGVsZXZhdGlvbnNbaV0ubG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5sYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmxhdCA9IGVsZXZhdGlvbnNbaV0ubGF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS56KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZXZhdGlvbi56ID0gZWxldmF0aW9uc1tpXS56O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxldmF0aW9uc1tpXS5hY2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLmFjYyA9IGVsZXZhdGlvbnNbaV0uYWNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZXZhdGlvbnNbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGV2YXRpb25zW2ldIGVzdCB1biBub21icmUsIGRhbnMgbGUgY2FzIGRlIHpvbmx5PXRydWUgbm90YW1tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxldmF0aW9uLnogPSBlbGV2YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbHRpUmVzcG9uc2UuZWxldmF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRpUmVzcG9uc2UuZWxldmF0aW9ucy5wdXNoKGVsZXZhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGFsdGlSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfQU5BTFlTRV8yXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfVU5LRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9GT1JNQVRfMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfVU5LRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2kgbGEgcsOpcG9uc2UgY29udGVuYWl0IHVuZSBleGNlcHRpb24gcmVudm95w6llIHBhciBsZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXhjZXB0aW9uUmVwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgZGF0YS5leGNlcHRpb25SZXBvcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzcyA9IGRhdGEuZXJyb3IuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgZXJyb3JNZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAyMDBcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlcIikpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSwgZGF0YSk7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBbHRpUmVzcG9uc2VGYWN0b3J5KTtcblxuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fUmVzcG9uc2VfbW9kZWxfQWx0aVJlc3BvbnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfRWxldmF0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxuLyoqXG4gKiBGb25jdGlvbiByZXRvdXJuYW50IHVuIG9iamV0IGNvbnRlbmFudCBkZXMgY2zDqXMgZGUgbGVjdHVyZSAocmVhZGVycylcbiAqICAgICAgcXVpIHBlcm1ldHRlbnQgZGUgcGFyc2VyIGRlcyByw6lwb25zZXMgWE1MIGR1IHNlcnZpY2UgQWx0aW3DqXRyaXF1ZSBkdSBHw6lvcG9ydGFpbFxuICogICAgICAoY2FsY3VsIGFsdGltw6l0cmlxdWUgc2ltcGxlIG91IHByb2ZpbCBhbHRpbcOpdHJpcXVlIGQndW5lIGNvdXJiZSksXG4gKiAgICAgIGxvcnNxdWUgbGUgcGFyYW3DqHRyZSBvdXRwdXQgPSB4bWwsXG4gKiAgICAgIGFmaW4gZGUgcsOpY3Vww6lyZXIgbGVzIMOpbMOpdmF0aW9ucyByZXRvdXJuw6llcy5cbiAqXG4gKiBAbW9kdWxlIEFsdGlSZXNwb25zZVJlYWRlclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkFsdGkuRm9ybWF0cy5BbHRpUmVzcG9uc2VSZWFkZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cblxuXG4vKipcbiAqXG4gKiBPYmpldCBBbHRpUmVzcG9uc2VSZWFkZXJcbiAqXG4gKiBAbWVtYmVyIHtPYmplY3R9IEFsdGlSZXNwb25zZVJlYWRlclxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUyAtIE9iamV0IGNvbnRlbmFudCBkZXMgZm9uY3Rpb25zIGRlIGxlY3R1cmUsIGFwcGVsw6llcyBcInJlYWRlcnNcIlxuICogICAgICBkb250IGNoYXF1ZSBjbMOpIGNvcnJlc3BvbmQgYXUgbm9tIGQndW4gdGFnIGR1IFhNTCBxdWUgbCdvbiBzb3VoYWl0ZSBsaXJlXG4gKiAgICAgIGV0IGxhIHZhbGV1ciBhc3NvY2nDqWUgZXN0IHVuZSBmb25jdGlvbiAobm9kZSwgZGF0YSlcbiAqICAgICAgb8O5IG5vZGUgZXN0IHVuIG5vZXVkIGR1IGRvY3VtZW50IERPTVxuICogICAgICBldCBkYXRhIGVzdCB1biBvYmpldCBvw7kgbCdvbiBzdG9ja2UgbGVzIGluZm9ybWF0aW9ucyBsdWVzIGRhbnMgbGUgWE1MLlxuICpcbiAqIEBwcm9wZXJ0eSB7TWV0aG9kfSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy5lbGV2YXRpb25zIC0gIExlY3R1cmUgZCd1biBub2V1ZCBcImVsZXZhdGlvbnNcIiBkZSBsYSByw6lwb25zZSBYTUxcbiAqICAgICAgZHUgc2VydmljZSBhbHRpLCBjb3JyZXNwb25kYW50IGxvZ2lxdWVtZW50IMOgIGxhIHJhY2luZSBkdSBkb2N1bWVudFxuICogICAgICAoY29udGllbnQgdW4gb3UgcGx1c2lldXJzIGNoaWxkTm9kZXMgY29ycmVzcG9uZGFudCBjaGFjdW4gw6AgdW5lIMOpbMOpdmF0aW9uIHJldG91cm7DqWUpXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmVsZXZhdGlvbiAtIGVjdHVyZSBkJ3VuIG5vZXVkIFwiZWxldmF0aW9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqICAgICAgKGNvbnRpZW50IHVuIG91IDQgY2hpbGROb2RlIChzKSBjb3JyZXNwb25kYW50IMOgIGwnYWx0aXR1ZGUgKHopIGV0IMOpdmVudHVlbGxlbWVudCBsYXQsIGxvbiwgZXQgYWNjKVxuICpcbiAqIEBwcm9wZXJ0eSB7TWV0aG9kfSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy5sYXQgLSBMZWN0dXJlIGQndW4gbm9ldWQgXCJsYXRcIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkZSBsYXRpdHVkZSwgcXVpIGVzdCB1biBmbG90dGFudClcbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMubG9uIC0gTGVjdHVyZSBkJ3VuIG5vZXVkIFwibG9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAqICAgICAgKGNvbnRpZW50IHVuZSB2YWxldXIgZGUgbG9uZ2l0dWRlLCBxdWkgZXN0IHVuIGZsb3R0YW50KVxuICpcbiAqIEBwcm9wZXJ0eSB7TWV0aG9kfSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy56IC0gTGVjdHVyZSBkJ3VuIG5vZXVkIFwielwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gKiAgICAgIChjb250aWVudCB1bmUgdmFsZXVyIGQnYWx0aXR1ZGUsIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmFjYyAtIExlY3R1cmUgZCd1biBub2V1ZCBcImFjY1wiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gKiAgICAgIChjb250aWVudCB1bmUgdmFsZXVyIGRlIHByw6ljaXNpb24sIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmV4Y2VwdGlvbnJlcG9ydCAtIExlY3R1cmUgZCd1biBub2V1ZCBcIkV4Y2VwdGlvblJlcG9ydFwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmV4Y2VwdGlvbiAtIExlY3R1cmUgZCd1biBub2V1ZCBcIkV4Y2VwdGlvblwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IEFsdGlSZXNwb25zZVJlYWRlci5yZWFkIC0gTcOpdGhvZGUgcGVybWV0dGFudCBkZSBsYW5jZXIgbGEgbGVjdHVyZSBkJ3VuZSByw6lwb25zZSBYTUwgZHUgc2VydmljZSBhbHRpbcOpdHJpcXVlLFxuICogICAgICDDoCBsJ2FpZGUgZGVzIHJlYWRlcnMgZGUgbGEgY2xhc3NlLlxuICpcbiAqL1xudmFyIEFsdGlSZXNwb25zZVJlYWRlciA9IHt9O1xuXG5BbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUyA9IHtcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcImVsZXZhdGlvbnNcIiBkZSBsYSByw6lwb25zZSBYTUwgZHUgc2VydmljZSBhbHRpLCBjb3JyZXNwb25kYW50IGxvZ2lxdWVtZW50IMOgIGxhIHJhY2luZSBkdSBkb2N1bWVudFxuICAgICAqICAgICAgKGNvbnRpZW50IHVuIG91IHBsdXNpZXVycyBjaGlsZE5vZGVzIGNvcnJlc3BvbmRhbnQgY2hhY3VuIMOgIHVuZSDDqWzDqXZhdGlvbiByZXRvdXJuw6llKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290IC0gcmFjaW5lIGRlIGxhIHLDqXBvbnNlIFhNTFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgQWx0aVJlc3BvbnNlUmVhZGVyXG4gICAgICovXG4gICAgZWxldmF0aW9ucyA6IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIC8vIElORk8gOiBvbiBwYXNzZSBlbiBwYXJhbcOodHJlIGwnb2JqZXQgZW4gZW50csOpZSBlbGV2YXRpb25zLCB2aWRlLCDDoCByZW1wbGlyLlxuICAgICAgICB2YXIgYWx0aVJlc3BvbnNlID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fUmVzcG9uc2VfbW9kZWxfQWx0aVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICBpZiAocm9vdC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHJvb3QuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIHZhciBlbGV2YXRpb247XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBlbGV2YXRpb24gPSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZC5ub2RlTmFtZV0oY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBhbHRpUmVzcG9uc2UuZWxldmF0aW9ucy5wdXNoKGVsZXZhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFsdGlSZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwiZWxldmF0aW9uXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAgICAgKiAgICAgIChjb250aWVudCB1biBvdSA0IGNoaWxkTm9kZSAocykgY29ycmVzcG9uZGFudCDDoCBsJ2FsdGl0dWRlICh6KSBldCDDqXZlbnR1ZWxsZW1lbnQgbGF0LCBsb24sIGV0IGFjYylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIGVsZXZhdGlvbiDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbGVzIGluZm9ybWF0aW9ucyBkZSBsJ8OpbMOpdmF0aW9uIHJldG91cm7DqWUgKHogWywgbG9uLCBsYXQsIGFjY10pXG4gICAgICogQHJldHVybiB7QXJyYXl9IGVsZXZhdGlvblJlc3BvbnNlIC0gZm9ybWF0IGRlIGxhIHLDqXBvbnNlIGVuIHNvcnRpZSwgaW5zdGFuY2UgZGUgQWx0aVJlc3BvbnNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgKi9cbiAgICBlbGV2YXRpb24gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZWxldmF0aW9uID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfRWxldmF0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZC5ub2RlTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSU5GTyA6IG9uIHBhc3NlIGVuIHBhcmFtw6h0cmUgbCdvYmpldCBlbiBlbnRyw6llIGVsZXZhdGlvbiwgdmlkZSwgw6AgcmVtcGxpci5cbiAgICAgICAgICAgICAgICAgICAgQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbY2hpbGQubm9kZU5hbWVdKGNoaWxkLCBlbGV2YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxldmF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMZWN0dXJlIGQndW4gbm9ldWQgXCJsYXRcIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICAgICAqICAgICAgKGNvbnRpZW50IHVuZSB2YWxldXIgZGUgbGF0aXR1ZGUsIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbGEgbGF0aXR1ZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxldmF0aW9uIC0gb2JqZXQgZGFucyBsZXF1ZWwgc3RvY2tlciBsYSBsYXRpdHVkZSByZXRvdXJuw6llXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgKi9cbiAgICBsYXQgOiBmdW5jdGlvbiAobm9kZSwgZWxldmF0aW9uKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICBlbGV2YXRpb24ubGF0ID0gcGFyc2VGbG9hdCh0ZXh0Tm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGRhbnMgbGEgbGVjdHVyZSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogbGF0aXR1ZGUgYXR0ZW5kdWUgbWFpcyBhYnNlbnRlXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcImxvblwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICogICAgICAoY29udGllbnQgdW5lIHZhbGV1ciBkZSBsb25naXR1ZGUsIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbGEgbG9uZ2l0dWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZXZhdGlvbiAtIG9iamV0IGRhbnMgbGVxdWVsIHN0b2NrZXIgbGEgbG9uZ2l0dWRlIHJldG91cm7DqWVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICAgICAqL1xuICAgIGxvbiA6IGZ1bmN0aW9uIChub2RlLCBlbGV2YXRpb24pIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGVsZXZhdGlvbi5sb24gPSBwYXJzZUZsb2F0KHRleHROb2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJldXIgZGFucyBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBsb25naXR1ZGUgYXR0ZW5kdWUgbWFpcyBhYnNlbnRlXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcInpcIiBkZSBsYSByw6lwb25zZSB4bWwgZHUgc2VydmljZSBhbHRpLlxuICAgICAqICAgICAgKGNvbnRpZW50IHVuZSB2YWxldXIgZCdhbHRpdHVkZSwgcXVpIGVzdCB1biBmbG90dGFudClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIMOgIGxpcmUgcG91ciByw6ljdXDDqXJlciBsJ2FsdGl0dWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZXZhdGlvbiAtIG9iamV0IGRhbnMgbGVxdWVsIHN0b2NrZXIgbCdhbHRpdHVkZSByZXRvdXJuw6llXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJvZiBBbHRpUmVzcG9uc2VSZWFkZXJcbiAgICAgKi9cbiAgICB6IDogZnVuY3Rpb24gKG5vZGUsIGVsZXZhdGlvbikge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZSAmJiB0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgaWYgKGVsZXZhdGlvbikge1xuICAgICAgICAgICAgICAgIGVsZXZhdGlvbi56ID0gcGFyc2VGbG9hdCh0ZXh0Tm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGV2YXRpb24gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19SZXNwb25zZV9tb2RlbF9FbGV2YXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgIGVsZXZhdGlvbi56ID0gcGFyc2VGbG9hdCh0ZXh0Tm9kZS5ub2RlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGV2YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJldXIgZGFucyBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBhbHRpdHVkZSBhdHRlbmR1ZSBtYWlzIGFic2VudGVcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGVjdHVyZSBkJ3VuIG5vZXVkIFwiYWNjXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAgICAgKiAgICAgIChjb250aWVudCB1bmUgdmFsZXVyIGRlIHByw6ljaXNpb24sIHF1aSBlc3QgdW4gZmxvdHRhbnQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbGEgcHLDqWNpc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGV2YXRpb24gLSBvYmpldCBkYW5zIGxlcXVlbCBzdG9ja2VyIGxhIHByw6ljaXNpb24gcmV0b3VybsOpZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgQWx0aVJlc3BvbnNlUmVhZGVyXG4gICAgICovXG4gICAgYWNjIDogZnVuY3Rpb24gKG5vZGUsIGVsZXZhdGlvbikge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZSAmJiB0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgZWxldmF0aW9uLmFjYyA9IHBhcnNlRmxvYXQodGV4dE5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycmV1ciBkYW5zIGxhIGxlY3R1cmUgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSA6IHByw6ljaXNpb24gKGFjYykgYXR0ZW5kdWUgbWFpcyBhYnNlbnRlXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcIkV4Y2VwdGlvblJlcG9ydFwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbCdleGNlcHRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV4Y2VwdGlvblJlcG9ydCAtIG9iamV0IGNvbnRlbmFudCBsJ2V4Y2VwdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgQWx0aVJlc3BvbnNlUmVhZGVyXG4gICAgICovXG4gICAgZXhjZXB0aW9ucmVwb3J0IDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0ge307XG5cbiAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IFwiRXhjZXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZXhjZXB0aW9uUmVwb3J0ID0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZXhjZXB0aW9uKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcIkV4Y2VwdGlvblwiIGRlIGxhIHLDqXBvbnNlIHhtbCBkdSBzZXJ2aWNlIGFsdGkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCDDoCBsaXJlIHBvdXIgcsOpY3Vww6lyZXIgbCdleGNlcHRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV4Y2VwdGlvblJlcG9ydCAtIG9iamV0IGNvbnRlbmFudCBsJ2V4Y2VwdGlvbiwgYXZlYyBkZXV4IGF0dHJpYnV0cyA6XG4gICAgICogICAgICB7U3RyaW5nfSBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uQ29kZSAtIHF1aSBjb250aWVudCBsJ2lkZW50aWZpYW50IGR1IGNvZGUgZGUgbCdleGNlcHRpb25cbiAgICAgKiAgICAgIHtTdHJpbmd9IGV4Y2VwdGlvblJlcG9ydC5leGNlcHRpb24gLSBxdWkgY29udGllbnQgbGUgbWVzc2FnZSBkZSBsJ2V4Y2VwdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyb2YgQWx0aVJlc3BvbnNlUmVhZGVyXG4gICAgICovXG4gICAgZXhjZXB0aW9uIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGV4Y2VwdGlvblJlcG9ydCA9IHt9O1xuXG4gICAgICAgIC8vIGdldCBleGNlcHRpb24gY29kZVxuICAgICAgICB2YXIgZXhjZXB0aW9uQ29kZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZXhjZXB0aW9uQ29kZVwiKTtcbiAgICAgICAgaWYgKGV4Y2VwdGlvbkNvZGUpIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvblJlcG9ydC5leGNlcHRpb25Db2RlID0gZXhjZXB0aW9uQ29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBleGNlcHRpb24gbWVzc2FnZVxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZSAmJiB0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgZXhjZXB0aW9uUmVwb3J0LmV4Y2VwdGlvbiA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGNlcHRpb25SZXBvcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExlY3R1cmUgZCd1biBub2V1ZCBcIkVycm9yXCIgZGUgbGEgcsOpcG9uc2UgeG1sIGR1IHNlcnZpY2UgYWx0aS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIMOgIGxpcmUgcG91ciByw6ljdXDDqXJlciBsJ2V4Y2VwdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZXJyb3IgLSBvYmpldCBjb250ZW5hbnQgbCdleGNlcHRpb25cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gICAgZXJyb3IgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBlcnJvciA6IHt9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldCBlcnJvciBjb2RlIGFuZCBkZXNjcmlwdGlvblxuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgZXJyb3IgY29kZVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJjb2RlXCIpIHsgLy8gMSA9PT0gbm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUgPSBjaGlsZC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yLmNvZGUgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGVycm9yIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxICYmIGNoaWxkLm5vZGVOYW1lID09PSBcImRlc2NyaXB0aW9uXCIpIHsgLy8gMSA9PT0gbm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUgPSBjaGlsZC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yLmRlc2NyaXB0aW9uID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogTcOpdGhvZGUgcGVybWV0dGFudCBkZSBsYW5jZXIgbGEgbGVjdHVyZSBkJ3VuZSByw6lwb25zZSBYTUwgZHUgc2VydmljZSBhbHRpbcOpdHJpcXVlLFxuICogICAgICDDoCBsJ2FpZGUgZGVzIHJlYWRlcnMgZGUgbGEgY2xhc3NlLlxuICpcbiAqIEBtZXRob2QgQWx0aVJlc3BvbnNlUmVhZGVyLnJlYWRcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdCAtIHJhY2luZSBkZSBsYSByw6lwb25zZSBYTUwgw6AgbGlyZVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIEFsdGlSZXNwb25zZVJlYWRlclxuICovXG5BbHRpUmVzcG9uc2VSZWFkZXIucmVhZCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgaWYgKHJvb3Qubm9kZU5hbWUgPT09IFwiZWxldmF0aW9uc1wiKSB7XG4gICAgICAgIHZhciBhbHRpUmVzcG9uc2UgPSBBbHRpUmVzcG9uc2VSZWFkZXIuUkVBREVSUy5lbGV2YXRpb25zKHJvb3QpO1xuICAgICAgICByZXR1cm4gYWx0aVJlc3BvbnNlO1xuICAgIH0gZWxzZSBpZiAocm9vdC5ub2RlTmFtZSA9PT0gXCJFeGNlcHRpb25SZXBvcnRcIikge1xuICAgICAgICB2YXIgZXhjZXB0aW9uUmVwb3J0ID0gQWx0aVJlc3BvbnNlUmVhZGVyLlJFQURFUlMuZXhjZXB0aW9ucmVwb3J0KHJvb3QpO1xuICAgICAgICByZXR1cm4gZXhjZXB0aW9uUmVwb3J0O1xuICAgIH0gZWxzZSBpZiAocm9vdC5ub2RlTmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHZhciBlcnJvciA9IEFsdGlSZXNwb25zZVJlYWRlci5SRUFERVJTLmVycm9yKHJvb3QpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGxvcnMgZGUgbGEgbGVjdHVyZSBkZSBsYSByw6lwb25zZSA6IGVsbGUgbidlc3QgcGFzIGF1IGZvcm1hdCBhdHRlbmR1LlwiKTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFsdGlSZXNwb25zZVJlYWRlcik7XG5cblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fVXRpbHNfSGVscGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19EZWZhdWx0VXJsU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0NvbW1vblNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19SZXNwb25zZV9BdXRvQ29uZlJlc3BvbnNlRmFjdG9yeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XG5cblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFwcGVsIGR1IHNlcnZpY2UgZCdhdXRvY29uZmlndXJhdGlvbiBkdSBHw6lvcG9ydGFpbFxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtHcC5TZXJ2aWNlcy5Db21tb25TZXJ2aWNlfVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkF1dG9Db25mXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlICgrIGxlcyBvcHRpb25zIGhlcml0w6llcylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGF5ZXJJZF0gLSBMZSBub20gZGUgbCdhZ3LDqWdhdCAoY291Y2hlKSBkb250IG9uIHZldXQgY29ubmHDrnRyZSBsZXMgaW5mb3JtYXRpb25zIGTDqXRhaWxsw6llcy5cbiAqICAgICAgTGEgcHLDqXNlbmNlIGRlIGNldHRlIHByb3ByacOpdMOpIGltcGxpcXVlIGwndXRpbGlzYXRpb24gZGUgbGEgZGV1eGnDqG1lIG9ww6lyYXRpb24gZHUgc2VydmljZSBwb3VyIGFjY8OpZGVyIGF1eCBpbmZvcm1hdGlvbnMgZCd1bmUgY291Y2hlIGFnZ3LDqWfDqWUuXG4gKiAgICAgIERhbnMgY2UgY2FzLCBsYSBmb25jdGlvbiBlZmZlY3R1ZXJhIHF1YW5kIG3Dqm1lIGRhbnMgdW4gcHJlbWllciB0ZW1wcyBsYSByw6ljdXDDqXJhdGlvbiBkZXMgaW5mb3JtYXRpb25zIGRlIGwnYXV0by1cbiAqICAgICAgY29uZmlndXJhdGlvbiBjb21wbMOodGUsIHNhdWYgc2kgdW4gcHJlbWllciBhcHBlbCDDoCBsJ2F1dG9jb25mIGEgZMOpasOgIMOpdMOpIGZhaXQgYXZlYyBjZXR0ZSBjbMOpIChpLmUuIHNpIGxhIHZhcmlhYmxlIGdsb2JhbGUgZXN0IGTDqWZpbmllXG4gKiAgICAgIHBvdXIgbGEgY2zDqSBkZSBjb250cmF0KS4gRWxsZSBpcmEgZW5zdWl0ZSBjaGVyY2hlciBsZXMgaW5mb3JtYXRpb25zIGRlcyBjb3VjaGVzIGFncsOpZ8OpZXMsIHF1aSBzZXJvbnQgYWpvdXTDqWVzIMOgIGxhIHZhcmlhYmxlIGdsb2JhbGUgR3AuQ29uZmlnLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZhciBvcHRpb25zID0ge1xuICogICAgICAvLyBvcHRpb25zIGNvbW11bmVzIGF1eCBzZXJ2aWNlc1xuICogICAgICBhcGlLZXkgOiBcImFwaWtleVwiLFxuICogICAgICBwcm90b2NvbCA6ICdKU09OUCcsIC8vIEpTT05QfFhIUlxuICogICAgICB0aW1lT3V0IDogMTAwMDAsIC8vIG1zXG4gKiAgICAgIHJhd1Jlc3BvbnNlIDogZmFsc2UsIC8vIHRydWV8ZmFsc2VcbiAqICAgICAgc2NvcGUgOiBudWxsLCAvLyB0aGlzXG4gKiAgICAgIG9uU3VjY2VzcyA6IGZ1bmN0aW9uIChyZXNwb25zZSkge30sXG4gKiAgICAgIG9uRmFpbHVyZSA6IGZ1bmN0aW9uIChlcnJvcikge30sXG4gKiAgICAgIGxheWVySWQgOiBcIk9SVEhPSU1BR0VSWS5PUlRIT1BIT1RPUy4zRCRHRU9QT1JUQUlMOk9HQzpXTVRTQGFnZ3JlZ2F0ZVwiXG4gKiAgIH07XG4gKi9cbmZ1bmN0aW9uIEF1dG9Db25mIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEF1dG9Db25mKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiQ0xBU1NfQ09OU1RSVUNUT1JcIiwgXCJBdXRvQ29uZlwiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICogRklYTUUgaW5zdGFuY2Ugb3UgY2xhc3NlID9cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiQXV0b0NvbmZcIjtcblxuICAgIC8vIEF1dG9jb25mIGRlZmF1bHQgcHJvdG9jb2wgcmVtYWlucyBKU09OUCAoI3NlZSBodHRwOi8vaWduZi5naXRodWIuaW8vZ2VvcG9ydGFsLWFjY2Vzcy1saWIvbGF0ZXN0L2pzZG9jL3R1dG9yaWFsLW9wdGltaXplLWdldGNvbmZpZy5odG1sKVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMucHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8IFwiSlNPTlBcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0NvbW1vblNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkdwLlNlcnZpY2VzLkF1dG9Db25mXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBBdXRvQ29uZiAob3B0aW9ucyldXCIpO1xuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgLy8gYW5hbHlzZSBkZXMgb3B0aW9uc1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4gICAgLy8gZ2VzdGlvbiBkZSBsJ3VybCBkdSBzZXJ2aWNlIHBhciBkZWZhdXRcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgLy8gc2kgbCd1cmwgbidlc3QgcGFzIHJlbnNlaWduw6llLCBpbCBmYXV0IHV0aWxpc2VyIGxlcyB1cmxzIHBhciBkZWZhdXRcbiAgICAgICAgLy8gZW4gZm9uY3Rpb24gZHUgbm9tYnJlIGRlIGNsw6lzIGVuIGVudHLDqWUgZXQgZHUgcGFyYW3DqHRyZSBsYXllcklkXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNlcnZlclVybCkge1xuICAgICAgICAgICAgdmFyIGxzdFVybEJ5RGVmYXVsdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRGVmYXVsdFVybFNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5BdXRvQ29uZi51cmwodGhpcy5vcHRpb25zLmFwaUtleSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxheWVySWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXMgZCd1bmUgYXV0b2NvbmYgc2ltcGxlXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLmFwaUtleSkgJiYgdGhpcy5vcHRpb25zLmFwaUtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcyBkJ3VuIHRhYmxlYXUgZGUgY2zDqXMgZW4gZW50csOpZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VydmVyVXJsID0gbHN0VXJsQnlEZWZhdWx0LmFwaUtleXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlcnZlclVybCA9IGxzdFVybEJ5RGVmYXVsdC5hcGlLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXMgZCd1bmUgYXV0b2NvbmYgcG91ciBkZXMgY291Y2hlcyBhZ2dyw6lnw6llc1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSBsc3RVcmxCeURlZmF1bHQuYWdncmVnYXRlICsgdGhpcy5vcHRpb25zLmxheWVySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJTkZPXG4gICAgLy8gbGUgc2VydmljZSBuZSByZXBvbmQgcGFzIGVuIG1vZGUgUE9TVCAoNDA1IE1ldGhvZCBOb3QgQWxsb3dlZClcbiAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sID09PSBcIlhIUlwiICYmIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTGUgc2VydmljZSBuZSBnw6lyZSBwYXMgbGUgbW9kZSBkJ2ludGVycm9nYXRpb24gZW4gUE9TVCwgb24gYmFzY3VsZSBzdXIgZHUgR0VUICFcIik7XG4gICAgICAgIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kID0gXCJHRVRcIjsgLy8gb24gc3VyY2hhcmdlICFcbiAgICB9XG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAvLyBhdHRyaWJ1dHMgZCdpbnN0YW5jZXNcbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBmb3Jjw6kgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSA6IFwieG1sXCJcbiAgICAgKiBzYXVmIHNpIGwnb24gc291aGFpdGUgdW5lIHJlcG9uc2UgYnJ1dGUgKG9wdGlvbnMucmF3UmVzcG9uc2UpXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCA9ICh0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UpID8gXCJcIiA6IFwieG1sXCI7XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpBdXRvQ29uZiNcbiAqL1xuXG5BdXRvQ29uZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSwge1xuICAgIC8vIHRvZG9cbiAgICAvLyBnZXR0ZXIvc2V0dGVyXG59KTtcblxuLypcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkF1dG9Db25mLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF1dG9Db25mO1xuXG4vKipcbiAqIENyw6lhdGlvbiBkZSBsYSByZXF1w6p0ZSAob3ZlcndyaXRlKVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBjYWxsYmFjayBkZXMgZXJyZXVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrIGRlIHN1Y2PDqHMgZGUgbGEgY3LDqWF0aW9uIGRlIGxhIHJlcXXDqnRlXG4gKi9cbkF1dG9Db25mLnByb3RvdHlwZS5idWlsZFJlcXVlc3QgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICB2YXIgc2NvcGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307XG5cbiAgICBpZiAoc2NvcGUuR3AgJiYgc2NvcGUuR3AuQ29uZmlnICYmIHNjb3BlLkdwLkNvbmZpZy5nZW5lcmFsT3B0aW9ucyAmJiBzY29wZS5HcC5Db25maWcubGF5ZXJzKSB7XG4gICAgICAgIGlmIChzY29wZS5HcC5Db25maWcuZ2VuZXJhbE9wdGlvbnMuYXBpS2V5c1t0aGlzLm9wdGlvbnMuYXBpS2V5XSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXllcklkKSB7IC8vIGNhcyBkJ3VuZSBhdXRvY29uZiArIGTDqXRhaWxsw6llIHN1ciB1bmUgY291Y2hlIGFncsOpZ8OpZVxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5HcC5Db25maWcubGF5ZXJzW3RoaXMub3B0aW9ucy5sYXllcklkXSAmJiBzY29wZS5HcC5Db25maWcubGF5ZXJzW3RoaXMub3B0aW9ucy5sYXllcklkXS5hZ2dyZWdhdGVkTGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJHcC5Db25maWcgZXhpc3RlIGTDqWrDoCBwb3VyIGNldHRlIGNsw6kgZXQgY2V0dGUgY291Y2hlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzLmNhbGwodGhpcywgc2NvcGUuR3AuQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkdwLkNvbmZpZyBleGlzdGUgZMOpasOgIHBvdXIgY2V0dGUgY2zDqVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzLmNhbGwodGhpcywgc2NvcGUuR3AuQ29uZmlnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXF1ZXRlIHBhciBkZWZhdXRcbiAgICB0aGlzLnJlcXVlc3QgPSBcIlwiO1xuXG4gICAgLy8gZ2VzdGlvbiBkZSBsJ2F1dG9jb25mIGxvY2FsXG4gICAgLy8gTGUgZmljaGllciBlbiBsb2NhbCBkb2l0IHJlc3BlY3RlciBsZSBmb3JtYXQgZGUgc29ydGllIGR1IHNlcnZpY2UuXG4gICAgLy8gIC0gRW4gWEhSLCBsZSBmb3JtYXQgZXN0IGVuIHhtbFxuICAgIC8vICAtIEVuIEpTT05QLCBsZSBmb3JtYXQgZXN0IGVuIHhtbCBlbmNhcHN1bMOpIGRhbnMgdW4ganNvbiBhdmVjIHVuZSBmb25jdGlvbiBkZSBjYWxsYmFja1xuICAgIC8vICAgIGV4LiBjYWxsYmFjayAoe1wiaHR0cFwiOntcInN0YXR1c1wiOjIwMCxcImVycm9yXCI6bnVsbH0sXCJ4bWxcIjpcIi4uLlwifSlcbiAgICB2YXIgYkxvY2FsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2VydmVyVXJsLmluZGV4T2YoXCJodHRwOi8vXCIpID09PSAtMSkge1xuICAgICAgICBiTG9jYWwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJMb2NhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIHBhcmFtLiBLVlAgb3B0aW9ubmVsIHN1ciB1biBzZXJ2aWNlIHVuaXF1ZW1lbnQgKHBhcyBzdXIgdW4gYXV0b2NvbmYgbG9jYWwgISlcbiAgICBpZiAoIWJMb2NhbCAmJiB0aGlzLmxheWVySWQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19IZWxwZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWx5emVQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGxheWVySWQgOiB0aGlzLmxheWVySWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsZW1lbnQgcGFzIGQnZXJyZXVyIGQnYXV0b2NvbmYuLi5cbiAgICAodGhpcy5yZXF1ZXN0IHx8IHRoaXMucmVxdWVzdCA9PT0gXCJcIilcbiAgICAgICAgPyBzdWNjZXNzLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0KVxuICAgICAgICA6IGVycm9yLmNhbGwodGhpcywgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVRVUVTVF9CVUlMRFwiKSkpO1xufTtcblxuLyoqXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2UgKG92ZXJ3cml0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFjayBkZSBzdWNjw6hzIGRlIGwnYW5hbHlzZSBkZSBsYSByw6lwb25zZVxuICovXG5BdXRvQ29uZi5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBsYXllcklkIDogdGhpcy5vcHRpb25zLmxheWVySWQsXG4gICAgICAgICAgICByZXNwb25zZSA6IHRoaXMucmVzcG9uc2UsXG4gICAgICAgICAgICByYXdSZXNwb25zZSA6IHRoaXMub3B0aW9ucy5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgIG9uU3VjY2VzcyA6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBvbkVycm9yIDogZXJyb3IsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Jlc3BvbnNlX0F1dG9Db25mUmVzcG9uc2VGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQXV0b0NvbmYpO1xuXG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRm9ybWF0c19YTUxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19Gb3JtYXRzX0F1dG9Db25mUmVzcG9uc2VSZWFkZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuLyoqXG4gKiBGYWN0b3J5IHBvdXIgZ8OpbsOpcmVyIHVuZSByZXBvbnNlIEpTT04gw6AgcGFydGlyIGQndW4gWE1MXG4gKlxuICogQG1vZHVsZSBBdXRvQ29uZlJlcG9uc2VGYWN0b3J5XG4gKiBAcHJpdmF0ZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkF1dG9Db25mLlJlc3BvbnNlLkF1dG9Db25mUmVzcG9uc2VGYWN0b3J5XG4gKiBAdG9kbyBnw6lyZXIgbGUgY2FzIGR1IEpTT05QIHF1aSBlbmNhcHN1bGUgZHUgWE1MID9cbiAqL1xuXG5cblxuXG5cblxudmFyIEF1dG9Db25mUmVwb25zZUZhY3RvcnkgPSB7XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcmZhY2UgdW5pcXVlXG4gICAgICogRmFicmlxdWUgZCdhbmFseXNlIGRlcyByw6lwb25zZXMgKHhtbCkgZHUgc2VydmljZSBkJ2F1dG9jb25maWd1cmF0aW9uLlxuICAgICAqIENyw6lhdGlvbiBkJ3VuIGZvcm1hdCBYTUwsIGF1cXVlbCBvbiBhc3NvY2llIHVuIHJlYWRlciBldCB1bmUgY2hhw65uZSBYTUwsIGV0IHF1aSByZW52ZXJyYSB1biBvYmpldCBKYXZhU2NyaXB0IGNvcnJlc3BvbmRhbnQuXG4gICAgICogU2kgdW5lIGVycmV1ciBlc3QgbGV2w6llIGxvcnMgZGUgbCdhbmFseXNlLCBvdSBzaSBsJ29iamV0IGVzdCB2aWRlIG91IGNvbnRpZW50IHVuZSBleGNlcHRpb24gOiBhcHBlbCBkZSBsYSBmb25jdGlvbiBkZSBjYWxsYmFjayBvbkVycm9yXG4gICAgICogU2lub24sIGFwcGVsIGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIG9uU3VjY2VzcyAoZMOpZmluaWVzIGRhbnMgQXV0b2NvbmYuYW5hbHl6ZVJlc3BvbnNlKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgQXV0b0NvbmZcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIGxheWVySWQgOlxuICAgICAqICAgICAgcmVzcG9uc2UgOlxuICAgICAqICAgICAgcmF3UmVzcG9uc2UgOlxuICAgICAqICAgICAgc2NvcGUgOlxuICAgICAqICAgICAgb25TdWNjZXNzIDpcbiAgICAgKiAgICAgIG9uRXJyb3IgOlxuICAgICAqICAgfTtcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJBdXRvQ29uZlJlc3BvbnNlRmFjdG9yeVwiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFtcIkF1dG9Db25mUmVzcG9uc2VGYWN0b3J5OjpidWlsZCgpXCJdKTtcblxuICAgICAgICAvLyBkYXRhIGRlIHR5cGUgQXV0b0NvbmZSZXNwb25zZVxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJhd1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRm9ybWF0c19YTUxfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0Zvcm1hdHNfQXV0b0NvbmZSZXNwb25zZVJlYWRlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRYTUxTdHJpbmcob3B0aW9ucy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTERvYyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwLnBhcnNlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaSB1bmUgZXhjZXB0aW9uIGEgw6l0w6kgbGV2w6llLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGQnZXJyZXVyIGF2ZWMgbGUgbWVzc2FnZSByZW52b3nDqVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiXFxuIChyYXcgcmVzcG9uc2Ugc2VydmljZSdcIiArIG9wdGlvbnMucmVzcG9uc2UgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiXFxuIChyYXcgcmVzcG9uc2Ugc2VydmljZSdcIiArIG9wdGlvbnMucmVzcG9uc2UuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCArIFwiJylcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNpIGxhIHLDqXBvbnNlIGVzdCB2aWRlLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGQnZXJyZXVyXG4gICAgICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWV8yXCIpKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTaSBsYSByw6lwb25zZSBjb250ZW5haXQgdW5lIGV4Y2VwdGlvbiByZW52b3nDqWUgcGFyIGxlIHNlcnZpY2UsIG9uIGFwcGVsbGUgbGUgY2FsbGJhY2sgZCdlcnJldXJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBkYXRhLmV4Y2VwdGlvblJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpIGxhIHLDqXBvbnNlICh4bWxTdHJpbmcpIGVzdCB2aWRlLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGQnZXJyZXVyXG4gICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZMOpZmluaXRpb24gZGUgbGEgdmFyaWFibGUgZ2xvYmFsZSBHcC5Db25maWcgw6AgcGFydGlyIGRlIGxhIHLDqXBvbnNlXG4gICAgICAgIHZhciBzY29wZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTtcblxuICAgICAgICBpZiAoIXNjb3BlLkdwKSB7XG4gICAgICAgICAgICBzY29wZS5HcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NvcGUuR3AuQ29uZmlnKSB7XG4gICAgICAgICAgICBzY29wZS5HcC5Db25maWcgPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXJnZUNvbmZpZyhzY29wZS5HcC5Db25maWcsIGRhdGEsIG9wdGlvbnMubGF5ZXJJZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaSB0b3V0IHMnZXN0IGJpZW4gcGFzc8OpLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGRlIHN1Y2PDqHNcbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlLCBzY29wZS5HcC5Db25maWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb25jdGlvbiB1dGlsaXPDqWUgZGFucyBsZSBjYXMgb8O5IGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGFwcGVsw6llIHBsdXNpZXVycyBmb2lzXG4gICAgICogKHBhciBleGVtcGxlIHBvdXIgZGVzIGNsw6lzIGRpZmbDqXJlbnRlcyBvdSBwb3VyIGRlcyBpbmZvcyBzdXIgdW5lIGNvdWNoZSBhZ3LDqWfDqWUpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1lcmdlQ29uZmlnXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBHcENvbmZpZyAtIFZhcmlhYmxlIEdwLkNvbmZpZyBwcsOpZXhpc3RhbnRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBsYSBub3V2ZWxsZSByw6lwb25zZSBkZSBsJ2F1dG9jb25mLCDDoCBmdXNpb25uZXIgYXZlYyBHcENvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbGF5ZXJJZF0gLSBsJ2lkZW50aWZpYW50IGQndW5lIGNvdWNoZSBhZ3LDqWfDqWUgZGFucyBsZSBjYXMgZCd1bmUgMsOoIG9ww6lyYXRpb24gZGUgbCdhdXRvY29uZlxuICAgICAqL1xuICAgIG1lcmdlQ29uZmlnIDogZnVuY3Rpb24gKEdwQ29uZmlnLCBkYXRhLCBsYXllcklkKSB7XG4gICAgICAgIGlmIChkYXRhICYmIEdwQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBvbiBib3VjbGUgc3VyIGxlcyBwcm9wcmnDqXTDqXMgKGdlbmVyYWxPcHRpb25zLCBsYXllcnMsIHByb2plY3Rpb25zLCBzZXJ2aWNlcywgdGlsZU1hdHJpeFNldHMsIHRlcnJpdG9yaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gcsOpY3Vww6hyZSBsYSBub3V2ZWxsZSBjbMOpIGRhbnMgZ2VuZXJhbE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwiZ2VuZXJhbE9wdGlvbnNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGFbcHJvcF0uYXBpS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW3Byb3BdLmFwaUtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhR3BDb25maWcuZ2VuZXJhbE9wdGlvbnMuYXBpS2V5c1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdwQ29uZmlnLmdlbmVyYWxPcHRpb25zLmFwaUtleXNba2V5XSA9IGRhdGFbcHJvcF0uYXBpS2V5c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIHLDqWN1cMOocmUgbGVzIG5vdXZlYXV4IG9iamV0cyAoVE1TLCBsYXllcnMsIHByb2plY3Rpb25zLi4uKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEdwQ29uZmlnW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb2JqIGluIGRhdGFbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbcHJvcF0uaGFzT3duUHJvcGVydHkob2JqKSAmJiAhR3BDb25maWdbcHJvcF1bb2JqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3BDb25maWdbcHJvcF1bb2JqXSA9IGRhdGFbcHJvcF1bb2JqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGFucyBsZSBjYXMgZCd1bmUgYXV0b2NvbmYgcG91ciB1bmUgY291Y2hlIGFncsOpZ8OpZSwgb24gcsOpY3Vww6hyZSBsJ2luZm9cbiAgICAgICAgICAgIGlmIChsYXllcklkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0ZWRMYXllcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGx5ciBpbiBkYXRhLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sYXllcnMuaGFzT3duUHJvcGVydHkobHlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZExheWVycy5wdXNoKGx5cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoR3BDb25maWcubGF5ZXJzW2xheWVySWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIEdwQ29uZmlnLmxheWVyc1tsYXllcklkXS5hZ2dyZWdhdGVkTGF5ZXJzID0gYWdncmVnYXRlZExheWVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEF1dG9Db25mUmVwb25zZUZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19SZXNwb25zZV9tb2RlbF9BdXRvQ29uZlJlc3BvbnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1Jlc3BvbnNlX21vZGVsX0NvbnN0cmFpbnRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fUmVzcG9uc2VfbW9kZWxfRm9ybWF0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1Jlc3BvbnNlX21vZGVsX0xheWVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1Jlc3BvbnNlX21vZGVsX0xlZ2VuZF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXNwb25zZV9tb2RlbF9NZXRhZGF0YV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19SZXNwb25zZV9tb2RlbF9PcmlnaW5hdG9yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1Jlc3BvbnNlX21vZGVsX1NlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fUmVzcG9uc2VfbW9kZWxfU3R5bGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fUmVzcG9uc2VfbW9kZWxfVGVycml0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19SZXNwb25zZV9tb2RlbF9UaGVtYXRpY19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fUmVzcG9uc2VfbW9kZWxfVGlsZU1hdHJpeFNldF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fUmVzcG9uc2VfbW9kZWxfVGlsZU1hdHJpeF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fUmVzcG9uc2VfbW9kZWxfVGlsZU1hdHJpeExpbWl0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuLyoqXG4gKiBGb25jdGlvbiByZXRvdXJuYW50IHVuIG9iamV0IGNvbnRlbmFudCBkZXMgY2zDqXMgZGUgbGVjdHVyZSAocmVhZGVycylcbiAqICAgICAgcXVpIHBlcm1ldHRlbnQgZGUgcGFyc2VyIGRlcyByw6lwb25zZXMgWE1MIGR1IHNlcnZpY2UgZCdhdXRvY29uZmlndXJhdGlvbiBkdSBHw6lvcG9ydGFpbFxuICogICAgICBhZmluIGRlIHLDqWN1cMOpcmVyIGxlcyBpbmZvcm1hdGlvbnMgcmV0b3VybsOpZXMuXG4gKiBAbW9kdWxlIEF1dG9Db25mUmVzcG9uc2VSZWFkZXJcbiAqIEBwcml2YXRlXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuQXV0b0NvbmYuRm9ybWF0cy5BdXRvQ29uZlJlc3BvbnNlUmVhZGVyXG4gKi9cblxuLy8gaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQXV0b0NvbmZSZXNwb25zZVJlYWRlciA9IHt9O1xuXG4vKipcbiAqIHZlcnNpb24gZHUgc2VydmljZSBkJ2F1dG9jb25mXG4gKi9cbkF1dG9Db25mUmVzcG9uc2VSZWFkZXIuVkVSU0lPTiA9IFwiMS4xLjBcIjtcblxuLyoqXG4gKiBPYmpldCBzdG9ja2FudCBsZXMgZGlmZsOpcmVudHMgbmFtZXNwYWNlcyBldCBsZXMgVVJJIGFzc29jacOpZXNcbiAqL1xuQXV0b0NvbmZSZXNwb25zZVJlYWRlci5OQU1FU1BBQ0VTID0ge1xuICAgIHhtbG5zIDogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2NvbnRleHRcIixcbiAgICBncHAgOiBcImh0dHA6Ly9hcGkuaWduLmZyL2dlb3BvcnRhaWxcIixcbiAgICBvd3MgOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvb3dzLzEuMVwiLFxuICAgIHNsZCA6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9zbGRcIixcbiAgICB3bXRzIDogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dtdHMvMS4wXCIsXG4gICAgeGxpbmsgOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4c2kgOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXCJcbn07XG5cbi8qKlxuICogTG9jYWxpc2F0aW9uIChVUkwpIGR1IHNjaGVtYSBkZSBkw6lmaW5pdGlvbiBkdSBYTUwgKFhTRClcbiAqL1xuQXV0b0NvbmZSZXNwb25zZVJlYWRlci5TQ0hFTUFMT0NBVElPTiA9IFtcbiAgICBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvY29udGV4dCBodHRwOi8vZ3BwMy13eHMuaWduLmZyL3NjaGVtYXMvZXh0Q29udGV4dC54c2QgaHR0cDovL2FwaS5pZ24uZnIvZ2VvcG9ydGFpbCBodHRwOi8vd3hzLmlnbi5mci9zY2hlbWFzL2F1dG9jb25mL2F1dG9jb25mLnhzZFwiLFxuICAgIFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9jb250ZXh0IGh0dHA6Ly9ncHAzLXd4cy5pZ24uZnIvc2NoZW1hcy9leHRDb250ZXh0LnhzZCBodHRwOi8vYXBpLmlnbi5mci9nZW9wb3J0YWlsIGh0dHA6Ly9ncHAzLXd4cy5pZ24uZnIvc2NoZW1hcy9hdXRvY29uZi54c2RcIlxuXTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgcGFyIGTDqWZhdXQgZHUgZm9ybWF0XG4gKi9cbkF1dG9Db25mUmVzcG9uc2VSZWFkZXIuREVGQVVMVFBSRUZJWCA9IFwiY29udGV4dFwiO1xuXG4vKipcbiAqIE9iamV0IGNvbnRlbmFudCBkZXMgZm9uY3Rpb25zIGRlIGxlY3R1cmUsIGFwcGVsw6llcyBcIlJFQURFUlNcIlxuICogICAgICBkb250IGNoYXF1ZSBjbMOpIGNvcnJlc3BvbmQgYXUgbm9tIGQndW4gdGFnIGR1IFhNTCBxdWUgbCdvbiBzb3VoYWl0ZSBsaXJlXG4gKiAgICAgIGV0IGxhIHZhbGV1ciBhc3NvY2nDqWUgZXN0IHVuZSBmb25jdGlvbiAobm9kZSwgZGF0YSlcbiAqICAgICAgb8O5IG5vZGUgZXN0IHVuIG5vZXVkIGR1IGRvY3VtZW50IERPTVxuICogICAgICBldCBkYXRhIGVzdCB1biBvYmpldCBvw7kgbCdvbiBzdG9ja2UgbGVzIGluZm9ybWF0aW9ucyBsdWVzIGRhbnMgbGUgWE1MLlxuICovXG5BdXRvQ29uZlJlc3BvbnNlUmVhZGVyLlJFQURFUlMgPSB7XG5cbiAgICBjb250ZXh0IDoge1xuXG4gICAgICAgIC8qKiBWaWV3Q29udGV4dCAqL1xuICAgICAgICBWaWV3Q29udGV4dCA6IGZ1bmN0aW9uICh2aWV3Q29udGV4dE5vZGUpIHtcbiAgICAgICAgICAgIC8vIGluZm8gOiBiYWxpc2UgXCJyYWNpbmVcIiBkZSBsYSByw6lwb25zZSBkZSBsJ2F1dG9jb25mXG5cbiAgICAgICAgICAgIC8vIHbDqXJpZmljYXRpb24gZGUgbGEgdmVyc2lvbiBkdSBzZXJ2aWNlLCBldCBkZXMgbmFtZXNwYWNlcyBkZSBsJ2VuLXTDqnRlXG4gICAgICAgICAgICBfX2NoZWNrU2VydmljZUF0dHJpYnV0ZXModmlld0NvbnRleHROb2RlKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIEF1dG9Db25mUmVzcG9uc2VcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19SZXNwb25zZV9tb2RlbF9BdXRvQ29uZlJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKHZpZXdDb250ZXh0Tm9kZSwgY29uZmlnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0dlbmVyYWwvVGl0bGVcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL1RpdGxlXG4gICAgICAgIC8qKiBUaXRsZSAqL1xuICAgICAgICBUaXRsZSA6IGZ1bmN0aW9uICh0aXRsZU5vZGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuZ2VuZXJhbE9wdGlvbnMpIHsgLy8gY2FzIGRlIGxhIHZhcmlhYmxlIGNvbmZpZyBnw6luw6lyYWxlXG4gICAgICAgICAgICAgICAgZGF0YS5nZW5lcmFsT3B0aW9ucy50aXRsZSA9IF9fZ2V0Q2hpbGRWYWx1ZSh0aXRsZU5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEubHlyKSB7IC8vIGNhcyBkJ3VuZSBsYXllclxuICAgICAgICAgICAgICAgIGRhdGEubHlyLnRpdGxlID0gX19nZXRDaGlsZFZhbHVlKHRpdGxlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvQWJzdHJhY3RcbiAgICAgICAgLyoqIEFic3RyYWN0ICovXG4gICAgICAgIEFic3RyYWN0IDogZnVuY3Rpb24gKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEubHlyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5seXIuZGVzY3JpcHRpb24gPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6U2VydmljZXMvU2VydmVyXG4gICAgICAgIC8vIG91IDogL0xheWVyTGlzdC9TZXJ2ZXJcbiAgICAgICAgLyoqIFNlcnZlciAqL1xuICAgICAgICBTZXJ2ZXIgOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHNlcnZlcklkID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzZXJ2aWNlXCIpO1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIpO1xuICAgICAgICAgICAgaWYgKHNlcnZlcklkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5zZXJ2aWNlcyAmJiB0eXBlb2YgZGF0YS5zZXJ2aWNlcyA9PT0gXCJvYmplY3RcIiAmJiAhZGF0YS5zZXJ2aWNlc1tzZXJ2ZXJJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gZXN0IGRhbnMgbGEgYmFsaXNlIFNlcnZpY2VzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fUmVzcG9uc2VfbW9kZWxfU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgIHMudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbCd1cmwgZHUgc2VydmljZSwgZGFucyB1bmUgYmFsaXNlIGVuZmFudCBcIk9ubGluZVJlc291cmNlXCJcbiAgICAgICAgICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBham91dCBkdSBzZXJ2aWNlIMOgIGxhIHZhcmlhYmxlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnNlcnZpY2VzW3NlcnZlcklkXSA9IHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEubHlyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGVzdCBkYW5zIGxhIGJhbGlzZSBMYXllclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEubHlyLnNlcnZpY2VQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpIGwnb2JqZXQgc2VydmljZVBhcmFtcyBuJ2EgcGFzIGVuY29yZSDDqXTDqSBjcsOpw6ksIG9uIGxlIGNyw6llLlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5seXIuc2VydmljZVBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubHlyLnNlcnZpY2VQYXJhbXMuaWQgPSBzZXJ2ZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5seXIuc2VydmljZVBhcmFtcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6U2VydmljZXMvU2VydmVyL09ubGluZVJlc291cmNlXG4gICAgICAgIC8vIG91IDogL0xheWVyTGlzdC9MYXllci9TZXJ2ZXIvT25saW5lUmVzb3VyY2VcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVudGlvbi9ncHA6TGF5ZXIvZ3BwOlF1aWNrTG9vay9PbmxpbmVSZXNvdXJjZVxuICAgICAgICAvLyBvdSA6IC9MYXllckxpc3QvTGF5ZXIvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6TGVnZW5kcy9ncHA6TGVnZW5kL2dwcDpMZWdlbmRVUkwvT25saW5lUmVzb3VyY2VcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk1ldGFkYXRhVVJML09ubGluZVJlc291cmNlXG4gICAgICAgIC8qKiBPbmxpbmVSZXNvdXJjZSAqL1xuICAgICAgICBPbmxpbmVSZXNvdXJjZSA6IGZ1bmN0aW9uIChub2RlLCBzZXJ2aWNlKSB7XG4gICAgICAgICAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLmhhc093blByb3BlcnR5KFwic2VydmVyVXJsXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VydmljZS5zZXJ2ZXJVcmwgPSBub2RlLmdldEF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3RcbiAgICAgICAgLyoqIExheWVyTGlzdCAqL1xuICAgICAgICBMYXllckxpc3QgOiBmdW5jdGlvbiAobGF5ZXJMaXN0Tm9kZSwgY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBsaXN0ZSBkZSBiYWxpc2VzIFwibGF5ZXJcIlxuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKGxheWVyTGlzdE5vZGUsIGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmxheWVycyAmJiBjb25maWcuZ2VuZXJhbE9wdGlvbnMgJiYgY29uZmlnLnNlcnZpY2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGVzIGNsw6lzIGV0IGRlcyBjb3VjaGVzIGFzc29jacOpZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBseXIgaW4gY29uZmlnLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxheWVycy5oYXNPd25Qcm9wZXJ0eShseXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXJDb25maWcgPSBjb25maWcubGF5ZXJzW2x5cl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGxhIGNsw6kgYXNzb2Npw6llXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpS2V5cyA9IGxheWVyQ29uZmlnLmFwaUtleXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpS2V5cyAmJiBBcnJheS5pc0FycmF5KGFwaUtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcGlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvdXIgY2hhcXVlIGNsw6kgQVBJLCBvbiBham91dGUgbGEgY291Y2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBhcGlLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmdlbmVyYWxPcHRpb25zLmFwaUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29uZmlnLmdlbmVyYWxPcHRpb25zLmFwaUtleXNba2V5XSB8fCAhQXJyYXkuaXNBcnJheShjb25maWcuZ2VuZXJhbE9wdGlvbnMuYXBpS2V5c1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy5hcGlLZXlzW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy5hcGlLZXlzW2tleV0ucHVzaChseXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkdSBzZXJ2aWNlIGFzc29jacOpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmljZVBhcmFtcyA9IGxheWVyQ29uZmlnLnNlcnZpY2VQYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmljZVBhcmFtcyAmJiBzZXJ2aWNlUGFyYW1zLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb25maWcuc2VydmljZXNbc2VydmljZVBhcmFtcy5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19SZXNwb25zZV9tb2RlbF9TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VQYXJhbXMuc2VydmVyVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLnNlcnZlclVybCA9IHNlcnZpY2VQYXJhbXMuc2VydmVyVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUGFyYW1zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMudmVyc2lvbiA9IHNlcnZpY2VQYXJhbXMudmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc2VydmljZXNbc2VydmljZVBhcmFtcy5pZF0gPSBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbGEgcHJvamVjdGlvbiBhc3NvY2nDqWUgKGRhbnMgbGUgY2FzIGQndW5lIGNvdWNoZSBXTVRTKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyQ29uZmlnLndtdHNPcHRpb25zICYmIGxheWVyQ29uZmlnLndtdHNPcHRpb25zLnRpbGVNYXRyaXhTZXRMaW5rICYmIGNvbmZpZy50aWxlTWF0cml4U2V0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXNMaW5rID0gbGF5ZXJDb25maWcud210c09wdGlvbnMudGlsZU1hdHJpeFNldExpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbGVNYXRyaXhTZXRzID0gY29uZmlnLnRpbGVNYXRyaXhTZXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRtcyBpbiB0aWxlTWF0cml4U2V0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGlsZU1hdHJpeFNldHMuaGFzT3duUHJvcGVydHkodG1zKSAmJiB0bXMgPT09IHRtc0xpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQ29uZmlnLmRlZmF1bHRQcm9qZWN0aW9uID0gdGlsZU1hdHJpeFNldHNbdG1zXS5wcm9qZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyXG4gICAgICAgIC8qKiBMYXllciAqL1xuICAgICAgICBMYXllciA6IGZ1bmN0aW9uIChsYXllck5vZGUsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGx5ckRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ciA6IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1Jlc3BvbnNlX21vZGVsX0xheWVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKSxcbiAgICAgICAgICAgICAgICAgICAgbHlySWQgOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBoaWRkZW4gPSBsYXllck5vZGUuZ2V0QXR0cmlidXRlKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIGlmIChoaWRkZW4gPT09IFwiMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5YWJsZSA9IGxheWVyTm9kZS5nZXRBdHRyaWJ1dGUoXCJxdWVyeWFibGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5YWJsZSA9PT0gXCIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIucXVlcnlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBseXJEYXRhLmx5ci5xdWVyeWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbiBwZXV0IGF2b2lyIGxlcyBiYWxpc2VzIDogU2VydmVyLCBOYW1lLCBUaXRsZSwgQWJzdHJhY3QsIERhdGFVUkwsIE1ldGFkYXRhVVJMLFxuICAgICAgICAgICAgICAgIC8vIHNsZDpNaW5TY2FsZURlbm9taW5hdG9yLCBzbGQ6TWF4U2NhbGVEZW5vbWluYXRvciwgU1JTLCBGb3JtYXRMaXN0LCBTdHlsZUxpc3RcbiAgICAgICAgICAgICAgICAvLyBEaW1lbnNpb25MaXN0LCBFeHRlbnNpb25cbiAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMobGF5ZXJOb2RlLCBseXJEYXRhKTtcblxuICAgICAgICAgICAgICAgIC8vIHNpIG9uIGEgYmllbiByw6ljdXDDqXLDqSBsJ2lkZW50aWZpYW50IGRlIGxhIGNvdWNoZSwgb24gcydlbiBzZXJ0IHBvdXIgbCdham91dGVyIGF1IHRhYmxlYXUgYXNzb2NpYXRpZiBkZXMgY291Y2hlcyBkaXNwb25pYmxlc1xuICAgICAgICAgICAgICAgIGlmIChseXJEYXRhLmx5cklkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERhbnMgbGUgY2FzIGRlcyBzZXJ2aWNlcywgb24gbW9kaWZpZSBsZSBjb250ZXh0ZSBkZSBsJ2lkZW50aWZpYW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAobHlyRGF0YS5seXIuc2VydmljZVBhcmFtcyAmJiBseXJEYXRhLmx5ci5zZXJ2aWNlUGFyYW1zLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmljZWlkID0gbHlyRGF0YS5seXIuc2VydmljZVBhcmFtcy5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlaWQudG9VcHBlckNhc2UoKS5pbmRleE9mKFwiT1BFTkxTXCIpICE9PSAtMSB8fCBzZXJ2aWNlaWQudG9VcHBlckNhc2UoKS5pbmRleE9mKFwiRUxFVkFUSU9OXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsIGZhdXQgY2hhbmdlciBsJ2lkZW50aWZpYW50IGRlIGxhIHJlc3NvdXJjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VJZCA9IGx5ckRhdGEubHlySWQuc3BsaXQoXCIkXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlySWQgPSByZXNvdXJjZUlkICsgXCIkXCIgKyBzZXJ2aWNlaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBham91dGUgbCdpbmZvcm1hdGlvbiBkYW5zIGxlcyBhdHRyaWJ1dHMgZGUgbGEgY291Y2hlXG4gICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLmxheWVySWQgPSBseXJEYXRhLmx5cklkO1xuICAgICAgICAgICAgICAgICAgICAvLyBldCBkYW5zIGxlIHRhYmxlYXUgR3AuQ29uZmlnLmxheWVyc1xuICAgICAgICAgICAgICAgICAgICBjb25maWcubGF5ZXJzW2x5ckRhdGEubHlySWRdID0gbHlyRGF0YS5seXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL05hbWVcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBOYW1lIDogZnVuY3Rpb24gKG5vZGUsIGx5ckRhdGEpIHtcbiAgICAgICAgICAgIGlmIChseXJEYXRhICYmIGx5ckRhdGEubHlyKSB7XG4gICAgICAgICAgICAgICAgbHlyRGF0YS5seXIubmFtZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9TUlMgKGRhbnMgbGUgY2FzIGRlcyBjb3VjaGVzIFdNUyBvdSBXRlMpXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgU1JTIDogZnVuY3Rpb24gKG5vZGUsIGx5ckRhdGEpIHtcbiAgICAgICAgICAgIC8vIG9uIHLDqWN1cMOocmUgbGEgcHJvamVjdGlvbiBkZSBsYSBjb3VjaGUgKFNSUylcbiAgICAgICAgICAgIGlmIChseXJEYXRhICYmIGx5ckRhdGEubHlyKSB7XG4gICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuZGVmYXVsdFByb2plY3Rpb24gPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvRm9ybWF0TGlzdC9Gb3JtYXRcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBGb3JtYXQgOiBmdW5jdGlvbiAobm9kZSwgbHlyRGF0YSkge1xuICAgICAgICAgICAgaWYgKGx5ckRhdGEgJiYgbHlyRGF0YS5seXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1Jlc3BvbnNlX21vZGVsX0Zvcm1hdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmdldEF0dHJpYnV0ZShcImN1cnJlbnRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IFwiMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGYubmFtZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBzaSBvbiBuJ2EgcGFzIGVuY29yZSBham91dMOpIGRlIGZvcm1hdCwgb24gY3LDqWUgbGUgdGFibGVhdSB2aWRlXG4gICAgICAgICAgICAgICAgaWYgKCFseXJEYXRhLmx5ci5mb3JtYXRzIHx8ICFBcnJheS5pc0FycmF5KGx5ckRhdGEubHlyLmZvcm1hdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLmZvcm1hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuZm9ybWF0cy5wdXNoKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL1N0eWxlTGlzdC9TdHlsZVxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFN0eWxlIDogZnVuY3Rpb24gKG5vZGUsIGx5ckRhdGEpIHtcbiAgICAgICAgICAgIGlmIChseXJEYXRhICYmIGx5ckRhdGEubHlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19SZXNwb25zZV9tb2RlbF9TdHlsZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBub2RlLmdldEF0dHJpYnV0ZShcImN1cnJlbnRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IFwiMVwiIHx8IGN1cnJlbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgeyAvLyAxID09PSBub2RlLkVMRU1FTlRfTk9ERVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTmFtZSA9IGNoaWxkLmxvY2FsTmFtZSB8fCBjaGlsZC5iYXNlTmFtZSB8fCBjaGlsZC5ub2RlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROYW1lID09PSBcIk5hbWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm5hbWUgPSBfX2dldENoaWxkVmFsdWUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSBcIlRpdGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy50aXRsZSA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNpIG9uIG4nYSBwYXMgZW5jb3JlIGFqb3V0w6kgZGUgc3R5bGUsIG9uIGNyw6llIGxlIHRhYmxlYXUgdmlkZVxuICAgICAgICAgICAgICAgIGlmICghbHlyRGF0YS5seXIuc3R5bGVzIHx8ICFBcnJheS5pc0FycmF5KGx5ckRhdGEubHlyLnN0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuc3R5bGVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLnN0eWxlcy5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0RpbWVuc2lvbkxpc3QvRGltZW5zaW9uXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgRGltZW5zaW9uIDogZnVuY3Rpb24gKG5vZGUsIGx5ckRhdGEpIHtcbiAgICAgICAgICAgIC8vIHBvc3PDqGRlIGRlcyBhdHRyaWJ1dHMgb2JsaWdhdG9pcmVzIDogbmFtZSwgdW5pdHMsIHVuaXRTeW1ib2wgZXQgdXNlclZhbHVlXG4gICAgICAgICAgICAvLyBldCBkJ2F1dHJlcyBhdHRyaWJ1dHMgZmFjdWx0YXRpZnMgOiBkZWZhdWx0LCBtdWx0aXBsZVZhbHVlcywgbmVhcmVzdFZhbHVlLCBjdXJyZW50XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHZhciBkaW0gPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICBpZiAobHlyRGF0YSAmJiBseXJEYXRhLmx5cikge1xuICAgICAgICAgICAgICAgIC8vIHNpIG9uIG4nYSBwYXMgZW5jb3JlIGFqb3V0w6kgZGUgZGltZW5zaW9uLCBvbiBjcsOpZSBsJ29iamV0IHZpZGVcbiAgICAgICAgICAgICAgICBpZiAoIWx5ckRhdGEubHlyLmRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuZGltZW5zaW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJUeXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuZGltZW5zaW9ucy50eXBlID0gZGltO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJWaXNpYmlsaXR5UmFuZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICBseXJEYXRhLmx5ci5kaW1lbnNpb25zLnZpc2liaWxpdHlSYW5nZSA9IGRpbTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiVmlzaWJpbGl0eU1vZGUgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyRGF0YS5seXIuZGltZW5zaW9ucy52aXNpYmlsaXR5TW9kZSA9IGRpbTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiR2VvbWV0cmljVHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLmRpbWVuc2lvbnMuZ2VvbWV0cmljVHlwZSA9IGRpbTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiTm9EYXRhVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICBseXJEYXRhLmx5ci5kaW1lbnNpb25zLm5vRGF0YVZhbHVlID0gZGltO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdwcCA6IHtcblxuICAgICAgICAvLyBpbmZvIDogL0dlbmVyYWwvRXh0ZW5zaW9uL2dwcDpHZW5lcmFsL2dwcDpUaGVtZVxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFRoZW1lIDogZnVuY3Rpb24gKHRoZW1lTm9kZSwgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5nZW5lcmFsT3B0aW9ucyAmJiBjb25maWcuZ2VuZXJhbE9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJ0aGVtZVwiKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy50aGVtZSA9IF9fZ2V0Q2hpbGRWYWx1ZSh0aGVtZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOmRlZmF1bHRHTUxHRklTdHlsZVVybFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIGRlZmF1bHRHTUxHRklTdHlsZVVybCA6IGZ1bmN0aW9uIChub2RlLCBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmdlbmVyYWxPcHRpb25zICYmIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRHTUxHRklTdHlsZVwiKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy5kZWZhdWx0R01MR0ZJU3R5bGUgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGVycml0b3JpZXMvZ3BwOlRlcnJpdG9yeVxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFRlcnJpdG9yeSA6IGZ1bmN0aW9uICh0ZXJyaXRvcnlOb2RlLCBjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGluZm8gOiBJbmZvcm1hdGlvbiB0byBjb25maWd1cmUgdGhlIEFQSSBmb3IgdGhpcyB0ZXJyaXRvcnlcbiAgICAgICAgICAgIHZhciB0aWQgPSB0ZXJyaXRvcnlOb2RlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgaWYgKHRpZCkge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBUZXJyaXRvcnlcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1Jlc3BvbnNlX21vZGVsX1RlcnJpdG9yeV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNEZWZhdWx0ID0gdGVycml0b3J5Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmF1bHQgPT09IFwiMVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHQuaXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0LmlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWFkIHRlcnJpdG9yeSBpbmZvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXModGVycml0b3J5Tm9kZSwgdCk7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRlcnJpdG9yeSB0byBjb25maWdcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy50ZXJyaXRvcmllcyAmJiB0eXBlb2YgY29uZmlnLnRlcnJpdG9yaWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy50ZXJyaXRvcmllc1t0aWRdID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGVycml0b3JpZXMvZ3BwOlRlcnJpdG9yeS9ncHA6ZGVmYXVsdENSU1xuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIGRlZmF1bHRDUlMgOiBmdW5jdGlvbiAobm9kZSwgdGVycml0b3J5KSB7XG4gICAgICAgICAgICAvLyBpbmZvIDogSWRlbnRpZmllciBmb3IgdGhlIGRlZmF1bHQgQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIChDUlMpLlxuICAgICAgICAgICAgaWYgKHRlcnJpdG9yeSAmJiB0ZXJyaXRvcnkuaGFzT3duUHJvcGVydHkoXCJkZWZhdWx0Q1JTXCIpKSB7XG4gICAgICAgICAgICAgICAgdGVycml0b3J5LmRlZmF1bHRDUlMgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGVycml0b3JpZXMvZ3BwOlRlcnJpdG9yeS9ncHA6QWRkaXRpb25hbENSU1xuICAgICAgICAvLyBvdSA6IC9MYXllckxpc3QvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6QWRkaXRpb25hbENSU1xuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIEFkZGl0aW9uYWxDUlMgOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgLy8gaW5mbyA6IElkZW50aWZpZXIgZm9yIGFkZGl0aW9uYWwgQ29vcmRpbmF0ZSBSZWZlcmVuY2UgU3lzdGVtIChDUlMpLlxuICAgICAgICAgICAgLy8gaW5mbyA6IGRhdGEgcGV1dCDDqnRyZSB1bmUgaW5zdGFuY2UgZGUgVGVycml0b3J5LmpzLCBvdSB1bmUgaW5zdGFuY2UgZGUgTGF5ZXIuanNcbiAgICAgICAgICAgIHZhciBhZGRDUlMgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICBpZiAoYWRkQ1JTICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmFkZGl0aW9uYWxDUlMpKSB7IC8vIGNhcyBkJ3VuIHRlcnJpdG9pcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRpdGlvbmFsQ1JTLnB1c2goYWRkQ1JTKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBjYXMgZCd1bmUgY291Y2hlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpIGxlIHRhYmxlYXUgbidlc3QgcGFzIGVuY29yZSBjcsOpw6lcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmFkZGl0aW9uYWxQcm9qZWN0aW9ucyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLmFkZGl0aW9uYWxQcm9qZWN0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYWRkaXRpb25hbFByb2plY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRpdGlvbmFsUHJvamVjdGlvbnMucHVzaChhZGRDUlMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0dlbmVyYWwvRXh0ZW5zaW9uL2dwcDpHZW5lcmFsL2dwcDpUZXJyaXRvcmllcy9ncHA6VGVycml0b3J5L2dwcDpEZWZhdWx0TGF5ZXJcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBEZWZhdWx0TGF5ZXIgOiBmdW5jdGlvbiAobm9kZSwgdGVycml0b3J5KSB7XG4gICAgICAgICAgICB2YXIgbHlyID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJsYXllcklkXCIpO1xuICAgICAgICAgICAgaWYgKGx5ciAmJiB0ZXJyaXRvcnkgJiYgQXJyYXkuaXNBcnJheSh0ZXJyaXRvcnkuZGVmYXVsdExheWVycykpIHtcbiAgICAgICAgICAgICAgICB0ZXJyaXRvcnkuZGVmYXVsdExheWVycy5wdXNoKGx5cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGVycml0b3JpZXMvZ3BwOlRlcnJpdG9yeS9ncHA6Qm91bmRpbmdCb3hcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOkJvdW5kaW5nQm94XG4gICAgICAgIC8vIG91IDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpDb25zdHJhaW50cy9ncHA6Q29uc3RyYWludC9ncHA6Qm91bmRpbmdCb3hcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk9yaWdpbmF0b3JzL2dwcDpPcmlnaW5hdG9yL2dwcDpDb25zdHJhaW50cy9ncHA6Q29uc3RyYWludC9ncHA6Qm91bmRpbmdCb3hcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBCb3VuZGluZ0JveCA6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBfX2dldENoaWxkVmFsdWUobm9kZSkuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBiYm94IGNvb3JkaW5hdGVzICh3Z3M4NClcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJib3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IDogcGFyc2VGbG9hdCh2YWx1ZXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgOiBwYXJzZUZsb2F0KHZhbHVlc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgOiBwYXJzZUZsb2F0KHZhbHVlc1szXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gOiBwYXJzZUZsb2F0KHZhbHVlc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRlbXBvcmFsIGV4dGVudCBwYXJhbXMgKGNvbnN0cmFpbnQgb3IgbGF5ZXIpXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5UID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJtaW5UXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibWF4VFwiKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcImdlb0JCT1hcIikpIHsgLy8gY2FzIGQndW4gdGVycml0b2lyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5nZW9CQk9YID0gYmJveDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmhhc093blByb3BlcnR5KFwiYmJveFwiKSkgeyAvLyBjYXMgZCd1bmUgY29uc3RyYWludFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYmJveC5sZWZ0IHx8IGRhdGEuYmJveC5yaWdodCB8fCBkYXRhLmJib3gudG9wIHx8IGRhdGEuYmJveC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaSBvbiBhIGTDqWrDoCB1bmUgYmJveCwgaWwgZmF1dCBzdG9ja2VyIGQnYXV0cmVzIGNvbnRyYWludGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLm11bHRpQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tdWx0aUNvbnN0cmFpbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb25zdHJhaW50ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfQ29uc3RyYWludF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29uc3RyYWludC5iYm94ID0gYmJveDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb25zdHJhaW50LnRlbXBvcmFsRXh0ZW50ID0gW21pblQsIG1heFRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubXVsdGlDb25zdHJhaW50cy5wdXNoKG5ld0NvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250cmFpbnRlIGNsYXNzaXF1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYmJveCA9IGJib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZW1wb3JhbEV4dGVudCA9IFttaW5ULCBtYXhUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2FzIGQndW5lIGxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZ2xvYmFsQ29uc3RyYWludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZ2xvYmFsQ29uc3RyYWludCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1Jlc3BvbnNlX21vZGVsX0NvbnN0cmFpbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5nbG9iYWxDb25zdHJhaW50LmJib3ggPSBiYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5nbG9iYWxDb25zdHJhaW50LnRlbXBvcmFsRXh0ZW50ID0gW21pblQsIG1heFRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRlcnJpdG9yaWVzL2dwcDpUZXJyaXRvcnkvZ3BwOlJlc29sdXRpb25cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBSZXNvbHV0aW9uIDogZnVuY3Rpb24gKG5vZGUsIHRlcnJpdG9yeSkge1xuICAgICAgICAgICAgLy8gaW5mbyA6IFRoZSBkZWZhdWx0IHJlc29sdXRpb24gdG8gZGlzcGxheSBvbiB0aGlzIHRlcnJpdG9yeSwgaW4gQ1JTIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICAgICAgICB2YXIgcmVzID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHJlcyAmJiB0ZXJyaXRvcnkgJiYgdGVycml0b3J5LmRlZmF1bHRPcHRpb25zICYmIHRlcnJpdG9yeS5kZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInJlc29sdXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICB0ZXJyaXRvcnkuZGVmYXVsdE9wdGlvbnMucmVzb2x1dGlvbiA9IHBhcnNlRmxvYXQocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0dlbmVyYWwvRXh0ZW5zaW9uL2dwcDpHZW5lcmFsL2dwcDpUZXJyaXRvcmllcy9ncHA6VGVycml0b3J5L2dwcDpDZW50ZXIvZ3BwOnhcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICB4IDogZnVuY3Rpb24gKG5vZGUsIHRlcnJpdG9yeSkge1xuICAgICAgICAgICAgdmFyIGxvbiA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmIChsb24gJiYgdGVycml0b3J5ICYmIHRlcnJpdG9yeS5nZW9DZW50ZXIgJiYgdGVycml0b3J5Lmdlb0NlbnRlci5oYXNPd25Qcm9wZXJ0eShcImxvblwiKSkge1xuICAgICAgICAgICAgICAgIHRlcnJpdG9yeS5nZW9DZW50ZXIubG9uID0gcGFyc2VGbG9hdChsb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRlcnJpdG9yaWVzL2dwcDpUZXJyaXRvcnkvZ3BwOkNlbnRlci9ncHA6eVxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIHkgOiBmdW5jdGlvbiAobm9kZSwgdGVycml0b3J5KSB7XG4gICAgICAgICAgICB2YXIgbGF0ID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGxhdCAmJiB0ZXJyaXRvcnkgJiYgdGVycml0b3J5Lmdlb0NlbnRlciAmJiB0ZXJyaXRvcnkuZ2VvQ2VudGVyLmhhc093blByb3BlcnR5KFwibGF0XCIpKSB7XG4gICAgICAgICAgICAgICAgdGVycml0b3J5Lmdlb0NlbnRlci5sYXQgPSBwYXJzZUZsb2F0KGxhdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6UmVzb2x1dGlvbnNcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBSZXNvbHV0aW9ucyA6IGZ1bmN0aW9uIChyZXNOb2RlLCBjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGluZm8gOiBMaXN0IG9mIHJlc29sdXRpb25zIGluIENSUzo4NCAoY29tbWEgc2VwYXJhdGVkIHZhbHVlcylcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmdlbmVyYWxPcHRpb25zICYmIGNvbmZpZy5nZW5lcmFsT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcIndnczg0UmVzb2x1dGlvbnNcIikpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZ2VuZXJhbE9wdGlvbnMud2dzODRSZXNvbHV0aW9ucyA9IF9fZ2V0Q2hpbGRWYWx1ZShyZXNOb2RlKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvRXh0ZW5zaW9uL2dwcDpMYXllclxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIExheWVyIDogZnVuY3Rpb24gKG5vZGUsIGx5ckRhdGEpIHtcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0cyA6IGlkLCBvcGFjaXR5LCBvcmRlciwgdmlzaWJsZUluQ2F0YWxvZywgYWdncmVnYXRlLCBtb3JlXG4gICAgICAgICAgICBpZiAobHlyRGF0YSAmJiBseXJEYXRhLmhhc093blByb3BlcnR5KFwibHlySWRcIikgJiYgbHlyRGF0YS5seXIpIHtcbiAgICAgICAgICAgICAgICBseXJEYXRhLmx5cklkID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYWdncmVnYXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJhZ2dyZWdhdGVcIik7XG4gICAgICAgICAgICAgICAgdmFyIG1vcmUgPSBub2RlLmdldEF0dHJpYnV0ZShcIm1vcmVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZSB8fCBtb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ckRhdGEubHlyLmlzQWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIGx5ckRhdGEubHlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpDb25zdHJhaW50cy9ncHA6Q29uc3RyYWludFxuICAgICAgICAvLyBvdSA6IC9MYXllckxpc3QvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6T3JpZ2luYXRvcnMvZ3BwOk9yaWdpbmF0b3IvZ3BwOkNvbnN0cmFpbnRzL2dwcDpDb25zdHJhaW50XG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgQ29uc3RyYWludCA6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1Jlc3BvbnNlX21vZGVsX0NvbnN0cmFpbnRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIGMpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBvbiBwZXV0IMOqdHJlIGRhbnMgbGUgY2FzIGQndW4gb3JpZ2luYXRvciBvdSBkJ3VuZSBsYXllciwgdG91cyBsZXMgZGV1eCBvbnQgbCdhdHRyaWJ1dCBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5jb25zdHJhaW50cyB8fCAhQXJyYXkuaXNBcnJheShkYXRhLmNvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbnN0cmFpbnRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FzIGRlIHBsdXNpZXVycyBjb250cmFpbnRlcyAocGFyIGV4IGRpZmbDqXJlbnRzIHRlcnJpdG9pcmVzKVxuICAgICAgICAgICAgICAgIGlmIChjLm11bHRpQ29uc3RyYWludHMgJiYgQXJyYXkuaXNBcnJheShjLm11bHRpQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHLDqWN1cMOocmUgbGEgcHJlbWnDqHJlIGNvbnRyYWludGUsIHN0b2Nrw6llIG5vcm1hbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfQ29uc3RyYWludF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuY3JzID0gYy5jcnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQuYmJveCA9IGMuYmJveDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taW5TY2FsZURlbm9taW5hdG9yID0gYy5taW5TY2FsZURlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50Lm1heFNjYWxlRGVub21pbmF0b3IgPSBjLm1heFNjYWxlRGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQudGVtcG9yYWxFeHRlbnQgPSBjLnRlbXBvcmFsRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvbnN0cmFpbnRzLnB1c2goY29uc3RyYWludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcHVpcyBvbiByw6ljdXDDqHJlIGxlcyBhdXRyZXMgY29udHJhaW50ZXMsIMOgIHBhcnRpciBkZSBtdWx0aUNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYy5tdWx0aUNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfQ29uc3RyYWludF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LmNycyA9IGMuY3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5taW5TY2FsZURlbm9taW5hdG9yID0gYy5taW5TY2FsZURlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5tYXhTY2FsZURlbm9taW5hdG9yID0gYy5tYXhTY2FsZURlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludC5iYm94ID0gYy5tdWx0aUNvbnN0cmFpbnRzW2ldLmJib3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50LnRlbXBvcmFsRXh0ZW50ID0gYy5tdWx0aUNvbnN0cmFpbnRzW2ldLnRlbXBvcmFsRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzIGQndW5lIGNvbnRyYWludGUgY2xhc3NpcXVlXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY29uc3RyYWludHMucHVzaChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6T3JpZ2luYXRvcnMvZ3BwOk9yaWdpbmF0b3IvZ3BwOkNvbnN0cmFpbnRzL2dwcDpDb25zdHJhaW50L2dwcDpDUlNcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOkNvbnN0cmFpbnRzL2dwcDpDb25zdHJhaW50L2dwcDpDUlNcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBDUlMgOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoXCJjcnNcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmNycyA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpUaGVtYXRpY3MvZ3BwOlRoZW1hdGljXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgVGhlbWF0aWMgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICBpZiAobHlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fUmVzcG9uc2VfbW9kZWxfVGhlbWF0aWNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgIHQuaW5zcGlyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHQubmFtZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBzaSBhdWN1bmUgdGjDqW1hdGlxdWUgbidhIMOpdMOpIGFqb3V0w6llLCBvbiBjcsOpZSBsZSB0YWJsZWF1IHZpZGVcbiAgICAgICAgICAgICAgICBpZiAoIWx5ci50aGVtYXRpY3MgfHwgIUFycmF5LmlzQXJyYXkobHlyLnRoZW1hdGljcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyLnRoZW1hdGljcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBseXIudGhlbWF0aWNzLnB1c2godCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6VGhlbWF0aWNzL2dwcDpJbnNwaXJlVGhlbWF0aWNcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBJbnNwaXJlVGhlbWF0aWMgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICBpZiAobHlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fUmVzcG9uc2VfbW9kZWxfVGhlbWF0aWNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgIHQuaW5zcGlyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdC5uYW1lID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIHNpIGF1Y3VuZSB0aMOpbWF0aXF1ZSBuJ2Egw6l0w6kgYWpvdXTDqWUsIG9uIGNyw6llIGxlIHRhYmxlYXUgdmlkZVxuICAgICAgICAgICAgICAgIGlmICghbHlyLnRoZW1hdGljcyB8fCAhQXJyYXkuaXNBcnJheShseXIudGhlbWF0aWNzKSkge1xuICAgICAgICAgICAgICAgICAgICBseXIudGhlbWF0aWNzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx5ci50aGVtYXRpY3MucHVzaCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpPcmlnaW5hdG9ycy9ncHA6T3JpZ2luYXRvclxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIE9yaWdpbmF0b3IgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICBpZiAobHlyKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5mbyA6IGNvbnRpZW50IGRlcyBiYWxpc2VzIEF0dHJpYnV0aW9uLCBMb2dvLCBVUkwsIGV0IENvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgdmFyIG8gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19SZXNwb25zZV9tb2RlbF9PcmlnaW5hdG9yX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgICAgICAgICBvLm5hbWUgPSBub2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIG8pO1xuICAgICAgICAgICAgICAgIC8vIHNpIGF1Y3VuIG9yaWdpbmF0b3IgbidhIMOpdMOpIGFqb3V0w6ksIG9uIGNyw6llIGxlIHRhYmxlYXUgdmlkZVxuICAgICAgICAgICAgICAgIGlmICghbHlyLm9yaWdpbmF0b3JzIHx8ICFBcnJheS5pc0FycmF5KGx5ci5vcmlnaW5hdG9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyLm9yaWdpbmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx5ci5vcmlnaW5hdG9ycy5wdXNoKG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk9yaWdpbmF0b3JzL2dwcDpPcmlnaW5hdG9yL2dwcDpBdHRyaWJ1dGlvblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIEF0dHJpYnV0aW9uIDogZnVuY3Rpb24gKG5vZGUsIG9yaWdpbmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hdG9yICYmIG9yaWdpbmF0b3IuaGFzT3duUHJvcGVydHkoXCJhdHRyaWJ1dGlvblwiKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmF0b3IuYXR0cmlidXRpb24gPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9MYXllckxpc3QvTGF5ZXIvRXh0ZW5zaW9uL2dwcDpMYXllci9ncHA6T3JpZ2luYXRvcnMvZ3BwOk9yaWdpbmF0b3IvZ3BwOkxvZ29cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBMb2dvIDogZnVuY3Rpb24gKG5vZGUsIG9yaWdpbmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hdG9yICYmIG9yaWdpbmF0b3IuaGFzT3duUHJvcGVydHkoXCJsb2dvXCIpKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYXRvci5sb2dvID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk9yaWdpbmF0b3JzL2dwcDpPcmlnaW5hdG9yL2dwcDpVUkxcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBVUkwgOiBmdW5jdGlvbiAobm9kZSwgb3JpZ2luYXRvcikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmF0b3IgJiYgb3JpZ2luYXRvci5oYXNPd25Qcm9wZXJ0eShcInVybFwiKSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmF0b3IudXJsID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOkxlZ2VuZHMvZ3BwOkxlZ2VuZFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIExlZ2VuZCA6IGZ1bmN0aW9uIChub2RlLCBseXIpIHtcbiAgICAgICAgICAgIC8vIDIgYmFsaXNlcyA6IHNsZDpNaW5TY2FsZURlbm9taW5hdG9yIGV0IGdwcDpMZWdlbmRVUkxcbiAgICAgICAgICAgIHZhciBsID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fUmVzcG9uc2VfbW9kZWxfTGVnZW5kX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgICAgIF9fZ2V0Q2hpbGROb2Rlcyhub2RlLCBsKTtcbiAgICAgICAgICAgIGlmIChseXIpIHtcbiAgICAgICAgICAgICAgICAvLyBzaSBhdWN1bmUgbMOpZ2VuZGUgbidhIGVuY29yZSDDqXTDqSBham91dMOpZSwgb24gY3LDqWUgbGUgdGFibGVhdSB2aWRlXG4gICAgICAgICAgICAgICAgaWYgKCFseXIubGVnZW5kcyB8fCAhQXJyYXkuaXNBcnJheShseXIubGVnZW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyLmxlZ2VuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbHlyLmxlZ2VuZHMucHVzaChsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpMZWdlbmRzL2dwcDpMZWdlbmQvZ3BwOkxlZ2VuZFVSTFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIExlZ2VuZFVSTCA6IGZ1bmN0aW9uIChub2RlLCBsZWdlbmQpIHtcbiAgICAgICAgICAgIGlmIChsZWdlbmQgJiYgbGVnZW5kLmhhc093blByb3BlcnR5KFwiZm9ybWF0XCIpKSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLmZvcm1hdCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROYW1lID09PSBcIk9ubGluZVJlc291cmNlXCIgJiYgbGVnZW5kLmhhc093blByb3BlcnR5KFwidXJsXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQudXJsID0gY2hpbGQuZ2V0QXR0cmlidXRlKFwieGxpbms6aHJlZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpRdWlja0xvb2tcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBRdWlja0xvb2sgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICAvLyBpbmZvIDogY29udGllbnQgdW5lIGJhbGlzZSBPbmxpbmVSZXNvdXJjZSBhdmVjIGwndXJsIGRhbnMgbCdhdHRyaWJ1dCBcInhsaW5rOmhyZWZcIlxuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5hbWUgPT09IFwiT25saW5lUmVzb3VyY2VcIiAmJiBseXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbHlyLnF1aWNrbG9va1VybCA9IGNoaWxkLmdldEF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk1ldGFkYXRhVVJMXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgTWV0YWRhdGFVUkwgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICBpZiAobHlyKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5mbyA6IGNvbnRpZW50IHVuZSBiYWxpc2UgT25saW5lUmVzb3VyY2UgYXZlYyBsJ3VybCBkYW5zIGwnYXR0cmlidXQgXCJ4bGluazpocmVmXCJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1Jlc3BvbnNlX21vZGVsX01ldGFkYXRhX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgICAgICAgICBtLmZvcm1hdCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiZm9ybWF0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROYW1lID09PSBcIk9ubGluZVJlc291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0udXJsID0gY2hpbGQuZ2V0QXR0cmlidXRlKFwieGxpbms6aHJlZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaSBhdWN1bmUgbWV0YWRhdGEgbidhIMOpdMOpIGFqb3V0w6llLCBvbiBjcsOpZSBsZSB0YWJsZWF1IHZpZGVcbiAgICAgICAgICAgICAgICBpZiAoIWx5ci5tZXRhZGF0YSAmJiAhQXJyYXkuaXNBcnJheShseXIubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ci5tZXRhZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBseXIubWV0YWRhdGEucHVzaChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpLZXlzL2dwcDpLZXlcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBLZXkgOiBmdW5jdGlvbiAobm9kZSwgbHlyKSB7XG4gICAgICAgICAgICBpZiAobHlyKSB7XG4gICAgICAgICAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGUgbGEgY2zDqSBBUElcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAvLyBzaSBvbiBuJ2EgcGFzIGVuY29yZSBham91dMOpIGRlIGNsw6ksIG9uIGNyw6llIGxlIHRhYmxlYXUgdmlkZVxuICAgICAgICAgICAgICAgIGlmICghbHlyLmFwaUtleXMgfHwgIUFycmF5LmlzQXJyYXkobHlyLmFwaUtleXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ci5hcGlLZXlzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGx5ci5hcGlLZXlzLnB1c2goa2V5KTtcblxuICAgICAgICAgICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgYXZlYyBsYSBjbMOpIEFQSVxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJVcmwgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFseXIuc2VydmljZVBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBseXIuc2VydmljZVBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWx5ci5zZXJ2aWNlUGFyYW1zLnNlcnZlclVybCkge1xuICAgICAgICAgICAgICAgICAgICBseXIuc2VydmljZVBhcmFtcy5zZXJ2ZXJVcmwgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFseXIuc2VydmljZVBhcmFtcy5zZXJ2ZXJVcmxba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBseXIuc2VydmljZVBhcmFtcy5zZXJ2ZXJVcmxba2V5XSA9IHNlcnZlclVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBvd3MgOiB7XG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgSWRlbnRpZmllciA6IGZ1bmN0aW9uIChub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KFwiVE1TXCIpKSB7IC8vIGRhbnMgbGUgY2FzIGQndW4gVGlsZU1hdHJpeFNldFxuICAgICAgICAgICAgICAgIGRhdGEuaWRlbnRpZmllciA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KFwibWF0cml4SWRcIikpIHsgLy8gZGFucyBsZSBjYXMgZCd1bmUgVGlsZU1hdHJpeFxuICAgICAgICAgICAgICAgIGRhdGEubWF0cml4SWQgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBTdXBwb3J0ZWRDUlMgOiBmdW5jdGlvbiAobm9kZSwgdG1zRGF0YSkge1xuICAgICAgICAgICAgaWYgKHRtc0RhdGEgJiYgdG1zRGF0YS5UTVMgJiYgdG1zRGF0YS5UTVMuaGFzT3duUHJvcGVydHkoXCJwcm9qZWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgdG1zRGF0YS5UTVMucHJvamVjdGlvbiA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzbGQgOiB7XG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRlcnJpdG9yaWVzL2dwcDpUZXJyaXRvcnkvc2xkOk1pblNjYWxlRGVub21pbmF0b3JcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL3NsZDpNaW5TY2FsZURlbm9taW5hdG9yXG4gICAgICAgIC8vIG91IDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL2dwcDpPcmlnaW5hdG9ycy9ncHA6T3JpZ2luYXRvci9ncHA6Q29uc3RyYWludHMvc2xkOk1pblNjYWxlRGVub21pbmF0b3JcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOkxlZ2VuZHMvZ3BwOkxlZ2VuZC9zbGQ6TWluU2NhbGVEZW5vbWluYXRvclxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIE1pblNjYWxlRGVub21pbmF0b3IgOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1pblNjYWxlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG1pblNjYWxlICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRPcHRpb25zXCIpKSB7IC8vIGNhcyBkJ3VuIHRlcnJpdG9pcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kZWZhdWx0T3B0aW9ucy5taW5TY2FsZURlbm9taW5hdG9yID0gcGFyc2VGbG9hdChtaW5TY2FsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmx5cikgeyAvLyBjYXMgZCd1bmUgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmx5ci5nbG9iYWxDb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmx5ci5nbG9iYWxDb25zdHJhaW50ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfQ29uc3RyYWludF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5seXIuZ2xvYmFsQ29uc3RyYWludC5taW5TY2FsZURlbm9taW5hdG9yID0gcGFyc2VGbG9hdChtaW5TY2FsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmhhc093blByb3BlcnR5KFwibWluU2NhbGVEZW5vbWluYXRvclwiKSkgeyAvLyBjYXMgZCd1bmUgY29udHJhaW50ZSBvdSBkJ3VuZSBsw6lnZW5kZVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm1pblNjYWxlRGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KG1pblNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGVycml0b3JpZXMvZ3BwOlRlcnJpdG9yeS9zbGQ6TWF4U2NhbGVEZW5vbWluYXRvclxuICAgICAgICAvLyBvdSA6IC9MYXllckxpc3QvTGF5ZXIvc2xkOk1heFNjYWxlRGVub21pbmF0b3JcbiAgICAgICAgLy8gb3UgOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvZ3BwOk9yaWdpbmF0b3JzL2dwcDpPcmlnaW5hdG9yL2dwcDpDb25zdHJhaW50cy9zbGQ6TWF4U2NhbGVEZW5vbWluYXRvclxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIE1heFNjYWxlRGVub21pbmF0b3IgOiBmdW5jdGlvbiAobm9kZSwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIG1heFNjYWxlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG1heFNjYWxlICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRPcHRpb25zXCIpKSB7IC8vIGNhcyBkJ3VuIHRlcnJpdG9pcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5kZWZhdWx0T3B0aW9ucy5tYXhTY2FsZURlbm9taW5hdG9yID0gcGFyc2VGbG9hdChtYXhTY2FsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmx5cikgeyAvLyBjYXMgZCd1bmUgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmx5ci5nbG9iYWxDb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmx5ci5nbG9iYWxDb25zdHJhaW50ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfbW9kZWxfQ29uc3RyYWludF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5seXIuZ2xvYmFsQ29uc3RyYWludC5tYXhTY2FsZURlbm9taW5hdG9yID0gcGFyc2VGbG9hdChtYXhTY2FsZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmhhc093blByb3BlcnR5KFwibWF4U2NhbGVEZW5vbWluYXRvclwiKSkgeyAvLyBjYXMgZCd1bmUgY29udHJhaW50ZVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm1heFNjYWxlRGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KG1heFNjYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd210cyA6IHtcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL3dtdHM6VGlsZU1hdHJpeFNldExpbmsvd210czpUaWxlTWF0cml4U2V0TGltaXRzXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgVGlsZU1hdHJpeFNldExpbWl0cyA6IGZ1bmN0aW9uIChub2RlLCBseXIpIHtcbiAgICAgICAgICAgIC8vIGluZm8gOiBjb250aWVudCBkZXMgYmFsaXNlcyB3bXRzOlRpbGVNYXRyaXhMaW1pdHNcbiAgICAgICAgICAgIGlmIChseXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGltaXRzID0ge307XG4gICAgICAgICAgICAgICAgLy8gb24gcsOpY3Vww6hyZSBsZXMgbGltaXRlcyBkYW5zIGxlcyBiYWxpc2VzIFRpbGVNYXRyaXhMaW1pdHNcbiAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMobm9kZSwgbGltaXRzKTtcblxuICAgICAgICAgICAgICAgIGlmICghbHlyLndtdHNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGx5ci53bXRzT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBseXIud210c09wdGlvbnMudGlsZU1hdHJpeFNldExpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0xheWVyTGlzdC9MYXllci9FeHRlbnNpb24vZ3BwOkxheWVyL3dtdHM6VGlsZU1hdHJpeFNldExpbmsvd210czpUaWxlTWF0cml4U2V0TGltaXRzL3dtdHM6VGlsZU1hdHJpeExpbWl0c1xuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFRpbGVNYXRyaXhMaW1pdHMgOiBmdW5jdGlvbiAobm9kZSwgbGltaXRzKSB7XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fUmVzcG9uc2VfbW9kZWxfVGlsZU1hdHJpeExpbWl0X19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgICAgIHZhciBsaW1pdElkO1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROYW1lID09PSBcIlRpbGVNYXRyaXhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXRJZCA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSBcIk1pblRpbGVSb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQubWluVGlsZVJvdyA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSBcIk1heFRpbGVSb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQubWF4VGlsZVJvdyA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSBcIk1pblRpbGVDb2xcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQubWluVGlsZUNvbCA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSBcIk1heFRpbGVDb2xcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQubWF4VGlsZUNvbCA9IF9fZ2V0Q2hpbGRWYWx1ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0SWQgJiYgbGltaXRzICYmICFsaW1pdHNbbGltaXRJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzW2xpbWl0SWRdID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldFxuICAgICAgICAvLyBvdSA6IC8vIGluZm8gOiAvTGF5ZXJMaXN0L0xheWVyL0V4dGVuc2lvbi9ncHA6TGF5ZXIvd210czpUaWxlTWF0cml4U2V0TGluay93bXRzOlRpbGVNYXRyaXhTZXRcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBUaWxlTWF0cml4U2V0IDogZnVuY3Rpb24gKG5vZGUsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGluZm8gOiBEZXNjcmliZXMgYSBwYXJ0aWN1bGFyIHNldCBvZiB0aWxlIG1hdHJpY2VzLlxuXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnRpbGVNYXRyaXhTZXRzKSB7IC8vIGxlcyB0aWxlTWF0cml4U2V0cyBkZSBHZW5lcmFsXG4gICAgICAgICAgICAgICAgLy8gbm91dmVsIG9iamV0IFRpbGVNYXRyaXhTZXRcbiAgICAgICAgICAgICAgICB2YXIgdG1zRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIHRtc0RhdGEuVE1TID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1Jlc3BvbnNlX21vZGVsX1RpbGVNYXRyaXhTZXRfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuICAgICAgICAgICAgICAgIHRtc0RhdGEucmVzb2x1dGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIGxlY3R1cmUgZGVzIGluZm9ybWF0aW9ucyBkdSBUTVNcbiAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMobm9kZSwgdG1zRGF0YSk7XG5cbiAgICAgICAgICAgICAgICAvLyByw6ljdXDDqXJhdGlvbiBkZXMgaWRlbnRpZmlhbnRzIGRlcyBuaXZlYXV4IGRlIG1hdHJpY2UgKHBvdXIgZmFjaWxpdGVyIGwnYWNjw6hzIGF1IFdNVFMgdmlhIGxlcyBBUEkgY2FydG8pXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVNYXRyaWNlcyA9IHRtc0RhdGEuVE1TLnRpbGVNYXRyaWNlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0bSBpbiB0aWxlTWF0cmljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbGVNYXRyaWNlcy5oYXNPd25Qcm9wZXJ0eSh0bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtc0RhdGEuVE1TLm1hdHJpeElkcy5wdXNoKHRtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0bXNEYXRhLlRNUy5nZXRQcm9qZWN0aW9uKCkgPT09IFwiSUdORjpXR1M4NEdcIiB8fCB0bXNEYXRhLlRNUy5nZXRQcm9qZWN0aW9uKCkgPT09IFwiRVBTRzo0MzI2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZ2VuZXJhbE9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmdlbmVyYWxPcHRpb25zLndnczg0UmVzb2x1dGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2dzODRSZXNvbHV0aW9ucyA9IGRhdGEuZ2VuZXJhbE9wdGlvbnMud2dzODRSZXNvbHV0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2dzODRSZXNvbHV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZm8gOiBsZXMgcsOpc29sdXRpb25zIHN0b2Nrw6llcyBkYW5zIHdnczg0UmVzb2x1dGlvbnMsIGlzc3VlcyBkZSBsJ2F1dG9jb25mLCBzb250IGRlcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXNEYXRhLnJlc29sdXRpb25zW2ldID0gcGFyc2VGbG9hdCh3Z3M4NFJlc29sdXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyaSBkZXMgcsOpc29sdXRpb25zIChwYXIgb3JkcmUgZMOpY3JvaXNzYW50IGNldHRlIGZvaXMpXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG1zRGF0YS5yZXNvbHV0aW9ucykgJiYgdG1zRGF0YS5yZXNvbHV0aW9ucy5zb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1zRGF0YS5yZXNvbHV0aW9ucy5zb3J0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geSAtIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtc0RhdGEuVE1TLm5hdGl2ZVJlc29sdXRpb25zID0gdG1zRGF0YS5yZXNvbHV0aW9ucztcblxuICAgICAgICAgICAgICAgIC8vIGFqb3V0IGR1IFRpbGVNYXRyaXhTZXQgw6AgbGEgdmFyaWFibGUgY29uZmlnXG4gICAgICAgICAgICAgICAgZGF0YS50aWxlTWF0cml4U2V0c1t0bXNEYXRhLmlkZW50aWZpZXJdID0gdG1zRGF0YS5UTVM7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBsZSBUaWxlTWF0cml4U2V0TGluayBkJ3VuZSBjb3VjaGUgKGxheWVyKVxuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmICFkYXRhLndtdHNPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEud210c09wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWpvdXQgZHUgbGllbiB2ZXJzIGxlIFRNU1xuICAgICAgICAgICAgICAgIGRhdGEud210c09wdGlvbnMudGlsZU1hdHJpeFNldExpbmsgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaW5mbyA6IC9HZW5lcmFsL0V4dGVuc2lvbi9ncHA6R2VuZXJhbC9ncHA6VGlsZU1hdHJpeFNldHMvd210czpUaWxlTWF0cml4U2V0L3dtdHM6VGlsZU1hdHJpeFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFRpbGVNYXRyaXggOiBmdW5jdGlvbiAobm9kZSwgdG1zRGF0YSkge1xuICAgICAgICAgICAgLy8gaW5mbyA6IERlc2NyaWJlcyBhIHBhcnRpY3VsYXIgdGlsZSBtYXRyaXguXG5cbiAgICAgICAgICAgIGlmICh0bXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbm91dmVhdSBuaXZlYXUgZGUgbWF0cmljZSA6IFRpbGVNYXRyaXhcbiAgICAgICAgICAgICAgICB2YXIgdGlsZU1hdHJpeCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19SZXNwb25zZV9tb2RlbF9UaWxlTWF0cml4X19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAgICAgICAgIC8vIGxlY3R1cmUgZGVzIGluZm9ybWF0aW9uIGR1IFRpbGVNYXRyaXhcbiAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMobm9kZSwgdGlsZU1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWwgZGUgbGEgcsOpc29sdXRpb24gYXNzb2Npw6llIGF1IGTDqW5vbWluYXRldXIgZCfDqWNoZWxsZSBkdSBuaXZlYXUgZGUgcHlyYW1pZGUsIHNlbG9uIGxhIHByb2plY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKHRtc0RhdGEuVE1TICYmIHRtc0RhdGEuVE1TLmdldFByb2plY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IHRtc0RhdGEuVE1TLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2ogPT09IFwiRVBTRzozODU3XCIgfHwgcHJvaiA9PT0gXCJFUFNHOjIxNTRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsIGRlIGxhIHLDqXNvbHV0aW9uIGFzc29jacOpZSwgZW4gbS9weFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW4gc2UgYmFzYW50IHN1ciB1bmUgXCJ0YWlsbGUgc3RhbmRhcmQgZGUgcGl4ZWxcIiBkZSAwLjI4bW0qMC4yOG1tIChzdGFuZGFyZCBXTVRTIDEuMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGlsZU1hdHJpeC5zY2FsZURlbm9taW5hdG9yICogMC4wMDAyODtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXNEYXRhLnJlc29sdXRpb25zICYmIEFycmF5LmlzQXJyYXkodG1zRGF0YS5yZXNvbHV0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXNEYXRhLnJlc29sdXRpb25zLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBham91dCBkdSBUaWxlTWF0cml4IGF1IFRpbGVNYXRyaXhTZXRcbiAgICAgICAgICAgICAgICBpZiAodG1zRGF0YS5UTVMgJiYgdG1zRGF0YS5UTVMudGlsZU1hdHJpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtc0RhdGEuVE1TLnRpbGVNYXRyaWNlc1t0aWxlTWF0cml4Lm1hdHJpeElkXSA9IHRpbGVNYXRyaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldC93bXRzOlRpbGVNYXRyaXgvd210czpTY2FsZURlbm9taW5hdG9yXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgU2NhbGVEZW5vbWluYXRvciA6IGZ1bmN0aW9uIChub2RlLCB0aWxlTWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICBpZiAoc2NhbGUgJiYgdGlsZU1hdHJpeCAmJiB0aWxlTWF0cml4Lmhhc093blByb3BlcnR5KFwic2NhbGVEZW5vbWluYXRvclwiKSkge1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXguc2NhbGVEZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldC93bXRzOlRpbGVNYXRyaXgvd210czpUb3BMZWZ0Q29ybmVyXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgVG9wTGVmdENvcm5lciA6IGZ1bmN0aW9uIChub2RlLCB0aWxlTWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMgJiYgdGlsZU1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgudG9wTGVmdENvcm5lciA9IHt9O1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgudG9wTGVmdENvcm5lci54ID0gcGFyc2VGbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgudG9wTGVmdENvcm5lci55ID0gcGFyc2VGbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldC93bXRzOlRpbGVNYXRyaXgvd210czpUaWxlV2lkdGhcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBUaWxlV2lkdGggOiBmdW5jdGlvbiAobm9kZSwgdGlsZU1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRpbGVNYXRyaXggJiYgdGlsZU1hdHJpeC5oYXNPd25Qcm9wZXJ0eShcInRpbGVXaWR0aFwiKSkge1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgudGlsZVdpZHRoID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBpbmZvIDogL0dlbmVyYWwvRXh0ZW5zaW9uL2dwcDpHZW5lcmFsL2dwcDpUaWxlTWF0cml4U2V0cy93bXRzOlRpbGVNYXRyaXhTZXQvd210czpUaWxlTWF0cml4L3dtdHM6VGlsZUhlaWdodFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFRpbGVIZWlnaHQgOiBmdW5jdGlvbiAobm9kZSwgdGlsZU1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRpbGVNYXRyaXggJiYgdGlsZU1hdHJpeC5oYXNPd25Qcm9wZXJ0eShcInRpbGVIZWlnaHRcIikpIHtcbiAgICAgICAgICAgICAgICB0aWxlTWF0cml4LnRpbGVIZWlnaHQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldC93bXRzOlRpbGVNYXRyaXgvd210czpNYXRyaXhXaWR0aFxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIE1hdHJpeFdpZHRoIDogZnVuY3Rpb24gKG5vZGUsIHRpbGVNYXRyaXgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0aWxlTWF0cml4ICYmIHRpbGVNYXRyaXguaGFzT3duUHJvcGVydHkoXCJtYXRyaXhXaWR0aFwiKSkge1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgubWF0cml4V2lkdGggPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGluZm8gOiAvR2VuZXJhbC9FeHRlbnNpb24vZ3BwOkdlbmVyYWwvZ3BwOlRpbGVNYXRyaXhTZXRzL3dtdHM6VGlsZU1hdHJpeFNldC93bXRzOlRpbGVNYXRyaXgvd210czpNYXRyaXhIZWlnaHRcbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBNYXRyaXhIZWlnaHQgOiBmdW5jdGlvbiAobm9kZSwgdGlsZU1hdHJpeCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHRpbGVNYXRyaXggJiYgdGlsZU1hdHJpeC5oYXNPd25Qcm9wZXJ0eShcIm1hdHJpeEhlaWdodFwiKSkge1xuICAgICAgICAgICAgICAgIHRpbGVNYXRyaXgubWF0cml4SGVpZ2h0ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgc2VydmljZUV4Y2VwdGlvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlTmFtZSA9PT0gXCJleGNlcHRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5leGNlcHRpb25SZXBvcnQgPSBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyLlJFQURFUlNbXCJleGNlcHRpb25cIl0oY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBleGNlcHRpb24gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZXhjZXB0aW9uUmVwb3J0ID0ge307XG5cbiAgICAgICAgLy8gZ2V0IGV4Y2VwdGlvbiBjb2RlXG4gICAgICAgIHZhciBleGNlcHRpb25Db2RlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb2RlXCIpO1xuICAgICAgICBpZiAoZXhjZXB0aW9uQ29kZSkge1xuICAgICAgICAgICAgZXhjZXB0aW9uUmVwb3J0LmV4Y2VwdGlvbkNvZGUgPSBleGNlcHRpb25Db2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGV4Y2VwdGlvbiBtZXNzYWdlXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvblJlcG9ydDtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogTcOpdGhvZGUgcGVybWV0dGFudCBkZSBsYW5jZXIgbGEgbGVjdHVyZSBkJ3VuZSByw6lwb25zZSBYTUwgZHUgc2VydmljZSBkJ2F1dG9jb25mLFxuICogICAgICDDoCBsJ2FpZGUgZGVzIFJFQURFUlMgZGUgbGEgY2xhc3NlLlxuICpcbiAqIEBtZXRob2QgQXV0b0NvbmZSZXNwb25zZVJlYWRlci5yZWFkXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3QgLSByYWNpbmUgZGUgbGEgcsOpcG9uc2UgWE1MIMOgIGxpcmVcbiAqIEByZXR1cm4ge09iamVjdH0gY29uZmlnfGV4Y2VwdGlvblJlcG9ydCA6IGwnb2JqZXQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZGUgbGEgcsOpcG9uc2UgWE1MLFxuICogICAgICBzb3VzIGxhIGZvcm1lIGQndW4gb2JqZXQgQXV0b0NvbmZSZXNwb25zZSwgb3UgdW4gb2JqZXQgbGl0dMOpcmFsIGV4Y2VwdGlvblJlcG9ydCBzaSBsZSBzZXJ2aWNlIGEgcmVudm95w6kgdW5lIGV4Y2VwdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyXG4gKi9cbkF1dG9Db25mUmVzcG9uc2VSZWFkZXIucmVhZCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgaWYgKHJvb3Qubm9kZU5hbWUgPT09IFwiVmlld0NvbnRleHRcIikge1xuICAgICAgICB2YXIgbnNQcmVmaXggPSByb290LnByZWZpeCB8fCBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyLkRFRkFVTFRQUkVGSVg7XG4gICAgICAgIHZhciBjb25maWcgPSBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyLlJFQURFUlNbbnNQcmVmaXhdW3Jvb3Qubm9kZU5hbWVdKHJvb3QpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH0gZWxzZSBpZiAocm9vdC5ub2RlTmFtZSA9PT0gXCJzZXJ2aWNlRXhjZXB0aW9uXCIpIHtcbiAgICAgICAgdmFyIGV4Y2VwdGlvblJlcG9ydCA9IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tyb290Lm5vZGVOYW1lXShyb290KTtcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvblJlcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJldXIgbG9ycyBkZSBsYSBsZWN0dXJlIGRlIGxhIHLDqXBvbnNlIDogZWxsZSBuJ2VzdCBwYXMgYXUgZm9ybWF0IGF0dGVuZHUuXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUsOpY3Vww6lyYXRpb24gZGVzIGF0dHJpYnV0cyBkJ3VuIG5vZXVkIMOpbMOpbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgQXV0b0NvbmZSZXNwb25zZVJlYWRlclxuICogQG1ldGhvZCBfX2dldEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIGNvbnRlbmFudCBsJ2F0dHJpYnV0IHJlY2hlcmNow6lcbiAqIEByZXR1cm4ge09iamVjdH0gbm9kZUF0dHJpYnV0ZXMgLSBvYmpldCBjb250ZW5hbnQgbGVzIG5vbXMgZXQgdmFsZXVycyBkZXMgZGlmZsOpcmVudHMgYXR0cmlidXRzXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0QXR0cmlidXRlcyAobm9kZSkge1xuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbm9kZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICBub2RlQXR0cmlidXRlc1thdHRyaWJ1dGUubm9kZU5hbWVdID0gYXR0cmlidXRlLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZUF0dHJpYnV0ZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFLDqWN1cMOpcmF0aW9uIGRlcyBub2V1ZHMgZW5mYW50cyAoc2V1bGVtZW50IGRlIHR5cGUgRUxFTUVOVCksIMOgIHBhcnRpciBkJ3VuIG5vZXVkIGRvbm7DqSwgcG91ciBsZWN0dXJlIChyZWFkTm9kZSkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyXG4gKiBAbWV0aG9kIF9fZ2V0Q2hpbGROb2Rlc1xuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gYSBET00gbm9kZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFtkYXRhXSAtIGFuIG9iamVjdCB0byBiZSBmaWxsZWQgd2l0aCBub2RlIGRhdGFcbiAqL1xuZnVuY3Rpb24gX19nZXRDaGlsZE5vZGVzIChub2RlLCBkYXRhKSB7XG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB2YXIgY2hpbGROYW1lO1xuICAgICAgICB2YXIgY2hpbGRQcmVmaXg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7IC8vIDEgPT09IG5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGNoaWxkUHJlZml4ID0gY2hpbGQucHJlZml4IHx8IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuREVGQVVMVFBSRUZJWDtcblxuICAgICAgICAgICAgICAgIGlmIChBdXRvQ29uZlJlc3BvbnNlUmVhZGVyLlJFQURFUlNbY2hpbGRQcmVmaXhdW2NoaWxkTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZFByZWZpeF1bY2hpbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyKGNoaWxkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMoY2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBMZWN0dXJlIGRlIGxhIHZhbGV1ciBkdSBwcmVtaWVyIGNoaWxkIGQndW4gbm9ldWQsIHNpIGVsbGUgZXhpc3RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgQXV0b0NvbmZSZXNwb25zZVJlYWRlclxuICogQG1ldGhvZCBfX2dldENoaWxkVmFsdWVcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIGEgRE9NIG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdmFsdWUgLSB2YWxldXIgZHUgZmlyc3RDaGlsZCBkdSBub2V1ZCBlbiBlbnRyw6llLCBvdSBjaGHDrm5lIHZpZGUuXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0Q2hpbGRWYWx1ZSAobm9kZSkge1xuICAgIHZhciB0ZXh0Tm9kZTtcbiAgICB2YXIgdmFsdWUgPSBcIlwiO1xuXG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUubm9kZVR5cGUgPT09IDMgfHwgdGV4dE5vZGUubm9kZVR5cGUgPT09IDQpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIHZhbHVlID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBWw6lyaWZpY2F0aW9uIGRlcyBhdHRyaWJ1dHMgZHUgc2VydmljZSwgZGFucyBsYSBiYWxpc2UgWExTIGRlIGxhIHLDqXBvbnNlIDpcbiAqICAgICAgdmVyc2lvbiwgbmFtZXNwYWNlcywgZXQgbmFtZXNwYWNlIHBhciBkw6lmYXV0IGRvaXZlbnQgY29ycmVzcG9uZHJlIMOgIGNldXggYXR0ZW5kdXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBBdXRvQ29uZlJlc3BvbnNlUmVhZGVyXG4gKiBAbWV0aG9kIF9fY2hlY2tTZXJ2aWNlQXR0cmlidXRlc1xuICogQHBhcmFtIHtET01FbGVtZW50fSB2aWV3Q29udGV4dE5vZGUgLSBhIERPTSBub2RlLCBjb3JyZXNwb25kaW5nIHRvIFhMUyBmaXJzdCB0YWcuXG4gKi9cbmZ1bmN0aW9uIF9fY2hlY2tTZXJ2aWNlQXR0cmlidXRlcyAodmlld0NvbnRleHROb2RlKSB7XG4gICAgaWYgKHZpZXdDb250ZXh0Tm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gb24gcsOpY3Vww6hyZSBldCBwYXJjb3VydCBsZXMgYXR0cmlidXRzIGRlIGxhIGJhbGlzZSBYTFMgZGUgbGEgcsOpcG9uc2VcbiAgICAgICAgdmFyIHhsc0F0dHJpYnV0ZXMgPSBfX2dldEF0dHJpYnV0ZXModmlld0NvbnRleHROb2RlKTtcbiAgICAgICAgZm9yICh2YXIgYXR0IGluIHhsc0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICh4bHNBdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dCkpIHtcbiAgICAgICAgICAgICAgICAvLyB2w6lyaWZpY2F0aW9uIGRlIGxhIHZlcnNpb25cbiAgICAgICAgICAgICAgICBpZiAoYXR0ID09PSBcInZlcnNpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGxzQXR0cmlidXRlc1tcInZlcnNpb25cIl0gIT09IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuVkVSU0lPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQXV0b0NvbmZSZXNwb25zZVJlYWRlcl0gYXV0b2NvbmYgdmVyc2lvbiBpcyBub3QgdGhlIGV4cGVjdGVkIG9uZSA6IHRoZXJlIG1heSBiZSBlcnJvcnMgaW4gcGFyc2luZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9uIHbDqXJpZmllIHF1ZSBsJ3VyaSBkdSBuYW1lc3BhY2UgcGFyIGTDqWZhdXQgZXN0IGJpZW4gY2VsbGUgcXVlIGwnb24gYXR0ZW5kXG4gICAgICAgICAgICAgICAgaWYgKGF0dCA9PT0gXCJ4bWxuc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4bHNBdHRyaWJ1dGVzW2F0dF0gIT09IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuTkFNRVNQQUNFUy54bWxucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQXV0b0NvbmZSZXNwb25zZVJlYWRlcl0gYXV0b2NvbmYgcmVzcG9uc2UgZGVmYXVsdCBuYW1lc3BhY2UgaXMgbm90IHRoZSBleHBlY3RlZCBvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGF0dC5zcGxpdChcIjpcIilbMF07XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gYXR0LnNwbGl0KFwiOlwiKVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHNpIG9uIGEgdW4gYXV0cmUgeG1sbnMsIG9uIHbDqXJpZmllIGF1c3NpIGxlcyBVUklcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIgJiYgbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2kgbCdhdHRyaWJ1dCBjb3JyZXNwb25kIMOgIHVuIG5hbWVzcGFjZSBkw6lmaW5pIGRhbnMgbGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBdXRvQ29uZlJlc3BvbnNlUmVhZGVyLk5BTUVTUEFDRVNbbnNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbCBmYXV0IHF1ZSBsZXMgVVJJIGNvcnJlc3BvbmRlbnQgYXVzc2kuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXV0b0NvbmZSZXNwb25zZVJlYWRlci5OQU1FU1BBQ0VTW25zXSAhPT0geGxzQXR0cmlidXRlc1thdHRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQXV0b0NvbmZSZXNwb25zZVJlYWRlcl0gYXV0b2NvbmYgcmVzcG9uc2UgXCIgKyBhdHQgKyBcIiBuYW1lc3BhY2UgaXMgbm90IHRoZSBleHBlY3RlZCBvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcG91ciBmaW5pciBvbiB2w6lyaWZpZSBsYSBsb2NhbGlzYXRpb24gZHUgc2NoZW1hIFhTRCBkdSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgaWYgKG5zID09PSBcInNjaGVtYUxvY2F0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhsc0F0dHJpYnV0ZXNbYXR0XSAhPT0gQXV0b0NvbmZSZXNwb25zZVJlYWRlci5TQ0hFTUFMT0NBVElPTlswXSAmJiB4bHNBdHRyaWJ1dGVzW2F0dF0gIT09IEF1dG9Db25mUmVzcG9uc2VSZWFkZXIuU0NIRU1BTE9DQVRJT05bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0F1dG9Db25mUmVzcG9uc2VSZWFkZXJdIGF1dG9jb25mIHJlc3BvbnNlIHNjaGVtYSBsb2NhdGlvbiBpcyBub3QgdGhlIGV4cGVjdGVkIG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBdXRvQ29uZlJlc3BvbnNlUmVhZGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0NvbW1vblNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19SZXF1ZXN0X0RpcmVjdEdlb2NvZGVSZXF1ZXN0RmFjdG9yeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXNwb25zZV9EaXJlY3RHZW9jb2RlUmVzcG9uc2VGYWN0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXG5cblxuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFwcGVsIGR1IHNlcnZpY2UgZGUgZ8Opb2NvZGFnZSBkaXJlY3QgZHUgR8Opb3BvcnRhaWwgOlxuICogICAgIGVudm9pIGRlIGxhIHJlcXXDqnRlIGNvbnN0cnVpdGUgc2Vsb24gbGVzIHBhcmFtw6h0cmVzIGVuIG9wdGlvbnMsXG4gKiAgICAgw6l2ZW50dWVsbGVtZW50IHBhcnNpbmcgZXQgYW5hbHlzZSAgZGUgbGEgcsOpcG9uc2UsXG4gKiAgICAgcmV0b3VyIGQndW5lIHLDqXBvbnNlIGVuIHBhcmFtw6h0cmUgZGUgbGEgZm9uY3Rpb24gb25TdWNjZXNzLlxuICpcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtHcC5TZXJ2aWNlcy5Db21tb25TZXJ2aWNlfVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgKCsgbGVzIG9wdGlvbnMgaGVyaXTDqWVzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9ucy5sb2NhdGlvbiAtIE5vbSBkZSBsJ2FkcmVzc2UsIGR1IHRvcG9ueW1lLCBkZSBsJ3VuaXTDqSBhZG1pbmlzdHJhdGl2ZSBvdSBkZSBsYSBwYXJjZWxsZSBjYWRhc3RyYWxlIHJlY2hlcmNow6llLlxuICogICAgICBTb3VzIGZvcm1lIGRlIFN0cmluZywgbGEgcHJvcHJpw6l0w6kgcGVybWV0IGRlIGZhaXJlIHVuZSByZWNoZXJjaGUgZMOpc3RydWN0dXLDqWUuXG4gKiAgICAgIFNvdXMgZm9ybWUgZCdvYmpldCwgbGEgcHJvcHJpw6l0w6kgcGVybWV0IGRlIHN0cnVjdHVyZXIgbGEgcmVjaGVyY2hlLlxuICogICAgICBEYW5zIGNlIGNhcywgbGVzIHByb3ByacOpdMOpcyBwb3NzaWJsZXMgZGUgY2V0IG9iamV0IHNvbnQgZMOpY3JpdGVzIGNpLWFwcsOocy5cbiAqICAgICAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvY2F0aW9uLm51bWJlcl0gLSBOdW3DqXJvIGR1IGLDonRpbWVudCBkZSBsJ2FkcmVzc2UgcmVjaGVyY2jDqWUsIGRhbnMgbGUgY2FzIGQndW5lIHJlY2hlcmNoZSBzdHJ1Y3R1csOpZVxuICogICAgICAoc2kgb3B0aW9ucy5sb2NhdGlvbiBlc3QgdW4gb2JqZXQgSmF2YXNjcmlwdCkuXG4gKiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sb2NhdGlvbi5zdHJlZXRdIC0gTm9tIGRlIGxhIHJ1ZSBkZSBsJ2FkcmVzc2UgcmVjaGVyY2jDqWUsIGRhbnMgbGUgY2FzIGQndW5lIHJlY2hlcmNoZSBzdHJ1Y3R1csOpZVxuICogICAgICAoc2kgb3B0aW9ucy5sb2NhdGlvbiBlc3QgdW4gb2JqZXQgSmF2YXNjcmlwdCkuXG4gKiAgICAgIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sb2NhdGlvbi5jaXR5XSAtIE5vbSBkZSBsYSB2aWxsZSBkZSBsJ2FkcmVzc2UgcmVjaGVyY2jDqWUsIGRhbnMgbGUgY2FzIGQndW5lIHJlY2hlcmNoZSBzdHJ1Y3R1csOpZVxuICogICAgICAoc2kgb3B0aW9ucy5sb2NhdGlvbiBlc3QgdW4gb2JqZXQgSmF2YXNjcmlwdCkuXG4gKiAgICAgIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sb2NhdGlvbi5wb3N0YWxDb2RlXSAtIE51bcOpcm8gZHUgY29kZSBwb3N0YWwgZGUgbCdhZHJlc3NlIHJlY2hlcmNow6llLCBkYW5zIGxlIGNhcyBkJ3VuZSByZWNoZXJjaGUgc3RydWN0dXLDqWVcbiAqICAgICAgKHNpIG9wdGlvbnMubG9jYXRpb24gZXN0IHVuIG9iamV0IEphdmFzY3JpcHQpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zXSAtIExlcyBwcm9wcmnDqXTDqXMgcG9zc2libGVzIGRlIGNldCBvYmpldCBzb250IGTDqWNyaXRlcyBjaS1hcHLDqHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy5iYm94XSAtIEVtcHJpc2UgZGFucyBsYXF1ZWxsZSBvbiBzb3VoYWl0ZSBlZmZlY3R1ZXIgbGEgcmVjaGVyY2hlLlxuICogICAgICBMZXMgcHJvcHJpw6l0w6lzIHBvc3NpYmxlcyBkZSBjZXQgb2JqZXQgc29udCBkw6ljcml0ZXMgY2ktYXByw6hzLlxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveC5sZWZ0IC0gQWJzY2lzc2UgZHUgY8O0dMOpIGdhdWNoZSBkZSBsYSBCQk9YXG4gKiAgICAgIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5iYm94LnJpZ2h0IC0gQWJzY2lzc2UgZHUgY8O0dMOpIGRyb2l0IGRlIGxhIEJCT1hcbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLmJib3gudG9wIC0gT3Jkb25uw6llIHN1cMOpcmlldXJlIGRlIGxhIEJCT1hcbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLmJib3guYm90dG9tIC0gT3Jkb25uw6llIGluZsOpcmlldXJlIGRlIGxhIEJCT1hcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUgPSBcIlN0cmVldEFkZHJlc3NcIl0gLSBUeXBlIGRlIGwnb2JqZXQgcmVjaGVyY2jDqS5cbiAqICAgICAgTGUgc2VydmljZSBkZSBnw6lvY29kYWdlIGR1IEfDqW9wb3J0YWlsIHBlcm1ldCBkZSByZWNoZXJjaGVyIGRlcyAnUG9zdGlvbk9mSW50ZXJlc3QnIHBvdXIgZGVzIHRvcG9ueW1lcywgZGVzICdTdHJlZXRBZGRyZXNzJ1xuICogICAgICBwb3VyIGRlcyBhZHJlc3NlcyBwb3N0YWxlcywgZXQvb3UgZGVzICdDYWRhc3RyYWxQYXJjZWwnIHBvdXIgZGVzIHBhcmNlbGxlcyBjYWRhc3RyYWxlcy5cbiAqICAgICAgRCdhdXRyZXMgdHlwZXMgcG91cnJvbnQgw6p0cmUgcmFqb3V0w6lzIHNlbG9uIGwnw6l2b2x1dGlvbiBkdSBzZXJ2aWNlLlxuICogICAgICBQYXIgZMOpZmF1dCwgdHlwZSA9IFsnU3RyZWV0QWRkcmVzcyddLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLltwcm9wcmlldGVzIGR1IGZpbHRyZV1dIC0gQ3JpdMOocmUgc3VwcGzDqW1lbnRhaXJlIHBvdXIgZmlsdHJlciBsYSByZWNoZXJjaGUgc291cyBsYSBmb3JtZVxuICogICAgICBkJ3VuIGNvdXBsZSBjbMOpL3ZhbGV1ciDDoCBkw6lmaW5pciBzZWxvbiBsZXMgcG9zc2liaWxpdMOpcyBkdSBzZXJ2ZXVyIGFqb3V0w6kgw6AgbGEgcmVxdcOqdGUuXG4gKiAgICAgIExlIHNlcnZpY2UgZGUgZ8Opb2NvZGFnZSBkdSBHw6lvcG9ydGFpbCBwZXJtZXQgZGUgZmlsdHJlciB0b3VzIGxlcyByw6lzdWx0YXRzIGF2ZWMgbGVzIHByb3ByacOpdMOpcyA6XG4gKiAgICAgICAgICBcIm11bmljaXBhbGl0eVwiLCBcImluc2VlXCIsIGV0IFwiZGVwYXJ0bWVudFwiLlxuICogICAgICBJbCBwZXJtZXQgYXVzc2kgZGUgZmlsdHJlciBsZXMgYWRyZXNzZXMgcG9zdGFsZXMgYXZlYyBsZXMgcHJvcHJpw6l0w6lzIDpcbiAqICAgICAgICAgIFwicXVhbGl0eVwiLCBcIklEXCIsIFwiSURfVFJcIiBldCBcInRlcnJpdG9yeVwiLlxuICogICAgICBJbCBwZXJtZXQgZGUgZmlsdHJlciBsZXMgdG9wb255bWVzIGF2ZWMgbGVzIHByb3ByacOpdMOpcyA6XG4gKiAgICAgICAgICBcImltcG9ydGFuY2VcIiwgXCJuYXR1cmVcIiBldCBcInRlcnJpdG9yeVwiLlxuICogICAgICBFbmZpbiwgaWwgcGVybWV0IGRlIGZpbHRyZXIgbGVzIHBhcmNlbGxlcyBjYWRhc3RyYWxlcyBhdmVjIGxlcyBwcm9wcmnDqXTDqXMgOlxuICogICAgICAgICAgXCJzaGVldFwiLCBcInNlY3Rpb25cIiwgZXQgXCJhYnNvcmJlZGNpdHlcIi4gUGFzIGRlIHZhbGV1ciBwYXIgZMOpZmF1dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bVJlc3BvbnNlc10gLSBOb21icmUgZGUgcsOpcG9uc2VzIG1heGltYWwgcXVlIGwnb24gc291aGFpdGUgcmVjZXZvaXIuXG4gKiAgICAgIFBhcyBkZSB2YWxldXIgcGFyIGTDqWZhdXQuXG4gKiAgICAgIFNpIGxlIHNlcnZldXIgY29uc3VsdMOpIGVzdCBjZWx1aSBkdSBHw6lvcG9ydGFpbCwgbGEgdmFsZXVyIHBhciBkw6lmYXV0IHNlcmEgZG9uYyBjZWxsZSBkdSBzZXJ2aWNlIDogMjUuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXR1cm5GcmVlRm9ybV0gLSBJbmRpcXVlIHNpIGwnb24gc291aGFpdGUgZW4gcsOpcG9uc2UgdW4gbG9jYWxpc2FudCBjb25jYXTDqW7DqWUgcGx1dMO0dCBxdWUgc3RydWN0dXLDqS5cbiAqICAgICAgUGFzIGRlIHZhbGV1ciBwYXIgZMOpZmF1dC4gU2kgbGUgc2VydmV1ciBjb25zdWx0w6kgZXN0IGNlbHVpIGR1IEfDqW9wb3J0YWlsLCBsYSB2YWxldXIgcGFyIGTDqWZhdXQgc2VyYSBkb25jIGNlbGxlIGR1IHNlcnZpY2UgOiAnZmFsc2UnLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zcnNdIC0gU3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGRhbnMgbGVxdWVsIGxlcyBwYXJhbcOodHJlcyBnw6lvZ3JhcGhpcXVlcyBlbiBlbnRyw6llIGV0IGxhIHLDqXBvbnNlIGR1IHNlcnZpY2Ugc29udCBleHByaW3DqXMuXG4gKiAgICAgIFBhcyBkZSB2YWxldXIgcGFyIGTDqWZhdXQuIFNpIGxlIHNlcnZldXIgY29uc3VsdMOpIGVzdCBjZWx1aSBkdSBHw6lvcG9ydGFpbCwgbGEgdmFsZXVyIHBhciBkw6lmYXV0IHNlcmEgZG9uYyBjZWxsZSBkdSBzZXJ2aWNlIDogJ0VQU0c6NDMyNicuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgdmFyIG9wdGlvbnMgPSB7XG4gKiAgICAgIGFwaUtleSA6IG51bGwsXG4gKiAgICAgIHNlcnZlclVybCA6ICdodHRwOi8vbG9jYWxob3N0L3NlcnZpY2UvJyxcbiAqICAgICAgcHJvdG9jb2wgOiAnSlNPTlAnLCAvLyBKU09OUHxYSFJcbiAqICAgICAgcHJveHlVUkwgOiBudWxsLFxuICogICAgICBodHRwTWV0aG9kIDogJ0dFVCcsIC8vIEdFVHxQT1NUXG4gKiAgICAgIHRpbWVPdXQgOiAxMDAwMCwgLy8gbXNcbiAqICAgICAgcmF3UmVzcG9uc2UgOiBmYWxzZSwgLy8gdHJ1ZXxmYWxzZVxuICogICAgICBzY29wZSA6IG51bGwsIC8vIHRoaXNcbiAqICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7fSxcbiAqICAgICAgb25GYWlsdXJlIDogZnVuY3Rpb24gKGVycm9yKSB7fSxcbiAqICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICogICAgICBwb3NpdGlvbnMgOiBbe2xvbjosIGxhdDp9LCB7bG9uOiwgbGF0On1dLFxuICogICAgICAoLi4uKVxuICogICB9O1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VvY29kZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHZW9jb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiQ0xBU1NfQ09OU1RSVUNUT1JcIiwgXCJHZW9jb2RlXCIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKiBGSVhNRSBpbnN0YW5jZSBvdSBjbGFzc2UgP1xuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJHZW9jb2RlXCI7XG5cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgcGFyIGhlcml0YWdlXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Db21tb25TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJHcC5TZXJ2aWNlcy5HZW9jb2RlXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBHZW9jb2RlIChvcHRpb25zKV1cIik7XG5cbiAgICBpZiAoIW9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcImxvY2F0aW9uXCIpKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSBFQ01BU2NyaXB0IDUgc3VwcG9ydFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhdGlvbiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmxvY2F0aW9uKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fRU1QVFlcIiwgXCJsb2NhdGlvblwiKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLmxvY2F0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcImxvY2F0aW9uXCIpKTtcbiAgICB9XG5cbiAgICAvLyBham91dCBkZXMgb3B0aW9ucyBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZVxuICAgIHRoaXMub3B0aW9ucy5sb2NhdGlvbiA9IG9wdGlvbnMubG9jYXRpb247XG5cbiAgICAvLyBvbiBkZWZpbml0IGRlcyBmaWx0cmVzIGFwciBkZWZhdXRcbiAgICBpZiAoIW9wdGlvbnMuZmlsdGVyT3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJPcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zID0gb3B0aW9ucy5maWx0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZSA6IFtcIlN0cmVldEFkZHJlc3NcIl1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRSBFQ01BU2NyaXB0IDUgc3VwcG9ydCAodmFsYWJsZSBwb3VyIHVuIG9iamV0IHVuaXF1ZW1lbnQgISlcbiAgICAvLyBjZWNpIHBlcm1ldCBkZSB0ZXN0ZXIgbGUgY2FzIG/DuSAnb3B0aW9ucy5maWx0ZXJPcHRpb25zJyA6IHt9XG4gICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMuZmlsdGVyT3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZSA6IFtcIlN0cmVldEFkZHJlc3NcIl1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyID0gT2JqZWN0LmtleXMob3B0aW9ucy5maWx0ZXJPcHRpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gZmlsdGVyW2ldO1xuICAgICAgICAvLyBvbiB0cmFuc2Zvcm1lIGNlcnRhaW5zIGZpbHRyZXMgcXVpIHBvdXJyYWllbnQgw6p0cmUgbnVtw6lyaXF1ZXMgZW4gc3RyaW5nXG4gICAgICAgIHZhciBmaWx0ZXJzQ291bGRCZU51bWJlckxpc3QgPSBbXCJkZXBhcnRtZW50XCIsIFwibnVtYmVyXCIsIFwicG9zdGFsQ29kZVwiLCBcImluc2VlXCIsIFwiaW1wb3J0YW5jZVwiLCBcIklEXCIsIFwiSURUUlwiLCBcImFic29yYmVkQ2l0eVwiLCBcInNoZWV0XCIsIFwic2VjdGlvblwiLCBcImluc2VlUmVnaW9uXCIsIFwiaW5zZWVEZXBhcnRtZW50XCJdO1xuICAgICAgICBpZiAoZmlsdGVyc0NvdWxkQmVOdW1iZXJMaXN0LmluZGV4T2Yoa2V5KSAhPT0gLTEgJiYgdHlwZW9mIG9wdGlvbnMuZmlsdGVyT3B0aW9uc1trZXldICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZpbHRlck9wdGlvbnNba2V5XSA9IG9wdGlvbnMuZmlsdGVyT3B0aW9uc1trZXldLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb24gc3VwcHJpbWUgbGVzIGZpbHRyZXMgdmlkZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLmZpbHRlck9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlID0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUgfHwgW1wiU3RyZWV0QWRkcmVzc1wiXTtcbiAgICB0aGlzLm9wdGlvbnMubWF4aW11bVJlc3BvbnNlcyA9IG9wdGlvbnMubWF4aW11bVJlc3BvbnNlcyB8fCAyNTtcbiAgICB0aGlzLm9wdGlvbnMucmV0dXJuRnJlZUZvcm0gPSBvcHRpb25zLnJldHVybkZyZWVGb3JtIHx8IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucy5zcnMgPSBvcHRpb25zLnNycyB8fCBcIkVQU0c6NDMyNlwiO1xuXG4gICAgLy8gYXR0cmlidXRzIGQnaW5zdGFuY2VzXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZm9yY8OpIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2UgOiBcInhtbFwiXG4gICAgICogc2F1ZiBzaSBsJ29uIHNvdWhhaXRlIHVuZSByZXBvbnNlIGJydXRlIChvcHRpb25zLnJhd1Jlc3BvbnNlKVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucy5vdXRwdXRGb3JtYXQgPSAodGhpcy5vcHRpb25zLnJhd1Jlc3BvbnNlKSA/IFwiXCIgOiBcInhtbFwiO1xufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6R2VvY29kZSNcbiAqL1xuR2VvY29kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSwge1xuICAgIC8vIHRvZG9cbiAgICAvLyBnZXR0ZXIvc2V0dGVyXG59KTtcblxuLypcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkdlb2NvZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvY29kZTtcblxuLyoqXG4gKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGUgKG92ZXJ3cml0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5HZW9jb2RlLnByb3RvdHlwZS5idWlsZFJlcXVlc3QgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cE1ldGhvZCA6IHRoaXMub3B0aW9ucy5odHRwTWV0aG9kLFxuICAgICAgICAvLyBvcHRpb25zIHNwZWNpZmlxdWVzIGR1IHNlcnZpY2VcbiAgICAgICAgbG9jYXRpb24gOiB0aGlzLm9wdGlvbnMubG9jYXRpb24sXG4gICAgICAgIHJldHVybkZyZWVGb3JtIDogdGhpcy5vcHRpb25zLnJldHVybkZyZWVGb3JtLFxuICAgICAgICBmaWx0ZXJPcHRpb25zIDogdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMsXG4gICAgICAgIHNycyA6IHRoaXMub3B0aW9ucy5zcnMsXG4gICAgICAgIG1heGltdW1SZXNwb25zZXMgOiB0aGlzLm9wdGlvbnMubWF4aW11bVJlc3BvbnNlc1xuICAgIH07XG5cbiAgICB0aGlzLnJlcXVlc3QgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1JlcXVlc3RfRGlyZWN0R2VvY29kZVJlcXVlc3RGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG5cbiAgICAvLyBvbiB0ZXN0ZSBzaSBsYSByZXF1ZXRlIGEgYmllbiDDqXTDqSBjb25zdHJ1aXRlICFcbiAgICAoIXRoaXMucmVxdWVzdClcbiAgICAgICAgPyBlcnJvci5jYWxsKHRoaXMsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFUVVFU1RfQlVJTERcIikpKVxuICAgICAgICA6IHN1Y2Nlc3MuY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QpO1xufTtcblxuLyoqXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2UgKG92ZXJ3cml0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5HZW9jb2RlLnByb3RvdHlwZS5hbmFseXplUmVzcG9uc2UgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICAvKiBJTkZPIDpcbiAgICAgICAgIEV0YXBlIDEgOiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAgICAgICAgICAgIC0+IEFwcGVsIGR1IGZvcm1hdCBPcGVuTFMgcG91ciBjcsOpZXIgdW5lIHJlcXXDqnRlIMOgIHBhcnRpciBkZXMgcGFyYW3DqHRyZXMgKHBhciBleGVtcGxlKVxuICAgICAgICAgICAgICAoc29pdCBkaXJlY3RlbWVudCB1bmUgVVJMIHNpIEdFVCwgc29pdCB1bmUgcmVxdcOqdGUgWE1MIHNpIFBPU1QpXG4gICAgICAgICAgICAvIVxcIHRlc3RlciBzaSBhcGlLZXkgJiYgc2VydmVyVXJsID0+IG9uIG5lIGdhcmRlIHF1ZSBzZXJ2ZXJVcmxcbiAgICAgICAgICAgIC0+IHN0b2NrYWdlIGRlIGxhIHJlcXXDqnRlIGRhbnMgdGhpcy5yZXF1ZXN0XG4gICAgICAgICBFdGFwZSAyIDogRW52b2kgZGUgbGEgcmVxdcOqdGUgc2Vsb24gbGUgYm9uIHByb3RvY29sZVxuICAgICAgICAgICAgLT4gYXBwZWwgZHUgcHJvdG9jb2wgSlNPTlAgb3UgWEhSLCBldCBlbnZvaSAocGFyIGV4IHNlbmQgKCkpICh0aGlzLnByb3RvY29sKVxuICAgICAgICAgICAgLT4gcsOpY3Vww6lyYXRpb24gZGUgbGEgcsOpcG9uc2UgeG1sIGRhbnMgbGEgZm9uY3Rpb24gb25TdWNjZXNzICgpICh0aGlzLnJlc3BvbnNlKVxuICAgICAgICAgICAgLT4gc2kgY29kZSBIVFRQIDIwMCBldCBwYXMgZGUgbWVzc2FnZSBkJ2VycmV1ciA6IGV0YXBlIDNcbiAgICAgICAgICAgIC0+IHNpIGNvZGUgSFRUUCAhPSAyMDAgOiBsYW5jZW1lbnQgZGUgbGEgZm9uY3Rpb24gZGUgY2FsbGJhY2sgb25GYWlsdXJlIGF2ZWMgbGUgbWVzc2FnZSBkJ2VycmV1clxuICAgICAgICAgRXRhcGUgMyA6IEFuYWx5c2UgZGUgbGEgcsOpcG9uc2UgeG1sIGV0IGNvbnN0cnVjdGlvbiBkdSBKU09OIChzaSByYXdSZXNwb25zZSA9PT0gZmFsc2UgKVxuICAgICAgICAgICAgLT4gYXBwZWwgZHUgcGFyc2VyIHBvdXIgcsOpY3Vww6lyZXIgbGUgeG1sRG9jdW1lbnRcbiAgICAgICAgICAgIC0+IGFwcGVsIGR1IHJlYWRlciBPcGVuTFMgcG91ciBsaXJlIGxlcyDDqWzDqW1lbnRzIGV0IHLDqWN1cMOpcmVyIGwnb2JqZXQgSlNPTlxuICAgICAgICAgICAgICAgY29ycmVzcG9uZGFudCBhdSB0eXBlIGRlIGfDqW9jb2RhZ2UgKGTDqWZpbmkgZGFucyBsZXMgc3BlY3MpXG4gICAgICAgICBFdGFwZSA0IDogTGFuY2VtZW50IGRlIGxhIGZvbmN0aW9uIGRlIGNhbGxiYWNrIG9uU3VjY2VzcyBhdmVjIGxhIHLDqXBvbnNlIDpcbiAgICAgICAgICAgIC0+IHhtbFJlc3BvbnNlIChzaSByYXdSZXNwb25zZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIC0+IG91IGdlb2NvZGVkTG9jYXRpb25zXG4gICAgKi9cblxuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVzcG9uc2UgOiB0aGlzLnJlc3BvbnNlLFxuICAgICAgICAgICAgcmF3UmVzcG9uc2UgOiB0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICBvbkVycm9yIDogZXJyb3IsXG4gICAgICAgICAgICBvblN1Y2Nlc3MgOiBzdWNjZXNzLFxuICAgICAgICAgICAgc2NvcGUgOiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXNwb25zZV9EaXJlY3RHZW9jb2RlUmVzcG9uc2VGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoR2VvY29kZSk7XG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Zvcm1hdHNfWExTX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0Zvcm1hdHNfWExTX0xvY2F0aW9uVXRpbGl0eVNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRm9ybWF0c19YTFNfTG9jYXRpb25VdGlsaXR5U2VydmljZV9HZW9jb2RlRmlsdGVyRXh0ZW5zaW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1JlcXVlc3RfbW9kZWxfU3RyZWV0QWRkcmVzc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXF1ZXN0X21vZGVsX1Bvc2l0aW9uT2ZJbnRlcmVzdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19SZXF1ZXN0X21vZGVsX0NhZGFzdHJhbFBhcmNlbF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19SZXF1ZXN0X21vZGVsX0FkbWluaXN0cmF0aWZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuLyoqXG4gKiBDcmVhdGlvbiBkJ3VuZSByZXF1w6p0ZSBPcGVuTFMgZW4gbW9kZSBQT1NUIG91IEdFVFxuICogKEZhY3RvcnkpXG4gKlxuICogQG1vZHVsZSBEaXJlY3RHZW9jb2RlUmVxdWVzdEZhY3RvcnlcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5HZW9jb2RlLlJlcXVlc3QuRGlyZWN0R2VvY29kZVJlcXVlc3RGYWN0b3J5XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuXG5cblxuXG5cblxuXG52YXIgRGlyZWN0R2VvY29kZVJlcXVlc3RGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgR2VvY29kZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgaHR0cE1ldGhvZDpcbiAgICAgKiAgICAgIC8vIG9wdGlvbnMgc3BlY2lmaXF1ZXMgZHUgc2VydmljZVxuICAgICAqICAgICAgbG9jYXRpb246XG4gICAgICogICAgICByZXR1cm5GcmVlRm9ybTpcbiAgICAgKiAgICAgIGZpbHRlck9wdGlvbnM6XG4gICAgICogICAgICBzcnM6XG4gICAgICogICAgICBtYXhpbXVtUmVzcG9uc2VzOlxuICAgICAqICAgfTtcbiAgICAgKiAgIHZhciByZXN1bHQgPSBEaXJlY3RHZW9jb2RlUmVxdWVzdEZhY3RvcnkuYnVpbGQob3B0aW9ucyk7XG4gICAgICogICBpZiAoIXJlc3VsdCkge1xuICAgICAqICAgICAgIC8vIGVycm9yLi4uXG4gICAgICogICB9XG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmVxdWVzdFxuICAgICAqL1xuICAgIGJ1aWxkIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkRpcmVjdEdlb2NvZGVSZXF1ZXN0RmFjdG9yeVwiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFtcIkRpcmVjdEdlb2NvZGVSZXF1ZXN0RmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGVzIGZpbHRyZXMgKHRhYmxlIGRlIGdlb2NvZGFnZSkgIVxuICAgICAgICAvLyBwYXIgZGVmYXV0LCBvbiBsZXMgYWpvdXRlIHRvdXRlIC4uLlxuICAgICAgICB2YXIgb0ZpbHRlciA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0Zvcm1hdHNfWExTX0xvY2F0aW9uVXRpbGl0eVNlcnZpY2VfR2VvY29kZUZpbHRlckV4dGVuc2lvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG4gICAgICAgIG9GaWx0ZXIuYWRkRmlsdGVyRXh0ZW5zaW9ucyhuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19SZXF1ZXN0X21vZGVsX0FkbWluaXN0cmF0aWZfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpKTtcbiAgICAgICAgb0ZpbHRlci5hZGRGaWx0ZXJFeHRlbnNpb25zKG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1JlcXVlc3RfbW9kZWxfU3RyZWV0QWRkcmVzc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCkpO1xuICAgICAgICBvRmlsdGVyLmFkZEZpbHRlckV4dGVuc2lvbnMobmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fUmVxdWVzdF9tb2RlbF9Qb3NpdGlvbk9mSW50ZXJlc3RfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpKTtcbiAgICAgICAgb0ZpbHRlci5hZGRGaWx0ZXJFeHRlbnNpb25zKG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1JlcXVlc3RfbW9kZWxfQ2FkYXN0cmFsUGFyY2VsX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKSk7XG5cbiAgICAgICAgLy8gb2JqZXQgTFVTXG4gICAgICAgIC8vIG9uIHBldXQgYXVzc2kgcGFyIHVuIG9iamV0IFhMUzo6R2VvY29kZVJlcXVlc3RcbiAgICAgICAgdmFyIG9MVVMgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Gb3JtYXRzX1hMU19Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgbG9jYXRpb24gOiBvcHRpb25zLmxvY2F0aW9uLFxuICAgICAgICAgICAgcmV0dXJuRnJlZUZvcm0gOiBvcHRpb25zLnJldHVybkZyZWVGb3JtLFxuICAgICAgICAgICAgZmlsdGVyT3B0aW9ucyA6IG9wdGlvbnMuZmlsdGVyT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgb0xVUy5hZGRGaWx0ZXIob0ZpbHRlcik7XG5cbiAgICAgICAgLy8gRm9ybWF0IFhMU1xuICAgICAgICB2YXIgb1hMUyA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Zvcm1hdHNfWExTX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgc3JzTmFtZSA6IG9wdGlvbnMuc3JzLFxuICAgICAgICAgICAgbWF4aW11bVJlc3BvbnNlcyA6IG9wdGlvbnMubWF4aW11bVJlc3BvbnNlc1xuICAgICAgICB9KTtcbiAgICAgICAgb1hMUy5uYW1lc3BhY2UgPSB0cnVlO1xuICAgICAgICBvWExTLnNldFNlcnZpY2Uob0xVUyk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCBicnV0ZSAhXG4gICAgICAgIHJlcXVlc3QgPSBvWExTLmJ1aWxkKCk7XG5cbiAgICAgICAgLy8gZW4gbW9kZSBHRVQsIGxhIHJlcXXDqnRlIGVzdCBlbmNvZMOpZVxuICAgICAgICAvLyBldCBsZSBwYXJhbS4gJ3F4bWwnIGVzdCBham91dMOpXG4gICAgICAgIGlmIChvcHRpb25zLmh0dHBNZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHZhciBteVJlcXVlc3QgPSBcInF4bWw9XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0KVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIiUyRFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIiU1RlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csIFwiJTJFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8hL2csIFwiJTIxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9+L2csIFwiJTdFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgXCIlMkFcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCIlMjdcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIiUyOFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpL2csIFwiJTI5XCIpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IG15UmVxdWVzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2dlci50cmFjZShyZXF1ZXN0KTtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKERpcmVjdEdlb2NvZGVSZXF1ZXN0RmFjdG9yeSk7XG5cblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBFbnTDqnRlIGRlIGxhIHJlcXXDqnRlIFhTTFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBoZWFkZXIgWFNMXG4gKiBoZWFkZXIgPSBuZXcgUmVxdWVzdEhlYWRlciAoKTtcbiAqIGhlYWRlci5zcnNOYW1lID0gXCJlcHNnOjQzMjZcIjtcbiAqIGhlYWRlci50b1N0cmluZygpO1xuICogLy8gb3V0IC0+XG4gKiAvLyA8UmVxdWVzdEhlYWRlciBzcnNOYW1lPVwiZXBzZzo0MzI2XCIvPlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLkZvcm1hdHMuWExTLlJlcXVlc3RIZWFkZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5zcnNOYW1lIC0gcHJvamVjdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbnN1Y2Nlc3MgLSBmdW5jdGlvbiBjYWxsYmFjayBzdWNjZXNzIChUT0RPKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmVycm9yICAgLSBmdW5jdGlvbiBjYWxsYmFjayBlcnJvciAgIChUT0RPKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFJlcXVlc3RIZWFkZXIgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJlcXVlc3RIZWFkZXIgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3RIZWFkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSZXF1ZXN0SGVhZGVyIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBwYXIgZGVmYXV0XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIHNyc05hbWUgOiBcIkVQU0c6NDMyNlwiXG4gICAgfTtcblxuICAgIC8vIGV0IG9uIGFqb3V0ZSBsZXMgb3B0aW9ucyBlbiBwYXJhbcOodHJlIGF1eCBvcHRpb25zIHBhciBkw6lmYXV0XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cblJlcXVlc3RIZWFkZXIucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpSZXF1ZXN0SGVhZGVyI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKiBzdWJzdGl0dXRpb24gZGVzIHZhbGV1cnMgc3VpdmFudGVzIDpcbiAgICAgKiBfX1NSU05BTUVfX1xuICAgICAqL1xuICAgIHRlbXBsYXRlIDogXCI8UmVxdWVzdEhlYWRlciBzcnNOYW1lPVxcXCJfX1NSU05BTUVfX1xcXCIvPlwiLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IFJlcXVlc3RIZWFkZXIsXG5cbiAgICAvKipcbiAgICAgKiB0b1N0cmluZ1xuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBudWxsO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19TUlNOQU1FX18vZywgdGhpcy5vcHRpb25zLnNyc05hbWUpO1xuICAgICAgICB0aGlzLnJlcXVlc3RTdHJpbmcgPSB0ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJlcXVlc3RIZWFkZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBSZXF1w6p0ZSBYTFNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gcmVxdWVzdCBYU0xcbiAqIHJlcXVlc3QgPSBuZXcgUmVxdWVzdCAoKTtcbiAqIHJlcXVlc3QubWF4aW11bVJlc3BvbnNlcyA9IDI2O1xuICogcmVxdWVzdC5tZXRob2ROYW1lID0gXCJHZW9jb2RlUmVxdWVzdFwiO1xuICogcmVxdWVzdC52ZXJzaW9uID0gXCIxLjJcIjtcbiAqIHJlcXVlc3QudG9TdHJpbmcoKTtcbiAqIC8vIG91dCAtPlxuICogLy8gPFJlcXVlc3QgbWF4aW11bVJlc3BvbnNlcz1cIjI2XCIgbWV0aG9kTmFtZT1cIkdlb2NvZGVSZXF1ZXN0XCIgcmVxdWVzdElEPVwidWlkMTM0OTA4MTQ5ODMxNF8zODhcIiB2ZXJzaW9uPVwiMS4yXCI+XG4gKiAvLyAgIDwhLS0gX19MVVNfXyAtLT5cbiAqIC8vICA8L1JlcXVlc3Q+XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLm1heGltdW1SZXNwb25zZXMgLSAyNVxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5tZXRob2ROYW1lIC0gbm9tIGRlIGwnb2JqZXQgTFVTLCBcIkdlb2NvZGVSZXF1ZXN0XCIgfCBcIlJldmVyc2VHZW9jb2RlUmVxdWVzdFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnZlcnNpb24gLSAnMS4yJ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbnN1Y2Nlc3MgLSBmdW5jdGlvbiBjYWxsYmFjayBzdWNjZXNzIChUT0RPKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbmVycm9yICAgLSBmdW5jdGlvbiBjYWxsYmFjayBlcnJvciAgIChUT0RPKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJlcXVlc3QgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSZXF1ZXN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBwYXIgZGVmYXV0XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7XG4gICAgICAgIG1heGltdW1SZXNwb25zZXMgOiAyNSxcbiAgICAgICAgbWV0aG9kTmFtZSA6IG51bGwsXG4gICAgICAgIHZlcnNpb24gOiBcIjEuMlwiXG4gICAgfTtcblxuICAgIC8vIGV0IG9uIGFqb3V0ZSBsZXMgb3B0aW9ucyBlbiBwYXJhbcOodHJlIGF1eCBvcHRpb25zIHBhciBkw6lmYXV0XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpSZXF1ZXN0I1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKiBzdWJzdGl0dXRpb24gZGVzIHZhbGV1cnMgc3VpdmFudGVzIDpcbiAgICAgKiBfX01BWFJFU1BPTlNFU19fLCBfX01FVEhPRE5BTUVfXywgX19VVUlEX18sIF9fVkVSU0lPTl9fXG4gICAgICogX19SRVFVRVNUU0VSVklDRV9fXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiBcIjxSZXF1ZXN0IG1heGltdW1SZXNwb25zZXM9XFxcIl9fTUFYUkVTUE9OU0VTX19cXFwiIG1ldGhvZE5hbWU9XFxcIl9fTUVUSE9ETkFNRV9fXFxcIiByZXF1ZXN0SUQ9XFxcIl9fVVVJRF9fXFxcIiB2ZXJzaW9uPVxcXCJfX1ZFUlNJT05fX1xcXCI+XCIgK1xuICAgICAgICBcIjwhLS0gX19SRVFVRVNUU0VSVklDRV9fIC0tPlwiICtcbiAgICAgICAgXCI8L1JlcXVlc3Q+XCIsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogUmVxdWVzdCxcblxuICAgIC8qKlxuICAgICAqIGFuIHJmYzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudCBndWlkXG4gICAgICovXG4gICAgZ3VpZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBjZi4gaHR0cDovL2J5cm9uc2FsYXUuY29tL2Jsb2cvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0L1xuICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgICAgICB2YXIgdiA9IGMgPT09IFwieFwiID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvU3RyaW5nXG4gICAgICovXG4gICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX01BWFJFU1BPTlNFU19fL2csIHRoaXMub3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzKTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX01FVEhPRE5BTUVfXy9nLCB0aGlzLm9wdGlvbnMubWV0aG9kTmFtZSk7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19VVUlEX18vZywgdGhpcy5ndWlkKCkpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fVkVSU0lPTl9fL2csIHRoaXMub3B0aW9ucy52ZXJzaW9uKTtcblxuICAgICAgICB0aGlzLnJlcXVlc3RTdHJpbmcgPSB0ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJlcXVlc3QpO1xuXG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tb2RlbF9BZGRyZXNzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0dlb2NvZGVGaWx0ZXJFeHRlbnNpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFJlcXXDqnRlIGRlIGdlb2NvZGFnZSBkaXJlY3RcbiAqXG4gKiBgYGBcbiAqIFhTRFxuICogR2VvY29kYWdlIGRpcmVjdCAoYmFsaXNlIHhzZCkgOlxuICogICBlbGVtZW50IHJlZj1cIlJlcXVlc3RIZWFkZXJcIiBbIChhdHRyaWJ1dGUgbmFtZT1cImNsaWVudE5hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cImNsaWVudFBhc3N3b3JkXCIgYXR0cmlidXRlIG5hbWU9XCJzZXNzaW9uSURcIiBhdHRyaWJ1dGUgbmFtZT1cInNyc05hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cIk1TSURcIikgXVxuICogICAgIGVsZW1lbnQgbmFtZT1cIlJlcXVlc3RcIiBhdHRyaWJ1dGUgbmFtZT1cIm1ldGhvZE5hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cInZlcnNpb25cIiBhdHRyaWJ1dGUgbmFtZT1cInJlcXVlc3RJRFwiIFsgYXR0cmlidXRlIG5hbWU9XCJtYXhpbXVtUmVzcG9uc2VzXCIgXVxuICogICAgICAgZWxlbWVudCBuYW1lPVwiR2VvY29kZVJlcXVlc3RcIiBhdHRyaWJ1dGUgbmFtZT1cInJldHVybkZyZWVGb3JtXCJcbiAqICAgICAgICAgZWxlbWVudCByZWY9XCJ4bHM6QWRkcmVzc1wiXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRpb24gZGUgbCdvYmpldCBHZW9jb2RlIGFuIGFqb3V0YW50IHVuIG9iamV0IEFkZHJlc3NcbiAqIHJlcSA9IG5ldyBHZW9jb2RlUmVxdWVzdCAoKTtcbiAqIHJlcS5yZXR1cm5GcmVlRm9ybSA9IHRydWU7IC8vIFRPRE8gIVxuICogcmVxLmFkZEFkZHJlc3MgKG5ldyBBZGRyZXNzICh7XG4gKiAgICAgIGxvY2F0aW9uIDogXCJzYWludCBtYW5kw6lcIixcbiAqICAgICAgdHlwZSA6IFsnUG9zaXRpb25PZkludGVyZXN0J10sXG4gKiAgICAgIGZpbHRlciA6IHtcbiAqICAgICAgICAgICguLi4pXG4gKiAgICAgIH1cbiAqIH0pKTtcbiAqIHJlcS50b1N0cmluZygpO1xuICogLy8gb3V0IC0+XG4gKiAvLyA8R2VvY29kZVJlcXVlc3Q+XG4gKiAvLyAgIDxBZGRyZXNzIGNvdW50cnlDb2RlPVwiUG9zaXRpb25PZkludGVyZXN0XCI+XG4gKiAvLyAgICAgPGZyZWVGb3JtQWRkcmVzcz5zYWludCBtYW5kw6k8L2ZyZWVGb3JtQWRkcmVzcz5cbiAqIC8vICAgPC9BZGRyZXNzPlxuICogLy8gPC9HZW9jb2RlUmVxdWVzdD5cbiAqXG4gKiAvLyBjcmVhdGlvbiBkZSBsJ29iamV0IEdlb2NvZGUgYXZlYyBsZXMgb3B0aW9ucyB1bmlxdWVtZW50XG4gKiByZXEgPSBuZXcgR2VvY29kZVJlcXVlc3QgKHtcbiAqICAgICAgbG9jYXRpb24gOiBcInNhaW50IG1hbmTDqVwiLFxuICogICAgICByZXR1cm5GcmVlRm9ybSA6IHRydWUsXG4gKiAgICAgIGZpbHRlck9wdGlvbnMgOiB7XG4gKiAgICAgICAgICB0eXBlIDogWydQb3NpdGlvbk9mSW50ZXJlc3QnXSxcbiAqICAgICAgICAgICguLi4pXG4gKiAgICAgIH1cbiAqIH0pO1xuICogcmVxLnRvU3RyaW5nKCk7XG4gKiAvLyBvdXQgLT5cbiAqIC8vIDxHZW9jb2RlUmVxdWVzdD5cbiAqIC8vICAgPEFkZHJlc3MgY291bnRyeUNvZGU9XCJQb3NpdGlvbk9mSW50ZXJlc3RcIj5cbiAqIC8vICAgICA8ZnJlZUZvcm1BZGRyZXNzPnNhaW50IG1hbmTDqTwvZnJlZUZvcm1BZGRyZXNzPlxuICogLy8gICA8L0FkZHJlc3M+XG4gKiAvLyA8L0dlb2NvZGVSZXF1ZXN0PlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQGFsaWFzIEdwLkZvcm1hdHMuWExTLkxvY2F0aW9uVXRpbGl0eVNlcnZpY2UuR2VvY29kZVJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5sb2NhdGlvbiAtIGxvY2F0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnJldHVybkZyZWVGb3JtIC0gcmV0dXJuRnJlZUZvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuZmlsdGVyT3B0aW9ucyAtIGZpbHRyZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25zdWNjZXNzIC0gZnVuY3Rpb24gY2FsbGJhY2sgc3VjY2VzcyAoVE9ETylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25lcnJvciAgIC0gZnVuY3Rpb24gY2FsbGJhY2sgZXJyb3IgICAoVE9ETylcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHZW9jb2RlUmVxdWVzdCAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgR2VvY29kZVJlcXVlc3QgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEdlb2NvZGVSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VvY29kZVJlcXVlc3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBvcHRpb25zIHBhciBkZWZhdXRcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gZXQgb24gYWpvdXRlIGxlcyBvcHRpb25zIGVuIHBhcmFtw6h0cmUgYXV4IG9wdGlvbnMgcGFyIGTDqWZhdXRcbiAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE9cbiAgICAvLyBnZXN0aW9uIGRlIGwnb3B0aW9uICdyZXR1cm5GcmVlRm9ybScgc2kgZWxsZSBuJ2VzdCBwYXMgcmVuc2VpZ27DqWUgZGFucyBsZXMgb3B0aW9ucyAhXG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiR2VvY29kZVJlcXVlc3RcIjtcbn1cblxuR2VvY29kZVJlcXVlc3QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpHZW9jb2RlUmVxdWVzdCNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIHJlcXVlc3QgKG91dClcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0clJlcXVlc3QgOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQWRkcmVzc2VcbiAgICAgKiBAdHlwZSB7QWRkcmVzc31cbiAgICAgKi9cbiAgICBvQWRkcmVzcyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJcbiAgICAgKiBAdHlwZSB7R2VvY29kZUZpbHRlckV4dGVuc2lvbn1cbiAgICAgKi9cbiAgICBvRmlsdGVyIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRlbXBsYXRlIGRlIGxhIHJlcXXDqnRlLlxuICAgICAqIHN1YnN0aXR1dGlvbiBkZXMgdmFsZXVycyBzdWl2YW50ZXMgOlxuICAgICAqIF9fQUREUkVTU19fLCBfX1JFVFVSTkZSRUVGT1JNX19cbiAgICAgKi9cbiAgICB0ZW1wbGF0ZSA6IFwiPEdlb2NvZGVSZXF1ZXN0IHJldHVybkZyZWVGb3JtPVxcXCJfX1JFVFVSTkZSRUVGT1JNX19cXFwiPlwiICtcbiAgICAgICAgXCJfX0FERFJFU1NfX1wiICtcbiAgICAgICAgXCI8L0dlb2NvZGVSZXF1ZXN0PlwiLFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZCd1biBvYmpldCBkZSB0eXBlIEFkcmVzc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQWRkcmVzcyAtIEFkcmVzc2VcbiAgICAgKi9cbiAgICBhZGRBZGRyZXNzIDogZnVuY3Rpb24gKG9BZGRyZXNzKSB7XG4gICAgICAgIGlmIChvQWRkcmVzcyBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbW9kZWxfQWRkcmVzc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSB7XG4gICAgICAgICAgICB0aGlzLm9BZGRyZXNzID0gb0FkZHJlc3M7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWpvdXQgZCd1biBvYmpldCBkZSB0eXBlIEdlb2NvZGVGaWx0ZXJFeHRlbnNpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvRmlsdGVyIC0gR2VvY29kZUZpbHRlckV4dGVuc2lvblxuICAgICAqL1xuICAgIGFkZEZpbHRlciA6IGZ1bmN0aW9uIChvRmlsdGVyKSB7XG4gICAgICAgIC8vIEZJWE1FIGdlc3Rpb24gZGVzIGZpbHRyZXMgw6AgcGFydGlyIGRlcyB0YWJsZXMgZGUgZ2VvY29kYWdlc1xuICAgICAgICBpZiAob0ZpbHRlciBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fR2VvY29kZUZpbHRlckV4dGVuc2lvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSB7XG4gICAgICAgICAgICB0aGlzLm9GaWx0ZXIgPSBvRmlsdGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBHZW9jb2RlUmVxdWVzdCxcblxuICAgIC8qKlxuICAgICAqIHRvU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG5cbiAgICAgICAgLy8gc29pdCBvbiBhIGTDqWrDoCB1biBvYmpldCBBZGRyZXNzIGluc3RhbmNpw6ksXG4gICAgICAgIC8vIHNpbm9uLCBvbiBsZSBmYWJyaXF1ZSB2aWEgbGVzIG9wdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLm9BZGRyZXNzKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgICAgIHNldHRpbmdzLmxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmxvY2F0aW9uO1xuICAgICAgICAgICAgc2V0dGluZ3MudHlwZSA9IHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUgfHwgW1wiU3RyZWV0QWRkcmVzc1wiXTtcbiAgICAgICAgICAgIHNldHRpbmdzLmZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zO1xuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmZpbHRlci50eXBlOyAvLyBvbiBuZSBtZXQgcGFzIGxlICd0eXBlJyBkYW5zIGxlcyBmaWx0cmVzLi4uXG5cbiAgICAgICAgICAgIC8vIGdlc3Rpb24gZGVzIGZpbHRyZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9GaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBvbiByZWNvbnN0cnVpdCBsZXMgZmlsdHJlc1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmZpbHRlciA9IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gb24gZGV0ZXJtaW5lIGxhIGxpc3RlIGRlcyBmaWx0cmVzIHBvc3NpYmxlc1xuICAgICAgICAgICAgICAgIC8vIHBvdXIgY2hhcXVlIHRhYmxlIGRlIGdlb2NvZGFnZSBlbiBwYXJhbVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCBpbiBzZXR0aW5ncy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBzZXR0aW5ncy50eXBlW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvRmlsdGVyID0gdGhpcy5vRmlsdGVyLmdldEZpbHRlcihmaWx0ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkxlIGZpbHRyZSAnXCIgKyBmaWx0ZXIgKyBcIicgbidleGlzdGUgcGFzICE/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbUZpbHRlciA9IHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmRhbmNlcyBkZXMgYXR0cmlidXRzIGRlIGZpbHRyZXMgcG9zc2libGVzIGF2ZWMgY2V1eCBxdWkgc29udCBlbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dHMgPSBvRmlsdGVyLmF0dHJpYnV0ZXNMaXN0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHhlID0gMDsgaWR4ZSA8IGF0dHJpYnV0cy5sZW5ndGg7IGlkeGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGF0dHJpYnV0c1tpZHhlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtRmlsdGVyW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmdLZXkgPSBvRmlsdGVyLnNlcnZpY2VBdHRyaWJ1dGVzW2lkeGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9GaWx0ZXIucGxhY2VBdHRyaWJ1dGVzW21hdGNoaW5nS2V5XSA9IG1GaWx0ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShcIlNlbGVjdGlvbiBkdSBmaWx0cmUgJ1wiICsga2V5ICsgXCInIHN1ciBsZSB0eXBlICdcIiArIGZpbHRlciArIFwiJy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBham91dCBkZXMgdmFsZXVycyBkZXMgZmlsdHJlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGxhY2VzID0gb0ZpbHRlci5wbGFjZUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtwbGFjZSBpbiBwbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZXMuaGFzT3duUHJvcGVydHkoa3BsYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZpbHRlcltrcGxhY2VdID0gcGxhY2VzW2twbGFjZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub0FkZHJlc3MgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tb2RlbF9BZGRyZXNzX19bXCJhXCIgLyogZGVmYXVsdCAqL10oc2V0dGluZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9BZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGEgY29uc3RydWN0aW9uIGRlIGwnYWRyZXNzZSBuJ2VzdCBwYXMgY29ycmVjdGVtZW50IGRlZmluaWUgIT9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBnZXN0aW9uIGRlcyBmaWx0cmVzIHBvdXIgdW4gb2JqZXQgQWRkcmVzcyBkw6lqw6AgaW5zdGFuY2nDqSA/XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0FERFJFU1NfXy9nLCB0aGlzLm9BZGRyZXNzLnRvU3RyaW5nKCkpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUkVUVVJORlJFRUZPUk1fXy9nLCAodGhpcy5vcHRpb25zLnJldHVybkZyZWVGb3JtKSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblxuICAgICAgICB0aGlzLnN0clJlcXVlc3QgPSB0ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyUmVxdWVzdDtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEdlb2NvZGVSZXF1ZXN0KTtcblxuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogTG9jYXRpb24gdHlwZSBcIkFkZHJlc3NcIi5cbiAqXG4gKiBNb2TDqGxlcyBkZSBjbGFzc2VzIDpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICogYGBgXG4gKlxuICogICAgICAgICAgICAgICAgQWRkcmVzc1xuICogICAgICAgICAgICAoZXN0IGNvbXBvc8OpIGRlKVxuICogICAgICAgICAgIF9fX19fXyB8IF9fX19fX19fXyBfX19fX19fX19fX19fX19fX1xuICogICAgICAgICAgLyAgICAgICB8ICAgICAgICAgIFxcICAgICAgICAgICAgICAgICBcXFxuICogICAgICBQbGFjZSAoU3RyZWV0QWRkcmVzcyBvdSBGcmVlRm9ybUFkZHJlc3MpIFBvc3RhbENvZGVcbiAqICAgICAgICgqKSAgICAgICBffF9cbiAqICAgICAgICAgICAgICAgIC8gICBcXFxuICogICAgICAgICAgIFN0cmVldCAgIEJ1aWxkaW5nXG4gKiBgYGBcbiAqIGBgYFxuICogWFNEXG4gKiBBZGRyZXNzIChiYWxpc2UgeHNkKSA6XG4gKiAgIGV4LiA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlN0cmVldEFkZHJlc3NcIj48ZnJlZUZvcm1BZGRyZXNzPjEgciBkZSBwYXJpcyBzYWludCBkZW5pczwvZnJlZUZvcm1BZGRyZXNzPjwvQWRkcmVzcz5cbiAqICAgYXR0cmlidXRlIG5hbWU9XCJjb3VudHJ5Q29kZVwiXG4gKiAgICAgZWxlbWVudCBuYW1lPVwiZnJlZUZvcm1BZGRyZXNzXCJcbiAqICAgICBlbGVtZW50IHJlZj1cInhsczpQbGFjZVwiXG4gKiAgICAgZWxlbWVudCByZWY9XCJnbWw6RW52ZWxvcGVcIlxuICogIG91XG4gKiAgIGV4LiA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlN0cmVldEFkZHJlc3NcIj48U3RyZWV0QWRkcmVzcz48U3RyZWV0PjEgcnVlIE1hcmNvbmk8L1N0cmVldD48L1N0cmVldEFkZHJlc3M+PFBsYWNlIHR5cGU9XCJNdW5pY2lwYWxpdHlcIj5NZXR6PC9QbGFjZT48UG9zdGFsQ29kZT41NzAwMDwvUG9zdGFsQ29kZT48L0FkZHJlc3M+XG4gKiAgIGF0dHJpYnV0ZSBuYW1lPVwiY291bnRyeUNvZGVcIlxuICogICAgIGVsZW1lbnQgcmVmPVwieGxzOlN0cmVldEFkZHJlc3NcIlxuICogICAgIGVsZW1lbnQgcmVmPVwieGxzOlBvc3RhbENvZGVcIlxuICogICAgIGVsZW1lbnQgcmVmPVwieGxzOlBsYWNlXCJcbiAqICAgICBlbGVtZW50IHJlZj1cImdtbDpFbnZlbG9wZVwiXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gc2ltcGxlXG4gKiBhZHIgPSBuZXcgQWRkcmVzcyAoe1xuICogICAgbG9jYXRpb24gOiBcIjIgYXYgcGFzdGV1ciwgU2FpbnQtTWFuZMOpZVwiLFxuICogICAgdHlwZSA6IFtcIlN0cmVldEFkZHJlc3NcIl0sXG4gKiAgICBmaWx0ZXIgOiB7fVxuICogfSk7XG4gKiBhZHIudG9TdHJpbmcoKTtcbiAqIC8vIC0+IG91dFxuICogLy8gPEFkZHJlc3MgY291bnRyeUNvZGU9XCJTdHJlZXRBZGRyZXNzXCI+XG4gKiAvLyAgIDxmcmVlRm9ybUFkZHJlc3M+MiBhdiBwYXN0ZXVyLCBTYWludC1NYW5kw6llPC9mcmVlRm9ybUFkZHJlc3M+XG4gKiAvLyA8L0FkZHJlc3M+XG4gKlxuICogLy8gYXZlYyBmaWx0cmVcbiAqIGFkciA9IG5ldyBBZGRyZXNzICh7XG4gKiAgICBsb2NhdGlvbiA6IHtcbiAqICAgICAgbnVtYmVyIDogMixcbiAqICAgICAgc3RyZWV0IDogXCJhdiBwYXN0ZXVyXCIsXG4gKiAgICAgIGNpdHkgOiBcIlNhaW50LU1hbmTDqWVcIiwgLy8gRklYTUUgZmlsdGVyIFBsYWNlIFwiY29tbXVuZVwiIG91IFwibXVuaWNpcGFsaXR5XCIgP1xuICogICAgICBwb3N0YWxDb2RlIDogXCI5NDE2NlwiICAgLy8gRklYTUUgZmlsdGVyIFBsYWNlIG91IGJhbGlzZSBQb3N0YWxDb2RlID9cbiAqICAgIH0sXG4gKiAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXSxcbiAqICAgIGZpbHRlciA6IHtcbiAqICAgICAgdGVycml0b3J5IDogXCJGUlwiLFxuICogICAgICBkZXBhcnRtZW50IDogXCI5NFwiXG4gKiAgICB9XG4gKiB9KTtcbiAqIGFkci50b1N0cmluZygpO1xuICogLy8gLT4gb3V0XG4gKiAvLyA8QWRkcmVzcyBjb3VudHJ5Q29kZT1cIlN0cmVldEFkZHJlc3NcIj5cbiAqIC8vICAgPFN0cmVldEFkZHJlc3M+XG4gKiAvLyAgIDxCdWlsZGluZyBudW1iZXI9XCIyXCIvPlxuICogLy8gICA8U3RyZWV0PjIgYXYgcGFzdGV1cjwvU3RyZWV0PlxuICogLy8gPC9TdHJlZXRBZGRyZXNzPlxuICogLy8gPFBsYWNlIHR5cGU9XCJtdW5pY2lwYWxpdHlcIj5TYWludC1NYW5kw6llPC9QbGFjZT5cbiAqIC8vIDxQbGFjZSB0eXBlPVwiZGVwYXJ0ZW1lbnRcIj45NDwvUGxhY2U+XG4gKiAvLyA8UGxhY2UgdHlwZT1cInRlcnJpdG9pcmVcIj5GUjwvUGxhY2U+XG4gKiAvLyA8UG9zdGFsQ29kZT45NDE2NjwvUG9zdGFsQ29kZT5cbiAqIC8vIDwvQWRkcmVzcz5cbiAqXG4gKiAvLyBhdmVjIGJib3hcbiAqIGFkciA9IG5ldyBBZGRyZXNzICh7XG4gKiAgICBsb2NhdGlvbiA6IFwiMiBhdiBwYXN0ZXVyLCBTYWludC1NYW5kw6llXCIsXG4gKiAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXSxcbiAqICAgIGZpbHRlciA6IHtcbiAqICAgICAgYmJveCA6IHtsZWZ0OjEsIHJpZ2h0OjIsIHRvcDoyLCBib3R0b206MH1cbiAqICAgIH1cbiAqIH0pO1xuICogYWRyLnRvU3RyaW5nKCk7XG4gKiAvLyAtPiBvdXRcbiAqIC8vIDxBZGRyZXNzIGNvdW50cnlDb2RlPVwiU3RyZWV0QWRkcmVzc1wiPlxuICogLy8gICA8ZnJlZUZvcm1BZGRyZXNzPjIgYXYgcGFzdGV1ciwgU2FpbnQtTWFuZMOpZTwvZnJlZUZvcm1BZGRyZXNzPlxuICogLy8gICA8Z21sOkVudmVsb3BlPlxuICogLy8gICAgIDxnbWw6bG93ZXJDb3JuZXI+MSAwPC9nbWw6bG93ZXJDb3JuZXI+XG4gKiAvLyAgICAgPGdtbDp1cHBlckNvcm5lcj4yIDI8L2dtbDp1cHBlckNvcm5lcj5cbiAqIC8vICAgPC9nbDpFbnZlbG9wZT5cbiAqIC8vIDwvQWRkcmVzcz5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5Gb3JtYXRzLlhMUy5Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlLkFkZHJlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMubG9jYXRpb24gLSBsb2NhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudHlwZSAtIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZpbHRlciAtIGZpbHRyZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZpbHRlci4qIC0gRmlsdHLDqSBlbiBmb25jdGlvbiBkZXMgdGFibGVzIGRlIGdlb2NvZGFnZSBpbnRlcnJvZ8OpZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBZGRyZXNzIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIkFkZHJlc3NcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEFkZHJlc3MgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBZGRyZXNzIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gcGFyYW0gcGFyIGRlZmF1dFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBsb2NhdGlvbiA6IHt9LFxuICAgICAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXSxcbiAgICAgICAgZmlsdGVyIDoge31cbiAgICB9O1xuXG4gICAgLy8gcGFyYW0gb2JsaWdhdG9pcmVcbiAgICBpZiAoIW9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibCdvcHRpb24gJ2xvY2F0aW9uJyBuJ2VzdCBwYXMgcmVuc2VpZ27DqWUgIVwiKTtcbiAgICB9XG5cbiAgICAvLyBldCBvbiBham91dGUgbGVzIG9wdGlvbnMgZW4gcGFyYW3DqHRyZSBhdXggb3B0aW9ucyBwYXIgZMOpZmF1dFxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6QWRkcmVzcyNcbiAqL1xuQWRkcmVzcy5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogQWRkcmVzcyxcblxuICAgIC8qKlxuICAgICAqIHJlcXVlc3QgKG91dClcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlcXVlc3RTdHJpbmcgOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBzdWJzdGl0dXRpb24gZGVzIHZhbGV1cnMgc3VpdmFudGVzIDpcbiAgICAgKiAtIGFkZHJlc3MgOiAgX19DT1VOVFJZQ09ERV9fLCBfX0xPQ0FUSU9OX18sIF9fUExBQ0VfXywgX19QT1NUQUxDT0RFX18sIF9fRU5WRUxPUEVfX1xuICAgICAqIC0gZnJlZUZvcm1BZGRyZXNzIDogX19GUkVFRk9STUFERFJFU1NWQUxVRV9fXG4gICAgICogLSBzdHJlZXRBZGRyZXNzIDogX19TVFJFRVRfXywgX19CVUlMRElOR19fXG4gICAgICogLSBzdHJlZXQgOiBfX1NUUkVFVFZBTFVFX19cbiAgICAgKiAtIGJ1aWxkaW5nIDogX19CVUlMRElOR1ZBTFVFX19cbiAgICAgKiAtIHBsYWNlIDogX19QTEFDRUFUWVBFX18sIF9fUExBQ0VWQUxVRV9fXG4gICAgICogLSBwb3N0YWxDb2RlIDogX19QT1NUQUxDT0RFVkFMVUVfX1xuICAgICAqIC0gZ21sOmVudmVsb3BlIDogX19MRUZUX18gX19CT1RUT01fXyBfX1JJR0hUX18gX19UT1BfX1xuICAgICAqXG4gICAgICogQHRvZG8gZ2VzdGlvbiBkZSBsXCJpbmRlbnRhdGlvblxuICAgICAqL1xuICAgIHRlbXBsYXRlIDoge1xuICAgICAgICBhZGRyZXNzIDogXCI8QWRkcmVzcyBjb3VudHJ5Q29kZT1cXFwiX19DT1VOVFJZQ09ERV9fXFxcIj5cIiArXG4gICAgICAgICAgICBcIl9fTE9DQVRJT05fX1wiICtcbiAgICAgICAgICAgIFwiX19QTEFDRV9fXCIgK1xuICAgICAgICAgICAgXCJfX1BPU1RBTENPREVfX1wiICtcbiAgICAgICAgICAgIFwiX19FTlZFTE9QRV9fXCIgK1xuICAgICAgICAgICAgXCI8L0FkZHJlc3M+XCIsXG4gICAgICAgIGxvY2F0aW9uIDoge1xuICAgICAgICAgICAgZnJlZUZvcm1BZGRyZXNzIDogXCI8ZnJlZUZvcm1BZGRyZXNzPl9fRlJFRUZPUk1BRERSRVNTVkFMVUVfXzwvZnJlZUZvcm1BZGRyZXNzPlwiLFxuICAgICAgICAgICAgc3RyZWV0QWRkcmVzcyA6IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgOiBcIjxTdHJlZXRBZGRyZXNzPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJfX1NUUkVFVF9fXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIl9fQlVJTERJTkdfX1wiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L1N0cmVldEFkZHJlc3M+XCIsXG4gICAgICAgICAgICAgICAgYnVpbGRpbmcgOiBcIjxCdWlsZGluZyBudW1iZXI9XFxcIl9fQlVJTERJTkdWQUxVRV9fXFxcIi8+XCIsXG4gICAgICAgICAgICAgICAgc3RyZWV0IDogXCI8U3RyZWV0Pl9fU1RSRUVUVkFMVUVfXzwvU3RyZWV0PlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlIDogXCI8UGxhY2UgdHlwZT1cXFwiX19QTEFDRVRZUEVfX1xcXCI+X19QTEFDRVZBTFVFX188L1BsYWNlPlwiLFxuICAgICAgICBwb3N0YWxDb2RlIDogXCI8UG9zdGFsQ29kZT5fX1BPU1RBTENPREVWQUxVRV9fPC9Qb3N0YWxDb2RlPlwiLFxuICAgICAgICBlbnZlbG9wZSA6IFwiPGdtbDpFbnZlbG9wZT5cIiArXG4gICAgICAgICAgICBcIjxnbWw6bG93ZXJDb3JuZXI+X19MRUZUX18gX19CT1RUT01fXzwvZ21sOmxvd2VyQ29ybmVyPlwiICtcbiAgICAgICAgICAgIFwiPGdtbDp1cHBlckNvcm5lcj5fX1JJR0hUX18gX19UT1BfXzwvZ21sOnVwcGVyQ29ybmVyPlwiICtcbiAgICAgICAgICAgIFwiPC9nbWw6RW52ZWxvcGU+XCJcbiAgICB9XG5cbn07XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5BZGRyZXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBudWxsO1xuICAgIHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZS5hZGRyZXNzO1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19DT1VOVFJZQ09ERV9fL2csIHRoaXMub3B0aW9ucy50eXBlKTtcblxuICAgIC8vIG9uIGEgdW5lIGFkcmVzc2Ugc3RydWN0dXLDqWUgb3UgbGlicmUgP1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmxvY2F0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIGJhbGlzZSBmcmVlRm9ybWVBZGRyZXNzXG4gICAgICAgIHZhciB0bXBsRnJlZUZvcm1BZGRyZXNzID0gdGhpcy50ZW1wbGF0ZS5sb2NhdGlvbi5mcmVlRm9ybUFkZHJlc3M7XG4gICAgICAgIHRtcGxGcmVlRm9ybUFkZHJlc3MgPSB0bXBsRnJlZUZvcm1BZGRyZXNzLnJlcGxhY2UoL19fRlJFRUZPUk1BRERSRVNTVkFMVUVfXy9nLCB0aGlzLm9wdGlvbnMubG9jYXRpb24pO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fTE9DQVRJT05fXy9nLCB0bXBsRnJlZUZvcm1BZGRyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBiYWxpc2VzIFN0cmVldCBldCBCdWlsZGluZ1xuICAgICAgICB2YXIgdG1wbEJ1aWxkaW5nID0gXCJcIjtcbiAgICAgICAgdmFyIHRtcGxTdHJlZXQgPSBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb24ubnVtYmVyKSB7XG4gICAgICAgICAgICB0bXBsQnVpbGRpbmcgPSB0aGlzLnRlbXBsYXRlLmxvY2F0aW9uLnN0cmVldEFkZHJlc3MuYnVpbGRpbmc7XG4gICAgICAgICAgICB0bXBsQnVpbGRpbmcgPSB0bXBsQnVpbGRpbmcucmVwbGFjZSgvX19CVUlMRElOR1ZBTFVFX18vZywgdGhpcy5vcHRpb25zLmxvY2F0aW9uLm51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9uLnN0cmVldCkge1xuICAgICAgICAgICAgdG1wbFN0cmVldCA9IHRoaXMudGVtcGxhdGUubG9jYXRpb24uc3RyZWV0QWRkcmVzcy5zdHJlZXQ7XG4gICAgICAgICAgICB0bXBsU3RyZWV0ID0gdG1wbFN0cmVldC5yZXBsYWNlKC9fX1NUUkVFVFZBTFVFX18vZywgdGhpcy5vcHRpb25zLmxvY2F0aW9uLnN0cmVldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWxpc2Ugc3RyZWV0QWRkcmVzc1xuICAgICAgICB2YXIgdG1wbFN0cmVldEFkZHJlc3MgPSB0aGlzLnRlbXBsYXRlLmxvY2F0aW9uLnN0cmVldEFkZHJlc3MuY29udGFpbmVyO1xuICAgICAgICB0bXBsU3RyZWV0QWRkcmVzcyA9IHRtcGxTdHJlZXRBZGRyZXNzLnJlcGxhY2UoL19fU1RSRUVUX18vZywgdG1wbFN0cmVldCk7XG4gICAgICAgIHRtcGxTdHJlZXRBZGRyZXNzID0gdG1wbFN0cmVldEFkZHJlc3MucmVwbGFjZSgvX19CVUlMRElOR19fL2csIHRtcGxCdWlsZGluZyk7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19MT0NBVElPTl9fL2csIHRtcGxTdHJlZXRBZGRyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBhIHQgb24gdW4gZmlsdHJlIGRlIHR5cGUgUG9zdGFsQ29kZSA/XG4gICAgdmFyIHRtcGxQb3N0YWxDb2RlID0gXCJcIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9uLnBvc3RhbENvZGUpIHtcbiAgICAgICAgdG1wbFBvc3RhbENvZGUgPSB0aGlzLnRlbXBsYXRlLnBvc3RhbENvZGU7XG4gICAgICAgIHRtcGxQb3N0YWxDb2RlID0gdG1wbFBvc3RhbENvZGUucmVwbGFjZSgvX19QT1NUQUxDT0RFVkFMVUVfXy9nLCB0aGlzLm9wdGlvbnMubG9jYXRpb24ucG9zdGFsQ29kZSk7XG4gICAgfVxuXG4gICAgLy8gYSB0IG9uIHVuIGZpbHRyZSBkZSB0eXBlIEdNTDo6RW52ZWxvcGUgP1xuICAgIHZhciB0bXBsRW52ZWxvcGUgPSBcIlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5vcHRpb25zLmZpbHRlci5iYm94O1xuICAgICAgICBpZiAoYmJveCkge1xuICAgICAgICAgICAgdG1wbEVudmVsb3BlID0gdGhpcy50ZW1wbGF0ZS5lbnZlbG9wZTtcbiAgICAgICAgICAgIHRtcGxFbnZlbG9wZSA9IHRtcGxFbnZlbG9wZS5yZXBsYWNlKC9fX0xFRlRfXy9nLCBiYm94LmxlZnQpO1xuICAgICAgICAgICAgdG1wbEVudmVsb3BlID0gdG1wbEVudmVsb3BlLnJlcGxhY2UoL19fQk9UVE9NX18vZywgYmJveC5ib3R0b20pO1xuICAgICAgICAgICAgdG1wbEVudmVsb3BlID0gdG1wbEVudmVsb3BlLnJlcGxhY2UoL19fUklHSFRfXy9nLCBiYm94LnJpZ2h0KTtcbiAgICAgICAgICAgIHRtcGxFbnZlbG9wZSA9IHRtcGxFbnZlbG9wZS5yZXBsYWNlKC9fX1RPUF9fL2csIGJib3gudG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpc3RlIGRlcyBmaWx0cmVzIFBsYWNlXG4gICAgdmFyIFBsYWNlcyA9IFtdO1xuXG4gICAgLy8gYSB0IG9uIGRlcyBmaWx0cmVzIGRlIHR5cGUgUGxhY2UgP1xuICAgIHZhciB0bXBsUGxhY2UgPSBcIlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5vcHRpb25zLmZpbHRlcjtcbiAgICAgICAgZm9yICh2YXIgZmlsdGVyIGluIGZpbHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgPT09IFwiYmJveFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSBnZXN0aW9uIGRlcyBmaWx0cmVzIHNww6ljaWZpcXVlcyBJR04gP1xuICAgICAgICAgICAgdG1wbFBsYWNlID0gdGhpcy50ZW1wbGF0ZS5wbGFjZTtcbiAgICAgICAgICAgIHRtcGxQbGFjZSA9IHRtcGxQbGFjZS5yZXBsYWNlKC9fX1BMQUNFVFlQRV9fL2csIGZpbHRlcik7XG4gICAgICAgICAgICB0bXBsUGxhY2UgPSB0bXBsUGxhY2UucmVwbGFjZSgvX19QTEFDRVZBTFVFX18vZywgZmlsdGVyc1tmaWx0ZXJdKTtcbiAgICAgICAgICAgIFBsYWNlcy5wdXNoKHRtcGxQbGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhIHQgb24gdW4gZmlsdHJlIGRlIHR5cGUgUGxhY2UgZGFucyBsb2NhdGlvbiA/XG4gICAgdmFyIHRtcGxQbGFjZUNpdHkgPSBcIlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb24uY2l0eSkge1xuICAgICAgICB0bXBsUGxhY2VDaXR5ID0gdGhpcy50ZW1wbGF0ZS5wbGFjZTtcbiAgICAgICAgdG1wbFBsYWNlQ2l0eSA9IHRtcGxQbGFjZUNpdHkucmVwbGFjZSgvX19QTEFDRVRZUEVfXy9nLCBcIk11bmljaXBhbGl0eVwiKTtcbiAgICAgICAgdG1wbFBsYWNlQ2l0eSA9IHRtcGxQbGFjZUNpdHkucmVwbGFjZSgvX19QTEFDRVZBTFVFX18vZywgdGhpcy5vcHRpb25zLmxvY2F0aW9uLmNpdHkpO1xuICAgICAgICBQbGFjZXMucHVzaCh0bXBsUGxhY2VDaXR5KTtcbiAgICB9XG5cbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUE9TVEFMQ09ERV9fL2csIHRtcGxQb3N0YWxDb2RlKTtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUExBQ0VfXy9nLCBQbGFjZXMuam9pbihcIlxcblwiKSk7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0VOVkVMT1BFX18vZywgdG1wbEVudmVsb3BlKTtcblxuICAgIHRoaXMucmVxdWVzdFN0cmluZyA9IHRlbXBsYXRlO1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RTdHJpbmc7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFkZHJlc3MpO1xuXG5cbi8qKiovIH0pLFxuLyogNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tb2RlbF9Qb3NpdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19tb2RlbF9QcmVmZXJlbmNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqXG4gKiBSZXF1w6p0ZSBkZSBnZW9jb2RhZ2UgaW52ZXJzZVxuICpcbiAqIFhTRFxuICogYGBgXG4gKiBHZW9jb2RhZ2UgaW52ZXJzZSAoYmFsaXNlIHhzZCkgOlxuICogICBlbGVtZW50IHJlZj1cIlJlcXVlc3RIZWFkZXJcIiBbIChhdHRyaWJ1dGUgbmFtZT1cImNsaWVudE5hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cImNsaWVudFBhc3N3b3JkXCIgYXR0cmlidXRlIG5hbWU9XCJzZXNzaW9uSURcIiBhdHRyaWJ1dGUgbmFtZT1cInNyc05hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cIk1TSURcIikgXVxuICogICAgIGVsZW1lbnQgbmFtZT1cIlJlcXVlc3RcIiBhdHRyaWJ1dGUgbmFtZT1cIm1ldGhvZE5hbWVcIiBhdHRyaWJ1dGUgbmFtZT1cInZlcnNpb25cIiBhdHRyaWJ1dGUgbmFtZT1cInJlcXVlc3RJRFwiIFsgYXR0cmlidXRlIG5hbWU9XCJtYXhpbXVtUmVzcG9uc2VzXCIgXVxuICogICAgICAgZWxlbWVudCBuYW1lPVwiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XCJcbiAqICAgICAgICAgZWxlbWVudCByZWY9XCJ4bHM6UG9zaXRpb25cIlxuICogICAgICAgICBlbGVtZW50IG5hbWU9XCJSZXZlcnNlR2VvY29kZVByZWZlcmVuY2VcIiAoZW51bWVyYXRpb24pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRpb24gZGUgbFwib2JqZXQgUmV2ZXJzZUdlb2NvZGVcbiAqIHJlcSA9IG5ldyBSZXZlcnNlR2VvY29kZVJlcXVlc3QgKCk7XG4gKiByZXEuYWRkUG9zaXRpb24gKG5ldyBQb3NpdGlvbiAocG9zaXRpb246e3g6ICwgeTogfSkpO1xuICogcmVxLmFkZFByZWZlcmVuY2UgKFtcIlN0cmVldEFkZHJlc3NcIl0pO1xuICogcmVxLnRvU3RyaW5nKCk7XG4gKiAvLyBvdXQgLT5cbiAqIC8vIDxSZXZlcnNlR2VvY29kZVJlcXVlc3Q+XG4gKiAvLyAgICAgPFBvc2l0aW9uPlxuICogLy8gICAgICAgPGdtbDpQb2ludCB4bWxuczpnbWw9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiPlxuICogLy8gICAgICAgICAgIDxnbWw6cG9zPjUwLjM0Nzc3NSAzLjIwNTA5ODwvZ21sOnBvcz5cbiAqIC8vICAgICAgIDwvZ21sOlBvaW50PlxuICogLy8gICAgIDwvUG9zaXRpb24+XG4gKiAvLyAgICAgPFJldmVyc2VHZW9jb2RlUHJlZmVyZW5jZT5TdHJlZXRBZGRyZXNzPC9SZXZlcnNlR2VvY29kZVByZWZlcmVuY2U+XG4gKiAvLyAgPC9SZXZlcnNlR2VvY29kZVJlcXVlc3Q+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5Gb3JtYXRzLlhMUy5SZXZlcnNlR2VvY29kZVJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5wb3NpdGlvbiAtIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnJldHVybkZyZWVGb3JtIC0gcmV0dXJuRnJlZUZvcm1cbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuZmlsdGVyT3B0aW9ucyAtIGZpbHRyZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25zdWNjZXNzIC0gZnVuY3Rpb24gY2FsbGJhY2sgc3VjY2VzcyAoVE9ETylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25lcnJvciAgIC0gZnVuY3Rpb24gY2FsbGJhY2sgZXJyb3IgICAoVE9ETylcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBSZXZlcnNlR2VvY29kZVJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJldmVyc2VHZW9jb2RlUmVxdWVzdCAoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBwYXIgZGVmYXV0XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIGV0IG9uIGFqb3V0ZSBsZXMgb3B0aW9ucyBlbiBwYXJhbcOodHJlIGF1eCBvcHRpb25zIHBhciBkw6lmYXV0XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0XCI7XG59XG5cblJldmVyc2VHZW9jb2RlUmVxdWVzdC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAbGVuZHMgbW9kdWxlOlJldmVyc2VHZW9jb2RlUmVxdWVzdCNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIHJlcXVlc3QgKG91dClcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHN0clJlcXVlc3QgOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25cbiAgICAgKiBAdHlwZSB7UG9zaXRpb259XG4gICAgICovXG4gICAgb1Bvc2l0aW9uIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFByZWZlcmVuY2VcbiAgICAgKiBAdHlwZSB7UHJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBvUHJlZmVyZW5jZSA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0LFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICogc3Vic3RpdHV0aW9uIGRlcyB2YWxldXJzIHN1aXZhbnRlcyA6XG4gICAgICogX19QT1NJVElPTl9fLCBfX1BSRUZFUkVOQ0VfXywgX19SRVRVUk5GUkVFRk9STV9fXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiBcIjxSZXZlcnNlR2VvY29kZVJlcXVlc3QgcmV0dXJuRnJlZUZvcm09XFxcIl9fUkVUVVJORlJFRUZPUk1fX1xcXCI+XCIgK1xuICAgICAgICBcIl9fUE9TSVRJT05fX1wiICtcbiAgICAgICAgXCJfX1BSRUZFUkVOQ0VfX1wiICtcbiAgICAgICAgXCI8L1JldmVyc2VHZW9jb2RlUmVxdWVzdD5cIixcblxuICAgIC8qKlxuICAgICAqIEFqb3V0IGRcInVuIG9iamV0IGRlIHR5cGUgUG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvUG9zaXRpb24gLSBQb3NpdGlvblxuICAgICAqL1xuICAgIGFkZFBvc2l0aW9uIDogZnVuY3Rpb24gKG9Qb3NpdGlvbikge1xuICAgICAgICBpZiAob1Bvc2l0aW9uIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tb2RlbF9Qb3NpdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSB7XG4gICAgICAgICAgICB0aGlzLm9Qb3NpdGlvbiA9IG9Qb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBam91dCBkXCJ1bmUgbGlzdGUgZGUgdGFibGUgZGUgcsOpZsOpcmVuY2UgTFVTIDpcbiAgICAgKiBbU3RyZWV0QWRkcmVzcywgUG9pbnRPZkludGVyZXN0LCBDYWRhc3RyYWxQYXJjZWwsIEFkbWluaXN0cmF0aXZdXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1ByZWZlcmVuY2UgLSBQcmVmZXJlbmNlXG4gICAgICovXG4gICAgYWRkUHJlZmVyZW5jZXMgOiBmdW5jdGlvbiAob1ByZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKG9QcmVmZXJlbmNlIGluc3RhbmNlb2YgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19tb2RlbF9QcmVmZXJlbmNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pIHtcbiAgICAgICAgICAgIHRoaXMub1ByZWZlcmVuY2UgPSBvUHJlZmVyZW5jZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0b1N0cmluZ1xuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGU7XG5cbiAgICAgICAgLy8gc2kgb24gYSBkw6lqw6AgdW4gb2JqZXQgUHJlZmVyZW5jZSBpbnN0YW5jacOpLFxuICAgICAgICAvLyBzaW5vbiwgb24gbGUgZmFicmlxdWUgdmlhIGxlcyBvcHRpb25zXG4gICAgICAgIGlmICghdGhpcy5vUHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgdGhpcy5vUHJlZmVyZW5jZSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21vZGVsX1ByZWZlcmVuY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlIHx8IFtcIlN0cmVldEFkZHJlc3NcIl0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9QcmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVzIHByZWZlcmVuY2VzIG5lIHNvbnQgcGFzIGRlZmluaWVzICE/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19QUkVGRVJFTkNFX18vZywgdGhpcy5vUHJlZmVyZW5jZS50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBzaSBvbiBhIGTDqWrDoCB1biBvYmpldCBQb3NpdGlvbiBpbnN0YW5jacOpLFxuICAgICAgICAvLyBzaW5vbiwgb24gbGUgZmFicmlxdWUgdmlhIGxlcyBvcHRpb25zXG4gICAgICAgIGlmICghdGhpcy5vUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBmaWx0ZXIgOiB7fVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRklYTUUgZ2VzdGlvbiBkZXMgZmlsdHJlcyA/XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5maWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucztcbiAgICAgICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MuZmlsdGVyLnR5cGU7IC8vIHBhcyBiZXNvaW4gP1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vUG9zaXRpb24gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19tb2RlbF9Qb3NpdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBwb3NpdGlvbiBldCBzZXMgZmlsdHJlcyBuZSBzb250IHBhcyBkZWZpbmlzICE/XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19QT1NJVElPTl9fL2csIHRoaXMub1Bvc2l0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUkVUVVJORlJFRUZPUk1fXy9nLCAodGhpcy5vcHRpb25zLnJldHVybkZyZWVGb3JtKSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKTtcblxuICAgICAgICB0aGlzLnN0clJlcXVlc3QgPSB0ZW1wbGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyUmVxdWVzdDtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJldmVyc2VHZW9jb2RlUmVxdWVzdCk7XG5cblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExvY2F0aW9uIGRlIHR5cGUgUG9zaXRpb25cbiAqXG4gKiBgYGBcbiAqIFhTRFxuICogUG9zaXRpb24gKGJhbGlzZSB4c2QpIDpcbiAqICAgZXguIDxQb3NpdGlvbj48Z21sOlBvaW50IHhtbG5zOmdtbD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCI+PGdtbDpwb3M+NTAuMzQ3Nzc1IDMuMjA1MDk4PC9nbWw6cG9zPjwvZ21sOlBvaW50PjwvUG9zaXRpb24+XG4gKiAgIGV4LiA8UG9zaXRpb24+PGdtbDpDaXJjbGVCeUNlbnRlclBvaW50IHhtbG5zOmdtbD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCI+PGdtbDpwb3M+NDguODU5Nzg1NzA2MTQ2OTEgMi4yOTEzNTcyNzYxMTI4ODc4PC9nbWw6cG9zPjxnbWw6cmFkaXVzPjEwMDA8L2dtbDpyYWRpdXM+PC9nbWw6Q2lyY2xlQnlDZW50ZXJQb2ludD48L1Bvc2l0aW9uPlxuICogICAoYXUgY2hvaXgpXG4gKiAgIGVsZW1lbnQgcmVmPVwiZ21sOlBvaW50XCJcbiAqICAgZWxlbWVudCByZWY9XCJnbWw6Q2lyY2xlQnlDZW50ZXJQb2ludFwiXG4gKiAgIGVsZW1lbnQgcmVmPVwiZ21sOlBvbHlnb25cIlxuICogICBlbGVtZW50IHJlZj1cImdtbDpNdWx0aVBvbHlnb25cIlxuICogYGBgXG4gKlxuICogRklYTUUgbGVzIGF1dHJlcyBlbGVtZW50cyBuZSBzb250IHBhcyBpbXBsw6ltZW50w6lzIChRb1AsIFNwZWVkLCBEaXJlY3Rpb24sIFRpbWUsIC4uLikgP1xuICpcbiAqIGBgYFxuICogdGVtcGxhdGUgOiBcIjxQb3NpdGlvbj5cbiAqICAgICAgICAgICAgICAgICAgX19HTUxQT0lOVF9fXG4gKiAgICAgICAgICAgICAgICAgIF9fR01MRklMVEVSX19cbiAqICAgICAgICAgICAgIDwvUG9zaXRpb24+XCJcbiAqIGBgYFxuICogYGBgXG4gKiBHTUwgOiB7XG4gKiAgcG9zICAgICA6IFwiPGdtbDpwb3M+X19YX18gX19ZX188L2dtbDpwb3M+XCIsXG4gKiAgcG9pbnQgICA6IFwiPGdtbDpQb2ludCB4bWxuczpnbWw9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXFxcIj5fX1BPU19fPC9nbWw6UG9pbnQ+XCIsXG4gKiAgY2lyY2xlICA6IFwiPGdtbDpDaXJjbGVCeUNlbnRlclBvaW50IHhtbG5zOmdtbD1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcXFwiPl9fUE9TX188Z21sOnJhZGl1cz5fX1JBRElVU19fPC9nbWw6cmFkaXVzPjwvZ21sOkNpcmNsZUJ5Q2VudGVyUG9pbnQ+XCIsXG4gKiAgLy8gbm90IHlldCBpbXBsZW1lbnRlZCAhXG4gKiAgcG9seWdvbiAgICAgIDogXCJcIixcbiAqICBtdWx0aXBvbHlnb24gOiBcIlwiXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5Gb3JtYXRzLlhMUy5Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlLlBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZG9ubsOpZXMgZW4gZW50csOpZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB4L3lcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZpbHRlciAtIGZpbHRyZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZmlsdGVyLmNpcmNsZSAtIHVuIGNlcmNsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZmlsdGVyLnBvbHlnb24gLSB1biBwb2x5Z29uZVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlBvc2l0aW9uXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBQb3NpdGlvbiAoKV1cIik7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQb3NpdGlvbiBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIHBhcmFtIHBhciBkZWZhdXRcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcGFyYW0gb2JsaWdhdG9pcmVcbiAgICBpZiAoIW9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibCdvcHRpb24gJ3Bvc2l0aW9uJyBuJ2VzdCBwYXMgcmVuc2VpZ27DqWUgIVwiKTtcbiAgICB9XG5cbiAgICAvLyBldCBvbiBham91dGUgbGVzIG9wdGlvbnMgZW4gcGFyYW3DqHRyZSBhdXggb3B0aW9ucyBwYXIgZMOpZmF1dFxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6UG9zaXRpb24jXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBQb3NpdGlvbixcblxuICAgIC8qKlxuICAgICAqIHJlcXVlc3QgKG91dClcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHJlcXVlc3RTdHJpbmcgOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBzdWJzdGl0dXRpb24gZGVzIHZhbGV1cnMgc3VpdmFudGVzIDpcbiAgICAgKiBfX0dNTFBPSU5UX18gX19HTUxGSUxURVJfX1xuICAgICAqIF9fWF9fIF9fWV9fIF9fUkFESVVTX19cbiAgICAgKiBfX1hZX19cbiAgICAgKiBAdG9kbyBpbmRlbnRhdGlvbiBYTUxcbiAgICAgKiBAdG9kbyBpbXBsZW1lbnRhdGlvbiBjbGFzc2UgR01MXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIHBvc2l0aW9uIDogXCI8UG9zaXRpb24+XCIgK1xuICAgICAgICAgICAgXCJfX0dNTFBPSU5UX19cIiArXG4gICAgICAgICAgICBcIl9fR01MRklMVEVSX19cIiArXG4gICAgICAgICAgICBcIjwvUG9zaXRpb24+XCIsXG4gICAgICAgIGdtbCA6IHtcbiAgICAgICAgICAgIHBvaW50IDogXCI8Z21sOlBvaW50IHhtbG5zOmdtbD1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcXFwiPjxnbWw6cG9zPl9fWF9fIF9fWV9fPC9nbWw6cG9zPjwvZ21sOlBvaW50PlwiLFxuICAgICAgICAgICAgcG9zIDogbnVsbCxcbiAgICAgICAgICAgIGZpbHRlciA6IHtcbiAgICAgICAgICAgICAgICBiYm94IDogXCI8Z21sOkVudmVsb3BlIHhtbG5zOmdtbD1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcXFwiPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8Z21sOmxvd2VyQ29ybmVyPl9fTEVGVF9fIF9fQk9UVE9NX188L2dtbDpsb3dlckNvcm5lcj5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiPGdtbDp1cHBlckNvcm5lcj5fX1JJR0hUX18gX19UT1BfXzwvZ21sOnVwcGVyQ29ybmVyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCI8L2dtbDpFbnZlbG9wZT5cIixcbiAgICAgICAgICAgICAgICBjaXJjbGUgOiBcIjxnbWw6Q2lyY2xlQnlDZW50ZXJQb2ludCB4bWxuczpnbWw9XFxcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXFxcIj48Z21sOnBvcz5fX1hfXyBfX1lfXzwvZ21sOnBvcz48Z21sOnJhZGl1cz5fX1JBRElVU19fPC9nbWw6cmFkaXVzPjwvZ21sOkNpcmNsZUJ5Q2VudGVyUG9pbnQ+XCIsXG4gICAgICAgICAgICAgICAgcG9seWdvbiA6IFwiPGdtbDpQb2x5Z29uIHhtbG5zOmdtbD1cXFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcXFwiPjxnbWw6ZXh0ZXJpb3I+PGdtbDpMaW5lYXJSaW5nPjxnbWw6cG9zTGlzdD5fX1hZX188L2dtbDpwb3NMaXN0PjwvZ21sOkxpbmVhclJpbmc+PC9nbWw6ZXh0ZXJpb3I+PC9nbWw6UG9seWdvbj5cIixcbiAgICAgICAgICAgICAgICBtdWx0aXBvbHlnb24gOiBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucG9zaXRpb247XG5cbiAgICB2YXIgdG1wbEdtbFBvaW50ID0gdGhpcy50ZW1wbGF0ZS5nbWwucG9pbnQ7XG4gICAgdG1wbEdtbFBvaW50ID0gdG1wbEdtbFBvaW50LnJlcGxhY2UoL19fWF9fL2csIHRoaXMub3B0aW9ucy5wb3NpdGlvbi54KTtcbiAgICB0bXBsR21sUG9pbnQgPSB0bXBsR21sUG9pbnQucmVwbGFjZSgvX19ZX18vZywgdGhpcy5vcHRpb25zLnBvc2l0aW9uLnkpO1xuXG4gICAgdmFyIHRtcGxHbWxGaWx0ZXIgPSBcIlwiO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLm9wdGlvbnMuZmlsdGVyO1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZmlsdGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRtcGxHbWxGaWx0ZXIgPSB0aGlzLnRlbXBsYXRlLmdtbC5maWx0ZXJbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRtcGxHbWxGaWx0ZXIgPSB0bXBsR21sRmlsdGVyLnJlcGxhY2UoL19fWF9fL2csIGZpbHRlcltuYW1lXS54KTtcbiAgICAgICAgICAgICAgICAgICAgdG1wbEdtbEZpbHRlciA9IHRtcGxHbWxGaWx0ZXIucmVwbGFjZSgvX19ZX18vZywgZmlsdGVyW25hbWVdLnkpO1xuICAgICAgICAgICAgICAgICAgICB0bXBsR21sRmlsdGVyID0gdG1wbEdtbEZpbHRlci5yZXBsYWNlKC9fX1JBRElVU19fL2csIGZpbHRlcltuYW1lXS5yYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmJveFwiOlxuICAgICAgICAgICAgICAgICAgICB0bXBsR21sRmlsdGVyID0gdGhpcy50ZW1wbGF0ZS5nbWwuZmlsdGVyW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0bXBsR21sRmlsdGVyID0gdG1wbEdtbEZpbHRlci5yZXBsYWNlKC9fX0xFRlRfXy9nLCBmaWx0ZXJbbmFtZV0ubGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcGxHbWxGaWx0ZXIgPSB0bXBsR21sRmlsdGVyLnJlcGxhY2UoL19fQk9UVE9NX18vZywgZmlsdGVyW25hbWVdLmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgIHRtcGxHbWxGaWx0ZXIgPSB0bXBsR21sRmlsdGVyLnJlcGxhY2UoL19fUklHSFRfXy9nLCBmaWx0ZXJbbmFtZV0ucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB0bXBsR21sRmlsdGVyID0gdG1wbEdtbEZpbHRlci5yZXBsYWNlKC9fX1RPUF9fL2csIGZpbHRlcltuYW1lXS50b3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicG9seWdvblwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBpbXBsZW1lbnRhdGlvbiBzaW1wbGUgZHUgcG9seWdvbmUgIVxuICAgICAgICAgICAgICAgICAgICAvLyBhdWN1biB0ZXN0IGRlIGZlcm1ldHVyZSBkdSBwb2x5Z29uZSwgbmkgZGUgZ2VzdGlvbiBkZXMgdHJvdXMgIVxuICAgICAgICAgICAgICAgICAgICB0bXBsR21sRmlsdGVyID0gdGhpcy50ZW1wbGF0ZS5nbWwuZmlsdGVyW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUG9pbnRzID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxzdFBvaW50cyA9IGZpbHRlcltuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3RQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZCA9IGxzdFBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiSG9sZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCAhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb29yZC54ICYmIGNvb3JkLnkpIHx8IChjb29yZC54ID09PSAwIHx8IGNvb3JkLnkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyUG9pbnRzICs9IGNvb3JkLnggKyBcIiBcIiArIGNvb3JkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobHN0UG9pbnRzLmxlbmd0aCAhPT0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJQb2ludHMgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG1wbEdtbEZpbHRlciA9IHRtcGxHbWxGaWx0ZXIucmVwbGFjZSgvX19YWV9fL2csIHN0clBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkZpbHRlciAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJUaGlzIGZpbHRlciAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCB1c2VmdWwgIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19HTUxQT0lOVF9fL2csIHRtcGxHbWxQb2ludCk7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0dNTEZJTFRFUl9fL2csIHRtcGxHbWxGaWx0ZXIpO1xuXG4gICAgdGhpcy5yZXF1ZXN0U3RyaW5nID0gdGVtcGxhdGU7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFN0cmluZztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUG9zaXRpb24pO1xuXG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogUHJlZmVyZW5jZSAoUmV2ZXJzZSlcbiAqXG4gKiBGSVhNRSBsaXN0ZSBkZXMgdHlwZXMgZGUgdGFibGVzIGRlIGdlb2NvZGFnZVxuICpcbiAqIGBgYFxuICogdGVtcGxhdGUgOiBcIjxSZXZlcnNlR2VvY29kZVByZWZlcmVuY2U+X19UWVBFX188L1JldmVyc2VHZW9jb2RlUHJlZmVyZW5jZT5cIlxuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuTG9jYXRpb25VdGlsaXR5U2VydmljZS5QcmVmZXJlbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHR5cGUgZGUgdGFibGUgZGUgZ2VvY29kYWdlXG4gKlxuICogQHByaXZhdGVcbiAqXG4gKi9cblxuZnVuY3Rpb24gUHJlZmVyZW5jZSAodHlwZSkge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJQcmVmZXJlbmNlXCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBQcmVmZXJlbmNlICgpXVwiKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcmVmZXJlbmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJlZmVyZW5jZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHR5cGUgZGUgdGFibGUgZGUgZ2VvY29kYWdlXG4gICAgICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpQcmVmZXJlbmNlI1xuICovXG5QcmVmZXJlbmNlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBQcmVmZXJlbmNlLFxuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIHN1YnN0aXR1dGlvbiBkZXMgdmFsZXVycyBzdWl2YW50ZXMgOlxuICAgICAqICBfX1RZUEVfX1xuICAgICAqXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiBcIjxSZXZlcnNlR2VvY29kZVByZWZlcmVuY2U+X19UWVBFX188L1JldmVyc2VHZW9jb2RlUHJlZmVyZW5jZT5cIlxufTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblByZWZlcmVuY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBQcmVmZXJlbmNlcyA9IFtdO1xuICAgIHZhciB0bXBsUHJlZmVyZW5jZSA9IFwiXCI7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy50eXBlLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdG1wbFByZWZlcmVuY2UgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICB0bXBsUHJlZmVyZW5jZSA9IHRtcGxQcmVmZXJlbmNlLnJlcGxhY2UoL19fVFlQRV9fL2csIHRoaXMudHlwZVtpZHhdKTtcbiAgICAgICAgUHJlZmVyZW5jZXMucHVzaCh0bXBsUHJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJSZXF1ZXN0ID0gUHJlZmVyZW5jZXMuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gdGhpcy5zdHJSZXF1ZXN0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcmVmZXJlbmNlKTtcblxuXG4vKioqLyB9KSxcbi8qIDcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZUxvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3JtYXQgZGVzIGF0dHJpYnV0cyBkJ3VuIHLDqXN1bHRhdCBkZSBnw6lvY29kYWdlIGRlIHR5cGUgU3RyZWV0QWRkcmVzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5HZW9jb2RlLlJlcXVlc3QuU3RyZWV0QWRkcmVzc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RyZWV0QWRkcmVzcyAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmVldEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdHJlZXRBZGRyZXNzIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gSU5GT1xuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBkZSBsYSBjbGFzc2UgbcOocmVcbiAgICAvLyBhdmVjIHBhc3NhZ2UgZGUgcGFyYW0uXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiU3RyZWV0QWRkcmVzc1wiO1xuXG4gICAgLyoqXG4gICAgICogTGlzdGUgZGVzIGF0dHJpYnV0cyBwb3NzaWJsZXMgcG91ciB1bmUgR2VvY29kZUxvY2F0aW9uIGRlIHR5cGUgU3RyZWV0QWRkcmVzc1xuICAgICAqIC0gKipiYm94KiogOiBFbXByaXNlIGRlIGwnYWRyZXNzZSBkYW5zIGxlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBkZW1hbmTDqSB7bGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tfS4gKntPYmplY3R9KlxuICAgICAqIC0gKipJRCoqIDogSWRlbnRpZmlhbnQgQkQgQURSRVNTRSBkYW5zIGxlIGNhcyBvw7kgbGUgcsOpc3VsdGF0IGVzdCB1bmUgYWRyZXNzZS4gKntTdHJpbmd9KlxuICAgICAqIC0gKipJRFRSKiogOiBJZGVudGlmaWFudCBcIlJvdXRlIEFkcmVzc2VcIiBkZSBsYSB2b2llIHBvcnRhbnQgbCdhZHJlc3NlIGRhbnMgbGEgYmFzZSBCRCBBRFJFU1NFLiAqe1N0cmluZ30qXG4gICAgICogLSAqKnF1YWxpdHkqKiA6IEluZGljYXRldXIgZGUgcXVhbGl0w6kgZHUgZ8Opb2NvZGFnZSAocG91ciBwbHVzIGQnaW5mb3MgOiBodHRwOi8vYXBpLmlnbi5mci90ZWNoLWRvY3MtanMvZnIvZGV2ZWxvcHBldXIvc2VhcmNoLmh0bWwgKntTdHJpbmd9KlxuICAgICAqIC0gKip0ZXJyaXRvcnkqKiA6IENvZGUgZHUgdGVycml0b2lyZSBmcmFuw6dhaXMgb8O5IHNlIHNpdHVlIGwnYWRyZXNzZSAqe1N0cmluZ30qXG4gICAgICogLSAqKmNvbW11bmUqKiA6IFZpbGxlIGwnYWRyZXNzZS4gKntTdHJpbmd9KlxuICAgICAqIC0gKipkZXBhcnRtZW50KiogOiBEw6lwYXJ0ZW1lbnQgbCdhZHJlc3NlLiAqe1N0cmluZ30qXG4gICAgICogLSAqKmluc2VlKiogOiBDb2RlIElOU0VFIGRlIGwnYWRyZXNzZS4gKntOdW1iZXJ9KlxuICAgICAqIC0gKiptdW5pY2lwYWxpdHkqKiA6IE11bmljaXBhbGl0w6kgZGUgbCdhZHJlc3NlLiAqe1N0cmluZ30qXG4gICAgICovXG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNMaXN0ID0gW1wiYmJveFwiLCBcIklEXCIsIFwiSURUUlwiLCBcInF1YWxpdHlcIiwgXCJ0ZXJyaXRvcnlcIiwgXCJjb21tdW5lXCIsIFwiZGVwYXJ0bWVudFwiLCBcImluc2VlXCIsIFwibXVuaWNpcGFsaXR5XCJdO1xuXG4gICAgdGhpcy5zZXJ2aWNlQXR0cmlidXRlcyA9IFtcImJib3hcIiwgXCJJRFwiLCBcIklEVFJcIiwgXCJRdWFsaXRlXCIsIFwiVGVycml0b2lyZVwiLCBcIkNvbW11bmVcIiwgXCJEZXBhcnRlbWVudFwiLCBcIklOU0VFXCIsIFwiTXVuaWNpcGFsaXR5XCJdO1xufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6U3RyZWV0QWRyZXNzI1xuICovXG5TdHJlZXRBZGRyZXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cblN0cmVldEFkZHJlc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RyZWV0QWRkcmVzcztcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChTdHJlZXRBZGRyZXNzKTtcblxuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZUxvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3JtYXQgZGVzIGF0dHJpYnV0cyBkJ3VuIHLDqXN1bHRhdCBkZSBnw6lvY29kYWdlIGRlIHR5cGUgUG9zaXRpb25PZkludGVyZXN0XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5SZXF1ZXN0LlBvc2l0aW9uT2ZJbnRlcmVzdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUG9zaXRpb25PZkludGVyZXN0ICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zaXRpb25PZkludGVyZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUG9zaXRpb25PZkludGVyZXN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gSU5GT1xuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBkZSBsYSBjbGFzc2UgbcOocmVcbiAgICAvLyBhdmVjIHBhc3NhZ2UgZGUgcGFyYW0uXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiUG9zaXRpb25PZkludGVyZXN0XCI7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZSBkZXMgYXR0cmlidXRzIHBvc3NpYmxlcyBwb3VyIHVuZSBHZW9jb2RlTG9jYXRpb24gZGUgdHlwZSBQb3NpdGlvbk9mSW50ZXJlc3RcbiAgICAgKiAtICoqYmJveCoqIDogRW1wcmlzZSBkdSB0b3BvbnltZSBkYW5zIGxlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBkZW1hbmTDqSB7bGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tfSAqe09iamVjdH0qXG4gICAgICogLSAqKmltcG9ydGFuY2UqKiA6IEltcG9ydGFuY2UgZHUgdG9wb255bWUgKntudW1iZXJ9KlxuICAgICAqIC0gKipuYXR1cmUqKiA6IE5hdHVyZSBkdSB0b3BvbnltZS4gKntTdHJpbmd9KlxuICAgICAqIC0gKip0ZXJyaXRvcnkqKiA6IENvZGUgZHUgdGVycml0b2lyZSBmcmFuw6dhaXMgb8O5IHNlIHNpdHVlIGxlIHRvcG9ueW1lICp7U3RyaW5nfSpcbiAgICAgKiAtICoqY29tbXVuZSoqIDogVmlsbGUgZHUgdG9wb255bWUuICp7U3RyaW5nfSpcbiAgICAgKiAtICoqZGVwYXJ0bWVudCoqIDogRMOpcGFydGVtZW50IGR1IHRvcG9ueW1lLiAqe1N0cmluZ30qXG4gICAgICogLSAqKmluc2VlKiogOiBDb2RlIElOU0VFIGRlIGxhIGNvbW11bmUgb8O5IHNlIHNpdHVlIGxlIHRvcG9ueW1lLiAqe051bWJlcn0qXG4gICAgICogLSAqKm11bmljaXBhbGl0eSoqIDogTXVuaWNpcGFsaXTDqSBkdSB0b3BvbnltZS4gKntTdHJpbmd9KlxuICAgICAqL1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzTGlzdCA9IFtcImJib3hcIiwgXCJpbXBvcnRhbmNlXCIsIFwibmF0dXJlXCIsIFwidGVycml0b3J5XCIsIFwiY29tbXVuZVwiLCBcImRlcGFydG1lbnRcIiwgXCJpbnNlZVwiLCBcIm11bmljaXBhbGl0eVwiXTtcblxuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXMgPSBbXCJiYm94XCIsIFwiSW1wb3J0YW5jZVwiLCBcIk5hdHVyZVwiLCBcIlRlcnJpdG9pcmVcIiwgXCJDb21tdW5lXCIsIFwiRGVwYXJ0ZW1lbnRcIiwgXCJJTlNFRVwiLCBcIk11bmljaXBhbGl0eVwiXTtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOlBvc2l0aW9uT2ZJbnRlcmVzdCNcbiAqL1xuUG9zaXRpb25PZkludGVyZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cblBvc2l0aW9uT2ZJbnRlcmVzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb3NpdGlvbk9mSW50ZXJlc3Q7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUG9zaXRpb25PZkludGVyZXN0KTtcblxuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZUxvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3JtYXQgZGVzIGF0dHJpYnV0cyBkJ3VuIGZpbHRyZSBkZSBnw6lvY29kYWdlIGRlIHR5cGUgQ2FkYXN0cmFsUGFyY2VsLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVxdWVzdC5DYWRhc3RyYWxQYXJjZWxcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENhZGFzdHJhbFBhcmNlbCAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENhZGFzdHJhbFBhcmNlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhZGFzdHJhbFBhcmNlbCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIElORk9cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgZGUgbGEgY2xhc3NlIG3DqHJlXG4gICAgLy8gYXZlYyBwYXNzYWdlIGRlIHBhcmFtLlxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZUxvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8qKlxuICAgICAqIE5vbSBkZSBsYSBjbGFzc2UgKGhlcml0YWdlKVxuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJDYWRhc3RyYWxQYXJjZWxcIjtcblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBhdHRyaWJ1dHMgcG9zc2libGVzIHBvdXIgdW5lIEdlb2NvZGVMb2NhdGlvbiBkZSB0eXBlIENhZGFzdHJhbFBhcmNlbFxuICAgICAqIC0gKiphYnNvcmJlZENpdHkqKiA6IENvZGUgY29tbXVuZSBhYnNvcmLDqWUgZGUgbGEgcGFyY2VsbGUgOlxuICAgICAqICAgICAgbG9yc3F1J3VuZSBwYXJjZWxsZSBlc3QgaXNzdWUgcCBkJ3VuZSBhbmNpZW5uZSBjb21tdW5lIHF1aSBhIGZ1c2lvbm7DqSBhdmVjIHVuZSBhdXRyZS5cbiAgICAgKiAgICAgIFNpbm9uLCBsZSBjb2RlIHZhdXQgJzAwMCcuICp7U3RyaW5nfSpcbiAgICAgKiAtICoqc2hlZXQqKiA6IEZldWlsbGUgZGUgbGEgcGFyY2VsbGUgKGV4IDEpLiAqe1N0cmluZ30qXG4gICAgICogLSAqKm51bWJlcioqIDogTnVtw6lybyBkZSBsYSBwYXJjZWxsZSAoZXguIDAwNDEpICp7U3RyaW5nfSpcbiAgICAgKiAtICoqc2VjdGlvbioqIDogU2VjdGlvbiBkZSBsYSBwYXJjZWxsZSAoZXggMEQpLiAqe1N0cmluZ30qXG4gICAgICogLSAqKmNvbW11bmUqKiA6IFZpbGxlIGR1IGZpbHRyZS4gKntTdHJpbmd9KlxuICAgICAqIC0gKipkZXBhcnRtZW50KiogOiBEw6lwYXJ0ZW1lbnQgZHUgZmlsdHJlLiAqe1N0cmluZ30qXG4gICAgICogLSAqKmluc2VlKiogOiBDb2RlIElOU0VFIGR1IGZpbHRyZS4gKntOdW1iZXJ9KlxuICAgICAqIC0gKiptdW5pY2lwYWxpdHkqKiA6IE11bmljaXBhbGl0w6kgZHUgZmlsdHJlLiAqe1N0cmluZ30qXG4gICAgICogLSAqKm9yaWdpbioqIDogTCdvcmlnaW5lIGRlIGwnb2JqZXQgcGFyY2VsbGFpcmUgcmVudm95w6lcbiAgICAgKiAgICAgIChjb3JyZXNwb25kIMOgIGwnYXR0cmlidXQgXCJ0eXBlXCIgZGFucyBsYSByw6lwb25zZSBYTUwpXG4gICAgICogICAgICBQb3VyIHBsdXMgZCdpbmZvcm1hdGlvbnMgOiBodHRwOi8vYXBpLmlnbi5mci90ZWNoLWRvY3MtanMvZnIvZGV2ZWxvcHBldXIvc2VhcmNoLmh0bWwjUmVjaGVyY2hlX3Bhcl9wYXJjZWxsZXNfY2FkYXN0cmFsZXMgKntOdW1iZXJ9KlxuICAgICAqXG4gICAgICovXG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNMaXN0ID0gW1wiYWJzb3JiZWRDaXR5XCIsIFwic2hlZXRcIiwgXCJudW1iZXJcIiwgXCJzZWN0aW9uXCIsIFwiY29tbXVuZVwiLCBcImRlcGFydG1lbnRcIiwgXCJpbnNlZVwiLCBcIm11bmljaXBhbGl0eVwiLCBcIm9yaWdpblwiXTtcblxuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXMgPSBbXCJDb21tdW5lQWJzb3JiZWVcIiwgXCJGZXVpbGxlXCIsIFwiTnVtZXJvXCIsIFwiU2VjdGlvblwiLCBcIkNvbW11bmVcIiwgXCJEZXBhcnRlbWVudFwiLCBcIklOU0VFXCIsIFwiTXVuaWNpcGFsaXR5XCIsIFwiVHlwZVwiXTtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkNhZGFzdHJhbFBhcmNlbCNcbiAqL1xuQ2FkYXN0cmFsUGFyY2VsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19HZW9jb2RlTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkNhZGFzdHJhbFBhcmNlbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYWRhc3RyYWxQYXJjZWw7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ2FkYXN0cmFsUGFyY2VsKTtcblxuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fR2VvY29kZUxvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3JtYXQgZGVzIGF0dHJpYnV0cyBkJ3VuIGZpbHRyZSBkZSBnw6lvY29kYWdlIGRlIHR5cGUgQWRtaW5pc3RyYXRpZi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVxdWVzdC5BZG1pbmlzdHJhdGlmXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBZG1pbmlzdHJhdGlmICgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQWRtaW5pc3RyYXRpZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFkbWluaXN0cmF0aWYgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBJTkZPXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIGRlIGxhIGNsYXNzZSBtw6hyZVxuICAgIC8vIGF2ZWMgcGFzc2FnZSBkZSBwYXJhbS5cbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0dlb2NvZGVMb2NhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJBZG1pbmlzdHJhdGlmXCI7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZSBkZXMgYXR0cmlidXRzIHBvc3NpYmxlcyBwb3VyIHVuZSBHZW9jb2RlZExvY2F0aW9uIGRlIHR5cGUgQWRtaW5pc3RyYXRpZlxuICAgICAqIC0gKipiYm94KiogOiBFbXByaXNlIGRlIGwndW5pdMOpIGFkbWluaXN0cmF0aXZlIGRhbnMgbGUgc3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGRlbWFuZMOpICp7bGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tfSpcbiAgICAgKiAtICoqcHJlZmVjdHVyZSoqIC0gTm9tIGRlIGxhIHByw6lmw6ljdHVyZSBkZSBsYSByw6lnaW9uIG91IGR1IGTDqXBhcnRlbWVudCAqe1N0cmluZ30qXG4gICAgICogLSAqKmluc2VlUmVnaW9uKiogLSBOdW3DqXJvIElOU0VFIGRlIGxhIHLDqWdpb24gKntTdHJpbmd9KlxuICAgICAqIC0gKippbnNlZURlcGFydG1lbnQqKiAtIE51bcOpcm8gSU5TRUUgZHUgZMOpcGFydGVtZW50ICp7U3RyaW5nfSpcbiAgICAgKiAtICoqbXVuaWNpcGFsaXR5KiogLSBOb20gZGUgbCd1bml0w6kgYWRtaW5pc3RyYXRpdmUgKntTdHJpbmd9KlxuICAgICAqXG4gICAgICovXG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNMaXN0ID0gW1wiYmJveFwiLCBcInByZWZlY3R1cmVcIiwgXCJpbnNlZVJlZ2lvblwiLCBcImluc2VlRGVwYXJ0bWVudFwiLCBcIm11bmljaXBhbGl0eVwiXTtcblxuICAgIHRoaXMuc2VydmljZUF0dHJpYnV0ZXMgPSBbXCJiYm94XCIsIFwiUHJlZmVjdHVyZVwiLCBcIkluc2VlUmVnaW9uXCIsIFwiSW5zZWVEZXBhcnRlbWVudFwiLCBcIk11bmljaXBhbGl0eVwiXTtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOkFkbWluaXN0cmF0aWYjXG4gKi9cbkFkbWluaXN0cmF0aWYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0dlb2NvZGVMb2NhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAqL1xuQWRtaW5pc3RyYXRpZi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBZG1pbmlzdHJhdGlmO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEFkbWluaXN0cmF0aWYpO1xuXG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRm9ybWF0c19YTUxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Gb3JtYXRzX0RpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG4vKipcbiAqIEZhY3RvcnkgcG91ciBnw6luw6lyZXIgdW5lIHJlcG9uc2UgSlNPTiDDoCBwYXJ0aXIgZCd1biBYTUxcbiAqIG91IGQndW4gSlNPTiBlbmNhcHN1bGFudCBkdSBYTUxcbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgR2VvY29kZVJlc3BvbnNlRmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVzcG9uc2UuR2VvY29kZVJlc3BvbnNlRmFjdG9yeVxuICogQHRvZG8gTGEgcmVwb25zZSBKU09OIHBldXQgZW5jYXBzdWxlciB1biBYTUwgIVxuICogQHByaXZhdGVcbiAqL1xuLy8gaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cblxuXG5cblxudmFyIERpcmVjdEdlb2NvZGVSZXBvbnNlRmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEdlb2NvZGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIHJlc3BvbnNlIDpcbiAgICAgKiAgICAgIHJhd1Jlc3BvbnNlIDpcbiAgICAgKiAgICAgIHNjb3BlIDpcbiAgICAgKiAgICAgIG9uU3VjY2VzcyA6XG4gICAgICogICAgICBvbkVycm9yIDpcbiAgICAgKiAgIH07XG4gICAgICpcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGRhdGEgZGUgdHlwZSBHZW9jb2RlUmVzcG9uc2VcbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0Zvcm1hdHNfWE1MX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Gb3JtYXRzX0RpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRYTUxTdHJpbmcob3B0aW9ucy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTERvYyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwLnBhcnNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMJ2FuYWx5c2UgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSAhP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIignXCIgKyBvcHRpb25zLnJlc3BvbnNlICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIignXCIgKyBvcHRpb25zLnJlc3BvbnNlLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgKyBcIicpXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VcIiwgbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfVU5LRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogLTFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2kgbGEgcsOpcG9uc2UgY29udGVuYWl0IHVuZSBleGNlcHRpb24gcmVudm95w6llIHBhciBsZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXhjZXB0aW9uUmVwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgZGF0YS5leGNlcHRpb25SZXBvcnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMCAvLyBGSVhNRSA6IDIwMCA/XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlcIiksXG4gICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUixcbiAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMSAvLyBGSVhNRSA6IHN0YXR1cyByZXNwb25zZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlLCBkYXRhKTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKERpcmVjdEdlb2NvZGVSZXBvbnNlRmFjdG9yeSk7XG5cblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19SZXNwb25zZV9tb2RlbF9HZW9jb2RlUmVzcG9uc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fUmVzcG9uc2VfbW9kZWxfRGlyZWN0R2VvY29kZWRMb2NhdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbi8qKlxuICogRm9uY3Rpb24gcmV0b3VybmFudCB1biBvYmpldCBjb250ZW5hbnQgZGVzIGNsw6lzIGRlIGxlY3R1cmUgKHJlYWRlcnMpXG4gKiAgICAgIHF1aSBwZXJtZXR0ZW50IGRlIHBhcnNlciBkZXMgcsOpcG9uc2VzIFhNTCBkdSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UgZGlyZWN0IGR1IEfDqW9wb3J0YWlsXG4gKiAgICAgIGFmaW4gZGUgcsOpY3Vww6lyZXIgbGVzIHLDqXN1bHRhdHMgcmV0b3VybsOpcy5cbiAqIEBtb2R1bGUgRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuR2VvY29kZS5Gb3JtYXRzLkRpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlclxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxuXG5cblxuXG4vKipcbiAqIEBtZW1iZXIgRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyXG4gKi9cbnZhciBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIgPSB7fTtcblxuLyoqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLlZFUlNJT04gLSB2ZXJzaW9uIGR1IHNlcnZpY2UgZGUgZ8Opb2NvZGFnZVxuICovXG5EaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuVkVSU0lPTiA9IFwiMS4yXCI7XG5cbi8qKlxuICogT2JqZXQgc3RvY2thbnQgbGVzIGRpZmbDqXJlbnRzIG5hbWVzcGFjZXMgZXQgbGVzIFVSSSBhc3NvY2nDqWVzXG4gKi9cbkRpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlci5OQU1FU1BBQ0VTID0ge1xuICAgIHhtbG5zIDogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3hsc1wiLFxuICAgIGdtbCA6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWxcIixcbiAgICB4bHMgOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzXCIsXG4gICAgeGxzZXh0IDogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3hsc2V4dFwiLFxuICAgIHhzaSA6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIlxufTtcblxuLyoqXG4gKiBMb2NhbGlzYXRpb24gKFVSTCkgZHUgc2NoZW1hIGRlIGTDqWZpbml0aW9uIGR1IFhNTCAoWFNEKVxuICovXG5EaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuU0NIRU1BTE9DQVRJT04gPSBcImh0dHA6Ly93eHMuaWduLmZyL3NjaGVtYXMvb2xzQWxsLnhzZFwiO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBwYXIgZMOpZmF1dCBkdSBmb3JtYXRcbiAqL1xuRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLkRFRkFVTFRQUkVGSVggPSBcInhsc1wiO1xuXG4vKipcbiAqIE9iamV0IGNvbnRlbmFudCBkZXMgZm9uY3Rpb25zIGRlIGxlY3R1cmUsIGFwcGVsw6llcyBcIlJFQURFUlNcIlxuICogICAgICBkb250IGNoYXF1ZSBjbMOpIGNvcnJlc3BvbmQgYXUgbm9tIGQndW4gdGFnIGR1IFhNTCBxdWUgbCdvbiBzb3VoYWl0ZSBsaXJlXG4gKiAgICAgIGV0IGxhIHZhbGV1ciBhc3NvY2nDqWUgZXN0IHVuZSBmb25jdGlvbiAobm9kZSwgZGF0YSlcbiAqICAgICAgb8O5IG5vZGUgZXN0IHVuIG5vZXVkIGR1IGRvY3VtZW50IERPTVxuICogICAgICBldCBkYXRhIGVzdCB1biBvYmpldCBvw7kgbCdvbiBzdG9ja2UgbGVzIGluZm9ybWF0aW9ucyBsdWVzIGRhbnMgbGUgWE1MLlxuICovXG5EaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSUyA9IHtcblxuICAgIHhscyA6IHtcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFhMUyA6IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgICAgICB2YXIgZ2VvY29kZVJlc3BvbnNlID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fUmVzcG9uc2VfbW9kZWxfR2VvY29kZVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAgICAgLy8gdsOpcmlmaWNhdGlvbiBkZSBsYSB2ZXJzaW9uIGR1IHNlcnZpY2UsIGV0IGRlcyBuYW1lc3BhY2VzIGRlIGwnZW4tdMOqdGVcbiAgICAgICAgICAgIF9fY2hlY2tTZXJ2aWNlQXR0cmlidXRlcyhyb290KTtcblxuICAgICAgICAgICAgLy8gcHVpcyBsYW5jZW1lbnQgZGUgbGEgbGVjdHVyZSBkZSBsJ2Vuc2VtYmxlIGRlcyBub2V1ZHMsIGVuIGJvdWNsYW50IHN1ciBsZXMgY2hpbGROb2Rlc1xuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKHJvb3QsIGdlb2NvZGVSZXNwb25zZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBnZW9jb2RlUmVzcG9uc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBHZW9jb2RlZEFkZHJlc3MgOiBmdW5jdGlvbiAobm9kZSwgZ2VvY29kZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZ2VvY29kZWRMb2NhdGlvbiA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1Jlc3BvbnNlX21vZGVsX0RpcmVjdEdlb2NvZGVkTG9jYXRpb25fX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXG4gICAgICAgICAgICBfX2dldENoaWxkTm9kZXMobm9kZSwgZ2VvY29kZWRMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIC8vIEFqb3V0IGR1IHLDqXN1bHRhdCBhdSB0YWJsZWF1IGdlb2NvZGVkTG9jYXRpb25zIGRlIGdlb2NvZGVSZXBvbnNlXG4gICAgICAgICAgICBpZiAoZ2VvY29kZVJlc3BvbnNlICYmIEFycmF5LmlzQXJyYXkoZ2VvY29kZVJlc3BvbnNlLmxvY2F0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBnZW9jb2RlUmVzcG9uc2UubG9jYXRpb25zLnB1c2goZ2VvY29kZWRMb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBHZW9jb2RlTWF0Y2hDb2RlIDogZnVuY3Rpb24gKG5vZGUsIGdlb2NvZGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBhY2MgPSBub2RlLmdldEF0dHJpYnV0ZShcImFjY3VyYWN5XCIpO1xuICAgICAgICAgICAgaWYgKGFjYyAmJiBnZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5hY2N1cmFjeSA9IHBhcnNlRmxvYXQoYWNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaFR5cGUgPSBub2RlLmdldEF0dHJpYnV0ZShcIm1hdGNoVHlwZVwiKTtcbiAgICAgICAgICAgIGlmIChtYXRjaFR5cGUgJiYgZ2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ubWF0Y2hUeXBlID0gbWF0Y2hUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgQWRkcmVzcyA6IGZ1bmN0aW9uIChub2RlLCBnZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY291bnRyeWNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImNvdW50cnlDb2RlXCIpO1xuICAgICAgICAgICAgaWYgKGdlb2NvZGVkTG9jYXRpb24gJiYgY291bnRyeWNvZGUpIHtcbiAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnR5cGUgPSBjb3VudHJ5Y29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9uIHZhIHLDqWN1cMOpcmVyIGxlcyBhdXRyZXMgaW5mb3JtYXRpb25zIChTdHJlZXRBZGRyZXNzLCBwbGFjZSwgcG9zdGFsQ29kZS4uLilcbiAgICAgICAgICAgIF9fZ2V0Q2hpbGROb2Rlcyhub2RlLCBnZW9jb2RlZExvY2F0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIGZyZWVGb3JtQWRkcmVzcyA6IGZ1bmN0aW9uIChub2RlLCBnZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZ2VvY29kZWRMb2NhdGlvbiAmJiBnZW9jb2RlZExvY2F0aW9uLmhhc093blByb3BlcnR5KFwicGxhY2VBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuZnJlZWZvcm0gPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBCdWlsZGluZyA6IGZ1bmN0aW9uIChub2RlLCBnZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbnVtID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJudW1iZXJcIik7XG4gICAgICAgICAgICBpZiAoZ2VvY29kZWRMb2NhdGlvbiAmJiBnZW9jb2RlZExvY2F0aW9uLmhhc093blByb3BlcnR5KFwicGxhY2VBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5udW1iZXIgPSBudW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImJ1aWxkaW5nTmFtZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5udW1iZXIgPSBub2RlLmdldEF0dHJpYnV0ZShcImJ1aWxkaW5nTmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwic3ViZGl2aXNpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMubnVtYmVyID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJzdWJkaXZpc2lvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBTdHJlZXQgOiBmdW5jdGlvbiAobm9kZSwgZ2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKGdlb2NvZGVkTG9jYXRpb24gJiYgZ2VvY29kZWRMb2NhdGlvbi5oYXNPd25Qcm9wZXJ0eShcInBsYWNlQXR0cmlidXRlc1wiKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgYSBzdHJlZXRBZGRyZXNzIHJlc3VsdCA6IHN0cmVldCByZXByZXNlbnRzIHRoZSBzdHJlZXQgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChnZW9jb2RlZExvY2F0aW9uLnR5cGUgPT09IFwiU3RyZWV0QWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnN0cmVldCA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIG9mIGEgY2FkYXN0cmFsIHBhcmNlbCByZXN1bHQgOiBzdHJlZXQgcmVwcmVzZW50cyB0aGUgY2FkYXN0cmFsIHBhcmNlbCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9jb2RlZExvY2F0aW9uLnR5cGUgPT09IFwiQ2FkYXN0cmFsUGFyY2VsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuY2FkYXN0cmFsUGFyY2VsID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFBsYWNlIDogZnVuY3Rpb24gKG5vZGUsIGdlb2NvZGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwbGFjZVR5cGUgPSBub2RlLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgICAgICAgICB2YXIgcGxhY2VOYW1lID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAoZ2VvY29kZWRMb2NhdGlvbiAmJiBnZW9jb2RlZExvY2F0aW9uLmhhc093blByb3BlcnR5KFwicGxhY2VBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlVHlwZSA9PT0gXCJNdW5pY2lwYWxpdHlcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5tdW5pY2lwYWxpdHkgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiQmJveFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBwbGFjZU5hbWUuc3BsaXQoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuYmJveCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IDogcGFyc2VGbG9hdCh2YWx1ZXNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0IDogcGFyc2VGbG9hdCh2YWx1ZXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA6IHBhcnNlRmxvYXQodmFsdWVzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gOiBwYXJzZUZsb2F0KHZhbHVlc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJDb21tdW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuY29tbXVuZSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJEZXBhcnRlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLmRlcGFydG1lbnQgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiSU5TRUVcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5pbnNlZSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJRdWFsaXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMucXVhbGl0eSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJUZXJyaXRvaXJlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMudGVycml0b3J5ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIklEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuSUQgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiSURfVFJcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5JRFRSID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkltcG9ydGFuY2VcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5pbXBvcnRhbmNlID0gcGFyc2VJbnQocGxhY2VOYW1lLCAxMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiTmF0dXJlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMubmF0dXJlID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIk51bWVyb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLm51bWJlciA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJGZXVpbGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuc2hlZXQgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiU2VjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnNlY3Rpb24gPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiQ29tbXVuZUFic29yYmVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuYWJzb3JiZWRDaXR5ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkFycm9uZGlzc2VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuYXJyb25kaXNzZW1lbnQgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJUeXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMub3JpZ2luID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIlByZWZlY3R1cmVcIikge1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5wcmVmZWN0dXJlID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkluc2VlUmVnaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuaW5zZWVSZWdpb24gPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiSW5zZWVEZXBhcnRtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuaW5zZWVEZXBhcnRtZW50ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFBvc3RhbENvZGUgOiBmdW5jdGlvbiAobm9kZSwgZ2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKGdlb2NvZGVkTG9jYXRpb24gJiYgZ2VvY29kZWRMb2NhdGlvbi5oYXNPd25Qcm9wZXJ0eShcInBsYWNlQXR0cmlidXRlc1wiKSkge1xuICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnBvc3RhbENvZGUgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBFcnJvciA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBvbiBpbWFnaW5lIHF1J29uIGEgdW5lIGJhbGlzZSBhaW5zaSA6XG4gICAgICAgICAgICAvLyA8RXJyb3IgbWVzc2FnZT1cIk1lc3NhZ2UuLi5cIiBlcnJvckNvZGU9XCJJbnRlcm5hbFNlcnZlckVycm9yXCIvPlxuICAgICAgICAgICAgdmFyIHNydk1lc3MgPSBub2RlLmdldEF0dHJpYnV0ZShcIm1lc3NhZ2VcIik7XG4gICAgICAgICAgICB2YXIgZXJyb3JDb2RlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJlcnJvckNvZGVcIik7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIixcbiAgICAgICAgICAgICAgICBcIihcIiArIGVycm9yQ29kZSArIFwiKSA6IFwiICsgc3J2TWVzcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlIDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnbWwgOiB7XG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBwb3MgOiBmdW5jdGlvbiAobm9kZSwgZ2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmIChnZW9jb2RlZExvY2F0aW9uICYmIHBvcykge1xuICAgICAgICAgICAgICAgIGdlb2NvZGVkTG9jYXRpb24ucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHggOiBwYXJzZUZsb2F0KHBvcy5zcGxpdChcIiBcIilbMF0pLFxuICAgICAgICAgICAgICAgICAgICB5IDogcGFyc2VGbG9hdChwb3Muc3BsaXQoXCIgXCIpWzFdKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIEV4Y2VwdGlvblJlcG9ydCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlTmFtZSA9PT0gXCJFeGNlcHRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5leGNlcHRpb25SZXBvcnQgPSBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tcIkV4Y2VwdGlvblwiXShjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIEV4Y2VwdGlvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25SZXBvcnQgPSB7fTtcblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIGNvZGVcbiAgICAgICAgdmFyIGV4Y2VwdGlvbkNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImV4Y2VwdGlvbkNvZGVcIik7XG4gICAgICAgIGlmIChleGNlcHRpb25Db2RlKSB7XG4gICAgICAgICAgICBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uQ29kZSA9IGV4Y2VwdGlvbkNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGV4Y2VwdGlvblJlcG9ydC5leGNlcHRpb24gPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhjZXB0aW9uUmVwb3J0O1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIGxhbmNlciBsYSBsZWN0dXJlIGQndW5lIHLDqXBvbnNlIFhNTCBkdSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UsXG4gKiAgICAgIMOgIGwnYWlkZSBkZXMgUkVBREVSUyBkZSBsYSBjbGFzc2UuXG4gKlxuICogQG1ldGhvZCBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIucmVhZFxuICogQHBhcmFtIHtET01FbGVtZW50fSByb290IC0gcmFjaW5lIGRlIGxhIHLDqXBvbnNlIFhNTCDDoCBsaXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdlb2NvZGVSZXNwb25zZXxleGNlcHRpb25SZXBvcnQgOiBsJ29iamV0IGNvbnRlbmFudCBsZXMgaW5mb3JtYXRpb25zIGRlIGxhIHLDqXBvbnNlIFhNTCxcbiAqICAgICAgc291cyBsYSBmb3JtZSBkJ3VuIG9iamV0IEdlb2NvZGVSZXNwb25zZSwgb3UgdW4gb2JqZXQgbGl0dMOpcmFsIGV4Y2VwdGlvblJlcG9ydCBzaSBsZSBzZXJ2aWNlIGEgcmVudm95w6kgdW5lIGV4Y2VwdGlvbi5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqL1xuRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLnJlYWQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgIGlmIChyb290Lm5vZGVOYW1lID09PSBcIlhMU1wiKSB7XG4gICAgICAgIHZhciBuc1ByZWZpeCA9IHJvb3QucHJlZml4O1xuICAgICAgICBpZiAoIW5zUHJlZml4KSB7XG4gICAgICAgICAgICBuc1ByZWZpeCA9IERpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlci5ERUZBVUxUUFJFRklYO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZW9jb2RlUmVzcG9uc2UgPSBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tuc1ByZWZpeF1bcm9vdC5ub2RlTmFtZV0ocm9vdCk7XG4gICAgICAgIHJldHVybiBnZW9jb2RlUmVzcG9uc2U7XG4gICAgfSBlbHNlIGlmIChyb290Lm5vZGVOYW1lID09PSBcIkV4Y2VwdGlvblJlcG9ydFwiKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25SZXBvcnQgPSBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tyb290Lm5vZGVOYW1lXShyb290KTtcbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvblJlcG9ydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWVzcyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIHJvb3Qubm9kZU5hbWUpO1xuICAgICAgICB0aHJvdyBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzLFxuICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1VOS0VSUixcbiAgICAgICAgICAgIHN0YXR1cyA6IDIwMFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFLDqWN1cMOpcmF0aW9uIGRlcyBhdHRyaWJ1dHMgZCd1biBub2V1ZCDDqWzDqW1lbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIERpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlclxuICogQG1ldGhvZCBfX2dldEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIG5vZXVkIGNvbnRlbmFudCBsJ2F0dHJpYnV0IHJlY2hlcmNow6lcbiAqIEByZXR1cm4ge09iamVjdH0gbm9kZUF0dHJpYnV0ZXMgLSBvYmpldCBjb250ZW5hbnQgbGVzIG5vbXMgZXQgdmFsZXVycyBkZXMgZGlmZsOpcmVudHMgYXR0cmlidXRzXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0QXR0cmlidXRlcyAobm9kZSkge1xuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbm9kZUF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICBub2RlQXR0cmlidXRlc1thdHRyaWJ1dGUubm9kZU5hbWVdID0gYXR0cmlidXRlLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZUF0dHJpYnV0ZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIFLDqWN1cMOpcmF0aW9uIGRlcyBub2V1ZHMgZW5mYW50cyDDoCBwYXJ0aXIgZCd1biBub2V1ZCBkb25uw6ksIHBvdXIgbGVjdHVyZSAocmVhZE5vZGUpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyXG4gKiBAbWV0aG9kIF9fZ2V0Q2hpbGROb2Rlc1xuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gYSBET00gbm9kZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IFtkYXRhXSAtIGFuIG9iamVjdCB0byBiZSBmaWxsZWQgd2l0aCBub2RlIGRhdGFcbiAqL1xuZnVuY3Rpb24gX19nZXRDaGlsZE5vZGVzIChub2RlLCBkYXRhKSB7XG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB2YXIgY2hpbGROYW1lO1xuICAgICAgICB2YXIgY2hpbGRQcmVmaXg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7IC8vIDEgPT09IG5vZGUuRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGNoaWxkUHJlZml4ID0gY2hpbGQucHJlZml4IHx8IERpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlci5ERUZBVUxUUFJFRklYO1xuXG4gICAgICAgICAgICAgICAgaWYgKERpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkUHJlZml4XVtjaGlsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZFByZWZpeF1bY2hpbGROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyKGNoaWxkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfX2dldENoaWxkTm9kZXMoY2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBMZWN0dXJlIGRlIGxhIHZhbGV1ciBkdSBwcmVtaWVyIGNoaWxkIGQndW4gbm9ldWQsIHNpIGVsbGUgZXhpc3RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyXG4gKiBAbWV0aG9kIF9fZ2V0Q2hpbGRWYWx1ZVxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gYSBET00gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfSB2YWx1ZSAtIHZhbGV1ciBkdSBmaXJzdENoaWxkIGR1IG5vZXVkIGVuIGVudHLDqWUsIG91IGNoYcOubmUgdmlkZS5cbiAqL1xuZnVuY3Rpb24gX19nZXRDaGlsZFZhbHVlIChub2RlKSB7XG4gICAgdmFyIHRleHROb2RlO1xuICAgIHZhciB2YWx1ZSA9IFwiXCI7XG5cbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgdmFsdWUgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFbDqXJpZmljYXRpb24gZGVzIGF0dHJpYnV0cyBkdSBzZXJ2aWNlLCBkYW5zIGxhIGJhbGlzZSBYTFMgZGUgbGEgcsOpcG9uc2UgOlxuICogICAgICB2ZXJzaW9uLCBuYW1lc3BhY2VzLCBldCBuYW1lc3BhY2UgcGFyIGTDqWZhdXQgZG9pdmVudCBjb3JyZXNwb25kcmUgw6AgY2V1eCBhdHRlbmR1cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIERpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlclxuICogQG1ldGhvZCBfX2NoZWNrU2VydmljZUF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gWExTTm9kZSAtIGEgRE9NIG5vZGUsIGNvcnJlc3BvbmRpbmcgdG8gWExTIGZpcnN0IHRhZy5cbiAqL1xuZnVuY3Rpb24gX19jaGVja1NlcnZpY2VBdHRyaWJ1dGVzIChYTFNOb2RlKSB7XG4gICAgaWYgKFhMU05vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIG9uIHLDqWN1cMOocmUgZXQgcGFyY291cnQgbGVzIGF0dHJpYnV0cyBkZSBsYSBiYWxpc2UgWExTIGRlIGxhIHLDqXBvbnNlXG4gICAgICAgIHZhciB4bHNBdHRyaWJ1dGVzID0gX19nZXRBdHRyaWJ1dGVzKFhMU05vZGUpO1xuICAgICAgICBmb3IgKHZhciBhdHQgaW4geGxzQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKHhsc0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0KSkge1xuICAgICAgICAgICAgICAgIC8vIHbDqXJpZmljYXRpb24gZGUgbGEgdmVyc2lvblxuICAgICAgICAgICAgICAgIGlmIChhdHQgPT09IFwidmVyc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4bHNBdHRyaWJ1dGVzW1widmVyc2lvblwiXSAhPT0gRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLlZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlcl0gZ2VvY29kZSB2ZXJzaW9uIGlzIG5vdCB0aGUgZXhwZWN0ZWQgb25lIDogdGhlcmUgbWF5IGJlIGVycm9ycyBpbiBwYXJzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb24gdsOpcmlmaWUgcXVlIGwndXJpIGR1IG5hbWVzcGFjZSBwYXIgZMOpZmF1dCBlc3QgYmllbiBjZWxsZSBxdWUgbCdvbiBhdHRlbmRcbiAgICAgICAgICAgICAgICBpZiAoYXR0ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhsc0F0dHJpYnV0ZXNbYXR0XSAhPT0gRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLk5BTUVTUEFDRVNbRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLkRFRkFVTFRQUkVGSVhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXJdIGdlb2NvZGUgcmVzcG9uc2UgZGVmYXVsdCBuYW1lc3BhY2UgaXMgbm90IHRoZSBleHBlY3RlZCBvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGF0dC5zcGxpdChcIjpcIilbMF07XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gYXR0LnNwbGl0KFwiOlwiKVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHNpIG9uIGEgdW4gYXV0cmUgeG1sbnMsIG9uIHbDqXJpZmllIGF1c3NpIGxlcyBVUklcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIgJiYgbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2kgbCdhdHRyaWJ1dCBjb3JyZXNwb25kIMOgIHVuIG5hbWVzcGFjZSBkw6lmaW5pIGRhbnMgbGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuTkFNRVNQQUNFU1tuc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsIGZhdXQgcXVlIGxlcyBVUkkgY29ycmVzcG9uZGVudCBhdXNzaS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEaXJlY3RHZW9jb2RlUmVzcG9uc2VSZWFkZXIuTkFNRVNQQUNFU1tuc10gIT09IHhsc0F0dHJpYnV0ZXNbYXR0XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlcl0gZ2VvY29kZSByZXNwb25zZSBcIiArIGF0dCArIFwiIG5hbWVzcGFjZSBpcyBub3QgdGhlIGV4cGVjdGVkIG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3VyIGZpbmlyIG9uIHbDqXJpZmllIGxhIGxvY2FsaXNhdGlvbiBkdSBzY2hlbWEgWFNEIGR1IHNlcnZpY2VcbiAgICAgICAgICAgICAgICBpZiAobnMgPT09IFwic2NoZW1hTG9jYXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyLlNDSEVNQUxPQ0FUSU9OICE9PSB4bHNBdHRyaWJ1dGVzW2F0dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RpcmVjdEdlb2NvZGVSZXNwb25zZVJlYWRlcl0gZ2VvY29kZSByZXNwb25zZSBzY2hlbWEgbG9jYXRpb24gaXMgbm90IHRoZSBleHBlY3RlZCBvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRGlyZWN0R2VvY29kZVJlc3BvbnNlUmVhZGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0NvbW1vblNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19SZXF1ZXN0X1JldmVyc2VHZW9jb2RlUmVxdWVzdEZhY3RvcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fUmVzcG9uc2VfUmV2ZXJzZUdlb2NvZGVSZXNwb25zZUZhY3RvcnlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xuXG5cblxuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQXBwZWwgZHUgc2VydmljZSBkZSBnw6lvY29kYWdlIGludmVyc2UgZHUgR8Opb3BvcnRhaWwgOlxuICogICAgIGVudm9pIGRlIGxhIHJlcXXDqnRlIGNvbnN0cnVpdGUgc2Vsb24gbGVzIHBhcmFtw6h0cmVzIGVuIG9wdGlvbnMsXG4gKiAgICAgw6l2ZW50dWVsbGVtZW50IHBhcnNpbmcgZXQgYW5hbHlzZSAgZGUgbGEgcsOpcG9uc2UsXG4gKiAgICAgcmV0b3VyIGQndW5lIHLDqXBvbnNlIGVuIHBhcmFtw6h0cmUgZGUgbGEgZm9uY3Rpb24gb25TdWNjZXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7R3AuU2VydmljZXMuQ29tbW9uU2VydmljZX1cbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5SZXZlcnNlR2VvY29kZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBzcMOpY2lmaXF1ZXMgYXUgc2VydmljZSAoKyBsZXMgb3B0aW9ucyBoZXJpdMOpZXMpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSBQb3NpdGlvbiBkdSBwb2ludCBkZSByw6lmw6lyZW5jZSBwb3VyIGxlIGNhbGN1bCBkZSBwcm94aW1pdMOpIGV4cHJpbcOpZSBkYW5zIGxlIHN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlIHNww6ljaWZpw6kgcGFyIGxlIHNycy5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5wb3NpdGlvbi54IC0gQWJjaXNzZSBkdSBwb2ludCBkZSByw6lmw6lyZW5jZSBwb3VyIGxlIGNhbGN1bCBkZSBwcm94aW1pdMOpIGV4cHJpbcOpZSBkYW5zIGxlIHN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlIHNww6ljaWZpw6kgcGFyIGxlIHNycy4gKD0gbG9uZ2l0dWRlIHNpIHNycyA9IFwiQ1JTOjg0XCIsIGxhdGl0dWRlIHNpIHNycyA9IFwiRVBTRzo0MzI2XCIpXG4gKiAgICAgIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMucG9zaXRpb24ueSAtIE9yZG9ubsOpZSBkdSBwb2ludCBkZSByw6lmw6lyZW5jZSBwb3VyIGxlIGNhbGN1bCBkZSBwcm94aW1pdMOpIGV4cHJpbcOpZSBkYW5zIGxlIHN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlIHNww6ljaWZpw6kgcGFyIGxlIHNycy4gKD0gbGF0aXR1ZGUgc2kgc3JzID0gXCJDUlM6ODRcIiwgbG9uZ2l0dWRlIHNpIHNycyA9IFwiRVBTRzo0MzI2XCIpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZpbHRlck9wdGlvbnNdIC0gTGVzIHByb3ByacOpdMOpcyBwb3NzaWJsZXMgZGUgY2V0IG9iamV0IHNvbnQgZMOpY3JpdGVzIGNpLWFwcsOocy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLmJib3hdIC0gRW1wcmlzZSBkYW5zIGxhcXVlbGxlIG9uIHNvdWhhaXRlIGVmZmVjdHVlciBsYSByZWNoZXJjaGUuXG4gKiAgICAgIExlcyBwcm9wcmnDqXTDqXMgcG9zc2libGVzIGRlIGNldCBvYmpldCBzb250IGTDqWNyaXRlcyBjaS1hcHLDqHMuXG4gKiAgICAgIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5iYm94LmxlZnQgICAtIEFic2Npc3NlIGR1IGPDtHTDqSBnYXVjaGUgZGUgbGEgQkJPWFxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveC5yaWdodCAgLSBBYnNjaXNzZSBkdSBjw7R0w6kgZHJvaXQgZGUgbGEgQkJPWFxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveC50b3AgICAgLSBPcmRvbm7DqWUgc3Vww6lyaWV1cmUgZGUgbGEgQkJPWFxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLmZpbHRlck9wdGlvbnMuYmJveC5ib3R0b20gLSBPcmRvbm7DqWUgaW5mw6lyaWV1cmUgZGUgbGEgQkJPWFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLmNpcmNsZV0gLSBDZXJjbGUgZGFucyBsZXF1ZWwgb24gc291aGFpdGUgZWZmZWN0dWVyIGxhIHJlY2hlcmNoZS5cbiAqICAgICAgTGVzIHByb3ByacOpdMOpcyBwb3NzaWJsZXMgZGUgY2V0IG9iamV0IHNvbnQgZMOpY3JpdGVzIGNpLWFwcsOocy5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLmNpcmNsZS54ICAgICAgLSBBYnNjaXNzZSBkdSBjZW50cmUgZHUgY2VyY2xlIGRlIHJlY2hlcmNoZS5cbiAqICAgICAgQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLmNpcmNsZS55ICAgICAgLSBPcmRvbm7DqWUgZHUgY2VudHJlIGR1IGNlcmNsZSBkZSByZWNoZXJjaGUuXG4gKiAgICAgIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGUucmFkaXVzIC0gUmF5b24gZHUgY2VyY2xlIGRlIHJlY2hlcmNoZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5maWx0ZXJPcHRpb25zLnBvbHlnb25dIC0gUG9seWdvbmUgZGFucyBsZXF1ZWwgb24gc291aGFpdGUgZWZmZWN0dWVyIGxhIHJlY2hlcmNoZS5cbiAqICAgICAgTGlzdGUgZGVzIGNvdXBsZXMgeCBldCB5IHBvdXIgY2hhcXVlIHBvaW50IGNvbnN0aXR1YW50IGxlIHBvbHlnb25lLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSA9IFwiU3RyZWV0QWRkcmVzc1wiXSAtIFR5cGUgZGUgbCdvYmpldCByZWNoZXJjaMOpLlxuICogICAgICBMZSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UgZHUgR8Opb3BvcnRhaWwgcGVybWV0IGRlIHJlY2hlcmNoZXIgZGVzICdQb3N0aW9uT2ZJbnRlcmVzdCcgcG91ciBkZXMgdG9wb255bWVzLCBkZXMgJ1N0cmVldEFkZHJlc3MnXG4gKiAgICAgIHBvdXIgZGVzIGFkcmVzc2VzIHBvc3RhbGVzIGV0L291IGRlcyAnQ2FkYXN0cmFsUGFyY2VsJyBwb3VyIGRlcyBwYXJjZWxsZXMgY2FkYXN0cmFsZXMuXG4gKiAgICAgIEQnYXV0cmVzIHR5cGVzIHBvdXJyb250IMOqdHJlIHJham91dMOpcyBzZWxvbiBsJ8Opdm9sdXRpb24gZHUgc2VydmljZS5cbiAqICAgICAgUGFyIGTDqWZhdXQsIHR5cGUgPSBbJ1N0cmVldEFkZHJlc3MnXS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4aW11bVJlc3BvbnNlc10gLSBOb21icmUgZGUgcsOpcG9uc2VzIG1heGltYWwgcXVlIGwnb24gc291aGFpdGUgcmVjZXZvaXIuXG4gKiAgICAgIFBhcyBkZSB2YWxldXIgcGFyIGTDqWZhdXQuIFNpIGxlIHNlcnZldXIgY29uc3VsdMOpIGVzdCBjZWx1aSBkdSBHw6lvcG9ydGFpbCwgbGEgdmFsZXVyIHBhciBkw6lmYXV0IHNlcmEgZG9uYyBjZWxsZSBkdSBzZXJ2aWNlIDogMjUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNycyA9IENSUzo4NF0gLSBTeXN0w6htZSBkZSBjb29yZG9ubsOpZXMgZGFucyBsZXF1ZWwgbGVzIHBhcmFtw6h0cmVzIGfDqW9ncmFwaGlxdWVzIGVuIGVudHLDqWUgZXQgbGEgcsOpcG9uc2UgZHUgc2VydmljZSBzb250IGV4cHJpbcOpcy5cbiAqICAgICAgUGFzIGRlIHZhbGV1ciBwYXIgZMOpZmF1dC5cbiAqICAgICAgU2kgbGUgc2VydmV1ciBjb25zdWx0w6kgZXN0IGNlbHVpIGR1IEfDqW9wb3J0YWlsLCBsYSB2YWxldXIgcGFyIGTDqWZhdXQgZXN0IDogXCJDUlM6ODRcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB2YXIgb3B0aW9ucyA9IHtcbiAqICAgICAgYXBpS2V5IDogbnVsbCxcbiAqICAgICAgc2VydmVyVXJsIDogJ2h0dHA6Ly9sb2NhbGhvc3Qvc2VydmljZS8nLFxuICogICAgICBwcm90b2NvbCA6ICdKU09OUCcsIC8vIEpTT05QfFhIUlxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICAvLyBzcMOpY2lmaXF1ZSBhdSBzZXJ2aWNlXG4gKiAgICAgIHBvc2l0aW9uIDoge3g6MCAsIHk6MH0sXG4gKiAgICAgIGZpbHRlck9wdGlvbnMgOntcbiAqICAgICAgICAgIGJib3ggOiB7bGVmdCA6IDAsIHJpZ2h0IDogMSwgdG9wIDogMSwgYm90dG9tIDogMH0sXG4gKiAgICAgICAgICBbY2lyY2xlIDoge1xuICogICAgICAgICAgICAgIHggOiAwLFxuICogICAgICAgICAgICAgIHkgOiAwLFxuICogICAgICAgICAgICAgIHJhZGl1cyA6IDEwMFxuICogICAgICAgICAgfV1cbiAqICAgICAgICAgIFtwb2x5Z29uICA6IFt7eDowLHk6MH0sIHt4OjEseToxfSwge3g6Mix5OjJ9LCB7eDozLHk6Mn0sIHt4OjQseToxfSwge3g6MCx5OjB9XV1cbiAqICAgICAgICAgIHR5cGUgOiBbJ1N0cmVldEFkZHJlc3MnXVxuICogICAgICB9LFxuICogICAgICBtYXhpbXVtUmVzcG9uc2VzIDogMjUsXG4gKiAgICAgIHNycyA6ICdFUFNHOjQzMjYnXG4gKiAgIH07XG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUmV2ZXJzZUdlb2NvZGUgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmV2ZXJzZUdlb2NvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIlJldmVyc2VHZW9jb2RlXCIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKiBGSVhNRSBpbnN0YW5jZSBvdSBjbGFzc2UgP1xuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJSZXZlcnNlR2VvY29kZVwiO1xuXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIHBhciBoZXJpdGFnZVxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKFwiR3AuU2VydmljZXMuUmV2ZXJzZUdlb2NvZGVcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJldmVyc2VHZW9jb2RlIChvcHRpb25zKV1cIik7XG5cbiAgICBpZiAoIW9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInBvc2l0aW9uXCIpKTtcbiAgICB9XG5cbiAgICAvLyBvbiBsYW5jZSB1bmUgZXhjZXB0aW9uIGFmaW4gZCdldml0ZXIgYXUgc2VydmljZSBkZSBsZSBmYWlyZS4uLlxuICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInBvc2l0aW9uLnhcIikpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInBvc2l0aW9uLnlcIikpO1xuICAgIH1cblxuICAgIC8vIGFqb3V0IGRlcyBvcHRpb25zIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIC8vIG9uIGRlZmluaXQgZGVzIGZpbHRyZXMgcGFyIGRlZmF1dFxuICAgIGlmICghb3B0aW9ucy5maWx0ZXJPcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zLmZpbHRlck9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMgPSBvcHRpb25zLmZpbHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZJWE1FIEVDTUFTY3JpcHQgNSBzdXBwb3J0ICh2YWxhYmxlIHBvdXIgdW4gb2JqZXQgdW5pcXVlbWVudCAhKVxuICAgIC8vIGNlY2kgcGVybWV0IGRlIHRlc3RlciBsZSBjYXMgb8O5IDogb2JqZWN0ID0ge31cbiAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucy5maWx0ZXJPcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIG9uIHRlc3RlIHBvdXIgY2hhcXVlIGZpbHRyZSwgbGVzIGNvbmRpdGlvbnMgc3VpdmFudGVzIDogbnVsbCBvdSB2aWRlICFcbiAgICB2YXIgZmlsdGVyID0gT2JqZWN0LmtleXMob3B0aW9ucy5maWx0ZXJPcHRpb25zKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gZmlsdGVyW2ldO1xuICAgICAgICBpZiAoIW9wdGlvbnMuZmlsdGVyT3B0aW9uc1trZXldIHx8IE9iamVjdC5rZXlzKG9wdGlvbnMuZmlsdGVyT3B0aW9uc1trZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSA9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlIHx8IFtcIlN0cmVldEFkZHJlc3NcIl07XG4gICAgLy8gb24gdsOpcmlmaWUgcXVlIGxlIHR5cGUgZXN0IGJpZW4gZGFucyB1biB0YWJsZWF1XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX1RZUEVcIiwgXCJmaWx0ZXJPcHRpb25zLnR5cGVcIikpO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzID0gb3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzIHx8IDI1O1xuXG4gICAgLy8gRklYTUUgOiBjZXQgYXR0cmlidXQgKHJldHVybkZyZWVGb3JtKSBuJ2VzdCBwYXMgc3DDqWNpZmnDqSBkYW5zIGxhIGRvYyBkdSBjb25zdHJ1Y3RldXIgP1xuICAgIC8vIElsIGVzdCBpbnV0aWxlIGVuIGVmZmV0LCBtYWlzIHByw6lzZW50IGRhbnMgbGVzIHNwZWNzLi4uXG4gICAgdGhpcy5vcHRpb25zLnJldHVybkZyZWVGb3JtID0gb3B0aW9ucy5yZXR1cm5GcmVlRm9ybSB8fCBmYWxzZTtcbiAgICAvLyBpbmZvIDogZW4gcsOpYWxpdMOpIGxlIHNlcnZpY2UgbmUgcmVjb25uYWl0IHF1ZSBFUFNHOjQzMjYuIHRoaXMub3B0aW9ucy5zcnMgcGVybWV0IGVzc2VudGllbGxlbWVudCBkZSBkaWZmw6lyZW5jaWVyIEVQU0c6NDMyNiAobGF0LGxvbikgZXQgQ1JTOjg0IChsb24sbGF0KVxuICAgIHRoaXMub3B0aW9ucy5zcnMgPSBvcHRpb25zLnNycyB8fCBcIkNSUzo4NFwiO1xuXG4gICAgLy8gc2kgb24gbidhIHBhcyB1biBzeXN0ZW1lIGRlIGNvb3Jkb25uw6llcyBFUFNHIGfDqW9ncmFwaGlxdWUsIGlsIGZhdXQgaW52ZXJzZXIgbGVzIGNvb3Jkb25uw6llc1xuICAgIC8vIChjYXIgZWxsZXMgc29udCBlbiBsb24sIGxhdCBhbG9ycyBxdWUgbGUgc2VydmljZSBhdHRlbmQgdW5lIHBvc2l0aW9uIGVuIGxhdCwgbG9uKS5cbiAgICAvLyBkYW5zIGxlIGNhcyBkJ0VQU0c6NDMyNiBwYXIgZXhlbXBsZSwgbGVzIGNvb3Jkb25uw6llcyBzb250IGJpZW4gZW4gbGF0LCBsb24gZG9uYyBvbiBuZSBmYWl0IHJpZW4uXG4gICAgaWYgKFJldmVyc2VHZW9jb2RlLmdlb0VQU0cuaW5kZXhPZih0aGlzLm9wdGlvbnMuc3JzKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gcG91ciBsYSBwb3NpdGlvblxuICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4IDogdGhpcy5vcHRpb25zLnBvc2l0aW9uLnksXG4gICAgICAgICAgICB5IDogdGhpcy5vcHRpb25zLnBvc2l0aW9uLnhcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcG91ciBsZXMgZmlsdHJlcyBzcGF0aWF1eCBzJ2lscyBzb250IHNww6ljaWZpw6lzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGUpIHtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGU7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy5jaXJjbGUgPSB7XG4gICAgICAgICAgICAgICAgeCA6IGNpcmNsZS55LFxuICAgICAgICAgICAgICAgIHkgOiBjaXJjbGUueCxcbiAgICAgICAgICAgICAgICByYWRpdXMgOiBjaXJjbGUucmFkaXVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy5wb2x5Z29uKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLnBvbHlnb247XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBwb2x5Z29uW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLnBvbHlnb25baV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHggOiBjb29yZHMueSxcbiAgICAgICAgICAgICAgICAgICAgeSA6IGNvb3Jkcy54XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0dHJpYnV0cyBkJ2luc3RhbmNlc1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGZvcmPDqSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogXCJ4bWxcIlxuICAgICAqIHNhdWYgc2kgbCdvbiBzb3VoYWl0ZSB1bmUgcmVwb25zZSBicnV0ZSAob3B0aW9ucy5yYXdSZXNwb25zZSlcbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gKHRoaXMub3B0aW9ucy5yYXdSZXNwb25zZSkgPyBcIlwiIDogXCJ4bWxcIjtcbn1cblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOlJldmVyc2VHZW9jb2RlI1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSwge1xuICAgIC8vIHRvZG9cbiAgICAvLyBnZXR0ZXIvc2V0dGVyXG59KTtcblxuLypcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cblJldmVyc2VHZW9jb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJldmVyc2VHZW9jb2RlO1xuXG4vKipcbiAqIChvdmVyd3JpdGUpXG4gKiBDcsOpYXRpb24gZGUgbGEgcmVxdcOqdGVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0ID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBNZXRob2QgOiB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCxcbiAgICAgICAgLy8gb3B0aW9ucyBzcGVjaWZpcXVlcyBkdSBzZXJ2aWNlXG4gICAgICAgIHBvc2l0aW9uIDogdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICByZXR1cm5GcmVlRm9ybSA6IHRoaXMub3B0aW9ucy5yZXR1cm5GcmVlRm9ybSxcbiAgICAgICAgZmlsdGVyT3B0aW9ucyA6IHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLFxuICAgICAgICBzcnMgOiBcIkVQU0c6NDMyNlwiLCAvLyBpbmZvIDogZW4gcsOpYWxpdMOpIGxlIHNlcnZpY2UgbmUgcmVjb25uYWl0IHF1ZSBFUFNHOjQzMjYuIHRoaXMub3B0aW9ucy5zcnMgcGVybWV0IGVzc2VudGllbGxlbWVudCBkZSBkaWZmw6lyZW5jaWVyIEVQU0c6NDMyNiAobGF0LGxvbikgZXQgQ1JTOjg0IChsb24sbGF0KVxuICAgICAgICBtYXhpbXVtUmVzcG9uc2VzIDogdGhpcy5vcHRpb25zLm1heGltdW1SZXNwb25zZXNcbiAgICB9O1xuXG4gICAgdGhpcy5yZXF1ZXN0ID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19SZXF1ZXN0X1JldmVyc2VHZW9jb2RlUmVxdWVzdEZhY3RvcnlfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5idWlsZChvcHRpb25zKTtcblxuICAgIC8vIG9uIHRlc3RlIHNpIGxhIHJlcXVldGUgYSBiaWVuIMOpdMOpIGNvbnN0cnVpdGUgIVxuICAgICghdGhpcy5yZXF1ZXN0KVxuICAgICAgICA/IGVycm9yLmNhbGwodGhpcywgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVRVUVTVF9CVUlMRFwiKSkpXG4gICAgICAgIDogc3VjY2Vzcy5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdCk7XG59O1xuXG4vKipcbiAqIChvdmVyd3JpdGUpXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5SZXZlcnNlR2VvY29kZS5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZXNwb25zZSA6IHRoaXMucmVzcG9uc2UsXG4gICAgICAgICAgICByYXdSZXNwb25zZSA6IHRoaXMub3B0aW9ucy5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgIG9uRXJyb3IgOiBlcnJvcixcbiAgICAgICAgICAgIG9uU3VjY2VzcyA6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1Jlc3BvbnNlX1JldmVyc2VHZW9jb2RlUmVzcG9uc2VGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29kZXMgRVBTRyBnw6lvZ3JhcGhpcXVlcyAobGF0L2xvbikuIFV0aWxlcyBjYXIgbGVzIGNvb3Jkb25uw6llcyBkb2l2ZW50IMOqdHJlIGludmVyc8OpZXMuXG4gKi9cblJldmVyc2VHZW9jb2RlLmdlb0VQU0cgPSBbXCJFUFNHOjQzMjZcIl07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUmV2ZXJzZUdlb2NvZGUpO1xuXG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19Gb3JtYXRzX1hMU19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Gb3JtYXRzX1hMU19Mb2NhdGlvblV0aWxpdHlTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbi8qKlxuICogQ3JlYXRpb24gZCd1bmUgcmVxdcOqdGUgT3BlbkxTIGVuIG1vZGUgUE9TVCBvdSBHRVRcbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0RmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkdlb2NvZGUuUmVxdWVzdC5SZXZlcnNlR2VvY29kZVJlcXVlc3RGYWN0b3J5XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuXG5cbnZhciBSZXZlcnNlR2VvY29kZVJlcXVlc3RGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgR2VvY29kZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgaHR0cE1ldGhvZCA6XG4gICAgICogICAgICAvLyBvcHRpb25zIHNwZWNpZmlxdWVzIGR1IHNlcnZpY2VcbiAgICAgKiAgICAgIHBvc2l0aW9uIDpcbiAgICAgKiAgICAgIHJldHVybkZyZWVGb3JtIDpcbiAgICAgKiAgICAgIGZpbHRlck9wdGlvbnMgOlxuICAgICAqICAgICAgc3JzIDpcbiAgICAgKiAgICAgIG1heGltdW1SZXNwb25zZXMgOlxuICAgICAqICAgfTtcbiAgICAgKiAgIHZhciByZXN1bHQgPSBSZXZlcnNlR2VvY29kZVJlcXVlc3RGYWN0b3J5LmJ1aWxkKG9wdGlvbnMpO1xuICAgICAqICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgKiAgICAgICAvLyBlcnJvci4uLlxuICAgICAqICAgfVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlcXVlc3RcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJSZXZlcnNlR2VvY29kZVJlcXVlc3RGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiUmV2ZXJzZUdlb2NvZGVSZXF1ZXN0RmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgLy8gb3B0aW9ucyBub24gZGVmaW5pZXNcbiAgICAgICAgdmFyIHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gb2JqZXQgTFVTXG4gICAgICAgIHZhciBvTFVTID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRm9ybWF0c19YTFNfTG9jYXRpb25VdGlsaXR5U2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgIHBvc2l0aW9uIDogc2V0dGluZ3MucG9zaXRpb24sXG4gICAgICAgICAgICByZXR1cm5GcmVlRm9ybSA6IHNldHRpbmdzLnJldHVybkZyZWVGb3JtLFxuICAgICAgICAgICAgZmlsdGVyT3B0aW9ucyA6IHNldHRpbmdzLmZpbHRlck9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRm9ybWF0IFhMU1xuICAgICAgICB2YXIgb1hMUyA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Zvcm1hdHNfWExTX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgc3JzTmFtZSA6IHNldHRpbmdzLnNycyxcbiAgICAgICAgICAgIG1heGltdW1SZXNwb25zZXMgOiBzZXR0aW5ncy5tYXhpbXVtUmVzcG9uc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBvWExTLm5hbWVzcGFjZSA9IHRydWU7XG4gICAgICAgIG9YTFMuc2V0U2VydmljZShvTFVTKTtcblxuICAgICAgICAvLyByZXF1ZXN0IGJydXRlICFcbiAgICAgICAgcmVxdWVzdCA9IG9YTFMuYnVpbGQoKTtcblxuICAgICAgICAvLyBlbiBtb2RlIEdFVCwgbGEgcmVxdcOqdGUgZXN0IGVuY29kw6llXG4gICAgICAgIC8vIGV0IGxlIHBhcmFtLiAncXhtbCcgZXN0IGFqb3V0w6lcbiAgICAgICAgaWYgKHNldHRpbmdzLmh0dHBNZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHZhciBteVJlcXVlc3QgPSBcInF4bWw9XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0KVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIiUyRFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIiU1RlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csIFwiJTJFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8hL2csIFwiJTIxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9+L2csIFwiJTdFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgXCIlMkFcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCIlMjdcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIiUyOFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpL2csIFwiJTI5XCIpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IG15UmVxdWVzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2dlci50cmFjZShyZXF1ZXN0KTtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJldmVyc2VHZW9jb2RlUmVxdWVzdEZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRm9ybWF0c19YTUxfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Gb3JtYXRzX1JldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xuLyoqXG4gKiBGYWN0b3J5IHBvdXIgZ8OpbsOpcmVyIHVuZSByZXBvbnNlIEpTT04gw6AgcGFydGlyIGQndW4gWE1MXG4gKiBvdSBkJ3VuIEpTT04gZW5jYXBzdWxhbnQgZHUgWE1MXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VGYWN0b3J5XG4gKiBAYWxpYXMgR3AuU2VydmljZXMuUmV2ZXJzZUdlb2NvZGUuUmVzcG9uc2UuUmV2ZXJzZUdlb2NvZGVSZXNwb25zZUZhY3RvcnlcbiAqIEB0b2RvIExhIHJlcG9uc2UgSlNPTiBwZXV0IGVuY2Fwc3VsZXIgdW4gWE1MICFcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5cblxuXG5cbnZhciBSZXZlcnNlR2VvY29kZVJlcG9uc2VGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgUmV2ZXJzZUdlb2NvZGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIHJlc3BvbnNlIDpcbiAgICAgKiAgICAgIHJhd1Jlc3BvbnNlIDpcbiAgICAgKiAgICAgIHNjb3BlIDpcbiAgICAgKiAgICAgIG9uU3VjY2VzcyA6XG4gICAgICogICAgICBvbkVycm9yIDpcbiAgICAgKiAgIH07XG4gICAgICpcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGRhdGEgZGUgdHlwZSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcblxuICAgICAgICBpZiAob3B0aW9ucy5yZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmF3UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Gb3JtYXRzX1hNTF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRm9ybWF0c19SZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnNldFhNTFN0cmluZyhvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuc2V0WE1MRG9jKG9wdGlvbnMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHAucGFyc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkwnYW5hbHlzZSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlICE/XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiByZWxheWUgbCdlcnJldXIgcmXDp3VlXG4gICAgICAgICAgICAgICAgICAgIGUuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNpIGxhIHLDqXBvbnNlIGNvbnRlbmFpdCB1bmUgZXhjZXB0aW9uIHJlbnZvecOpZSBwYXIgbGUgc2VydmljZVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gOiBxdWFuZCBjZWxhIGFycml2ZS10LWlsID9cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBkYXRhLmV4Y2VwdGlvblJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRhbnMgbGUgY2FzIGQndW4gc3JzIG5vbiBFUFNHIGfDqW9ncmFwaGlxdWUsIGlsIGZhdXQgcsOpaW52ZXJzZXIgbGVzIGNvb3Jkb25uw6llcyAobGF0LGxvbiA9PiBsb24sbGF0KVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNjb3BlICYmIG9wdGlvbnMuc2NvcGUub3B0aW9ucyAmJiBvcHRpb25zLnNjb3BlLm9wdGlvbnMuc3JzICYmIG9wdGlvbnMuc2NvcGUub3B0aW9ucy5zcnMgIT09IFwiRVBTRzo0MzI2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSB8fCBkYXRhLmxvY2F0aW9ucyB8fCBkYXRhLmxvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGRhdGEubG9jYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBsb2NhdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gaW52ZXJzZSBsZXMgMiBjb29yZG9ubsOpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggOiBwb3MueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IDogcG9zLnhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VNUFRZXCIpLFxuICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlIsXG4gICAgICAgICAgICAgICAgc3RhdHVzIDogLTEgLy8gRklYTUUgOiBzdGF0dXMgcmVzcG9uc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSwgZGF0YSk7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChSZXZlcnNlR2VvY29kZVJlcG9uc2VGYWN0b3J5KTtcblxuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1Jlc3BvbnNlX21vZGVsX0dlb2NvZGVSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19SZXNwb25zZV9tb2RlbF9SZXZlcnNlR2VvY29kZWRMb2NhdGlvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbi8qKlxuICogRm9uY3Rpb24gcmV0b3VybmFudCB1biBvYmpldCBjb250ZW5hbnQgZGVzIGNsw6lzIGRlIGxlY3R1cmUgKHJlYWRlcnMpXG4gKiAgICAgIHF1aSBwZXJtZXR0ZW50IGRlIHBhcnNlciBkZXMgcsOpcG9uc2VzIFhNTCBkdSBzZXJ2aWNlIGRlIGfDqW9jb2RhZ2UgaW52ZXJzZSBkdSBHw6lvcG9ydGFpbFxuICogICAgICBhZmluIGRlIHLDqWN1cMOpcmVyIGxlcyByw6lzdWx0YXRzIHJldG91cm7DqXMuXG4gKiBAbW9kdWxlIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5HZW9jb2RlLkZvcm1hdHMuUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlclxuICogQHByaXZhdGVcbiAqL1xuXG4vLyBpbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi8uLi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxuXG5cblxuXG4vKipcbiAqIE9iamV0IFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqIEBtZW1iZXIge09iamVjdH0gUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlclxuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLlZFUlNJT04gLSBWZXJzaW9uIGR1IHNlcnZpY2UgZGUgZ8Opb2NvZGFnZVxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLk5BTUVTUEFDRVMgLSBPYmpldCBzdG9ja2FudCBsZXMgZGlmZsOpcmVudHMgbmFtZXNwYWNlcyBldCBsZXMgVVJJIGFzc29jacOpZXNcbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5TQ0hFTUFMT0NBVElPTiAtIExvY2FsaXNhdGlvbiAoVVJMKSBkdSBzY2hlbWEgZGUgZMOpZmluaXRpb24gZHUgWE1MIChYU0QpXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9IFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuREVGQVVMVFBSRUZJWCAtIE5hbWVzcGFjZSBwYXIgZMOpZmF1dCBkdSBmb3JtYXRcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5SRUFERVJTIC0gT2JqZXQgY29udGVuYW50IGRlcyBmb25jdGlvbnMgZGUgbGVjdHVyZSwgYXBwZWzDqWVzIFwiUkVBREVSU1wiXG4gKiAgICAgIGRvbnQgY2hhcXVlIGNsw6kgY29ycmVzcG9uZCBhdSBub20gZCd1biB0YWcgZHUgWE1MIHF1ZSBsJ29uIHNvdWhhaXRlIGxpcmVcbiAqICAgICAgZXQgbGEgdmFsZXVyIGFzc29jacOpZSBlc3QgdW5lIGZvbmN0aW9uIChub2RlLCBkYXRhKVxuICogICAgICBvw7kgbm9kZSBlc3QgdW4gbm9ldWQgZHUgZG9jdW1lbnQgRE9NXG4gKiAgICAgIGV0IGRhdGEgZXN0IHVuIG9iamV0IG/DuSBsJ29uIHN0b2NrZSBsZXMgaW5mb3JtYXRpb25zIGx1ZXMgZGFucyBsZSBYTUwuXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIucmVhZCAtIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgbGFuY2VyIGxhIGxlY3R1cmUgZCd1bmUgcsOpcG9uc2UgWE1MIGR1IHNlcnZpY2UgZGUgZ8Opb2NvZGFnZSxcbiAqICAgICAgw6AgbCdhaWRlIGRlcyBSRUFERVJTIGRlIGxhIGNsYXNzZS5cbiAqXG4gKi9cblxudmFyIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIgPSB7fTtcblxuLyoqXG4gKiB2ZXJzaW9uIGR1IHNlcnZpY2UgZGUgZ8Opb2NvZGFnZVxuICovXG5SZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLlZFUlNJT04gPSBcIjEuMlwiO1xuXG4vKipcbiAqIE9iamV0IHN0b2NrYW50IGxlcyBkaWZmw6lyZW50cyBuYW1lc3BhY2VzIGV0IGxlcyBVUkkgYXNzb2Npw6llc1xuICovXG5SZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLk5BTUVTUEFDRVMgPSB7XG4gICAgeG1sbnMgOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzXCIsXG4gICAgZ21sIDogXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiLFxuICAgIHhscyA6IFwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIixcbiAgICB4bHNleHQgOiBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzZXh0XCIsXG4gICAgeHNpIDogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZVwiXG59O1xuXG4vKipcbiAqIExvY2FsaXNhdGlvbiAoVVJMKSBkdSBzY2hlbWEgZGUgZMOpZmluaXRpb24gZHUgWE1MIChYU0QpXG4gKi9cblJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuU0NIRU1BTE9DQVRJT04gPSBcImh0dHA6Ly93eHMuaWduLmZyL3NjaGVtYXMvb2xzQWxsLnhzZFwiO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBwYXIgZMOpZmF1dCBkdSBmb3JtYXRcbiAqL1xuUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5ERUZBVUxUUFJFRklYID0gXCJ4bHNcIjtcblxuLyoqXG4gKiBPYmpldCBjb250ZW5hbnQgZGVzIGZvbmN0aW9ucyBkZSBsZWN0dXJlLCBhcHBlbMOpZXMgXCJSRUFERVJTXCJcbiAqICAgICAgZG9udCBjaGFxdWUgY2zDqSBjb3JyZXNwb25kIGF1IG5vbSBkJ3VuIHRhZyBkdSBYTUwgcXVlIGwnb24gc291aGFpdGUgbGlyZVxuICogICAgICBldCBsYSB2YWxldXIgYXNzb2Npw6llIGVzdCB1bmUgZm9uY3Rpb24gKG5vZGUsIGRhdGEpXG4gKiAgICAgIG/DuSBub2RlIGVzdCB1biBub2V1ZCBkdSBkb2N1bWVudCBET01cbiAqICAgICAgZXQgZGF0YSBlc3QgdW4gb2JqZXQgb8O5IGwnb24gc3RvY2tlIGxlcyBpbmZvcm1hdGlvbnMgbHVlcyBkYW5zIGxlIFhNTC5cbiAqL1xuUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5SRUFERVJTID0ge1xuXG4gICAgeGxzIDoge1xuXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgWExTIDogZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlR2VvY29kZVJlc3BvbnNlID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fUmVzcG9uc2VfbW9kZWxfR2VvY29kZVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAgICAgLy8gdsOpcmlmaWNhdGlvbiBkZSBsYSB2ZXJzaW9uIGR1IHNlcnZpY2UsIGV0IGRlcyBuYW1lc3BhY2VzIGRlIGwnZW4tdMOqdGVcbiAgICAgICAgICAgIF9fY2hlY2tTZXJ2aWNlQXR0cmlidXRlcyhyb290KTtcblxuICAgICAgICAgICAgLy8gcHVpcyBsYW5jZW1lbnQgZGUgbGEgbGVjdHVyZSBkZSBsJ2Vuc2VtYmxlIGRlcyBub2V1ZHMsIGVuIGJvdWNsYW50IHN1ciBsZXMgY2hpbGROb2Rlc1xuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKHJvb3QsIHJldmVyc2VHZW9jb2RlUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV2ZXJzZUdlb2NvZGVSZXNwb25zZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFJldmVyc2VHZW9jb2RlZExvY2F0aW9uIDogZnVuY3Rpb24gKG5vZGUsIHJldmVyc2VHZW9jb2RlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlR2VvY29kZWRMb2NhdGlvbiA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1Jlc3BvbnNlX21vZGVsX1JldmVyc2VHZW9jb2RlZExvY2F0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKTtcblxuICAgICAgICAgICAgLy8gQWpvdXQgZHUgcsOpc3VsdGF0IGF1IHRhYmxlYXUgbG9jYXRpb25zIGRlIHJldmVyc2VHZW9jb2RlUmVzcG9uc2VcbiAgICAgICAgICAgIGlmIChyZXZlcnNlR2VvY29kZVJlc3BvbnNlICYmIEFycmF5LmlzQXJyYXkocmV2ZXJzZUdlb2NvZGVSZXNwb25zZS5sb2NhdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVSZXNwb25zZS5sb2NhdGlvbnMucHVzaChyZXZlcnNlR2VvY29kZWRMb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBBZGRyZXNzIDogZnVuY3Rpb24gKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY291bnRyeWNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImNvdW50cnlDb2RlXCIpO1xuICAgICAgICAgICAgaWYgKHJldmVyc2VHZW9jb2RlZExvY2F0aW9uICYmIGNvdW50cnljb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24udHlwZSA9IGNvdW50cnljb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb24gdmEgcsOpY3Vww6lyZXIgbGVzIGF1dHJlcyBpbmZvcm1hdGlvbnMgKFN0cmVldEFkZHJlc3MsIHBsYWNlLCBwb3N0YWxDb2RlLi4uKVxuICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIEJ1aWxkaW5nIDogZnVuY3Rpb24gKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbnVtID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJudW1iZXJcIik7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24gJiYgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24uaGFzT3duUHJvcGVydHkoXCJwbGFjZUF0dHJpYnV0ZXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5udW1iZXIgPSBudW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImJ1aWxkaW5nTmFtZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMubnVtYmVyID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJidWlsZGluZ05hbWVcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShcInN1YmRpdmlzaW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5udW1iZXIgPSBub2RlLmdldEF0dHJpYnV0ZShcInN1YmRpdmlzaW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFN0cmVldCA6IGZ1bmN0aW9uIChub2RlLCByZXZlcnNlR2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBhIHN0cmVldEFkZHJlc3MgcmVzdWx0IDogc3RyZWV0IHJlcHJlc2VudHMgdGhlIHN0cmVldCBuYW1lXG4gICAgICAgICAgICBpZiAocmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24udHlwZSA9PT0gXCJTdHJlZXRBZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuc3RyZWV0ID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBvZiBhIGNhZGFzdHJhbCBwYXJjZWwgcmVzdWx0IDogc3RyZWV0IHJlcHJlc2VudHMgdGhlIGNhZGFzdHJhbCBwYXJjZWwgaWRlbnRpZmllclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXZlcnNlR2VvY29kZWRMb2NhdGlvbi50eXBlID09PSBcIkNhZGFzdHJhbFBhcmNlbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLmNhZGFzdHJhbFBhcmNlbCA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIFBsYWNlIDogZnVuY3Rpb24gKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcGxhY2VUeXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICAgICAgICAgICAgdmFyIHBsYWNlTmFtZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcblxuICAgICAgICAgICAgaWYgKHJldmVyc2VHZW9jb2RlZExvY2F0aW9uICYmIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLmhhc093blByb3BlcnR5KFwicGxhY2VBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlVHlwZSA9PT0gXCJNdW5pY2lwYWxpdHlcIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMubXVuaWNpcGFsaXR5ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkJib3hcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gcGxhY2VOYW1lLnNwbGl0KFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5iYm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgOiBwYXJzZUZsb2F0KHZhbHVlc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgOiBwYXJzZUZsb2F0KHZhbHVlc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wIDogcGFyc2VGbG9hdCh2YWx1ZXNbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA6IHBhcnNlRmxvYXQodmFsdWVzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkNvbW11bmVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuY29tbXVuZSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJEZXBhcnRlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5kZXBhcnRtZW50ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIklOU0VFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLmluc2VlID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIlF1YWxpdGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMucXVhbGl0eSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJUZXJyaXRvaXJlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnRlcnJpdG9yeSA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJJRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5JRCA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJJRF9UUlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5JRFRSID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkltcG9ydGFuY2VcIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuaW1wb3J0YW5jZSA9IHBhcnNlSW50KHBsYWNlTmFtZSwgMTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIk5hdHVyZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5uYXR1cmUgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiTnVtZXJvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLm51bWJlciA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJGZXVpbGxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnNoZWV0ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIlNlY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuc2VjdGlvbiA9IHBsYWNlTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBsYWNlVHlwZSA9PT0gXCJDb21tdW5lQWJzb3JiZWVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wbGFjZUF0dHJpYnV0ZXMuYWJzb3JiZWRDaXR5ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkFycm9uZGlzc2VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLmFycm9uZGlzc2VtZW50ID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiVHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5vcmlnaW4gPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwbGFjZVR5cGUgPT09IFwiUHJlZmVjdHVyZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5wcmVmZWN0dXJlID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkluc2VlUmVnaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLmluc2VlUmVnaW9uID0gcGxhY2VOYW1lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhY2VUeXBlID09PSBcIkluc2VlRGVwYXJ0bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLnBsYWNlQXR0cmlidXRlcy5pbnNlZURlcGFydG1lbnQgPSBwbGFjZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgUG9zdGFsQ29kZSA6IGZ1bmN0aW9uIChub2RlLCByZXZlcnNlR2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKHJldmVyc2VHZW9jb2RlZExvY2F0aW9uICYmIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uLmhhc093blByb3BlcnR5KFwicGxhY2VBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24ucGxhY2VBdHRyaWJ1dGVzLnBvc3RhbENvZGUgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICBTZWFyY2hDZW50cmVEaXN0YW5jZSA6IGZ1bmN0aW9uIChub2RlLCByZXZlcnNlR2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24uc2VhcmNoQ2VudGVyRGlzdGFuY2UgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgRXJyb3IgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gPEVycm9yIG1lc3NhZ2U9XCJGb3IgaW5wdXQgc3RyaW5nIDogJnF1b3Q7Miw0NSZxdW90O1wiIGVycm9yQ29kZT1cIkludGVybmFsU2VydmVyRXJyb3JcIi8+XG4gICAgICAgICAgICB2YXIgc3J2TWVzcyA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibWVzc2FnZVwiKTtcbiAgICAgICAgICAgIHZhciBlcnJvckNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImVycm9yQ29kZVwiKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLFxuICAgICAgICAgICAgICAgIFwiKFwiICsgZXJyb3JDb2RlICsgXCIpIDogXCIgKyBzcnZNZXNzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdtbCA6IHtcblxuICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgIHBvcyA6IGZ1bmN0aW9uIChub2RlLCByZXZlcnNlR2VvY29kZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlR2VvY29kZWRMb2NhdGlvbiAmJiBwb3MpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeCA6IHBhcnNlRmxvYXQocG9zLnNwbGl0KFwiIFwiKVswXSksXG4gICAgICAgICAgICAgICAgICAgIHkgOiBwYXJzZUZsb2F0KHBvcy5zcGxpdChcIiBcIilbMV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB4bHNleHQgOiB7XG4gICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgRXh0ZW5kZWRHZW9jb2RlTWF0Y2hDb2RlIDogZnVuY3Rpb24gKG5vZGUsIHJldmVyc2VHZW9jb2RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBpZiAocmV2ZXJzZUdlb2NvZGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZWRMb2NhdGlvbi5tYXRjaFR5cGUgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIEV4Y2VwdGlvblJlcG9ydCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlTmFtZSA9PT0gXCJFeGNlcHRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5leGNlcHRpb25SZXBvcnQgPSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbXCJFeGNlcHRpb25cIl0oY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBFeGNlcHRpb24gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZXhjZXB0aW9uUmVwb3J0ID0ge307XG5cbiAgICAgICAgLy8gZ2V0IGV4Y2VwdGlvbiBjb2RlXG4gICAgICAgIHZhciBleGNlcHRpb25Db2RlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJleGNlcHRpb25Db2RlXCIpO1xuICAgICAgICBpZiAoZXhjZXB0aW9uQ29kZSkge1xuICAgICAgICAgICAgZXhjZXB0aW9uUmVwb3J0LmV4Y2VwdGlvbkNvZGUgPSBleGNlcHRpb25Db2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGV4Y2VwdGlvbiBtZXNzYWdlXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4Y2VwdGlvblJlcG9ydDtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogTcOpdGhvZGUgcGVybWV0dGFudCBkZSBsYW5jZXIgbGEgbGVjdHVyZSBkJ3VuZSByw6lwb25zZSBYTUwgZHUgc2VydmljZSBkZSBnw6lvY29kYWdlLFxuICogICAgICDDoCBsJ2FpZGUgZGVzIFJFQURFUlMgZGUgbGEgY2xhc3NlLlxuICpcbiAqIEBtZXRob2QgUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5yZWFkXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3QgLSByYWNpbmUgZGUgbGEgcsOpcG9uc2UgWE1MIMOgIGxpcmVcbiAqIEByZXR1cm4ge09iamVjdH0gZ2VvY29kZVJlc3BvbnNlfGV4Y2VwdGlvblJlcG9ydCA6IGwnb2JqZXQgY29udGVuYW50IGxlcyBpbmZvcm1hdGlvbnMgZGUgbGEgcsOpcG9uc2UgWE1MLFxuICogICAgICBzb3VzIGxhIGZvcm1lIGQndW4gb2JqZXQgR2VvY29kZVJlc3BvbnNlLCBvdSB1biBvYmpldCBsaXR0w6lyYWwgZXhjZXB0aW9uUmVwb3J0IHNpIGxlIHNlcnZpY2UgYSByZW52b3nDqSB1bmUgZXhjZXB0aW9uLlxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqL1xuUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5yZWFkID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICBpZiAocm9vdC5ub2RlTmFtZSA9PT0gXCJYTFNcIikge1xuICAgICAgICB2YXIgbnNQcmVmaXggPSByb290LnByZWZpeDtcbiAgICAgICAgaWYgKCFuc1ByZWZpeCkge1xuICAgICAgICAgICAgbnNQcmVmaXggPSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLkRFRkFVTFRQUkVGSVg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlb2NvZGVSZXNwb25zZSA9IFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tuc1ByZWZpeF1bcm9vdC5ub2RlTmFtZV0ocm9vdCk7XG4gICAgICAgIHJldHVybiBnZW9jb2RlUmVzcG9uc2U7XG4gICAgfSBlbHNlIGlmIChyb290Lm5vZGVOYW1lID09PSBcIkV4Y2VwdGlvblJlcG9ydFwiKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25SZXBvcnQgPSBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbcm9vdC5ub2RlTmFtZV0ocm9vdCk7XG4gICAgICAgIHJldHVybiBleGNlcHRpb25SZXBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyZXVyIGxvcnMgZGUgbGEgbGVjdHVyZSBkZSBsYSByw6lwb25zZSA6IGVsbGUgbidlc3QgcGFzIGF1IGZvcm1hdCBhdHRlbmR1LlwiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFLDqWN1cMOpcmF0aW9uIGRlcyBhdHRyaWJ1dHMgZCd1biBub2V1ZCDDqWzDqW1lbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqIEBtZXRob2QgX19nZXRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBub2V1ZCBjb250ZW5hbnQgbCdhdHRyaWJ1dCByZWNoZXJjaMOpXG4gKiBAcmV0dXJuIHtPYmplY3R9IG5vZGVBdHRyaWJ1dGVzIC0gb2JqZXQgY29udGVuYW50IGxlcyBub21zIGV0IHZhbGV1cnMgZGVzIGRpZmbDqXJlbnRzIGF0dHJpYnV0c1xuICovXG5mdW5jdGlvbiBfX2dldEF0dHJpYnV0ZXMgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGVBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgbm9kZUF0dHJpYnV0ZXNbYXR0cmlidXRlLm5vZGVOYW1lXSA9IGF0dHJpYnV0ZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVBdHRyaWJ1dGVzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSw6ljdXDDqXJhdGlvbiBkZXMgbm9ldWRzIGVuZmFudHMgw6AgcGFydGlyIGQndW4gbm9ldWQgZG9ubsOpLCBwb3VyIGxlY3R1cmUgKHJlYWROb2RlKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqIEBtZXRob2QgX19nZXRDaGlsZE5vZGVzXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBhIERPTSBub2RlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gW2RhdGFdIC0gYW4gb2JqZWN0IHRvIGJlIGZpbGxlZCB3aXRoIG5vZGUgZGF0YVxuICovXG5mdW5jdGlvbiBfX2dldENoaWxkTm9kZXMgKG5vZGUsIGRhdGEpIHtcbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIHZhciBjaGlsZE5hbWU7XG4gICAgICAgIHZhciBjaGlsZFByZWZpeDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHsgLy8gMSA9PT0gbm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICBjaGlsZE5hbWUgPSBjaGlsZC5sb2NhbE5hbWUgfHwgY2hpbGQuYmFzZU5hbWUgfHwgY2hpbGQubm9kZU5hbWU7XG4gICAgICAgICAgICAgICAgY2hpbGRQcmVmaXggPSBjaGlsZC5wcmVmaXggfHwgUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5ERUZBVUxUUFJFRklYO1xuXG4gICAgICAgICAgICAgICAgaWYgKFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tjaGlsZFByZWZpeF1bY2hpbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkUHJlZml4XVtjaGlsZE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIoY2hpbGQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9fZ2V0Q2hpbGROb2RlcyhjaGlsZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIExlY3R1cmUgZGUgbGEgdmFsZXVyIGR1IHByZW1pZXIgY2hpbGQgZCd1biBub2V1ZCwgc2kgZWxsZSBleGlzdGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyXG4gKiBAbWV0aG9kIF9fZ2V0Q2hpbGRWYWx1ZVxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIC0gYSBET00gbm9kZVxuICogQHJldHVybiB7U3RyaW5nfSB2YWx1ZSAtIHZhbGV1ciBkdSBmaXJzdENoaWxkIGR1IG5vZXVkIGVuIGVudHLDqWUsIG91IGNoYcOubmUgdmlkZS5cbiAqL1xuZnVuY3Rpb24gX19nZXRDaGlsZFZhbHVlIChub2RlKSB7XG4gICAgdmFyIHRleHROb2RlO1xuICAgIHZhciB2YWx1ZSA9IFwiXCI7XG5cbiAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMykgeyAvLyAzID09PSBub2RlLlRFWFRfTk9ERVxuICAgICAgICAgICAgdmFsdWUgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFbDqXJpZmljYXRpb24gZGVzIGF0dHJpYnV0cyBkdSBzZXJ2aWNlLCBkYW5zIGxhIGJhbGlzZSBYTFMgZGUgbGEgcsOpcG9uc2UgOlxuICogICAgICB2ZXJzaW9uLCBuYW1lc3BhY2VzLCBldCBuYW1lc3BhY2UgcGFyIGTDqWZhdXQgZG9pdmVudCBjb3JyZXNwb25kcmUgw6AgY2V1eCBhdHRlbmR1cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJcbiAqIEBtZXRob2QgX19jaGVja1NlcnZpY2VBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IFhMU05vZGUgLSBhIERPTSBub2RlLCBjb3JyZXNwb25kaW5nIHRvIFhMUyBmaXJzdCB0YWcuXG4gKi9cbmZ1bmN0aW9uIF9fY2hlY2tTZXJ2aWNlQXR0cmlidXRlcyAoWExTTm9kZSkge1xuICAgIGlmIChYTFNOb2RlLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBvbiByw6ljdXDDqHJlIGV0IHBhcmNvdXJ0IGxlcyBhdHRyaWJ1dHMgZGUgbGEgYmFsaXNlIFhMUyBkZSBsYSByw6lwb25zZVxuICAgICAgICB2YXIgeGxzQXR0cmlidXRlcyA9IF9fZ2V0QXR0cmlidXRlcyhYTFNOb2RlKTtcbiAgICAgICAgZm9yICh2YXIgYXR0IGluIHhsc0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICh4bHNBdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dCkpIHtcbiAgICAgICAgICAgICAgICAvLyB2w6lyaWZpY2F0aW9uIGRlIGxhIHZlcnNpb25cbiAgICAgICAgICAgICAgICBpZiAoYXR0ID09PSBcInZlcnNpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGxzQXR0cmlidXRlc1tcInZlcnNpb25cIl0gIT09IFJldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuVkVSU0lPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlcl0gZ2VvY29kZSB2ZXJzaW9uIGlzIG5vdCB0aGUgZXhwZWN0ZWQgb25lIDogdGhlcmUgbWF5IGJlIGVycm9ycyBpbiBwYXJzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb24gdsOpcmlmaWUgcXVlIGwndXJpIGR1IG5hbWVzcGFjZSBwYXIgZMOpZmF1dCBlc3QgYmllbiBjZWxsZSBxdWUgbCdvbiBhdHRlbmRcbiAgICAgICAgICAgICAgICBpZiAoYXR0ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhsc0F0dHJpYnV0ZXNbYXR0XSAhPT0gUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5OQU1FU1BBQ0VTW1JldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXIuREVGQVVMVFBSRUZJWF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JldmVyc2VHZW9jb2RlUmVzcG9uc2VSZWFkZXJdIGdlb2NvZGUgcmVzcG9uc2UgZGVmYXVsdCBuYW1lc3BhY2UgaXMgbm90IHRoZSBleHBlY3RlZCBvbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGF0dC5zcGxpdChcIjpcIilbMF07XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gYXR0LnNwbGl0KFwiOlwiKVsxXTtcblxuICAgICAgICAgICAgICAgIC8vIHNpIG9uIGEgdW4gYXV0cmUgeG1sbnMsIG9uIHbDqXJpZmllIGF1c3NpIGxlcyBVUklcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIgJiYgbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2kgbCdhdHRyaWJ1dCBjb3JyZXNwb25kIMOgIHVuIG5hbWVzcGFjZSBkw6lmaW5pIGRhbnMgbGUgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyLk5BTUVTUEFDRVNbbnNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbCBmYXV0IHF1ZSBsZXMgVVJJIGNvcnJlc3BvbmRlbnQgYXVzc2kuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5OQU1FU1BBQ0VTW25zXSAhPT0geGxzQXR0cmlidXRlc1thdHRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlcl0gZ2VvY29kZSByZXNwb25zZSBcIiArIGF0dCArIFwiIG5hbWVzcGFjZSBpcyBub3QgdGhlIGV4cGVjdGVkIG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3VyIGZpbmlyIG9uIHbDqXJpZmllIGxhIGxvY2FsaXNhdGlvbiBkdSBzY2hlbWEgWFNEIGR1IHNlcnZpY2VcbiAgICAgICAgICAgICAgICBpZiAobnMgPT09IFwic2NoZW1hTG9jYXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUmV2ZXJzZUdlb2NvZGVSZXNwb25zZVJlYWRlci5TQ0hFTUFMT0NBVElPTiAhPT0geGxzQXR0cmlidXRlc1thdHRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyXSBnZW9jb2RlIHJlc3BvbnNlIHNjaGVtYSBsb2NhdGlvbiBpcyBub3QgdGhlIGV4cGVjdGVkIG9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChSZXZlcnNlR2VvY29kZVJlc3BvbnNlUmVhZGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fQ29tbW9uU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1Jlc3BvbnNlX0F1dG9Db21wbGV0ZVJlc3BvbnNlRmFjdG9yeV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1V0aWxzX0hlbHBlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFwcGVsIGR1IHNlcnZpY2UgZCdhdXRvY29tcGzDqXRpb24gZHUgR8Opb3BvcnRhaWwgOlxuICogZW52b2kgZGUgbGEgcmVxdcOqdGUgY29uc3RydWl0ZSBzZWxvbiBsZXMgcGFyYW3DqHRyZXMgZW4gb3B0aW9ucyxcbiAqIMOpdmVudHVlbGxlbWVudCBwYXJzaW5nIGV0IGFuYWx5c2UgIGRlIGxhIHLDqXBvbnNlLFxuICogcmV0b3VyIGQndW5lIHLDqXBvbnNlIGVuIHBhcmFtw6h0cmUgZGUgbGEgZm9uY3Rpb24gb25TdWNjZXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7R3AuU2VydmljZXMuQ29tbW9uU2VydmljZX1cbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5BdXRvQ29tcGxldGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgKCsgbGVzIG9wdGlvbnMgaGVyaXTDqWVzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRleHQgLSBMYSBjaGHDrm5lIGRlIGNhcmFjdMOocmUgw6AgY29tcGzDqXRlci5cbiAqICAgICAgQ2V0dGUgY2hhw65uZSBuJ2VzdCBwYXMgXCJVUkwgZW5jb2TDqWVcIi5cbiAqICAgICAgQydlc3QgbCdBUEkgcXVpIHMnb2NjdXBlIGRlIGwnZW5jb2RlciBwb3VyIGwnaW5jbHVyZSBkYW5zIGxhIHJlcXXDqnRlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSA9IFwiU3RyZWV0QWRkcmVzc1wiXSAtIFR5cGUgZGUgbCdvYmpldCByZWNoZXJjaMOpLlxuICogICAgICBMZSBzZXJ2aWNlIGQnYXV0b2NvbXBsw6l0aW9uIGR1IEfDqW9wb3J0YWlsIHBlcm1ldCBkZSByZWNoZXJjaGVyIGRlcyB0b3BvbnltZXMgJ1Bvc3Rpb25PZkludGVyZXN0JyBldC9vdSBkZXMgYWRyZXNzZXMgcG9zdGFsZXMgJ1N0cmVldEFkZHJlc3MnLlxuICogICAgICBEJ2F1dHJlcyB0eXBlcyBwb3Vycm9udCDDqnRyZSByYWpvdXTDqXMgc2Vsb24gbCfDqXZvbHV0aW9uIGR1IHNlcnZpY2UuXG4gKiAgICAgIFBhciBkw6lmYXV0LCB0eXBlID0gWydTdHJlZXRBZGRyZXNzJ10uXG4gKlxuICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gW29wdGlvbnMuZmlsdGVyT3B0aW9ucy50ZXJyaXRvcnldIC0gTGltaXRhdGlvbiBkZSBsYSB6b25lIGRlIHJlY2hlcmNoZSBkZSBsb2NhbGlzYW50cy5cbiAqICAgICAgTGUgc2VydmljZSBkJ2F1dG9jb21wbMOpdGlvbiBkdSBHw6lvcG9ydGFpbCBwZXJtZXQgZGUgbGltaXRlciBsYSByZWNoZXJjaGUgw6AgbGEgbcOpdHJvcG9sZSBldCBsYSBDb3JzZSA6IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy50ZXJyaXRvcnkgPSBbJ01FVFJPUE9MRSddLFxuICogICAgICBET01TIFRPTVMgOiBvcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5ID0gWydET01UT00nXSwgb3Ugw6AgdW5lIGxpc3RlIGRlIGTDqXBhcnRlbWVudHMgOiBvcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5ID0gWyczMScsICczNCddXG4gKiAgICAgIFBhcyBkZSB2YWxldXIgcGFyIGTDqWZhdXQuXG4gKiAgICAgIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgZG9uYyBjZWxsZSBkdSBzZXJ2aWNlLlxuICogICAgICBMZSBzZXJ2aWNlIGQnYXV0b2NvbXBsw6l0aW9uIGR1IEfDqW9wb3J0YWlsIHJlbnZvaWUgdG91dGVzIGxlcyBpbmZvcm1hdGlvbnMgcXVhbmQgYXVjdW4gdGVycml0b2lyZSBuJ2VzdCBzcMOpY2lmacOpLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzID0gMTBdIC0gTm9tYnJlIGRlIHLDqXBvbnNlcyBtYXhpbWFsIHF1ZSBsJ29uIHNvdWhhaXRlIHJlY2V2b2lyLlxuICogICAgICBQYXMgZGUgdmFsZXVyIHBhciBkw6lmYXV0LlxuICogICAgICBMYSB2YWxldXIgcGFyIGTDqWZhdXQgc2VyYSBkb25jIGNlbGxlIGR1IHNlcnZpY2UgOiAxMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB2YXIgb3B0aW9ucyA9IHtcbiAqICAgICAgLy8gb3B0aW9ucyBjb21tdW5lcyBhdXggc2VydmljZXNcbiAqICAgICAgYXBpS2V5IDogbnVsbCxcbiAqICAgICAgc2VydmVyVXJsIDogJ2h0dHA6Ly9sb2NhbGhvc3Qvc2VydmljZS8nLFxuICogICAgICBwcm90b2NvbCA6ICdKU09OUCcsIC8vIEpTT05QfFhIUlxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICAvLyBzcMOpY2lmaXF1ZSBhdSBzZXJ2aWNlXG4gKiAgICAgIHRleHQgOiBcIlwiLFxuICogICAgICBmaWx0ZXJPcHRpb25zIDoge1xuICogICAgICAgICAgdHlwZSA6IFtcIlN0cmVldEFkZHJlc3NcIl0sXG4gKiAgICAgICAgICB0ZXJyaXRvcnkgOiBbJ01FVFJPUE9MRScsICdET01UT00nLCAnMzEnXVxuICogICAgICB9LFxuICogICAgICBtYXhpbXVtUmVzcG9uc2VzIDogMTBcbiAqICAgfTtcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEF1dG9Db21wbGV0ZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBdXRvQ29tcGxldGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIkF1dG9Db21wbGV0ZVwiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICogRklYTUUgaW5zdGFuY2Ugb3UgY2xhc3NlID9cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiQXV0b0NvbXBsZXRlXCI7XG5cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgcGFyIGhlcml0YWdlXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19Db21tb25TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJHcC5TZXJ2aWNlcy5BdXRvQ29tcGxldGVcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIEF1dG9Db21wbGV0ZSAob3B0aW9ucyldXCIpO1xuXG4gICAgaWYgKCFvcHRpb25zLnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInRleHRcIikpO1xuICAgIH1cblxuICAgIC8vIGFqb3V0IGRlcyBvcHRpb25zIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlXG4gICAgdGhpcy5vcHRpb25zLnRleHQgPSBvcHRpb25zLnRleHQ7XG5cbiAgICAvLyBvbiBkZWZpbml0IGRlcyBmaWx0cmVzIHBhciBkZWZhdXRcbiAgICBpZiAoIW9wdGlvbnMuZmlsdGVyT3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJPcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zID0gb3B0aW9ucy5maWx0ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdGVycml0b3J5IDogW10sXG4gICAgICAgICAgICB0eXBlIDogW1wiU3RyZWV0QWRkcmVzc1wiXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZJWE1FIEVDTUFTY3JpcHQgNSBzdXBwb3J0ICh2YWxhYmxlIHBvdXIgdW4gb2JqZXQgdW5pcXVlbWVudCAhKVxuICAgIC8vIGNlY2kgcGVybWV0IGRlIHRlc3RlciBsZSBjYXMgb8O5IDogb2JqZWN0ID0ge31cbiAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucy5maWx0ZXJPcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0ZXJyaXRvcnkgOiBbXSxcbiAgICAgICAgICAgIHR5cGUgOiBbXCJTdHJlZXRBZGRyZXNzXCJdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMudHlwZSA9IG9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlIHx8IFtcIlN0cmVldEFkZHJlc3NcIl07XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5ID0gb3B0aW9ucy5maWx0ZXJPcHRpb25zLnRlcnJpdG9yeSB8fCBbXTtcbiAgICB0aGlzLm9wdGlvbnMubWF4aW11bVJlc3BvbnNlcyA9IG9wdGlvbnMubWF4aW11bVJlc3BvbnNlcyB8fCAxMDtcblxuICAgIC8vIElORk9cbiAgICAvLyBsZSBzZXJ2aWNlIG5lIHJlcG9uZCBwYXMgZW4gbW9kZSBQT1NUICg0MDUgTWV0aG9kIE5vdCBBbGxvd2VkKVxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvdG9jb2wgPT09IFwiWEhSXCIgJiYgdGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJMZSBzZXJ2aWNlIG5lIGfDqXJlIHBhcyBsZSBtb2RlIGQnaW50ZXJyb2dhdGlvbiBlbiBQT1NULCBvbiBiYXNjdWxlIHN1ciBkdSBHRVQgIVwiKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmh0dHBNZXRob2QgPSBcIkdFVFwiOyAvLyBvbiBzdXJjaGFyZ2UgIVxuICAgIH1cblxuICAgIC8vIGF0dHJpYnV0cyBkJ2luc3RhbmNlc1xuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGZvcmPDqSBkZSBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIDogXCJqc29uXCJcbiAgICAgKiBzYXVmIHNpIGwnb24gc291aGFpdGUgdW5lIHJlcG9uc2UgYnJ1dGUgKG9wdGlvbnMucmF3UmVzcG9uc2UpXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCA9ICh0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UpID8gXCJcIiA6IFwianNvblwiO1xufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6QXV0b0NvbXBsZXRlI1xuICovXG5cbkF1dG9Db21wbGV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZSwge1xuICAgIC8vIHRvZG9cbiAgICAvLyBnZXR0ZXIvc2V0dGVyXG59KTtcblxuLypcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cbkF1dG9Db21wbGV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBdXRvQ29tcGxldGU7XG5cbi8qKlxuICogKG92ZXJ3cml0ZSlcbiAqIENyw6lhdGlvbiBkZSBsYSByZXF1w6p0ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBjYWxsYmFjayBkZXMgZXJyZXVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gKi9cbkF1dG9Db21wbGV0ZS5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0ID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgLy8gZXguXG4gICAgLy8gaHR0cDovL3d4cy5pZ24uZnIvQ0xFRi9vbHMvYXBpcy9jb21wbGV0aW9uP1xuICAgIC8vIHRleHQ9QnJpZS1Db210JlxuICAgIC8vIHR5cGU9U3RyZWV0QWRkcmVzcyxQb3NpdGlvbk9mSW50ZXJlc3QmXG4gICAgLy8gdGVycml0b3J5PU1FVFJPUE9MRSZcbiAgICAvLyBtYXhpbXVtUmVzcG9uc2VzPTEwXG5cbiAgICAvLyB0cmFpdGVtZW50IGRlcyBwYXJhbSBLUFYgc291cyBmb3JtZSBkZSB0YWJsZWF1XG4gICAgdmFyIHRlcnJpdG9yaWVzID0gXCJcIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5KSB7XG4gICAgICAgIHRlcnJpdG9yaWVzID0gdGhpcy5vcHRpb25zLmZpbHRlck9wdGlvbnMudGVycml0b3J5LmpvaW4oXCI7XCIpO1xuICAgIH1cblxuICAgIHZhciB0eXBlcyA9IFwiXCI7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWx0ZXJPcHRpb25zLnR5cGUpIHtcbiAgICAgICAgdHlwZXMgPSB0aGlzLm9wdGlvbnMuZmlsdGVyT3B0aW9ucy50eXBlLmpvaW4oXCIsXCIpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzYXRpb24gZGUgbGEgcmVxdWV0ZSBhdmVjIHBhcmFtIEtQVlxuICAgIHRoaXMucmVxdWVzdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fVXRpbHNfSGVscGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFseXplUGFyYW1ldGVycyh7XG4gICAgICAgIHRleHQgOiBlbmNvZGVVUklDb21wb25lbnQodGhpcy5vcHRpb25zLnRleHQpLFxuICAgICAgICB0eXBlIDogdHlwZXMsXG4gICAgICAgIHRlcnIgOiB0ZXJyaXRvcmllcyxcbiAgICAgICAgbWF4aW11bVJlc3BvbnNlcyA6IHRoaXMub3B0aW9ucy5tYXhpbXVtUmVzcG9uc2VzXG4gICAgfSk7XG5cbiAgICAoIXRoaXMucmVxdWVzdClcbiAgICAgICAgPyBlcnJvci5jYWxsKHRoaXMsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFUVVFU1RfQlVJTERcIikpKVxuICAgICAgICA6IHN1Y2Nlc3MuY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QpO1xufTtcblxuLyoqXG4gKiAob3ZlcndyaXRlKVxuICogQW5hbHlzZSBkZSBsYSByZXBvbnNlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgICAtIGNhbGxiYWNrIGRlcyBlcnJldXJzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIC0gY2FsbGJhY2sgZGUgc3VjY8OocyBkZSBsJ2FuYWx5c2UgZGUgbGEgcsOpcG9uc2VcbiAqL1xuQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5hbmFseXplUmVzcG9uc2UgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlIDogdGhpcy5yZXNwb25zZSxcbiAgICAgICAgICAgIHJhd1Jlc3BvbnNlIDogdGhpcy5vcHRpb25zLnJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgb25TdWNjZXNzIDogc3VjY2VzcyxcbiAgICAgICAgICAgIG9uRXJyb3IgOiBlcnJvcixcbiAgICAgICAgICAgIHNjb3BlIDogdGhpc1xuICAgICAgICB9O1xuXG4gICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fUmVzcG9uc2VfQXV0b0NvbXBsZXRlUmVzcG9uc2VGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IuY2FsbCh0aGlzLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQXV0b0NvbXBsZXRlKTtcblxuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX21vZGVsX0F1dG9Db21wbGV0ZVJlc3BvbnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX21vZGVsX1N1Z2dlc3RlZExvY2F0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcbi8qKlxuICogRmFjdG9yeSBwb3VyIGfDqW7DqXJlciB1bmUgcmVwb25zZSBKU09OIMOgIHBhcnRpciBkJ3VuIFhNTCBvdSBkJ3VuIEpTT05cbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgQXV0b0NvbXBsZXRlUmVzcG9uc2VGYWN0b3J5XG4gKiBAcHJpdmF0ZVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLkF1dG9Db21wbGV0ZS5SZXNwb25zZS5BdXRvQ29tcGxldGVSZXNwb25zZUZhY3RvcnlcbiAqL1xuXG5cblxuXG5cblxudmFyIEF1dG9Db21wbGV0ZVJlc3BvbnNlRmFjdG9yeSA9IHtcblxuICAgIC8qKlxuICAgICAqIGludGVyZmFjZSB1bmlxdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IEFsdGlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgKiAgICAgIHJlc3BvbnNlIDpcbiAgICAgKiAgICAgIG91dHB1dEZvcm1hdCA6XG4gICAgICogICAgICByYXdSZXNwb25zZSA6XG4gICAgICogICAgICBzY29wZSA6XG4gICAgICogICAgICBvblN1Y2Nlc3MgOlxuICAgICAqICAgICAgb25FcnJvciA6XG4gICAgICogICB9O1xuICAgICAqXG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKFwiQXV0b0NvbXBsZXRlUmVzcG9uc2VGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiQXV0b0NvbXBsZXRlUmVzcG9uc2VGYWN0b3J5OjpidWlsZCgpXCJdKTtcblxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJhd1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IHJhd1wiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTT05SZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgSlNPTlJlc3BvbnNlID0gSlNPTi5wYXJzZShvcHRpb25zLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBKU09OUmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgZGUgbGEgcsOpcG9uc2VcbiAgICAgICAgICAgICAgICBpZiAoSlNPTlJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlIHNlcnZpY2UgcmVudm9pZSB0IGlsIHVuZSBlcnJldXIgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoSlNPTlJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleC4gP1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgSlNPTlJlc3BvbnNlLmVycm9yLmRlc2NyaXB0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiBKU09OUmVzcG9uc2UuZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjcsOpYXRpb24gZGUgbCdvYmpldCByw6lwb25zZVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fbW9kZWxfQXV0b0NvbXBsZXRlUmVzcG9uc2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdWNsZSBzdXIgbGVzIHLDqXN1bHRhdHMgZGUgbCdhdXRvY29tcGzDqXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT05SZXNwb25zZS5yZXN1bHRzICYmIEFycmF5LmlzQXJyYXkoSlNPTlJlc3BvbnNlLnJlc3VsdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VnZ2VzdGVkTG9jYXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSlNPTlJlc3BvbnNlLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTlJlc3BvbnNlLnJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkTG9jYXRpb24gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19tb2RlbF9TdWdnZXN0ZWRMb2NhdGlvbl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY291bnRyeSA9PT0gXCJTdHJlZXRBZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZExvY2F0aW9uLnN0cmVldCA9IHJlc3VsdC5zdHJlZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRMb2NhdGlvbi50eXBlID0gXCJTdHJlZXRBZGRyZXNzXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb3VudHJ5ID09PSBcIlBvc2l0aW9uT2ZJbnRlcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0ZWRMb2NhdGlvbi5wb2kgPSByZXN1bHQuc3RyZWV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkTG9jYXRpb24ua2luZCA9IHJlc3VsdC5raW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkTG9jYXRpb24udHlwZSA9IFwiUG9zaXRpb25PZkludGVyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VnZ2VzdGVkTG9jYXRpb24ucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZExvY2F0aW9uLnBvc2l0aW9uLnggPSByZXN1bHQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZExvY2F0aW9uLnBvc2l0aW9uLnkgPSByZXN1bHQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZExvY2F0aW9uLmNvbW11bmUgPSByZXN1bHQuY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkTG9jYXRpb24uZnVsbFRleHQgPSByZXN1bHQuZnVsbHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZExvY2F0aW9uLnBvc3RhbENvZGUgPSByZXN1bHQuemlwY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VnZ2VzdGVkTG9jYXRpb24uY2xhc3NpZmljYXRpb24gPSByZXN1bHQuY2xhc3NpZmljYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFqb3V0IGR1IHLDqXN1bHRhdCBhdSB0YWJsZWF1IHJldmVyc2VHZW9jb2RlZExvY2F0aW9ucyBkZSBnZW9jb2RlZExvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zdWdnZXN0ZWRMb2NhdGlvbnMucHVzaChzdWdnZXN0ZWRMb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9GT1JNQVRfM1wiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnN1Z2dlc3RlZExvY2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0ZPUk1BVF8zXCIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0FOQUxZU0VfMlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9VTktFUlIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgOiAtMVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTaSBsYSByw6lwb25zZSBjb250ZW5haXQgdW5lIGV4Y2VwdGlvbiByZW52b3nDqWUgcGFyIGxlIHNlcnZpY2VcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBkYXRhLmV4Y2VwdGlvblJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpIGxhIHLDqXBvbnNlICh4bWxTdHJpbmcpIGVzdCB2aWRlLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGQnZXJyZXVyXG4gICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgdG91dCBzJ2VzdCBiaWVuIHBhc3PDqSwgb24gYXBwZWxsZSBsZSBjYWxsYmFjayBkZSBzdWNjw6hzXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSwgZGF0YSk7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChBdXRvQ29tcGxldGVSZXNwb25zZUZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fQ29tbW9uU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0RlZmF1bHRVcmxTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fUmVxdWVzdF9Sb3V0ZVJlcXVlc3RGYWN0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Jlc3BvbnNlX1JvdXRlUmVzcG9uc2VGYWN0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQXBwZWwgZHUgc2VydmljZSBkJ2l0aW7DqXJhaXJlIGR1IEfDqW9wb3J0YWlsIDpcbiAqICAgICBlbnZvaSBkZSBsYSByZXF1w6p0ZSBjb25zdHJ1aXRlIHNlbG9uIGxlcyBwYXJhbcOodHJlcyBlbiBvcHRpb25zLFxuICogICAgIMOpdmVudHVlbGxlbWVudCBwYXJzaW5nIGV0IGFuYWx5c2UgIGRlIGxhIHLDqXBvbnNlLFxuICogICAgIHJldG91ciBkJ3VuZSByw6lwb25zZSBlbiBwYXJhbcOodHJlIGRlIGxhIGZvbmN0aW9uIG9uU3VjY2Vzcy5cbiAqXG4gKiBAYWxpYXMgR3AuU2VydmljZXMuUm91dGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0dwLlNlcnZpY2VzLkNvbW1vblNlcnZpY2V9XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgc3DDqWNpZmlxdWVzIGF1IHNlcnZpY2UgKCsgbGVzIG9wdGlvbnMgaGVyaXTDqWVzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hcGldIC0gTWFuacOocmUgZCdhY2PDqWRlciBhdSBzZXJ2aWNlIDogJ1JFU1QnICh2aWEgbCdBUEkgUkVTVCkgb3UgJ09MUycgKHZpYSBsYSBub3JtZSBYTFMpLlxuICogUGFyIGTDqWZhdXQsIG9uIHV0aWxpc2UgbCdBUEkgUkVTVC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vdXRwdXRGb3JtYXQgLSBMZSBmb3JtYXQgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSBpdGluZXJhaXJlIDogJ3htbCcgb3UgJ2pzb24nLlxuICogICAgICBDZSBwYXJhbcOodHJlIGTDqXRlcm1pbmVyYSBsJ2V4dGVuc2lvbiAnLnhtbCcgb3UgJy5qc29uJyBkdSBzZXJ2aWNlIGRhbnMgbGUgY2FzIGRlIGwnQVBJIFJFU1QuXG4gKiAgICAgIE7DqWNlc3NhaXJlIHNpIHNlcnZlclVybCBlc3QgcmVuc2VpZ27DqSwgZXQgcXUnb24gc291aGFpdGUgcGFzc2VyIHBhciBsJ0FQSSBSRVNULFxuICogICAgICBwb3VyIGNvbm5hw650cmUgbGUgZm9ybWF0IGRhbnMgbGVxdWVsIHNlcmEgZm91cm5pZSBsYSByw6lwb25zZSAocG91ciBzb24gdHJhaXRlbWVudCkuXG4gKiAgICAgIE5vbiBuw6ljZXNzYWlyZSBwb3VyIGxhIG5vcm1lIE9MUy4gUGFyIGTDqWZhdXQsIGNlIHBhcmFtw6h0cmUgdmF1dCAnanNvbicuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJvdXRlUHJlZmVyZW5jZSA9IFwiZmFzdGVzdFwiXSAtIE1vZGUgZGUgY2FsY3VsIMOgIHV0aWxpc2VyIDpcbiAqIC0gbGUgcGx1cyByYXBpZGUgwqsgZmFzdGVzdCDCu1xuICogLSBsZSBwbHVzIGNvdXJ0IMKrIHNob3J0ZXN0IMK7XG4gKiBQYXIgZMOpZmF1dCA6IMKrIGZhc3Rlc3QgwrsuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc3RhcnRQb2ludCAtIFBvaW50IGRlIGTDqXBhcnQgZHUgY2FsY3VsLiBDb29yZG9ubsOpZXMgZXhwcmltw6llcyBlbiBsb25naXR1ZGVzLCBsYXRpdHVkZXMgKEVQU0c6NDMyNilcbiAqIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuc3RhcnRQb2ludC54IC0gQWJjaXNzZSBkdSBwb2ludCBkZSBkw6lwYXJ0IGR1IGNhbGN1bCBkJ2l0aW7DqXJhaXJlLlxuICogQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5zdGFydFBvaW50LnkgLSBPcmRvbm7DqWUgZHUgcG9pbnQgZGUgZMOpcGFydCBkdSBjYWxjdWwgZCdpdGluw6lyYWlyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5lbmRQb2ludCAtIFBvaW50IGQnYXJyaXbDqWUgZHUgY2FsY3VsLiBDb29yZG9ubsOpZXMgZXhwcmltw6llcyBlbiBsb25naXR1ZGVzLCBsYXRpdHVkZXMgKEVQU0c6NDMyNilcbiAqIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuZW5kUG9pbnQueCAtIEFiY2lzc2UgZHUgcG9pbnQgZCdhcnJpdsOpZSBkdSBjYWxjdWwgZCdpdGluw6lyYWlyZS5cbiAqIEBwYXJhbSB7RmxvYXR9IG9wdGlvbnMuZW5kUG9pbnQueSAtIE9yZG9ubsOpZSBkdSBwb2ludCBkJ2Fycml2w6llIGR1IGNhbGN1bCBkJ2l0aW7DqXJhaXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLnZpYVBvaW50c10gLSBMaXN0ZSBkZSBwb2ludCAoe3g6RmxvYXQseTpGbG9hdH0pIGludGVybcOpZGFpcmVzIHF1ZSBsJ2l0aW7DqXJhaXJlIGRvaXQgZW1wcnVudGVyIGRhbnMgbCdvcmRyZSBkdSB0YWJsZWF1LlxuICogICAgICBDb29yZG9ubsOpZXMgZXhwcmltw6llcyBlbiBsb25naXR1ZGVzLCBsYXRpdHVkZXMgKEVQU0c6NDMyNikgOnt4OmZsb2F0LCB5OmZsb2F0fVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ncmFwaCA9IFwidm9pdHVyZVwiXSAtIFR5cGUgZGUgZ3JhcGhlIHV0aWxpc8OpIDogXCJWb2l0dXJlXCIgb3UgXCJQaWV0b25cIi5cbiAqICAgICAgRMOpdGVybWluZSBsZSBwcm9maWwgZGUgdml0ZXNzZXMgdXRpbGlzw6kgcG91ciBsZSBjYWxjdWwgYWluc2kgcXVlIGxlcyB0cm9uw6dvbnMgYXV0b3Jpc8OpcyBvdSBub24uXG4gKiAgICAgIFBhciBkw6lmYXV0LCBjJ2VzdCBsYSB2YWxldXIgXCJWb2l0dXJlXCIgcXVpIHNlcmEgdXRpbGlzw6llLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nW119IFtvcHRpb25zLmV4Y2x1c2lvbnNdIC0gQ3JpdMOocmVzIGQnZXhjbHVzaW9ucyDDoCBhcHBsaXF1ZXIgcG91ciBsZSBjYWxjdWwuIChjb3JyZXNwb25kIGF1IHBhcmFtw6h0cmUgXCJhdm9pZEZlYXR1cmVcIiBkJ09wZW5MUylcbiAqICAgICAgT24gcHLDqWNpc2UgaWNpIGxlIHR5cGUgZGUgdHJvbsOnb25zIHF1ZSBsJ29uIG5lIHZldXQgcGFzIHF1ZSBsJ2l0aW7DqXJhaXJlIGVtcHJ1bnRlXG4gKiAgICAgICh2YWxldXJzIHBvc3NpYmxlcyA6IMKrIHRvbGwgwrsgKMOpdml0ZXIgbGVzIHDDqWFnZXMpLCDCqyBicmlkZ2UgwrssIMKrIHR1bm5lbCDCuykuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZW9tZXRyeUluSW5zdHJ1Y3Rpb25zID0gZmFsc2VdIC0gSW5kaXF1ZSBzaSBsYSBnw6lvbcOpdHJpZSBkZSBsJ2l0aW7DqXJhaXJlIGRvaXQgw6p0cmUgcmVwcmlzZSBtb3JjZWF1IHBhciBtb3JjZWF1IGRhbnMgbGVzIGluc3RydWN0aW9ucy5cbiAqICAgICAgKGNvcnJlc3BvbmQgYXUgcGFyYW3DqHRyZSBcInByb3ZpZGVHZW9tZXRyeVwiIGQnT3BlbkxTKSBQYXIgZMOpZmF1dCA6IGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucHJvdmlkZUJib3ggPSB0cnVlXSAtIEluZGlxdWUgc2kgbGVzIGluc3RydWN0aW9ucyBkb2l2ZW50IMOqdHJlIGxvY2FsaXPDqWVzIHBhciB1bmUgYmJveCBkYW5zIGxhIHLDqXBvbnNlLlxuICogICAgICBQYXIgZMOpZmF1dCA6IHRydWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRpc3RhbmNlVW5pdCA9IFwia21cIl0gLSBJbmRpcXVlIHNpIGxhIGRpc3RhbmNlIGRvaXQgw6p0cmUgZXhwcmltw6llIGVuIGttIG91IG0gZGFucyBsYSByw6lwb25zZS5cbiAqICAgICAgUGFyIGTDqWZhdXQgOiBrbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuc3JzXSAtIFN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyBkYW5zIGxlcXVlbCBsZXMgcGFyYW3DqHRyZXMgZ8Opb2dyYXBoaXF1ZXMgZW4gZW50csOpZSBldCBsYSByw6lwb25zZSBkdSBzZXJ2aWNlIHNvbnQgZXhwcmltw6lzLlxuICogICAgICBQYXMgZGUgdmFsZXVyIHBhciBkw6lmYXV0LiBTaSBsZSBzZXJ2ZXVyIGNvbnN1bHTDqSBlc3QgY2VsdWkgZHUgR8Opb3BvcnRhaWwsIGxhIHZhbGV1ciBwYXIgZMOpZmF1dCBzZXJhIGRvbmMgY2VsbGUgZHUgc2VydmljZSA6ICdFUFNHOjQzMjYnLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgdmFyIG9wdGlvbnMgPSB7XG4gKiAgICAgIC8vIG9wdGlvbnMgY29tbXVuZXMgYXV4IHNlcnZpY2VzXG4gKiAgICAgIGFwaUtleSA6IG51bGwsXG4gKiAgICAgIHNlcnZlclVybCA6ICdodHRwOi8vbG9jYWxob3N0L3NlcnZpY2UvJyxcbiAqICAgICAgcHJvdG9jb2wgOiAnSlNPTlAnLCAvLyBKU09OUHxYSFJcbiAqICAgICAgcHJveHlVUkwgOiBudWxsLFxuICogICAgICBodHRwTWV0aG9kIDogJ0dFVCcsIC8vIEdFVHxQT1NUXG4gKiAgICAgIHRpbWVPdXQgOiAxMDAwMCwgLy8gbXNcbiAqICAgICAgcmF3UmVzcG9uc2UgOiBmYWxzZSwgLy8gdHJ1ZXxmYWxzZVxuICogICAgICBzY29wZSA6IG51bGwsIC8vIHRoaXNcbiAqICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7fSxcbiAqICAgICAgb25GYWlsdXJlIDogZnVuY3Rpb24gKGVycm9yKSB7fSxcbiAqICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICogICAgICBhcGkgOiAnT0xTJyxcbiAqICAgICAgb3V0cHV0Rm9ybWF0IDogJ3htbCcsXG4gKiAgICAgIHN0YXJ0UG9pbnQgOiB7XG4gKiAgICAgICAgICB4IDogNDIuMTEyMSxcbiAqICAgICAgICAgIHkgOiAxLjU1NTdcbiAqICAgICAgfSxcbiAqICAgICAgZW5kUG9pbnQgOiB7XG4gKiAgICAgICAgICB4IDogNDIuMTEyMSxcbiAqICAgICAgICAgIHkgOiAxLjU1NTdcbiAqICAgICAgfSxcbiAqICAgICAgcHJvdmlkZUJib3ggOiBmYWxzZSxcbiAqICAgICAgZXhjbHVzaW9ucyA6IFtcIkJyaWRnZVwiLCBcIlR1bm5lbFwiLCBcIlRvbGxcIl0sXG4gKiAgICAgIGRpc3RhbmNlVW5pdCA6IFwia21cIixcbiAqICAgICAgZ3JhcGggOiBcIlZvaXR1cmVcIixcbiAqICAgICAgZ2VvbWV0cnlJbkluc3RydWN0aW9ucyA6IGZhbHNlLFxuICogICAgICByb3V0ZVByZWZlcmVuY2UgOiBcImZhc3Rlc3RcIlxuICogIH07XG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUm91dGUgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUm91dGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIlJvdXRlXCIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlIChoZXJpdGFnZSlcbiAgICAgKiBGSVhNRSBpbnN0YW5jZSBvdSBjbGFzc2UgP1xuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NOQU1FID0gXCJSb3V0ZVwiO1xuXG4gICAgLy8gYXBwZWwgZHUgY29uc3RydWN0ZXVyIHBhciBoZXJpdGFnZVxuICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fQ29tbW9uU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKFwiR3AuU2VydmljZXMuUm91dGVcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJvdXRlIChvcHRpb25zKV1cIik7XG5cbiAgICBpZiAoIW9wdGlvbnMuc3RhcnRQb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9NSVNTSU5HXCIsIFwic3RhcnRQb2ludFwiKSk7XG4gICAgfVxuXG4gICAgLy8gb24gbGFuY2UgdW5lIGV4Y2VwdGlvbiBhZmluIGQnZXZpdGVyIGF1IHNlcnZpY2UgZGUgbGUgZmFpcmUuLi5cbiAgICBpZiAob3B0aW9ucy5zdGFydFBvaW50LnggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fTUlTU0lOR1wiLCBcInN0YXJ0UG9pbnQueFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnRQb2ludC55ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJzdGFydFBvaW50LnlcIikpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5lbmRQb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9NSVNTSU5HXCIsIFwiZW5kUG9pbnRcIikpO1xuICAgIH1cblxuICAgIC8vIG9uIGxhbmNlIHVuZSBleGNlcHRpb24gYWZpbiBkJ2V2aXRlciBhdSBzZXJ2aWNlIGRlIGxlIGZhaXJlLi4uXG4gICAgaWYgKG9wdGlvbnMuZW5kUG9pbnQueCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9NSVNTSU5HXCIsIFwiZW5kUG9pbnQueFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZW5kUG9pbnQueSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9NSVNTSU5HXCIsIFwiZW5kUG9pbnQueVwiKSk7XG4gICAgfVxuXG4gICAgLy8gb3B0aW9ucyBwYXIgZGVmYXV0XG4gICAgLy8gb24gcGFzc2UgbCdvcHRpb24gYXBpIGVuIG1hanVzY3VsZXMgYWZpbiBkJ8Opdml0ZXIgZGVzIGV4Y2VwdGlvbnMuXG4gICAgdGhpcy5vcHRpb25zLmFwaSA9ICh0eXBlb2Ygb3B0aW9ucy5hcGkgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5hcGkudG9VcHBlckNhc2UoKSA6IFwiUkVTVFwiO1xuXG4gICAgLy8gb24gcGFzc2UgbCdvcHRpb24gb3V0cHV0Rm9ybWF0IGVuIG1pbnVzY3VsZXMgYWZpbiBkJ8Opdml0ZXIgZGVzIGV4Y2VwdGlvbnMuXG4gICAgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCA9ICh0eXBlb2Ygb3B0aW9ucy5vdXRwdXRGb3JtYXQgPT09IFwic3RyaW5nXCIpID8gb3B0aW9ucy5vdXRwdXRGb3JtYXQudG9Mb3dlckNhc2UoKSA6IFwianNvblwiO1xuXG4gICAgdGhpcy5vcHRpb25zLnN0YXJ0UG9pbnQgPSBvcHRpb25zLnN0YXJ0UG9pbnQ7XG4gICAgdGhpcy5vcHRpb25zLmVuZFBvaW50ID0gb3B0aW9ucy5lbmRQb2ludDtcbiAgICB0aGlzLm9wdGlvbnMudmlhUG9pbnRzID0gb3B0aW9ucy52aWFQb2ludHMgfHwgbnVsbDsgLy8gSU5GTyBtYXBwaW5nIHZpYVBvaW50cyA8PT4geGxzOnZpYVBvaW50XG4gICAgdGhpcy5vcHRpb25zLmV4Y2x1c2lvbnMgPSBvcHRpb25zLmV4Y2x1c2lvbnMgfHwgbnVsbDsgLy8gSU5GTyBtYXBwaW5nIGV4Y2x1c2lvbnMgPD0+IHhsczphdm9pZEZlYXR1cmVcbiAgICB0aGlzLm9wdGlvbnMucm91dGVQcmVmZXJlbmNlID0gb3B0aW9ucy5yb3V0ZVByZWZlcmVuY2UgfHwgXCJmYXN0ZXN0XCI7XG4gICAgdGhpcy5vcHRpb25zLmdyYXBoID0gb3B0aW9ucy5ncmFwaCB8fCBcIlZvaXR1cmVcIjtcbiAgICB0aGlzLm9wdGlvbnMuZ2VvbWV0cnlJbkluc3RydWN0aW9ucyA9IG9wdGlvbnMuZ2VvbWV0cnlJbkluc3RydWN0aW9ucyB8fCBmYWxzZTsgLy8gSU5GTyBtYXBwaW5nIGdlb21ldHJ5SW5JbnN0cnVjdGlvbnMgPD0+IHhsczpwcm92aWRlR2VvbWV0cnlcbiAgICB0aGlzLm9wdGlvbnMucHJvdmlkZUJib3ggPSBvcHRpb25zLnByb3ZpZGVCYm94IHx8IHRydWU7IC8vIElORk8gbWFwcGluZyBwcm92aWRlQmJveCA8PT4geGxzOnByb3ZpZGVCb3VuZGluZ0JveFxuICAgIHRoaXMub3B0aW9ucy5kaXN0YW5jZVVuaXQgPSBvcHRpb25zLmRpc3RhbmNlVW5pdCB8fCBcImttXCI7XG4gICAgdGhpcy5vcHRpb25zLmV4cGVjdGVkU3RhcnRUaW1lID0gbnVsbDsgLy8gRklYTUUgbm90IHlldCBpbXBsZW1lbnRlZCAhXG4gICAgdGhpcy5vcHRpb25zLnNycyA9IG9wdGlvbnMuc3JzIHx8IFwiRVBTRzo0MzI2XCI7XG5cbiAgICAvLyBGSVhNRSA6IGxlcyByZWFkZXJzIE9MUyBuZSBzb250IHBhcyBpbXBsw6ltZW50w6lzLiBvbiB1dGlsaXNlIGRvbmMgbCdBUEkgUkVTVC5cbiAgICB0aGlzLm9wdGlvbnMuYXBpID0gXCJSRVNUXCI7XG4gICAgdGhpcy5sb2dnZXIud2FybihcIkZJWE1FIDogU3VyY2hhcmdlIG9wdGlvbiAnYXBpJyA6IFJFU1RcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gXCJYSFJcIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaHR0cE1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU3VyY2hhcmdlIG9wdGlvbiAnSHR0cE1ldGhvZCcgOiBcIiArIHRoaXMub3B0aW9ucy5odHRwTWV0aG9kKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgcGFyIGRlZmF1dFxuICAgIC8vIHNpIGwndXJsIG4nZXN0IHBhcyByZW5zZWlnbsOpZSwgaWwgZmF1dCB1dGlsaXNlciBsZXMgdXJscyBwYXIgZGVmYXV0XG4gICAgLy8gZW4gZm9uY3Rpb24gZHUgdHlwZSBkJ2FwaSwgUkVTVCBvdSBPTFNcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwpIHtcbiAgICAgICAgdmFyIGxzdFVybEJ5RGVmYXVsdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRGVmYXVsdFVybFNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5Sb3V0ZS51cmwodGhpcy5vcHRpb25zLmFwaUtleSk7XG4gICAgICAgIHZhciB1cmxGb3VuZCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLmFwaSkge1xuICAgICAgICAgICAgY2FzZSBcIk9MU1wiOlxuICAgICAgICAgICAgICAgIHVybEZvdW5kID0gbHN0VXJsQnlEZWZhdWx0Lm9scztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRVNUXCI6XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IFwicm91dGVcIiArIFwiLVwiICsgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdDtcbiAgICAgICAgICAgICAgICB1cmxGb3VuZCA9IGxzdFVybEJ5RGVmYXVsdFtrZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9VTktOT1dOXCIsIFwiYXBpXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsRm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVybCBieSBkZWZhdWx0IG5vdCBmb3VuZCAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSB1cmxGb3VuZDtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJTZXJ2ZXVyIFVSTCBwYXIgZGVmYXV0IDogXCIgKyB0aGlzLm9wdGlvbnMuc2VydmVyVXJsKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGR1IHR5cGUgZGUgc2VydmljZVxuICAgIC8vIHNpIGwnZXh0ZW5zaW9uIGRlIGwndXJsIGVzdCAuanNvbiBvdSAueG1sLCBvbiBzdXJjaGFyZ2UgbGUgZm9ybWF0IGRlIHNvcnRpZSAob3V0cHV0Rm9ybWF0KVxuICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLnNlcnZlclVybC5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmxlbmd0aCA8IDUpIHsgLy8gRklYTUUgZXh0ZW5zaW9uIGRlIG1vaW5zIGRlIDQgY2FyLiAuLi5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmV1ciBFeHRlbnNpb24gVVJMIDogXCIgKyBleHRlbnNpb24pO1xuICAgICAgICAgICAgc3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgb2Ygc2VydmljZSA6IHVua25vd24gb3IgdW5zdXBwb3J0ZWQgKGpzb24gb3IgeG1sKSAhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6Um91dGUjXG4gKi9cblJvdXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Db21tb25TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLCB7XG4gICAgLy8gdG9kb1xuICAgIC8vIGdldHRlci9zZXR0ZXJcbn0pO1xuXG4vKlxuICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAqL1xuUm91dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm91dGU7XG5cbi8qKlxuICogKG92ZXJ3cml0ZSlcbiAqIENyw6lhdGlvbiBkZSBsYSByZXF1w6p0ZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBjYWxsYmFjayBkZXMgZXJyZXVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gKi9cblJvdXRlLnByb3RvdHlwZS5idWlsZFJlcXVlc3QgPSBmdW5jdGlvbiAoZXJyb3IsIHN1Y2Nlc3MpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICAgICAgICBhcGkgOiB0aGlzLm9wdGlvbnMuYXBpLFxuICAgICAgICBzdGFydFBvaW50IDogdGhpcy5vcHRpb25zLnN0YXJ0UG9pbnQsXG4gICAgICAgIGVuZFBvaW50IDogdGhpcy5vcHRpb25zLmVuZFBvaW50LFxuICAgICAgICB2aWFQb2ludHMgOiB0aGlzLm9wdGlvbnMudmlhUG9pbnRzLFxuICAgICAgICBwcm92aWRlQmJveCA6IHRoaXMub3B0aW9ucy5wcm92aWRlQmJveCxcbiAgICAgICAgZXhjbHVzaW9ucyA6IHRoaXMub3B0aW9ucy5leGNsdXNpb25zLFxuICAgICAgICBkaXN0YW5jZVVuaXQgOiB0aGlzLm9wdGlvbnMuZGlzdGFuY2VVbml0LFxuICAgICAgICBncmFwaCA6IHRoaXMub3B0aW9ucy5ncmFwaCxcbiAgICAgICAgZ2VvbWV0cnlJbkluc3RydWN0aW9ucyA6IHRoaXMub3B0aW9ucy5nZW9tZXRyeUluSW5zdHJ1Y3Rpb25zLFxuICAgICAgICByb3V0ZVByZWZlcmVuY2UgOiB0aGlzLm9wdGlvbnMucm91dGVQcmVmZXJlbmNlLFxuICAgICAgICBzcnMgOiB0aGlzLm9wdGlvbnMuc3JzXG4gICAgfTtcblxuICAgIHRoaXMucmVxdWVzdCA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fUmVxdWVzdF9Sb3V0ZVJlcXVlc3RGYWN0b3J5X19bXCJhXCIgLyogZGVmYXVsdCAqL10uYnVpbGQob3B0aW9ucyk7XG5cbiAgICAvLyBvbiB0ZXN0ZSBzaSBsYSByZXF1ZXRlIGEgYmllbiDDqXTDqSBjb25zdHJ1aXRlICFcbiAgICBpZiAoIXRoaXMucmVxdWVzdCkge1xuICAgICAgICBlcnJvci5jYWxsKHRoaXMsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFUVVFU1RfQlVJTERcIikpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdWNjZXNzLmNhbGwodGhpcywgdGhpcy5yZXF1ZXN0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIChvdmVyd3JpdGUpXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICovXG5Sb3V0ZS5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgLy8gSU5GT1xuICAgIC8vIEZhY3RvcnkgcG91ciBtYXNxdWVyIGxhIGNvbXBsZXhpdMOpIGR1IHJldG91ciBkdSBzZXJ2aWNlIHF1aSByZW52b2llIHNvaXRcbiAgICAvLyAgLSB1bmUgJ3N0cmluZycgcXVpIGNvbnRpZW50IGR1IFhNTCBvdSBKU09OIG5hdGlmIGVuIG1vZGUgWEhSXG4gICAgLy8gIC0gdW4gb2JqZXQgSlNPTiBxdWkgZXN0IG5hdGlmIG91IGVuY2Fwc3Vsw6lcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZGlzdGFuY2VVbml0IDogdGhpcy5vcHRpb25zLmRpc3RhbmNlVW5pdCwgLy8gRklYTUUgY2UgcGFyYW1ldHJlIG5vdXMgcGVybWV0IGRlIGNob2lzaXIgbGUgdHlwZSBkJ3VuaXTDqSBkYW5zIGxhIHJlcG9uc2UgIVxuICAgICAgICAgICAgcmVzcG9uc2UgOiB0aGlzLnJlc3BvbnNlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCwgLy8gdXRpbGUgcG91ciBwYXJzZXIgbGEgc3RyaW5nIGVuIG1vZGUgWEhSIDogSlNPTiBvdSBYTUwgIVxuICAgICAgICAgICAgYXBpIDogdGhpcy5vcHRpb25zLmFwaSwgLy8gdXRpbGUgZGUgY29ubmFpdHJlIGxlIHR5cGUgZCdBUEkgY2FyIGxhIHJlcG9uc2UgZXN0IGRpZmZlcmVudGUgIVxuICAgICAgICAgICAgcmF3UmVzcG9uc2UgOiB0aGlzLm9wdGlvbnMucmF3UmVzcG9uc2UsXG4gICAgICAgICAgICBvbkVycm9yIDogZXJyb3IsXG4gICAgICAgICAgICBvblN1Y2Nlc3MgOiBzdWNjZXNzLFxuICAgICAgICAgICAgc2NvcGUgOiB0aGlzXG4gICAgICAgIH07XG5cbiAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19SZXNwb25zZV9Sb3V0ZVJlc3BvbnNlRmFjdG9yeV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJ1aWxkKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yLmNhbGwodGhpcywgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRU1QVFlcIikpKTtcbiAgICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFJvdXRlKTtcblxuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19Sb3V0ZVJlcXVlc3RPTFNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fUm91dGVSZXF1ZXN0UkVTVF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG4vKipcbiAqIENyZWF0aW9uIGQndW5lIHJlcXXDqnRlIE9wZW5MUyBvdSBSRVNUIGVuIG1vZGUgUE9TVCBvdSBHRVRcbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgUm91dGVSZXF1ZXN0RmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlJvdXRlLlJlcXVlc3QuUm91dGVSZXF1ZXN0RmFjdG9yeVxuICogQHByaXZhdGVcbiAqL1xuXG5cblxuXG5cbnZhciBSb3V0ZVJlcXVlc3RGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgUm91dGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAvLyB1dGlsaXNhdGlvbiBhdmVjIGxlcyBjYWxsYmFja1xuICAgICAqICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICAoLi4uKVxuICAgICAqICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7fSxcbiAgICAgKiAgICAgIG9uRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICAgICAqICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICAgICAqICAgICAgYXBpIDogJ09MUycsXG4gICAgICogICAgICBzdGFydFBvaW50IDoge1xuICAgICAqICAgICAgICAgIHggOiA0Mi4xMTIxLFxuICAgICAqICAgICAgICAgIHkgOiAxLjU1NTdcbiAgICAgKiAgICAgIH0sXG4gICAgICogICAgICBlbmRQb2ludCA6IHtcbiAgICAgKiAgICAgICAgICB4IDogNDIuMTEyMSxcbiAgICAgKiAgICAgICAgICB5IDogMS41NTU3XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAgcHJvdmlkZUJib3ggOiBmYWxzZSxcbiAgICAgKiAgICAgIGV4Y2x1c2lvbnMgOiBbXCJCcmlkZ2VcIiwgXCJUdW5uZWxcIiwgXCJUb2xsXCJdLFxuICAgICAqICAgICAgZGlzdGFuY2VVbml0IDogXCJrbVwiLFxuICAgICAqICAgICAgZ3JhcGggOiBcIlZvaXR1cmVcIixcbiAgICAgKiAgICAgIGdlb21ldHJ5SW5JbnN0cnVjdGlvbnMgOiBmYWxzZSxcbiAgICAgKiAgICAgIHJvdXRlUHJlZmVyZW5jZSA6IFwiZmFzdGVzdFwiXG4gICAgICogICB9O1xuICAgICAqICAgUm91dGVSZXF1ZXN0RmFjdG9yeS5idWlsZChvcHRpb25zKTtcbiAgICAgKlxuICAgICAqICAgLy8gdXRpbGlzYXRpb24gc2FucyBjYWxsYmFja1xuICAgICAqICAgdmFyIG9wdGlvbnMgPSB7Li4ufTtcbiAgICAgKiAgIHRyeSB7XG4gICAgICogICAgICB2YXIgcmVzdWx0ID0gUm91dGVSZXF1ZXN0RmFjdG9yeS5idWlsZChvcHRpb25zKTtcbiAgICAgKiAgICAgIGlmICghIHJlc3VsdCkgeyB0aHJvdyBuZXcgRXJyb3IoXCIuLi5cIik6fVxuICAgICAqICAgfSBjYXRjaCAoZSkge1xuICAgICAqICAgICAgLy8gdG9kb1xuICAgICAqICAgfVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlcXVlc3RcbiAgICAgKi9cbiAgICBidWlsZCA6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIGxvZ2dlclxuICAgICAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJSb3V0ZVJlcXVlc3RGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiUm91dGVSZXF1ZXN0RmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gZ2VzdGlvbiBkZXMgY2FsbGJhY2tcbiAgICAgICAgdmFyIGJPbkVycm9yID0gISEoKG9wdGlvbnMub25FcnJvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy5vbkVycm9yID09PSBcImZ1bmN0aW9uXCIpKTtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IG51bGw7XG4gICAgICAgIC8vIGNob2l4IGVudHJlIGxlcyAyIHR5cGVzIGQnQVBJIHBvdXIgY29uc3VsdGVyIGxlIHNlcnZpY2VcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmFwaSkge1xuICAgICAgICAgICAgY2FzZSBcIlJFU1RcIjpcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBsZXMgZXhjZXB0aW9ucyBuZSBzb250IHBhcyAnY2F0Y2jDqWVzJyBzdXIgbGUgY29uc3RydWN0ZXVyICFcbiAgICAgICAgICAgICAgICB2YXIgbXlSZXEgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Sb3V0ZVJlcXVlc3RSRVNUX19bXCJhXCIgLyogZGVmYXVsdCAqL10oc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghbXlSZXEucHJvY2Vzc1JlcXVlc3RTdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJFcnJvciBwcm9jZXNzIHJlcXVlc3QgKHJlc3QpICFcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBteVJlcS5yZXF1ZXN0U3RyaW5nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9MU1wiOlxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1JvdXRlUmVxdWVzdE9MU19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJ1aWxkKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiRXJyb3IgcHJvY2VzcyByZXF1ZXN0IChvbHMpICFcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJUeXBlIG9mIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZpY2UgKFJFU1Qgb3IgT0xTKSAhXCI7XG4gICAgICAgICAgICAgICAgaWYgKGJPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10obWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXF1ZXN0RmFjdG9yeSk7XG5cblxuLyoqKi8gfSksXG4vKiA4NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Zvcm1hdHNfWExTX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0Zvcm1hdHNfWExTX1JvdXRlU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG4vKipcbiAqIENyZWF0aW9uIGQndW5lIHJlcXXDqnRlIE9wZW5MUyBlbiBtb2RlIFBPU1Qgb3UgR0VUXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIFJvdXRlUmVxdWVzdE9MU1xuICogQGFsaWFzIEdwLlNlcnZpY2VzLlJvdXRlLlJlcXVlc3QuUm91dGVSZXF1ZXN0T0xTXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuXG5cbnZhciBSb3V0ZVJlcXVlc3RPTFMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcmZhY2UgdW5pcXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBkZWZpbmllcyBkYW5zIGxlIGNvbXBvc2FudCBSb3V0ZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgICAgKC4uLilcbiAgICAgKiAgIH07XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXF1ZXN0XG4gICAgICovXG4gICAgYnVpbGQgOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvLyBsb2dnZXJcbiAgICAgICAgdmFyIGxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKFwiUm91dGVSZXF1ZXN0T0xTXCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoW1wiUm91dGVSZXF1ZXN0T0xTOjpidWlsZCgpXCJdKTtcblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBzdGFydFBvaW50IDogb3B0aW9ucy5zdGFydFBvaW50LFxuICAgICAgICAgICAgZW5kUG9pbnQgOiBvcHRpb25zLmVuZFBvaW50LFxuICAgICAgICAgICAgdmlhUG9pbnQgOiBvcHRpb25zLnZpYVBvaW50cywgLy8gbWFwcGluZyBPTFMgZXQgb3B0aW9uc1xuICAgICAgICAgICAgcHJvdmlkZUJvdW5kaW5nQm94IDogb3B0aW9ucy5wcm92aWRlQmJveCwgLy8gbWFwcGluZyBPTFMgZXQgb3B0aW9uc1xuICAgICAgICAgICAgYXZvaWRGZWF0dXJlIDogb3B0aW9ucy5leGNsdXNpb25zLCAvLyBtYXBwaW5nIE9MUyBldCBvcHRpb25zXG4gICAgICAgICAgICBleHBlY3RlZFN0YXJ0VGltZSA6IG9wdGlvbnMuZXhwZWN0ZWRTdGFydFRpbWUsIC8vIFRPRE8gZm9ybWF0ID9cbiAgICAgICAgICAgIGRpc3RhbmNlVW5pdCA6IG9wdGlvbnMuZGlzdGFuY2VVbml0LFxuICAgICAgICAgICAgZ3JhcGggOiBvcHRpb25zLmdyYXBoLFxuICAgICAgICAgICAgcHJvdmlkZUdlb21ldHJ5IDogb3B0aW9ucy5nZW9tZXRyeUluSW5zdHJ1Y3Rpb25zLCAvLyBtYXBwaW5nIE9MUyBldCBvcHRpb25zXG4gICAgICAgICAgICByb3V0ZVByZWZlcmVuY2UgOiBvcHRpb25zLnJvdXRlUHJlZmVyZW5jZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG9iamV0IFJvdXRlU2VydmljZVxuICAgICAgICB2YXIgb1JTID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRm9ybWF0c19YTFNfUm91dGVTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oc2V0dGluZ3MpO1xuXG4gICAgICAgIC8vIEZvcm1hdCBYTFNcbiAgICAgICAgdmFyIG9YTFMgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19Gb3JtYXRzX1hMU19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgIHNyc05hbWUgOiBvcHRpb25zLnNycyxcbiAgICAgICAgICAgIG1heGltdW1SZXNwb25zZXMgOiBvcHRpb25zLm1heGltdW1SZXNwb25zZXNcbiAgICAgICAgfSk7XG4gICAgICAgIG9YTFMubmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgb1hMUy5zZXRTZXJ2aWNlKG9SUyk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCBicnV0ZSAhXG4gICAgICAgIHJlcXVlc3QgPSBvWExTLmJ1aWxkKCk7XG5cbiAgICAgICAgLy8gZW4gbW9kZSBHRVQsIGxhIHJlcXXDqnRlIGVzdCBlbmNvZMOpZVxuICAgICAgICAvLyBldCBsZSBwYXJhbS4gJ3F4bWwnIGVzdCBham91dMOpXG4gICAgICAgIGlmIChvcHRpb25zLmh0dHBNZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHZhciBteVJlcXVlc3QgPSBcInF4bWw9XCIgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChyZXF1ZXN0KVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIiUyRFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIiU1RlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csIFwiJTJFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8hL2csIFwiJTIxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9+L2csIFwiJTdFXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgXCIlMkFcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCIlMjdcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIiUyOFwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpL2csIFwiJTI5XCIpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IG15UmVxdWVzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXF1ZXN0T0xTKTtcblxuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWJzdHJhY3RTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1JvdXRlU2VydmljZV9EZXRlcm1pbmVSb3V0ZVJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fUm91dGVTZXJ2aWNlX1JvdXRlUmVxdWVzdEV4dGVuc2lvbl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Sb3V0ZVNlcnZpY2VfUm91dGVSZXF1ZXN0RXh0ZW5zaW9uX19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1JvdXRlU2VydmljZV9Sb3V0ZVJlcXVlc3RFeHRlbnNpb25fXyk7XG5cblxuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogUmVxdcOqdGUgZGUgdHlwZSBSb3V0ZVNlcnZpY2VcbiAqIChGYWN0b3J5KVxuICpcbiAqIFhTRCA6XG4gKiAtLS0tXG4gKiBbXSA9PiBub24gaW1wbGVtZW50w6kgIVxuICpcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiRGV0ZXJtaW5lUm91dGVSZXF1ZXN0XCJcbiAqICBbYXR0cmlidXRlIG5hbWU9XCJwcm92aWRlUm91dGVIYW5kbGVcIiBkZWZhdWx0PVwiZmFsc2VcIl1cbiAqICBhdHRyaWJ1dGUgbmFtZT1cImRpc3RhbmNlVW5pdFwiICAgICAgIGRlZmF1bHQ9XCJNXCJcbiAqICAgICAgW2VsZW1lbnQgcmVmPVwieGxzOlJvdXRlSGFuZGxlXCIgfHwgZWxlbWVudCByZWY9XCJ4bHM6Um91dGVQbGFuXCJdXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwieGxzOlJvdXRlUGxhblwiXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwieGxzOlJvdXRlSW5zdHJ1Y3Rpb25zUmVxdWVzdFwiXG4gKiAgICAgIFtlbGVtZW50IHJlZj1cInhsczpSb3V0ZUdlb21ldHJ5UmVxdWVzdFwiXVxuICogICAgICBbZWxlbWVudCByZWY9XCJ4bHM6Um91dGVNYXBSZXF1ZXN0XCJdXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiUm91dGVQbGFuXCJcbiAqICBbYXR0cmlidXRlIG5hbWU9XCJ1c2VSZWFsVGltZVRyYWZmaWNcIiBkZWZhdWx0PVwiZmFsc2VcIl1cbiAqICBbYXR0cmlidXRlIG5hbWU9XCJleHBlY3RlZFN0YXJ0VGltZVwiICB0eXBlPVwiZGF0ZVRpbWVcIl1cbiAqICBbYXR0cmlidXRlIG5hbWU9XCJleHBlY3RlZEVuZFRpbWVcIiAgICB0eXBlPVwiZGF0ZVRpbWVcIl1cbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6Um91dGVQcmVmZXJlbmNlXCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6V2F5UG9pbnRMaXN0XCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6QXZvaWRMaXN0XCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJSb3V0ZVByZWZlcmVuY2VcIiA9PiB2YWx1ZSA9IEZhc3Rlc3QgfCBTaG9ydGVzdCB8IFBlZGVzdHJpYW5cbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJXYXlQb2ludExpc3RcIlxuICogICAgICBlbGVtZW50IHJlZj1cInhsczpTdGFydFBvaW50XCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6VmlhUG9pbnRcIiBtaW5PY2N1cnM9XCIwXCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6RW5kUG9pbnRcIlxuICogYGBgXG4gKiBgYGBcbiAqIGVsZW1lbnQgbmFtZT1cIlN0YXJ0UG9pbnRcIlxuICogICAgW2VsZW1lbnQgbmFtZT1cIkdlb2NvZGVNYXRjaENvZGVcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwiYWNjdXJhY3lcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwibWF0Y2hUeXBlXCJdID0+IHZhbHVlID0gQ2l0eSwgU3RyZWV0LCBTdHJlZXQgbnVtYmVyLCBTdHJlZXQgZW5oYW5jZWQsIC4uLlxuICogICAgZWxlbWVudCBuYW1lPVwiUG9zaXRpb25cIlxuICogICAgICBlbGVtZW50IHJlZj1cImdtbDpQb2ludFwiXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiVmlhUG9pbnRcIlxuICogICAgW2VsZW1lbnQgbmFtZT1cIkdlb2NvZGVNYXRjaENvZGVcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwiYWNjdXJhY3lcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwibWF0Y2hUeXBlXCJdID0+IHZhbHVlID0gQ2l0eSwgU3RyZWV0LCBTdHJlZXQgbnVtYmVyLCBTdHJlZXQgZW5oYW5jZWQsIC4uLlxuICogICAgZWxlbWVudCBuYW1lPVwiUG9zaXRpb25cIlxuICogICAgICBlbGVtZW50IHJlZj1cImdtbDpQb2ludFwiXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiRW5kUG9pbnRcIlxuICogICAgW2VsZW1lbnQgbmFtZT1cIkdlb2NvZGVNYXRjaENvZGVcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwiYWNjdXJhY3lcIl1cbiAqICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwibWF0Y2hUeXBlXCJdID0+IHZhbHVlID0gQ2l0eSwgU3RyZWV0LCBTdHJlZXQgbnVtYmVyLCBTdHJlZXQgZW5oYW5jZWQsIC4uLlxuICogICAgZWxlbWVudCBuYW1lPVwiUG9zaXRpb25cIlxuICogICAgICBlbGVtZW50IHJlZj1cImdtbDpQb2ludFwiXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiQXZvaWRMaXN0XCJcbiAqICAgICAgW2VsZW1lbnQgcmVmPVwieGxzOkFPSVwiXVxuICogICAgICBbZWxlbWVudCByZWY9XCJ4bHM6X0xvY2F0aW9uXCJdIChjZi4gZWxlbWVudCBuYW1lPVwiUG9zaXRpb25cIilcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6QXZvaWRGZWF0dXJlXCJcbiAqIGBgYFxuICogYGBgXG4gKiBbZWxlbWVudCBuYW1lPVwiQU9JXCJdXG4gKiAgICAgIFtlbGVtZW50IHJlZj1cImdtbDpDaXJjbGVCeUNlbnRlclBvaW50XCIgfHwgZWxlbWVudCByZWY9XCJnbWw6UG9seWdvblwiIHx8IGVsZW1lbnQgcmVmPVwiZ21sOkVudmVsb3BlXCJdXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiQXZvaWRGZWF0dXJlXCIgPT4gdmFsdWUgPSBoaWdod2F5IHwgdG9sbHdheSB8IHR1bm5lbCB8IGJyaWRnZVxuICogYGBgXG4gKiBgYGBcbiAqIFtlbGVtZW50IG5hbWU9XCJSb3V0ZU1hcFJlcXVlc3RcIl1cbiAqICAgICAgW2VsZW1lbnQgbmFtZT1cIk91dHB1dFwiXVxuICogICAgICAgICAgYXR0cmlidXRlIG5hbWU9XCJ3aWR0aFwiXG4gKiAgICAgICAgICBhdHRyaWJ1dGUgbmFtZT1cImhlaWdodFwiXG4gKiAgICAgICAgICBhdHRyaWJ1dGUgbmFtZT1cImZvcm1hdFwiXG4gKiAgICAgICAgICBhdHRyaWJ1dGUgbmFtZT1cIkJHY29sb3JcIlxuICogICAgICAgICAgYXR0cmlidXRlIG5hbWU9XCJ0cmFuc3BhcmVudFwiXG4gKiAgICAgICAgICBhdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCIgPT4gdmFsdWUgPSBPdmVydmlldyB8IE1hbmV1dmVyXG4gKiAgICAgICAgICBlbGVtZW50IG5hbWU9XCJCQm94Q29udGV4dFwiIHR5cGU9XCJnbWw6RW52ZWxvcGVUeXBlXCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJSb3V0ZUluc3RydWN0aW9uc1JlcXVlc3RcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cImZvcm1hdFwiXSAgICAgICAgICAgZGVmYXVsdD1cInRleHQvcGxhaW5cIlxuICogIGF0dHJpYnV0ZSBuYW1lPVwicHJvdmlkZUdlb21ldHJ5XCIgICAgZGVmYXVsdD1cImZhbHNlXCJcbiAqICBhdHRyaWJ1dGUgbmFtZT1cInByb3ZpZGVCb3VuZGluZ0JveFwiIGRlZmF1bHQ9XCJmYWxzZVwiXG4gKiBgYGBcbiAqIGBgYFxuICogW2VsZW1lbnQgbmFtZT1cIlJvdXRlR2VvbWV0cnlSZXF1ZXN0XCJdXG4gKiAgW2F0dHJpYnV0ZSBuYW1lPVwic2NhbGVcIl0gICAgICAgICAgICAgICAgICBkZWZhdWx0PVwiMVwiXG4gKiAgW2F0dHJpYnV0ZSBuYW1lPVwicHJvdmlkZVN0YXJ0aW5nUG9ydGlvblwiXSBkZWZhdWx0PVwiZmFsc2VcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cIm1heFBvaW50c1wiXSAgICAgICAgICAgICAgZGVmYXVsdD1cIjEwMFwiXG4gKiAgICAgIFtlbGVtZW50IG5hbWU9XCJCb3VuZGluZ0JveFwiIHR5cGU9XCJnbWw6RW52ZWxvcGVUeXBlXCIgXVxuICogYGBgXG4gKlxuICogLS0tLS0tLS1cbiAqIFJlcXXDqnRlIDpcbiAqIC0tLS0tLS0tXG4gKiBgYGBcbiAqIDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxuICogPFhMU1xuICogeG1sbnM6eGxzPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHNcIlxuICogeG1sbnM6c2NoPVwiaHR0cDovL3d3dy5hc2NjLm5ldC94bWwvc2NoZW1hdHJvblwiXG4gKiB4bWxuczpnbWw9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiXG4gKiB4bWxuczp4bHNleHQ9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3hsc2V4dFwiXG4gKiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxuICogeG1sbnM6eHNpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIlxuICogeHNpOnNjaGVtYUxvY2F0aW9uPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC94bHMgaHR0cDovL3NjaGVtYXMub3Blbmdpcy5uZXQvb2xzLzEuMS4wL1JvdXRlU2VydmljZS54c2RcIlxuICogdmVyc2lvbj1cIjEuMVwiIHhsczpsYW5nPVwiZW5cIj5cbiAqIDxSZXF1ZXN0SGVhZGVyLz5cbiAqIDxSZXF1ZXN0IG1ldGhvZE5hbWU9XCJSb3V0ZVJlcXVlc3RcIiByZXF1ZXN0SUQ9XCIxMjM0NTY3ODlcIiB2ZXJzaW9uPVwiMS4xXCI+XG4gKiAgIDxEZXRlcm1pbmVSb3V0ZVJlcXVlc3QgZGlzdGFuY2VVbml0PVwiS01cIj5cbiAqICAgICA8Um91dGVQbGFuPlxuICogICAgICAgPFJvdXRlUHJlZmVyZW5jZT5GYXN0ZXN0PC9Sb3V0ZVByZWZlcmVuY2U+XG4gKiAgICAgICA8eGxzZXh0OnZlaGljbGUgbmFtZT1cIkNhclwiIC8+XG4gKiAgICAgICA8V2F5UG9pbnRMaXN0PlxuICogICAgICAgICA8U3RhcnRQb2ludD5cbiAqICAgICAgICAgICA8UG9zaXRpb24+PGdtbDpQb2ludCBzcnNOYW1lPVwiRVBTRzo0MzI2XCI+PGdtbDpwb3M+Mi4yOTk5MyA0OC44NzIyODwvZ21sOnBvcz48L2dtbDpQb2ludD48L1Bvc2l0aW9uPlxuICogICAgICAgICA8L1N0YXJ0UG9pbnQ+XG4gKiAgICAgICAgIDxFbmRQb2ludD5cbiAqICAgICAgICAgICA8UG9zaXRpb24+PGdtbDpQb2ludCBzcnNOYW1lPVwiRVBTRzo0MzI2XCI+PGdtbDpwb3M+LTEuNTM2MDQgNDcuMjE1NDg8L2dtbDpwb3M+PC9nbWw6UG9pbnQ+PC9Qb3NpdGlvbj5cbiAqICAgICAgICAgPC9FbmRQb2ludD5cbiAqICAgICAgIDwvV2F5UG9pbnRMaXN0PlxuICogICAgIDwvUm91dGVQbGFuPlxuICogICAgIDxSb3V0ZUluc3RydWN0aW9uc1JlcXVlc3QgcHJvdmlkZUdlb21ldHJ5PVwidHJ1ZVwiLz5cbiAqICAgICA8Um91dGVHZW9tZXRyeVJlcXVlc3QvPlxuICogICA8L0RldGVybWluZVJvdXRlUmVxdWVzdD5cbiAqIDwvUmVxdWVzdD5cbiAqIDwvWExTXG4gKiBgYGBcbiAqIC0tLS0tLS0tLS0tXG4gKiBSZWZlcmVuY2VzIDpcbiAqIC0tLS0tLS0tLS0tXG4gKiAtIHtAbGluayBodHRwczovL2dlb3BvcnRhaWwuZm9yZ2UuaWduLmZyL2ppcmEvYnJvd3NlL0dQUC1DSX1cbiAqIC0ge0BsaW5rIGh0dHBzOi8vZ2VvcG9ydGFpbC5mb3JnZS5pZ24uZnIvamlyYS9icm93c2UvR1BQLUNJLTEgU3BlY2lmLiBvbHN9XG4gKiAtIHtAbGluayBodHRwczovL2dlb3BvcnRhaWwuZm9yZ2UuaWduLmZyL2ppcmEvYnJvd3NlL0dQUC1DSS05IEV4dGVuc2lvbn1cbiAqIC0ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9FbWVyZ3lhL29wZW5sYXllcnMvYmxvYi9tYXN0ZXIvbGliL09wZW5MYXllcnMvRm9ybWF0L1hMUy92MV8yXzAuanN9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGVuY2Fwc3VsZSB1biBvYmpldCBkYW5zIHVuZSBjb3F1aWxsZSBYU0wsIEZhY3Rvcnkgc3VyIGxlcyBvYmpldHMgJydcbiAqIHJzID0gbmV3IFJvdXRlU2VydmljZSAoKTtcbiAqIHJzLmFkZFJlcXVlc3QgKHJlcSk7XG4gKiBycy50b1N0cmluZygpO1xuICogIG91XG4gKiBycyA9IG5ldyBSb3V0ZVNlcnZpY2UgKHtcbiAqICAgICAgLi4uXG4gKiB9KTtcbiAqIHJzLnRvU3RyaW5nKCk7XG4gKlxuICogQGV4dGVuZHMge0dwLkZvcm1hdHMuWExTfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuUm91dGVTZXJ2aWNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMucm91dGVQcmVmZXJlbmNlIC0gwqsgZmFzdGVzdCDCuywgwqsgc2hvcnRlc3Qgwrsgb3UgwqsgcGVkZXN0cmlhbiDCu1xuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy5zdGFydFBvaW50IC0gUG9pbnQgZGUgZMOpcGFydCAoY29vcmRvbm7DqWVzIGV4cHJpbcOpZXMgZW4gV0dTODRHKVxuICogQHBhcmFtIHtTdHJpbmd9ICAgb3B0aW9ucy52aWFQb2ludCAtIExpc3RlIGRlIHBvaW50cyBpbnRlcm3DqWRpYWlyZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMuZW5kUG9pbnQgLSBQb2ludCBkJ2Fycml2w6llIChjb29yZG9ubsOpZXMpXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLmF2b2lkRmVhdHVyZSAtIMKrIGhpZ2h3YXkgwrssIMKrIHRvbGx3YXkgwrssIMKrIHR1bm5lbCDCuyBvdSDCqyBicmlkZ2UgwrtcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMuZ3JhcGggLSDCqyBjYXIgwrtcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMuZXhwZWN0ZWRTdGFydFRpbWUgLSBEYXRlIGV0IGhldXJlIGRlIGTDqXBhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMucHJvdmlkZUdlb21ldHJ5IC0gdHJ1ZSB8IGZhbHNlXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnByb3ZpZGVCb3VuZGluZ0JveCAtIHRydWUgfCBmYWxzZVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5kaXN0YW5jZVVuaXQgLSBVbml0w6kgZGFucyBsZXNxdWVsbGVzIGxhIGRpc3RhbmNlIGVzdCBleHByaW3DqWUgKMKrIG0gwrsgb3Ugwqsga20gwrspXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uc3VjY2VzcyAtIGZ1bmN0aW9uIGNhbGxiYWNrIHN1Y2Nlc3MgKFRPRE8pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uZXJyb3IgICAtIGZ1bmN0aW9uIGNhbGxiYWNrIGVycm9yICAgKFRPRE8pXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBvcHRpb25zID0ge1xuICogICAgICAvLyBzcMOpY2lmaXF1ZSBhdSBzZXJ2aWNlXG4gKiAgICAgIHN0YXJ0UG9pbnQ6IHtcbiAqICAgICAgICAgIHg6IDQyLjExMjEsXG4gKiAgICAgICAgICB5OiAxLjU1NTdcbiAqICAgICAgfSxcbiAqICAgICAgZW5kUG9pbnQ6IHtcbiAqICAgICAgICAgIHg6IDQyLjExMjEsXG4gKiAgICAgICAgICB5OiAxLjU1NTdcbiAqICAgICAgfSxcbiAqICAgICAgdmlhUG9pbnQgOiBbXG4gKiAgICAgICAgICB7eDogNDIuMTEyMSx5OiAxLjU1NTd9LFxuICogICAgICAgICAge3g6IDQyLjExMjEseTogMS41NTU3fSxcbiAqICAgICAgICAgIHt4OiA0Mi4xMTIxLHk6IDEuNTU1N31cbiAqICAgICAgXSxcbiAqICAgICAgcHJvdmlkZUJvdW5kaW5nQm94IDogZmFsc2UsXG4gKiAgICAgIGF2b2lkRmVhdHVyZSA6IFtcImJyaWRnZVwiLCBcInR1bm5lbFwiLCBcInRvbGx3YXlcIl0sXG4gKiAgICAgIGV4cGVjdGVkU3RhcnRUaW1lIDogXCIyMDE1LTEyLTIzXCIsIC8vIFlZWVktTU0tRERUaGg6bW06c3NaXG4gKiAgICAgIGRpc3RhbmNlVW5pdCA6IFwia21cIixcbiAqICAgICAgdmVoaWNsZTogXCJjYXJcIixcbiAqICAgICAgcHJvdmlkZUdlb21ldHJ5IDogZmFsc2UsXG4gKiAgICAgIHJvdXRlUHJlZmVyZW5jZSA6IFwiZmFzdGVzdFwiXG4gKiB9O1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlU2VydmljZSAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgUm91dGVTZXJ2aWNlICgpXVwiKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3V0ZVNlcnZpY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSb3V0ZVNlcnZpY2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb20gZGUgbGEgY2xhc3NlXG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIlJvdXRlU2VydmljZVwiO1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBkZSBjbGFzc2VcbiAgICAgKiBSb3V0ZVJlcXVlc3QgcGFyIGRlZmF1dFxuICAgICAqL1xuICAgIHRoaXMuQ0xBU1NUWVBFID0gXCJSb3V0ZVJlcXVlc3RcIjtcblxuICAgIC8vIGFwcGVsIGR1IGNvbnN0cnVjdGV1ciBwYXIgaGVyaXRhZ2VcbiAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Fic3RyYWN0U2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQGxlbmRzIG1vZHVsZTpSb3V0ZVNlcnZpY2UjXG4gKi9cblJvdXRlU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fQWJzdHJhY3RTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLCB7XG4gICAgLy8gdG9kb1xuICAgIC8vIGdldHRlci9zZXR0ZXJcbn0pO1xuXG4vKipcbiAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gKi9cblJvdXRlU2VydmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3V0ZVNlcnZpY2U7XG5cbi8qKlxuICogKG92ZXJ3cml0ZSkgQWpvdXQgZCd1biBvYmpldCBkZSB0eXBlICA6IFJvdXRlUmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvUmVxdWVzdCAtIFJvdXRlUmVxdWVzdFxuICovXG5Sb3V0ZVNlcnZpY2UucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbiAob1JlcXVlc3QpIHtcbiAgICAvLyBvbiBjb250cm9sZSBsZXMgdHlwZXMgYWNjZXB0w6lzXG4gICAgaWYgKG9SZXF1ZXN0LkNMQVNTTkFNRSA9PT0gXCJEZXRlcm1pbmVSb3V0ZVJlcXVlc3RcIikge1xuICAgICAgICB0aGlzLm9SZXF1ZXN0ID0gb1JlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Ugbidlc3QgcGFzIHVuIG9iamV0IGRlIHR5cGUgJ1JvdXRlIFJlcXVlc3QnICE/XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogKG92ZXJ3cml0ZSkgQWpvdXQgZCd1biBvYmpldCBkZSB0eXBlIFJvdXRlRmlsdGVyRXh0ZW5zaW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9GaWx0ZXIgLSBSb3V0ZUZpbHRlckV4dGVuc2lvblxuICovXG5Sb3V0ZVNlcnZpY2UucHJvdG90eXBlLmFkZEZpbHRlciA9IGZ1bmN0aW9uIChvRmlsdGVyKSB7XG4gICAgLy8gZ2VzdGlvbiBkZXMgZXh0ZW5zaW9ucyAodmVoaWNsZSlcbiAgICBpZiAob0ZpbHRlciBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fUm91dGVTZXJ2aWNlX1JvdXRlUmVxdWVzdEV4dGVuc2lvbl9fX2RlZmF1bHQuYSkge1xuICAgICAgICB0aGlzLm9GaWx0ZXIgPSBvRmlsdGVyO1xuICAgIH1cbn07XG5cbi8qKlxuICogKG92ZXJ3cml0ZSkgdG9TdHJpbmdcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Sb3V0ZVNlcnZpY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNvaXQsIG9uIGEgdW4gb2JqZXQgUmVxdWVzdCBkw6lqw6AgaW5zdGFuY2nDqVxuICAgIC8vIHNpbm9uLCBpbCBmYXV0IGxlIGNvbnN0cnVpcmUgw6AgcGFydGlyIGRlcyBvcHRpb25zIMOgIGRpc3Bvc2l0aW9uXG4gICAgaWYgKCF0aGlzLm9SZXF1ZXN0KSB7XG4gICAgICAgIC8vIGlsIG5vdXMgZmF1dCBkZXMgb3B0aW9uc1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVzIG9wdGlvbnMgbmUgc29udCBwYXMgcmVuc2VpZ27DqWVzLCBpbXBvc3NpYmxlIGRlIGNvbnN0cnVpcmUgbGEgcmVxdcOqdGUgIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLkNMQVNTVFlQRSA9PT0gXCJSb3V0ZVJlcXVlc3RcIikge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlVW5pdCA6IHRoaXMub3B0aW9ucy5kaXN0YW5jZVVuaXQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBwcm92aWRlR2VvbWV0cnkgOiB0aGlzLm9wdGlvbnMucHJvdmlkZUdlb21ldHJ5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgcHJvdmlkZUJvdW5kaW5nQm94IDogdGhpcy5vcHRpb25zLnByb3ZpZGVCb3VuZGluZ0JveCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHJvdXRlIDoge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZVByZWZlcmVuY2UgOiB0aGlzLm9wdGlvbnMucm91dGVQcmVmZXJlbmNlIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgOiB0aGlzLm9wdGlvbnMuc3RhcnRQb2ludCxcbiAgICAgICAgICAgICAgICAgICAgdmlhUG9pbnQgOiB0aGlzLm9wdGlvbnMudmlhUG9pbnQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQgOiB0aGlzLm9wdGlvbnMuZW5kUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGF2b2lkRmVhdHVyZSA6IHRoaXMub3B0aW9ucy5hdm9pZEZlYXR1cmUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGggOiB0aGlzLm9wdGlvbnMuZ3JhcGggfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRTdGFydFRpbWUgOiB0aGlzLm9wdGlvbnMuZXhwZWN0ZWRTdGFydFRpbWUgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9SZXF1ZXN0ID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fUm91dGVTZXJ2aWNlX0RldGVybWluZVJvdXRlUmVxdWVzdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHNldHRpbmdzKTtcbiAgICAgICAgICAgIC8vIGFqb3V0IGRlcyBmaWx0cmVzIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlXG4gICAgICAgICAgICBpZiAodGhpcy5vRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vUmVxdWVzdC5hZGRGaWx0ZXIodGhpcy5vRmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9iamV0IGluZGVmaW5pICE/XG4gICAgaWYgKCF0aGlzLm9SZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgZGUgcmVxdcOqdGUgaW5kZWZpbmkgIVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0clJlcXVlc3QgPSB0aGlzLm9SZXF1ZXN0LnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyUmVxdWVzdDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVTZXJ2aWNlKTtcblxuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbW9kZWxfUm91dGVQbGFuX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIFJlcXXDqnRlIGRlIGNhbGN1bCBkJ2l0aW7DqXJhaXJlXG4gKlxuICogLS0tLVxuICogWFNEIDpcbiAqIC0tLS1cbiAqIFtdID0+IG5vbiBpbXBsZW1lbnTDqSAhXG4gKlxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJEZXRlcm1pbmVSb3V0ZVJlcXVlc3RcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cInByb3ZpZGVSb3V0ZUhhbmRsZVwiIGRlZmF1bHQ9XCJmYWxzZVwiXVxuICogIGF0dHJpYnV0ZSBuYW1lPVwiZGlzdGFuY2VVbml0XCIgICAgICAgZGVmYXVsdD1cIk1cIlxuICogICAgICBbZWxlbWVudCByZWY9XCJ4bHM6Um91dGVIYW5kbGVcIiB8fCBlbGVtZW50IHJlZj1cInhsczpSb3V0ZVBsYW5cIl1cbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6Um91dGVQbGFuXCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6Um91dGVJbnN0cnVjdGlvbnNSZXF1ZXN0XCJcbiAqICAgICAgW2VsZW1lbnQgcmVmPVwieGxzOlJvdXRlR2VvbWV0cnlSZXF1ZXN0XCJdXG4gKiAgICAgIFtlbGVtZW50IHJlZj1cInhsczpSb3V0ZU1hcFJlcXVlc3RcIl1cbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJSb3V0ZUluc3RydWN0aW9uc1JlcXVlc3RcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cImZvcm1hdFwiXSAgICAgICAgICAgZGVmYXVsdD1cInRleHQvcGxhaW5cIlxuICogIGF0dHJpYnV0ZSBuYW1lPVwicHJvdmlkZUdlb21ldHJ5XCIgICAgZGVmYXVsdD1cImZhbHNlXCJcbiAqICBhdHRyaWJ1dGUgbmFtZT1cInByb3ZpZGVCb3VuZGluZ0JveFwiIGRlZmF1bHQ9XCJmYWxzZVwiXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiUm91dGVHZW9tZXRyeVJlcXVlc3RcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cInNjYWxlXCJdICAgICAgICAgICAgICAgICAgZGVmYXVsdD1cIjFcIlxuICogIFthdHRyaWJ1dGUgbmFtZT1cInByb3ZpZGVTdGFydGluZ1BvcnRpb25cIl0gZGVmYXVsdD1cImZhbHNlXCJcbiAqICBbYXR0cmlidXRlIG5hbWU9XCJtYXhQb2ludHNcIl0gICAgICAgICAgICAgIGRlZmF1bHQ9XCIxMDBcIlxuICogICAgICBbZWxlbWVudCBuYW1lPVwiQm91bmRpbmdCb3hcIiB0eXBlPVwiZ21sOkVudmVsb3BlVHlwZVwiIF1cbiAqIGBgYFxuICogYGBgXG4gKiBbZWxlbWVudCBuYW1lPVwiUm91dGVNYXBSZXF1ZXN0XCJdXG4gKiAgICAgIFtlbGVtZW50IG5hbWU9XCJPdXRwdXRcIl1cbiAqICAgICAgICAgIFthdHRyaWJ1dGUgbmFtZT1cIndpZHRoXCJdXG4gKiAgICAgICAgICBbYXR0cmlidXRlIG5hbWU9XCJoZWlnaHRcIl1cbiAqICAgICAgICAgIFthdHRyaWJ1dGUgbmFtZT1cImZvcm1hdFwiXVxuICogICAgICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwiQkdjb2xvclwiXVxuICogICAgICAgICAgW2F0dHJpYnV0ZSBuYW1lPVwidHJhbnNwYXJlbnRcIl1cbiAqICAgICAgICAgIFthdHRyaWJ1dGUgbmFtZT1cInN0eWxlXCJdID0+IHZhbHVlID0gT3ZlcnZpZXcgfCBNYW5ldXZlclxuICogICAgICAgICAgW2VsZW1lbnQgbmFtZT1cIkJCb3hDb250ZXh0XCIgdHlwZT1cImdtbDpFbnZlbG9wZVR5cGVcIl1cbiAqIGBgYFxuICpcbiAqIC0tLS0tLS0tXG4gKiBSZXF1w6p0ZSA6XG4gKiAtLS0tLS0tLVxuICogYGBgXG4gKiAgIDxEZXRlcm1pbmVSb3V0ZVJlcXVlc3QgZGlzdGFuY2VVbml0PVwiS01cIj5cbiAqICAgICA8Um91dGVQbGFuPlxuICogICAgICAgICAgICAgIDxSb3V0ZVByZWZlcmVuY2U+RmFzdGVzdDwvUm91dGVQcmVmZXJlbmNlPlxuICogICAgICAgICAgICAgIDx4bHNleHQ6dmVoaWNsZSBuYW1lPVwiQ2FyXCIgLz5cbiAqICAgICAgICAgICAgICA8V2F5UG9pbnRMaXN0PlxuICogICAgICAgICAgICAgICAgICA8U3RhcnRQb2ludD5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxQb3NpdGlvbj48Z21sOlBvaW50IHNyc05hbWU9XCJFUFNHOjQzMjZcIj48Z21sOnBvcz4yLjI5OTkzIDQ4Ljg3MjI4PC9nbWw6cG9zPjwvZ21sOlBvaW50PjwvUG9zaXRpb24+XG4gKiAgICAgICAgICAgICAgICAgIDwvU3RhcnRQb2ludD5cbiAqICAgICAgICAgICAgICAgICAgPEVuZFBvaW50PlxuICogICAgICAgICAgICAgICAgICAgICAgPFBvc2l0aW9uPjxnbWw6UG9pbnQgc3JzTmFtZT1cIkVQU0c6NDMyNlwiPjxnbWw6cG9zPi0xLjUzNjA0IDQ3LjIxNTQ4PC9nbWw6cG9zPjwvZ21sOlBvaW50PjwvUG9zaXRpb24+XG4gKiAgICAgICAgICAgICAgICAgIDwvRW5kUG9pbnQ+XG4gKiAgICAgICAgICAgICAgPC9XYXlQb2ludExpc3Q+XG4gKiAgICAgPC9Sb3V0ZVBsYW4+XG4gKiAgICAgPFJvdXRlSW5zdHJ1Y3Rpb25zUmVxdWVzdCBwcm92aWRlR2VvbWV0cnk9XCJ0cnVlXCIvPlxuICogICAgIDxSb3V0ZUdlb21ldHJ5UmVxdWVzdC8+XG4gKiAgIDwvRGV0ZXJtaW5lUm91dGVSZXF1ZXN0PlxuICogYGBgXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuUm91dGVTZXJ2aWNlLkRldGVybWluZVJvdXRlUmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnJvdXRlLnJvdXRlUHJlZmVyZW5jZSAtIMKrIGZhc3Rlc3QgwrssIMKrIHNob3J0ZXN0IMK7IG91IMKrIHBlZGVzdHJpYW4gwrtcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucm91dGUuc3RhcnRQb2ludCAtIFBvaW50IGRlIGTDqXBhcnQgKGNvb3Jkb25uw6llcyBleHByaW3DqWVzIGVuIFdHUzg0RylcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG9wdGlvbnMucm91dGUudmlhUG9pbnQgLSBMaXN0ZSBkZSBwb2ludHMgaW50ZXJtw6lkaWFpcmVzXG4gKiBAcGFyYW0ge1N0cmluZ30gICBvcHRpb25zLnJvdXRlLmVuZFBvaW50IC0gUG9pbnQgZCdhcnJpdsOpZSAoY29vcmRvbm7DqWVzKVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5yb3V0ZS5hdm9pZEZlYXR1cmUgLSDCqyBoaWdod2F5IMK7LCDCqyB0b2xsd2F5IMK7LCDCqyB0dW5uZWwgwrsgb3UgwqsgYnJpZGdlIMK7XG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnJvdXRlLnZlaGljbGUgLSDCqyBjYXIgwrtcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMucm91dGUuZXhwZWN0ZWRTdGFydFRpbWUgLSBEYXRlIGV0IGhldXJlIGRlIGTDqXBhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMucHJvdmlkZUdlb21ldHJ5IC0gdHJ1ZSB8IGZhbHNlXG4gKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zLnByb3ZpZGVCb3VuZGluZ0JveCAtIHRydWUgfCBmYWxzZVxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucy5kaXN0YW5jZVVuaXQgLSBVbml0w6kgZGFucyBsZXNxdWVsbGVzIGxhIGRpc3RhbmNlIGVzdCBleHByaW3DqWUgKMKrIG0gwrsgb3Ugwqsga20gwrspXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uc3VjY2VzcyAtIGZ1bmN0aW9uIGNhbGxiYWNrIHN1Y2Nlc3MgKFRPRE8pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uZXJyb3IgICAtIGZ1bmN0aW9uIGNhbGxiYWNrIGVycm9yICAgKFRPRE8pXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRGV0ZXJtaW5lUm91dGVSZXF1ZXN0IChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBEZXRlcm1pbmVSb3V0ZVJlcXVlc3QgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERldGVybWluZVJvdXRlUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRldGVybWluZVJvdXRlUmVxdWVzdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbnMgcGFyIGRlZmF1dFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBldCBvbiBham91dGUgbGVzIG9wdGlvbnMgZW4gcGFyYW3DqHRyZSBhdXggb3B0aW9ucyBwYXIgZMOpZmF1dFxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICovXG4gICAgdGhpcy5DTEFTU05BTUUgPSBcIkRldGVybWluZVJvdXRlUmVxdWVzdFwiO1xufVxuXG5EZXRlcm1pbmVSb3V0ZVJlcXVlc3QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpEZXRlcm1pbmVSb3V0ZVJlcXVlc3QjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiByZXF1ZXN0IChvdXQpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdHJSZXF1ZXN0IDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJvdXRlUGxhblxuICAgICAqIEB0eXBlIHtBZGRyZXNzfVxuICAgICAqL1xuICAgIG9Sb3V0ZVBsYW4gOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUuXG4gICAgICogc3Vic3RpdHV0aW9uIGRlcyB2YWxldXJzIHN1aXZhbnRlcyA6XG4gICAgICogX19ESVNUQU5DRVVOSVRfXyxcbiAgICAgKiBfX1JPVVRFUExBTl9fLCBfX1JPVVRFSU5TVFJVQ1RJT05SRVFVRVNUX18sIF9fUk9VVEVHRU9NRVRSWVJFUVVFU1RfXywgX19ST1VURU1BUFJFUVVFU1RfX1xuICAgICAqIF9fUFJPVklERUdFT01FVFJZX18sIF9fUFJPVklERUJCT1hfX1xuICAgICAqL1xuICAgIHRlbXBsYXRlIDoge1xuICAgICAgICBkZXRlcm1pbmVSb3V0ZVJlcXVlc3QgOiBcIjxEZXRlcm1pbmVSb3V0ZVJlcXVlc3QgZGlzdGFuY2VVbml0PVxcXCJfX0RJU1RBTkNFVU5JVF9fXFxcIj5cIiArXG4gICAgICAgICAgICBcIl9fUk9VVEVQTEFOX19cIiArXG4gICAgICAgICAgICBcIl9fUk9VVEVJTlNUUlVDVElPTlJFUVVFU1RfX1wiICtcbiAgICAgICAgICAgIFwiX19ST1VURUdFT01FVFJZUkVRVUVTVF9fXCIgK1xuICAgICAgICAgICAgXCJfX1JPVVRFTUFQUkVRVUVTVF9fXCIgK1xuICAgICAgICAgICAgXCI8L0RldGVybWluZVJvdXRlUmVxdWVzdD5cIixcbiAgICAgICAgcm91dGVJbnN0cnVjdGlvblJlcXVlc3QgOiBcIjxSb3V0ZUluc3RydWN0aW9uc1JlcXVlc3QgXCIgK1xuICAgICAgICAgICAgXCJwcm92aWRlR2VvbWV0cnk9XFxcIl9fUFJPVklERUdFT01FVFJZX19cXFwiIFwiICtcbiAgICAgICAgICAgIFwicHJvdmlkZUJvdW5kaW5nQm94PVxcXCJfX1BST1ZJREVCQk9YX19cXFwiIC8+XCIsXG4gICAgICAgIHJvdXRlR2VvbWV0cnlSZXF1ZXN0IDogXCI8Um91dGVHZW9tZXRyeVJlcXVlc3QgLz5cIixcbiAgICAgICAgcm91dGVNYXBSZXF1ZXN0IDogXCJcIiAvLyBGSVhNRSA8Um91dGVNYXBSZXF1ZXN0Lz4gbm90IHlldCBpbXBsZW1lbnRlZCAhXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFqb3V0IGQndW4gb2JqZXQgZGUgdHlwZSBSb3V0ZVBsYW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvUm91dGVQbGFuIC0gUm91dGVQbGFuXG4gICAgICovXG4gICAgYWRkUm91dGUgOiBmdW5jdGlvbiAob1JvdXRlUGxhbikge1xuICAgICAgICBpZiAob1JvdXRlUGxhbiBpbnN0YW5jZW9mIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbW9kZWxfUm91dGVQbGFuX19bXCJhXCIgLyogZGVmYXVsdCAqL10pIHtcbiAgICAgICAgICAgIHRoaXMub1JvdXRlUGxhbiA9IG9Sb3V0ZVBsYW47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZXVyIChhbGlhcylcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciA6IERldGVybWluZVJvdXRlUmVxdWVzdCxcblxuICAgIC8qKlxuICAgICAqIHRvU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUuZGV0ZXJtaW5lUm91dGVSZXF1ZXN0O1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fRElTVEFOQ0VVTklUX18vZywgdGhpcy5vcHRpb25zLmRpc3RhbmNlVW5pdCB8fCBcIktNXCIpO1xuXG4gICAgICAgIC8vIHNvaXQgb24gYSBkw6lqw6AgdW4gb2JqZXQgUm91dGVQbGFuIGluc3RhbmNpw6ksXG4gICAgICAgIC8vIHNpbm9uLCBvbiBsZSBmYWJyaXF1ZSB2aWEgbGVzIG9wdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLm9Sb3V0ZVBsYW4pIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5yb3V0ZTtcblxuICAgICAgICAgICAgdGhpcy5vUm91dGVQbGFuID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbW9kZWxfUm91dGVQbGFuX19bXCJhXCIgLyogZGVmYXVsdCAqL10oc2V0dGluZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9Sb3V0ZVBsYW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYSBjb25zdHJ1Y3Rpb24gZHUgY2FsY3VsIGQnaW5pdGluZXJhaXJlIG4nZXN0IHBhcyBjb3JyZWN0ZW1lbnQgZGVmaW5pZSAhP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvdXRlcGxhblxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUk9VVEVQTEFOX18vZywgdGhpcy5vUm91dGVQbGFuLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIC8vIGluc3RydWN0aW9uXG4gICAgICAgIHZhciB0bXBsSW5zdHJ1Y3Rpb24gPSB0aGlzLnRlbXBsYXRlLnJvdXRlSW5zdHJ1Y3Rpb25SZXF1ZXN0O1xuICAgICAgICB0bXBsSW5zdHJ1Y3Rpb24gPSB0bXBsSW5zdHJ1Y3Rpb24ucmVwbGFjZSgvX19QUk9WSURFR0VPTUVUUllfXy9nLCB0aGlzLm9wdGlvbnMucHJvdmlkZUdlb21ldHJ5IHx8IGZhbHNlKTtcbiAgICAgICAgdG1wbEluc3RydWN0aW9uID0gdG1wbEluc3RydWN0aW9uLnJlcGxhY2UoL19fUFJPVklERUJCT1hfXy9nLCB0aGlzLm9wdGlvbnMucHJvdmlkZUJvdW5kaW5nQm94IHx8IGZhbHNlKTtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1JPVVRFSU5TVFJVQ1RJT05SRVFVRVNUX18vZywgdG1wbEluc3RydWN0aW9uKTtcblxuICAgICAgICAvLyBnZW9tZXRyeVxuICAgICAgICB2YXIgdG1wbEdlb21ldHJ5ID0gdGhpcy50ZW1wbGF0ZS5yb3V0ZUdlb21ldHJ5UmVxdWVzdDtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1JPVVRFR0VPTUVUUllSRVFVRVNUX18vZywgdG1wbEdlb21ldHJ5KTtcblxuICAgICAgICAvLyBtYXBcbiAgICAgICAgdmFyIHRtcGxNYXAgPSB0aGlzLnRlbXBsYXRlLnJvdXRlTWFwUmVxdWVzdDtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1JPVVRFTUFQUkVRVUVTVF9fL2csIHRtcGxNYXApO1xuXG4gICAgICAgIHRoaXMuc3RyUmVxdWVzdCA9IHRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJSZXF1ZXN0O1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRGV0ZXJtaW5lUm91dGVSZXF1ZXN0KTtcblxuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogICogw4lsw6ltZW50IHJlZ3JvdXBhbnQgbCdlbnNlbWJsZSBkZXMgZG9ubsOpZXMgZXQgcGFyYW3DqHRyZXMgcG91ciBsZSBjYWxjdWwgZCdpdGluw6lyYWlyZSA6IHBvaW50cyBkZSBuYXZpZ2F0aW9uLCBjb25maWd1cmF0aW9uLlxuICpcbiAqIC0tLS1cbiAqIFhTRCA6XG4gKiAtLS0tXG4gKiBbXSA9PiBub24gaW1wbGVtZW50w6kgIVxuICpcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiUm91dGVQbGFuXCJcbiAqICBbYXR0cmlidXRlIG5hbWU9XCJ1c2VSZWFsVGltZVRyYWZmaWNcIiBkZWZhdWx0PVwiZmFsc2VcIl1cbiAqICBbYXR0cmlidXRlIG5hbWU9XCJleHBlY3RlZFN0YXJ0VGltZVwiICB0eXBlPVwiZGF0ZVRpbWVcIl1cbiAqICBbYXR0cmlidXRlIG5hbWU9XCJleHBlY3RlZEVuZFRpbWVcIiAgICB0eXBlPVwiZGF0ZVRpbWVcIl1cbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6Um91dGVQcmVmZXJlbmNlXCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6V2F5UG9pbnRMaXN0XCJcbiAqICAgICAgZWxlbWVudCByZWY9XCJ4bHM6QXZvaWRMaXN0XCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJSb3V0ZVByZWZlcmVuY2VcIlxuICogID0+IHZhbHVlID0gZmFzdGVzdCB8IHNob3J0ZXN0IHwgcGVkZXN0cmlhblxuICogYGBgXG4gKiBgYGBcbiAqIGVsZW1lbnQgbmFtZT1cIldheVBvaW50TGlzdFwiXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwieGxzOlN0YXJ0UG9pbnRcIlxuICogICAgICBlbGVtZW50IHJlZj1cInhsczpWaWFQb2ludFwiIG1pbk9jY3Vycz1cIjBcIlxuICogICAgICBlbGVtZW50IHJlZj1cInhsczpFbmRQb2ludFwiXG4gKiBgYGBcbiAqIGBgYFxuICogZWxlbWVudCBuYW1lPVwiU3RhcnRQb2ludFwiXG4gKiAgICBbZWxlbWVudCBuYW1lPVwiR2VvY29kZU1hdGNoQ29kZVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJhY2N1cmFjeVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJtYXRjaFR5cGVcIl0gPT4gdmFsdWUgPSBDaXR5LCBTdHJlZXQsIFN0cmVldCBudW1iZXIsIFN0cmVldCBlbmhhbmNlZCwgLi4uXG4gKiAgICBlbGVtZW50IG5hbWU9XCJQb3NpdGlvblwiXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwiZ21sOlBvaW50XCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJWaWFQb2ludFwiXG4gKiAgICBbZWxlbWVudCBuYW1lPVwiR2VvY29kZU1hdGNoQ29kZVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJhY2N1cmFjeVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJtYXRjaFR5cGVcIl0gPT4gdmFsdWUgPSBDaXR5LCBTdHJlZXQsIFN0cmVldCBudW1iZXIsIFN0cmVldCBlbmhhbmNlZCwgLi4uXG4gKiAgICBlbGVtZW50IG5hbWU9XCJQb3NpdGlvblwiXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwiZ21sOlBvaW50XCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJFbmRQb2ludFwiXG4gKiAgICBbZWxlbWVudCBuYW1lPVwiR2VvY29kZU1hdGNoQ29kZVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJhY2N1cmFjeVwiXVxuICogICAgICBbYXR0cmlidXRlIG5hbWU9XCJtYXRjaFR5cGVcIl0gPT4gdmFsdWUgPSBDaXR5LCBTdHJlZXQsIFN0cmVldCBudW1iZXIsIFN0cmVldCBlbmhhbmNlZCwgLi4uXG4gKiAgICBlbGVtZW50IG5hbWU9XCJQb3NpdGlvblwiXG4gKiAgICAgIGVsZW1lbnQgcmVmPVwiZ21sOlBvaW50XCJcbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJBdm9pZExpc3RcIlxuICogICAgICBbZWxlbWVudCByZWY9XCJ4bHM6QU9JXCJdXG4gKiAgICAgIFtlbGVtZW50IHJlZj1cInhsczpfTG9jYXRpb25cIl0gKGNmLiBlbGVtZW50IG5hbWU9XCJQb3NpdGlvblwiKVxuICogICAgICBlbGVtZW50IHJlZj1cInhsczpBdm9pZEZlYXR1cmVcIlxuICogYGBgXG4gKiBgYGBcbiAqIFtlbGVtZW50IG5hbWU9XCJBT0lcIl1cbiAqICAgICAgW2VsZW1lbnQgcmVmPVwiZ21sOkNpcmNsZUJ5Q2VudGVyUG9pbnRcIiB8fCBlbGVtZW50IHJlZj1cImdtbDpQb2x5Z29uXCIgfHwgZWxlbWVudCByZWY9XCJnbWw6RW52ZWxvcGVcIl1cbiAqIGBgYFxuICogYGBgXG4gKiBlbGVtZW50IG5hbWU9XCJBdm9pZEZlYXR1cmVcIiA9PiB2YWx1ZSA9IGhpZ2h3YXkgfCB0b2xsd2F5IHwgdHVubmVsIHwgYnJpZGdlXG4gKiBgYGBcbiAqXG4gKiAtLS0tLS0tLVxuICogUmVxdcOqdGUgOlxuICogLS0tLS0tLS1cbiAqIGBgYFxuICogICAgIDxSb3V0ZVBsYW4+XG4gKiAgICAgICA8Um91dGVQcmVmZXJlbmNlPkZhc3Rlc3Q8L1JvdXRlUHJlZmVyZW5jZT5cbiAqICAgICAgIDx4bHNleHQ6dmVoaWNsZSBuYW1lPVwiQ2FyXCIgLz5cbiAqICAgICAgIDxXYXlQb2ludExpc3Q+XG4gKiAgICAgICAgIDxTdGFydFBvaW50PlxuICogICAgICAgICAgIDxQb3NpdGlvbj48Z21sOlBvaW50IHNyc05hbWU9XCJFUFNHOjQzMjZcIj48Z21sOnBvcz4yLjI5OTkzIDQ4Ljg3MjI4PC9nbWw6cG9zPjwvZ21sOlBvaW50PjwvUG9zaXRpb24+XG4gKiAgICAgICAgIDwvU3RhcnRQb2ludD5cbiAqICAgICAgICAgPEVuZFBvaW50PlxuICogICAgICAgICAgIDxQb3NpdGlvbj48Z21sOlBvaW50IHNyc05hbWU9XCJFUFNHOjQzMjZcIj48Z21sOnBvcz4tMS41MzYwNCA0Ny4yMTU0ODwvZ21sOnBvcz48L2dtbDpQb2ludD48L1Bvc2l0aW9uPlxuICogICAgICAgICA8L0VuZFBvaW50PlxuICogICAgICAgPC9XYXlQb2ludExpc3Q+XG4gKiAgICAgICA8QXZvaWRMaXN0PlxuICogICAgICAgICAgPEF2b2lkRmVhdHVyZT5oaWdod2F5PC9Bdm9pZEZlYXR1cmU+XG4gKiAgICAgICAgICA8QXZvaWRGZWF0dXJlPnRvbGx3YXk8L0F2b2lkRmVhdHVyZT5cbiAqICAgICAgICAgIDxBdm9pZEZlYXR1cmU+dHVubmVsPC9Bdm9pZEZlYXR1cmU+XG4gKiAgICAgICA8L0F2b2lkTGlzdD5cbiAqICAgICA8L1JvdXRlUGxhbj5cbiAqIGBgYFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgR3AuRm9ybWF0cy5YTFMuUm91dGVTZXJ2aWNlLlJvdXRlUGxhblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUm91dGVQbGFuIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlJvdXRlUGxhblwiKTtcbiAgICB0aGlzLmxvZ2dlci50cmFjZShcIltDb25zdHJ1Y3RldXIgUm91dGVQbGFuICgpXVwiKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSb3V0ZVBsYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSb3V0ZVBsYW4gY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICAvLyBwYXJhbSBwYXIgZGVmYXV0XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHBhcmFtIG9ibGlnYXRvaXJlXG4gICAgaWYgKCFvcHRpb25zLnN0YXJ0UG9pbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibCdvcHRpb24gJ3N0YXJ0UG9pbnQnIG4nZXN0IHBhcyByZW5zZWlnbsOpZSAhXCIpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5lbmRQb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsJ29wdGlvbiAnZW5kUG9pbnQnIG4nZXN0IHBhcyByZW5zZWlnbsOpZSAhXCIpO1xuICAgIH1cblxuICAgIC8vIGV0IG9uIGFqb3V0ZSBsZXMgb3B0aW9ucyBlbiBwYXJhbcOodHJlIGF1eCBvcHRpb25zIHBhciBkw6lmYXV0XG4gICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW29wdF0gPSBvcHRpb25zW29wdF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cblJvdXRlUGxhbi5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogUm91dGVQbGFuLFxuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdCAob3V0KVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKiBzdWJzdGl0dXRpb24gZGVzIHZhbGV1cnMgc3VpdmFudGVzIDpcbiAgICAgKiAtIF9fUk9VVEVQUkVGRVJFTkNFX18sIF9fVkFMVUVST1VURVBSRUZFUkVOQ0VfX1xuICAgICAqIC0gX19HUkFQSF9fLCBfX1ZBTFVFR1JBUEhfX1xuICAgICAqIC0gX19XQVlQT0lOVExJU1RfXyAobHN0PyksIF9fU1RBUlRQT0lOVF9fLCBfX1ZJQVBPSU5UX18sIF9fRU5EUE9JTlRfXywgX19QT0lOVF9fLCBfX1hfXywgX19ZX19cbiAgICAgKiAtIF9fQVZPSURMSVNUX18gKGxzdCEpLCBfX0FWT0lERkVBVFVSRV9fLCBfX1ZBTFVFQVZPSURGRUFUVVJFX19cbiAgICAgKi9cbiAgICB0ZW1wbGF0ZSA6IHtcbiAgICAgICAgcm91dGVQbGFuIDogXCI8Um91dGVQbGFuPlwiICtcbiAgICAgICAgICAgIFwiX19ST1VURVBSRUZFUkVOQ0VfX1wiICtcbiAgICAgICAgICAgIFwiX19HUkFQSF9fXCIgK1xuICAgICAgICAgICAgXCJfX1dBWVBPSU5UTElTVF9fXCIgK1xuICAgICAgICAgICAgXCJfX0FWT0lETElTVF9fXCIgK1xuICAgICAgICAgICAgXCI8L1JvdXRlUGxhbj5cIixcbiAgICAgICAgcm91dGVQcmVmZXJlbmNlIDogXCI8Um91dGVQcmVmZXJlbmNlPl9fVkFMVUVST1VURVBSRUZFUkVOQ0VfXzwvUm91dGVQcmVmZXJlbmNlPlwiLFxuICAgICAgICBncmFwaCA6IFwiPHhsc2V4dDpncmFwaE5hbWUgeG1sbnM6eGxzZXh0PVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3hsc2V4dFxcXCIgbmFtZT1cXFwiX19WQUxVRUdSQVBIX19cXFwiLz5cIixcbiAgICAgICAgd2F5UG9pbnRMaXN0IDoge1xuICAgICAgICAgICAgY29udGFpbmVyIDogXCI8V2F5UG9pbnRMaXN0PlwiICtcbiAgICAgICAgICAgICAgICBcIl9fU1RBUlRQT0lOVF9fXCIgK1xuICAgICAgICAgICAgICAgIFwiX19WSUFQT0lOVF9fXCIgK1xuICAgICAgICAgICAgICAgIFwiX19FTkRQT0lOVF9fXCIgK1xuICAgICAgICAgICAgICAgIFwiPC9XYXlQb2ludExpc3Q+XCIsXG4gICAgICAgICAgICBwb2ludCA6IFwiPFBvc2l0aW9uPjxnbWw6UG9pbnQgeG1sbnM6Z21sPVxcXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFxcXCI+PGdtbDpwb3M+X19YX18gX19ZX188L2dtbDpwb3M+PC9nbWw6UG9pbnQ+PC9Qb3NpdGlvbj5cIixcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgOiBcIjxTdGFydFBvaW50PlwiICtcbiAgICAgICAgICAgICAgICBcIl9fUE9JTlRfX1wiICtcbiAgICAgICAgICAgICAgICBcIjwvU3RhcnRQb2ludD5cIixcbiAgICAgICAgICAgIGVuZFBvaW50IDogXCI8RW5kUG9pbnQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiX19QT0lOVF9fXCIgK1xuICAgICAgICAgICAgICAgIFwiPC9FbmRQb2ludD5cIixcbiAgICAgICAgICAgIHZpYVBvaW50IDogXCI8VmlhUG9pbnQ+XCIgK1xuICAgICAgICAgICAgICAgIFwiX19QT0lOVF9fXCIgK1xuICAgICAgICAgICAgICAgIFwiPC9WaWFQb2ludD5cIiAvLyBpbXBsw6ltZW50YXRpb24gZGUgcGx1c2lldXJzIMOpdGFwZXMuLi5cbiAgICAgICAgfSxcbiAgICAgICAgYXZvaWRMaXN0IDoge1xuICAgICAgICAgICAgY29udGFpbmVyIDogXCI8QXZvaWRMaXN0PlwiICtcbiAgICAgICAgICAgICAgICBcIl9fQVZPSURGRUFUVVJFX19cIiArXG4gICAgICAgICAgICAgICAgXCI8L0F2b2lkTGlzdD5cIixcbiAgICAgICAgICAgIGF2b2lkRmVhdHVyZSA6IFwiPEF2b2lkRmVhdHVyZT5fX1ZBTFVFQVZPSURGRUFUVVJFX188L0F2b2lkRmVhdHVyZT5cIlxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBcIlwiO1xuICAgICAgICB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUucm91dGVQbGFuO1xuXG4gICAgICAgIC8vIHByZWZlcmVuY2VcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb3V0ZVByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIHZhciB0bXBsUHJlZmVyZW5jZSA9IHRoaXMudGVtcGxhdGUucm91dGVQcmVmZXJlbmNlO1xuICAgICAgICAgICAgdG1wbFByZWZlcmVuY2UgPSB0bXBsUHJlZmVyZW5jZS5yZXBsYWNlKC9fX1ZBTFVFUk9VVEVQUkVGRVJFTkNFX18vLCB0aGlzLm9wdGlvbnMucm91dGVQcmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvX19ST1VURVBSRUZFUkVOQ0VfXy9nLCB0bXBsUHJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYW4gcHJlZmVyZW5jZVxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fUk9VVEVQUkVGRVJFTkNFX18vZywgXCJcIik7XG5cbiAgICAgICAgLy8gZXhjbHVzaW9uc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF2b2lkRmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIHRtcGxBdm9pZExpc3QgPSB0aGlzLnRlbXBsYXRlLmF2b2lkTGlzdC5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgYXZvaWRGZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuYXZvaWRGZWF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcGxBdm9pZEZlYXR1cmUgPSB0aGlzLnRlbXBsYXRlLmF2b2lkTGlzdC5hdm9pZEZlYXR1cmU7XG4gICAgICAgICAgICAgICAgdG1wbEF2b2lkRmVhdHVyZSA9IHRtcGxBdm9pZEZlYXR1cmUucmVwbGFjZSgvX19WQUxVRUFWT0lERkVBVFVSRV9fLywgdGhpcy5vcHRpb25zLmF2b2lkRmVhdHVyZVtpXSk7XG4gICAgICAgICAgICAgICAgYXZvaWRGZWF0dXJlcy5wdXNoKHRtcGxBdm9pZEZlYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1wbEF2b2lkTGlzdCA9IHRtcGxBdm9pZExpc3QucmVwbGFjZSgvX19BVk9JREZFQVRVUkVfXy8sIGF2b2lkRmVhdHVyZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fQVZPSURMSVNUX18vZywgdG1wbEF2b2lkTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xlYW4gZXhjbHVzaW9uc1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL19fQVZPSURMSVNUX18vZywgXCJcIik7XG5cbiAgICAgICAgLy8gZ3JhcGhcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncmFwaCkge1xuICAgICAgICAgICAgdmFyIHRtcGxWZWhpY2xlID0gdGhpcy50ZW1wbGF0ZS5ncmFwaDtcbiAgICAgICAgICAgIHRtcGxWZWhpY2xlID0gdG1wbFZlaGljbGUucmVwbGFjZSgvX19WQUxVRUdSQVBIX18vLCB0aGlzLm9wdGlvbnMuZ3JhcGgpO1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0dSQVBIX18vZywgdG1wbFZlaGljbGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFuIHZlaGljbGVcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX0dSQVBIX18vZywgXCJcIik7XG5cbiAgICAgICAgLy8gcG9pbnRzXG4gICAgICAgIHZhciB0bXBsV2F5UG9pbnRMaXN0ID0gdGhpcy50ZW1wbGF0ZS53YXlQb2ludExpc3QuY29udGFpbmVyO1xuICAgICAgICB2YXIgdG1wbFBvaW50ID0gXCJcIjtcbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdG1wbFBvaW50ID0gdGhpcy50ZW1wbGF0ZS53YXlQb2ludExpc3QucG9pbnQ7XG4gICAgICAgIHRtcGxQb2ludCA9IHRtcGxQb2ludC5yZXBsYWNlKC9fX1hfXy8sIHRoaXMub3B0aW9ucy5zdGFydFBvaW50LngpO1xuICAgICAgICB0bXBsUG9pbnQgPSB0bXBsUG9pbnQucmVwbGFjZSgvX19ZX18vLCB0aGlzLm9wdGlvbnMuc3RhcnRQb2ludC55KTtcbiAgICAgICAgdG1wbFdheVBvaW50TGlzdCA9IHRtcGxXYXlQb2ludExpc3QucmVwbGFjZSgvX19TVEFSVFBPSU5UX18vLFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS53YXlQb2ludExpc3Quc3RhcnRQb2ludC5yZXBsYWNlKC9fX1BPSU5UX18vLCB0bXBsUG9pbnQpKTtcbiAgICAgICAgLy8gZW5kXG4gICAgICAgIHRtcGxQb2ludCA9IHRoaXMudGVtcGxhdGUud2F5UG9pbnRMaXN0LnBvaW50O1xuICAgICAgICB0bXBsUG9pbnQgPSB0bXBsUG9pbnQucmVwbGFjZSgvX19YX18vLCB0aGlzLm9wdGlvbnMuZW5kUG9pbnQueCk7XG4gICAgICAgIHRtcGxQb2ludCA9IHRtcGxQb2ludC5yZXBsYWNlKC9fX1lfXy8sIHRoaXMub3B0aW9ucy5lbmRQb2ludC55KTtcbiAgICAgICAgdG1wbFdheVBvaW50TGlzdCA9IHRtcGxXYXlQb2ludExpc3QucmVwbGFjZSgvX19FTkRQT0lOVF9fLyxcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUud2F5UG9pbnRMaXN0LmVuZFBvaW50LnJlcGxhY2UoL19fUE9JTlRfXy8sIHRtcGxQb2ludCkpO1xuICAgICAgICAvLyB2aWFcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52aWFQb2ludCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm9wdGlvbnMudmlhUG9pbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMub3B0aW9ucy52aWFQb2ludFtqXTtcbiAgICAgICAgICAgICAgICB0bXBsUG9pbnQgPSB0aGlzLnRlbXBsYXRlLndheVBvaW50TGlzdC5wb2ludDtcbiAgICAgICAgICAgICAgICB0bXBsUG9pbnQgPSB0bXBsUG9pbnQucmVwbGFjZSgvX19YX18vLCBwLngpO1xuICAgICAgICAgICAgICAgIHRtcGxQb2ludCA9IHRtcGxQb2ludC5yZXBsYWNlKC9fX1lfXy8sIHAueSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godG1wbFBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wbFdheVBvaW50TGlzdCA9IHRtcGxXYXlQb2ludExpc3QucmVwbGFjZSgvX19WSUFQT0lOVF9fLyxcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlLndheVBvaW50TGlzdC52aWFQb2ludC5yZXBsYWNlKC9fX1BPSU5UX18vLCBwb2ludHMuam9pbihcIlxcblwiKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2xlYW4gdmlhUG9pbnRcbiAgICAgICAgICAgIHRtcGxXYXlQb2ludExpc3QgPSB0bXBsV2F5UG9pbnRMaXN0LnJlcGxhY2UoL19fVklBUE9JTlRfXy8sIFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9fX1dBWVBPSU5UTElTVF9fL2csIHRtcGxXYXlQb2ludExpc3QpO1xuXG4gICAgICAgIHRoaXMucmVxdWVzdFN0cmluZyA9IHRlbXBsYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RyaW5nO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVQbGFuKTtcblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogbm90IGltcGxlbWVudGVkICFcbiAqXG4gKiBFeHRlbnNpb24gZGUgdHlwZSAnZ3JhcGhOYW1lJyBkZSBsJ29iamV0IFJvdXRlUGxhbidcbiAqXG4gKiBGSVhNRSBMJ2V4dGVuc2lvbiAnZ3JhcGhOYW1lJyBlc3QgaW50w6lncsOpIGNvbW1lIMOpdGFudCBkdSBzdGFuZGFyZCBPTFMuXG4gKiAgICAgICBMYSBiYWxpc2UgPHhsc2V4dDpHcmFwaE5hbWU+IHZpZW5kcmFpdCBzdXJjaGFyZ2VyIGxlIGNvbXBvcnRlbWVudCBkZSBSb3V0ZVByZWZlcmVuY2UuLi5cbiAqXG4gKiBleC4gPHhsc2V4dDpncmFwaE5hbWUgbmFtZT1cIlZvaXR1cmVcIiAvPlxuICovXG5cblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fbW9kZWxfUm91dGVQYXJhbVJFU1RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIpO1xuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHJlcXXDqnRlcyBkZSB0eXBlIFJFU1Qgc3VyIGxlIHNlcnZpY2UgZGUgY2FsY3VsIGQnaXRpbmVyYWlyZVxuICogKHVuaXF1ZW1lbnQgZW4gR0VUKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlJvdXRlLlJlcXVlc3QuUm91dGVSZXF1ZXN0UkVTVFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGRlZmluaWVzIGRhbnMgbGUgY29tcG9zYW50IFJvdXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBvcHRpb25zID0ge1xuICogICAgICAoLi4uKVxuICogfTtcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBSb3V0ZVJlcXVlc3RSRVNUIChvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlJvdXRlUmVxdWVzdFJFU1RcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJvdXRlUmVxdWVzdFJFU1QgKCldXCIpO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJvdXRlUmVxdWVzdFJFU1QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJSb3V0ZVJlcXVlc3RSRVNUIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gZXhpc3RhbmNlIGRlcyBvcHRpb25zXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX0VNUFRZXCIsIFwib3B0aW9uc1wiKSk7XG4gICAgfVxuXG4gICAgLyoqIGxpc3RlIGRlcyBvcHRpb25zICovXG4gICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnM7XG59XG5cblJvdXRlUmVxdWVzdFJFU1QucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpSb3V0ZVJlcXVlc3RSRVNUI1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogcmVxdWVzdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgcmVxdWVzdFN0cmluZyA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogUm91dGVSZXF1ZXN0UkVTVCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGlvbiBkZSBsYSByZXF1w6p0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gR0VUICBvdXQgOiBvcmlnaW49Mi40MTY5MDczNTM4MDk1MTMsNDguODQ2NTc3MjE0MjI5NyZkZXN0aW5hdGlvbj0yLjQyNDgwMzc3NzE0OTM2NzMsNDguODQ1OTEzNTMxNjE4MzhcbiAgICAgKiAvLyBQT1NUIG91dCA6IE5vdCB5ZXQgc3VwcG9ydGVkIG1ldGhvZCBQT1NUICFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXF1ZXN0XG4gICAgICovXG4gICAgcHJvY2Vzc1JlcXVlc3RTdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElORk9cbiAgICAgICAgLy8gY29uc3RydWN0aW9uIHNpbXBsZSBzYW5zIHRlbXBsYXRlLi4uLFxuICAgICAgICAvLyBtYWlzIGVuIGF0dGVuZGFudCBxdWUgbGVzIHNlcnZpY2VzIHNvaWVudCBmaXjDqXMsIG9uIHRhZ2d1ZSBjZSBjb21wb3NhbnQgZW4gbW9kZSBQUk9UT1RZUEUgIVxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRklYTUUgOiBQUk9UT1RZUEUgIVwiKTtcblxuICAgICAgICAvLyBNYXBwaW5nIGRlcyBvcHRpb25zIGF2ZWMgbGUgc2VydmljZSBkZSBsJ0FQSSBSRVNUXG4gICAgICAgIHZhciBvUGFyYW1zID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fbW9kZWxfUm91dGVQYXJhbVJFU1RfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG9QYXJhbXMuZ2V0UGFyYW1zKCk7XG5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG8gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgKz0gXCImXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0ICs9IG8uayArIFwiPVwiICsgby52O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlbXBsZSA6XG4gICAgICAgIC8vICBodHRwOi8vd3hzLmlnbi5mci9LRVkvaXRpbmVyYWlyZS9yZXN0L3JvdXRlLmpzb24/XG4gICAgICAgIC8vICBvcmlnaW49JlxuICAgICAgICAvLyAgZGVzdGluYXRpb249JlxuICAgICAgICAvLyAgd2F5cG9pbnRzPSZcbiAgICAgICAgLy8gIG1ldGhvZD1ESVNUQU5DRSZcbiAgICAgICAgLy8gIGdyYXBoPVBpZXRvbiZcbiAgICAgICAgLy8gIGdyYXBoTmFtZT1QaWV0b24mXG4gICAgICAgIC8vICBleGNsdXNpb25zPSZcbiAgICAgICAgLy8gIHRvbGVyYW5jZT0xMCZcbiAgICAgICAgLy8gIHNycz1cblxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RyaW5nID0gcmVxdWVzdDtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RyaW5nO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXF1ZXN0UkVTVCk7XG5cblxuLyoqKi8gfSksXG4vKiA5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2xhc3NlIGRlIGdlc3Rpb24gZGVzIHBhcmFtLiBkZXMgcmVxdcOqdGVzIGR1IHNlcnZpY2UgZGUgY2FsY3VsIGQnaXRpbmVyYWlyZSAoUkVTVCkuXG4gKiAgICAgIFBlcm1ldCBsZSBtYXBwaW5nIGF2ZWMgbGVzIG9wdGlvbnMgZHUgc2VydmljZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlJvdXRlLlJlcXVlc3QuUm91dGVQYXJhbVJFU1RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFJvdXRlUGFyYW1SRVNUIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJvdXRlUGFyYW1SRVNUKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUm91dGVQYXJhbVJFU1QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TG9nZ2VyKCk7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFJvdXRlUGFyYW1SRVNUICgpXVwiKTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgZW4gcGFyYW3DqnRyZXMgZHUgY29uc3RydWN0ZXVyLlxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBtYXBwaW5nIGRlcyBvcHRpb25zIGF2ZWMgbCdBUEkgUkVTVFxuXG4gICAgLyoqIENvb3Jkb25uw6llcyBkdSBwb2ludCBkZSBkw6lwYXJ0LiAqL1xuICAgIHRoaXMub3JpZ2luID0gdGhpcy5vcHRpb25zLnN0YXJ0UG9pbnQueCArIFwiLFwiICsgdGhpcy5vcHRpb25zLnN0YXJ0UG9pbnQueTtcblxuICAgIC8qKiBDb29yZG9ubsOpZXMgZHUgcG9pbnQgZOKAmWFycml2w6llLiAqL1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnQueCArIFwiLFwiICsgdGhpcy5vcHRpb25zLmVuZFBvaW50Lnk7XG5cbiAgICAvKiogQ29vcmRvbm7DqWVzIGRlcyDDqXRhcGVzIHBvaW50IGRlIGTDqXBhcnQuICovXG4gICAgdGhpcy53YXlwb2ludHMgPSB0aGlzLm9wdGlvbnMudmlhUG9pbnRzIHx8IG51bGw7XG5cbiAgICAvKiogRGF0ZSBldCBoZXVyZSBkZSBkw6lwYXJ0ICovXG4gICAgdGhpcy5zdGFydERhdGVUaW1lID0gdGhpcy5vcHRpb25zLmV4cGVjdGVkU3RhcnRUaW1lIHx8IG51bGw7IC8vIFRPRE8gZm9ybWF0ICE/XG5cbiAgICAvKiogTm9tIGR1IGdyYXBoZSDDoCB1dGlsaXNlciAqL1xuICAgIHRoaXMuZ3JhcGhOYW1lID0gdGhpcy5vcHRpb25zLmdyYXBoO1xuXG4gICAgLyoqIHByb2plY3Rpb24gKGNvZGUgRVBTRyBjb21tZSBlcHNnOjQzMjYgb3Ugd2dzODQpICovXG4gICAgdGhpcy5zcnMgPSB0aGlzLm9wdGlvbnMuc3JzO1xuXG4gICAgLyoqIExpc3RlIGRlcyByw6hnbGVzIGRlIHJlc3RyaWN0aW9ucyDDoCB1dGlsaXNlciwgc8OpcGFyw6lzIHBhcyBsZSBjYXJhY3TDqHJlICwgb3UgOyAoRXhlbXBsZSA6IFRvbGwsIFR1bm5lbCwgQnJpZGdlKSAqL1xuICAgIHRoaXMuZXhjbHVzaW9ucyA9IHRoaXMub3B0aW9ucy5leGNsdXNpb25zO1xuXG4gICAgLyoqXG4gICAgICogaXRpbsOpcmFpcmUgbGUgcGx1cyBjb3VydCAoRElTVEFOQ0UpIG91IGxlIHBsdXMgcmFwaWRlIChUSU1FKVxuICAgICAqIFBhciBkZWZhdXQsIERJU1RBTkNFLi4uXG4gICAgICogY2YuIG1hcHBpbmcgY2kgZGVzc291c1xuICAgICAqL1xuICAgIHRoaXMubWV0aG9kID0gXCJUSU1FXCI7XG5cbiAgICAvLyBtYXBwaW5nIHBhcnRpY3VsaWVyIHN1ciBsJ29wdGlvbiAncm91dGVQcmVmZXJlbmNlJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMucm91dGVQcmVmZXJlbmNlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMub3B0aW9ucy5yb3V0ZVByZWZlcmVuY2U7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmYXN0ZXN0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIlRJTUVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzaG9ydGVzdFwiOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJESVNUQU5DRVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUGFyIGRlZmF1dCwgb24gcHJlbmQgbCdpdGluw6lyYWlyZSBsZSBwbHVzIHJhcGlkZSAhXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJUSU1FXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRm9ybWF0IGRlIHNvcnRpZSAocsOpc3Vtw6kgZGUgbOKAmWl0aW7DqXJhaXJlKSAqL1xuICAgIHRoaXMuZm9ybWF0ID0gKHRoaXMub3B0aW9ucy5nZW9tZXRyeUluSW5zdHJ1Y3Rpb25zKSA/IFwiU1RBTkRBUkRFWFRcIiA6IFwiU1RBTkRBUkRcIjtcblxuICAgIC8vIHknYSB0LWlsIGQnYXV0cmVzIG9wdGlvbnMgw6AgYWpvdXRlciAocGFyIGRlZmF1dCkgP1xuXG4gICAgLyoqIERpc3RhbmNlIGRlIHRvbMOpcmFuY2UgKGVuIG3DqHRyZSkgZGUgc2ltcGxpZmljYXRpb24gZGUgbGEgZ8Opb23DqXRyaWUuICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSAxMDtcblxuICAgIC8qKiBpZGVudGlmaWFudCBkdSB2w6loaWN1bGUgKGVucmVnaXN0csOpIGRhbnMgbGVzIHByb2ZpbHMgZGUgdsOpaGljdWxlKSDDoCB1dGlsaXNlciAqL1xuICAgIHRoaXMucHJvZmlsZUlkID0gbnVsbDtcblxuICAgIC8qKiBQcm9maWwgZHUgdsOpaGljdWxlIChlbnJlZ2lzdHLDqSBkYW5zIGxlcyBwcm9maWxzIGRlIHbDqWhpY3VsZSkgw6AgdXRpbGlzZXIgKi9cbiAgICB0aGlzLnByb2ZpbGVOYW1lID0gbnVsbDtcblxuICAgIC8vIG9wdGlvbnMgZG9udCBsZSBtYXBwaW5nIG4nZXN0IHBhcyBwb3NzaWJsZSA6XG4gICAgLy8gLSBkaXN0YW5jZVVuaXRcbiAgICAvLyAtIHByb3ZpZGVCb3VuZGluZ0JveFxufVxuXG4vKipcbiAqIENMQVNTTkFNRVxuICovXG5Sb3V0ZVBhcmFtUkVTVC5DTEFTU05BTUUgPSBcIlJvdXRlUGFyYW1SRVNUXCI7XG5cblJvdXRlUGFyYW1SRVNULnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6Um91dGVQYXJhbVJFU1QjXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIDogUm91dGVQYXJhbVJFU1QsXG5cbiAgICAvKipcbiAgICAgKiBSZXRvdXJuZSB1bmUgbGlzdGUgZGUgcG9pbnRzXG4gICAgICogQHJldHVybnMge0FycmF5fSB1bmUgbGlzdGUgZGUgcG9pbnRzIChzZXAgJzsnKVxuICAgICAqL1xuICAgIGdldFdheXBvaW50cyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndheXBvaW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2F5cG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gdGhpcy53YXlwb2ludHNbaV07XG4gICAgICAgICAgICBhcnJheS5wdXNoKG9iai54ICsgXCIsXCIgKyBvYmoueSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuam9pbihcIjtcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBleGNsdXNpb25zXG4gICAgICogQHJldHVybnMge0FycmF5fSB1bmUgbGlzdGUgZCdleGNsdXNpb25zIChzZXAgJzsnKVxuICAgICAqL1xuICAgIGdldEV4Y2x1c2lvbnMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1c2lvbnMuam9pbihcIjtcIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUYWJsZWF1IGRlIGNsZWZzL3ZhbGV1cnMgcG91ciBwYXJhbS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9IGxpc3RlIGRlIHBhcmFtw6p0cmVzXG4gKi9cblJvdXRlUGFyYW1SRVNULnByb3RvdHlwZS5nZXRQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJvcmlnaW5cIixcbiAgICAgICAgdiA6IHRoaXMub3JpZ2luXG4gICAgfSk7XG5cbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImRlc3RpbmF0aW9uXCIsXG4gICAgICAgIHYgOiB0aGlzLmRlc3RpbmF0aW9uXG4gICAgfSk7XG5cbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcIm1ldGhvZFwiLFxuICAgICAgICB2IDogdGhpcy5tZXRob2RcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLndheXBvaW50cykge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJ3YXlwb2ludHNcIixcbiAgICAgICAgICAgIHYgOiB0aGlzLmdldFdheXBvaW50cygpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXJ0RGF0ZVRpbWUpIHtcbiAgICAgICAgbWFwLnB1c2goe1xuICAgICAgICAgICAgayA6IFwic3RhcnREYXRlVGltZVwiLFxuICAgICAgICAgICAgdiA6IHRoaXMuc3RhcnREYXRlVGltZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaE5hbWUpIHtcbiAgICAgICAgbWFwLnB1c2goe1xuICAgICAgICAgICAgayA6IFwiZ3JhcGhOYW1lXCIsXG4gICAgICAgICAgICB2IDogdGhpcy5ncmFwaE5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhjbHVzaW9ucykge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJleGNsdXNpb25zXCIsXG4gICAgICAgICAgICB2IDogdGhpcy5nZXRFeGNsdXNpb25zKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3JzKSB7XG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICAgIGsgOiBcInNyc1wiLFxuICAgICAgICAgICAgdiA6IHRoaXMuc3JzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJmb3JtYXRcIixcbiAgICAgICAgICAgIHYgOiB0aGlzLmZvcm1hdFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChSb3V0ZVBhcmFtUkVTVCk7XG5cblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Gb3JtYXRzX1hNTF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0Zvcm1hdHNfV0tUX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fRm9ybWF0c19Sb3V0ZVJlc3BvbnNlUkVTVFJlYWRlcl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19Gb3JtYXRzX1JvdXRlUmVzcG9uc2VPTFNSZWFkZXJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fbW9kZWxfUm91dGVSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19tb2RlbF9Sb3V0ZUluc3RydWN0aW9uX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbi8qKlxuICogRmFjdG9yeSBwb3VyIGfDqW7DqXJlciB1bmUgcmVwb25zZSBKU09OIMOgIHBhcnRpciBkJ3VuIFhNTCBvdSBkJ3VuIEpTT05cbiAqIChGYWN0b3J5KVxuICpcbiAqIEBtb2R1bGUgUm91dGVSZXNwb25zZUZhY3RvcnlcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Sb3V0ZS5SZXNwb25zZS5Sb3V0ZVJlc3BvbnNlRmFjdG9yeVxuICogQHByaXZhdGVcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgUm91dGVSZXNwb25zZUZhY3RvcnkgPSB7XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcmZhY2UgdW5pcXVlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBkZWZpbmllcyBkYW5zIGxlIGNvbXBvc2FudCBBbHRpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICByZXNwb25zZSA6XG4gICAgICogICAgICBvdXRwdXRGb3JtYXQgOlxuICAgICAqICAgICAgcmF3UmVzcG9uc2UgOlxuICAgICAqICAgICAgc2NvcGUgOlxuICAgICAqICAgICAgb25TdWNjZXNzIDpcbiAgICAgKiAgICAgIG9uRXJyb3IgOlxuICAgICAqICAgfTtcbiAgICAgKlxuICAgICAqL1xuICAgIGJ1aWxkIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlJvdXRlUmVzcG9uc2VGYWN0b3J5XCIpO1xuICAgICAgICBsb2dnZXIudHJhY2UoXCJSb3V0ZVJlc3BvbnNlRmFjdG9yeTo6YnVpbGQoKVwiKTtcblxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJhd1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IHJhd1wiKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLm91dHB1dEZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwieG1sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJhbmFseXplIHJlc3BvbnNlIDogeG1sXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIGRlIHJlYWRlciBlbiBmb25jdGlvbiBkZSBsJ0FQSVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlUmVhZGVyID0gb3B0aW9ucy5hcGkgPT09IFwiUkVTVFwiID8gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19Gb3JtYXRzX1JvdXRlUmVzcG9uc2VSRVNUUmVhZGVyX19bXCJhXCIgLyogZGVmYXVsdCAqL10gOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX0Zvcm1hdHNfUm91dGVSZXNwb25zZU9MU1JlYWRlcl9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fRm9ybWF0c19YTUxfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA6IHJvdXRlUmVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSA6IG1vZGUgWEhSIG5lIHJldG91cm5lIHF1ZSBkZXMgc3RyaW5nID8gSlNPTlAgYXVzc2kgw6AgY2Ugbml2ZWF1ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRYTUxTdHJpbmcob3B0aW9ucy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5zZXRYTUxEb2Mob3B0aW9ucy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHAucGFyc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9GT1JNQVRcIiwgXCJ4bWxcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIG9wdGlvbnMucmVzcG9uc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IGpzb25cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBKU09OUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OUmVzcG9uc2UgPSBKU09OLnBhcnNlKG9wdGlvbnMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OUmVzcG9uc2UgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZSBzZXJ2aWNlIHJlbnZvaWUgdCBpbCB1bmUgZXJyZXVyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OUmVzcG9uc2UubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4LiB7XCJtZXNzYWdlXCI6XCJtZXNzYWdlIG5vdCBudWxsXCIsIFwic3RhdHVzXCI6XCJFUlJPUlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBKU09OUmVzcG9uc2UubWVzc2FnZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdGlvbiBkZSBsJ29iamV0IHLDqXBvbnNlIEpTT05cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKU09OUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWdTdGVwcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGVwcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX21vZGVsX1JvdXRlUmVzcG9uc2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoXCJ0b3RhbFRpbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5mbyA6IGlsIHkgYSBhdXNzaSBKU09OUmVzcG9uc2UuZHVyYXRpb24sIHF1aSBkb25uZSBsYSBkdXLDqWUgZW4gaGg6bW06c3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudG90YWxUaW1lID0gcGFyc2VGbG9hdChKU09OUmVzcG9uc2UuZHVyYXRpb25TZWNvbmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoXCJ0b3RhbERpc3RhbmNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudG90YWxEaXN0YW5jZSA9IChvcHRpb25zLmRpc3RhbmNlVW5pdCA9PT0gXCJtXCIpID8gSlNPTlJlc3BvbnNlLmRpc3RhbmNlTWV0ZXJzIDogSlNPTlJlc3BvbnNlLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KFwiYmJveFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gSlNPTlJlc3BvbnNlLmJvdW5kcy5zcGxpdCgvWyw7XS8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJib3gubGVmdCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5iYm94LmJvdHRvbSA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5iYm94LnJpZ2h0ID0gcGFyc2VGbG9hdChjb29yZHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmJib3gudG9wID0gcGFyc2VGbG9hdChjb29yZHNbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGNhbGxiYWNrIHN1Y2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0ganNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbldLVFN1Y2Nlc3MgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlR2VvbWV0cnkgPSBqc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBjYWxsYmFjayBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25XS1RFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fRk9STUFUXCIsIFtcImdlb21ldHJ5V2t0XCJdKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShcInJvdXRlR2VvbWV0cnlcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gSlNPTlJlc3BvbnNlLmdlb21ldHJ5V2t0IHx8IEpTT05SZXNwb25zZS5zaW1wbGlmaWVkV2t0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRm9ybWF0c19XS1RfX1tcImFcIiAvKiBkZWZhdWx0ICovXS50b0pzb24oZ2VvbWV0cnksIG9uV0tUU3VjY2Vzcywgb25XS1RFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEucm91dGVHZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KFwicm91dGVJbnN0cnVjdGlvbnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ0xpc3QgPSBKU09OUmVzcG9uc2UubGVncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxlZ0xpc3QpICYmIGxlZ0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVnTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ3MucHVzaChsZWdMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsZWdzKSAmJiBsZWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdTdGVwcy5wdXNoKGxlZ3NbaV0uc3RlcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxlZ1N0ZXBzKSAmJiBsZWdTdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWdTdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gc3RlcHMuY29uY2F0KGxlZ1N0ZXBzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnMucHVzaChuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19tb2RlbF9Sb3V0ZUluc3RydWN0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zW2RhdGEucm91dGVJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0uZHVyYXRpb24gPSBzdGVwLmR1cmF0aW9uU2Vjb25kcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5kaXN0YW5jZSA9IChvcHRpb25zLmRpc3RhbmNlVW5pdCA9PT0gXCJtXCIpID8gc3RlcC5kaXN0YW5jZU1ldGVycyA6IHN0ZXAuZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zW2RhdGEucm91dGVJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0uY29kZSA9IHN0ZXAubmF2SW5zdHJ1Y3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZW9tZXRyaWUgZW4gZ2VvanNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHN0ZXAucG9pbnRzW2ldLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5nZW9tZXRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBcIkxpbmVTdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFkdWN0aW9uIGR1IGNvZGUgZW4gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBGIDogdG91dCBkcm9pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAtIEIgOiBkZW1pLXRvdXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBMIDogdG91cm5lciDDoCBnYXVjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBSIDogdG91cm5lciDDoCBkcm9pdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBCTCA6IHRvdXJuZXIgdHLDqHMgw6AgZ2F1Y2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gQlIgOiB0b3VybmVyIHRyw6hzIMOgIGRyb2l0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAtIEZMIDogdG91cm5lciBsw6lnw6hyZW1lbnQgw6AgZ2F1Y2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gRlIgOiB0b3VybmVyIGzDqWfDqHJlbWVudCDDoCBkcm9pdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSByb3VuZF9hYm91dF9lbnRyeSA6IGVudHLDqWUgcm9uZC1wb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAtIHJvdW5kX2Fib3V0X2V4aXQgOiBzb3J0aWUgcm9uZC1wb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gbmUgc291aGFpdGUgcGFzIGRlIGNlIHR5cGUgZGUgdmFsZXVyLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcC5uYW1lID09PSBcIlZhbGV1ciBub24gcmVuc2VpZ27DqWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXAubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RlcC5uYXZJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJGXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5pbnN0cnVjdGlvbiA9IFwiVG91dCBkcm9pdCBcIiArIHN0ZXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5pbnN0cnVjdGlvbiA9IFwiQ29udGludWVyIHRvdXQgZHJvaXQgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3V0ZUluc3RydWN0aW9uc1tkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmluc3RydWN0aW9uID0gXCJEZW1pLXRvdXIgXCIgKyBzdGVwLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5pbnN0cnVjdGlvbiA9IFwiVG91cm5lciDDoCBnYXVjaGUgXCIgKyBzdGVwLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5pbnN0cnVjdGlvbiA9IFwiVG91cm5lciDDoCBkcm9pdGUgXCIgKyBzdGVwLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCTFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zW2RhdGEucm91dGVJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0uaW5zdHJ1Y3Rpb24gPSBcIlRvdXJuZXIgdHLDqHMgw6AgZ2F1Y2hlIFwiICsgc3RlcC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQlJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3V0ZUluc3RydWN0aW9uc1tkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmluc3RydWN0aW9uID0gXCJUb3VybmVyIHRyw6hzIMOgIGRyb2l0ZSBcIiArIHN0ZXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucm91dGVJbnN0cnVjdGlvbnNbZGF0YS5yb3V0ZUluc3RydWN0aW9ucy5sZW5ndGggLSAxXS5pbnN0cnVjdGlvbiA9IFwiVG91cm5lciBsw6lnw6hyZW1lbnQgw6AgZ2F1Y2hlIFwiICsgc3RlcC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRlJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3V0ZUluc3RydWN0aW9uc1tkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmluc3RydWN0aW9uID0gXCJUb3VybmVyIGzDqWfDqHJlbWVudCDDoCBkcm9pdGUgXCIgKyBzdGVwLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyb3VuZF9hYm91dF9lbnRyeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zW2RhdGEucm91dGVJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0uaW5zdHJ1Y3Rpb24gPSBcIkVudHLDqWUgcm9uZC1wb2ludCBcIiArIHN0ZXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJvdW5kX2Fib3V0X2V4aXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3V0ZUluc3RydWN0aW9uc1tkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmluc3RydWN0aW9uID0gXCJTb3J0aWUgcm9uZC1wb2ludCBcIiArIHN0ZXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zW2RhdGEucm91dGVJbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0uaW5zdHJ1Y3Rpb24gPSBcIlByZW5kcmUgdG91dCBkcm9pdCBcIiArIHN0ZXAubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yb3V0ZUluc3RydWN0aW9uc1tkYXRhLnJvdXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdLmluc3RydWN0aW9uID0gXCI/XCIgKyBzdGVwLm5hdkluc3RydWN0aW9uICsgXCI/IFwiICsgc3RlcC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIFwianNvblwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9GT1JNQVRcIiwgXCJqc29uXCIsIFwieG1sXCIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2kgbGEgcsOpcG9uc2UgY29udGVuYWl0IHVuZSBleGNlcHRpb24gcmVudm95w6llIHBhciBsZSBzZXJ2aWNlXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVTUE9OU0VfRVhDRVBUSU9OXzJcIikpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VNUFRZXCIpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLm9uU3VjY2Vzcy5jYWxsKG9wdGlvbnMuc2NvcGUsIGRhdGEpO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXNwb25zZUZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0Zvcm1hdHNfV0tUX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19SZXNwb25zZV9tb2RlbF9Sb3V0ZVJlc3BvbnNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1Jlc3BvbnNlX21vZGVsX1JvdXRlSW5zdHJ1Y3Rpb25fXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyoqXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2UgUkVTVFxuICpcbiAqIEBtb2R1bGUgUm91dGVSZXNwb25zZVJFU1RSZWFkZXJcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Sb3V0ZS5Gb3JtYXRzLlJvdXRlUmVzcG9uc2VSRVNUUmVhZGVyXG4gKiBAdG9kbyBub3QgeWV0IGltcGxlbWVudGVkICFcbiAqIEBwcml2YXRlXG4gKi9cblxuLy8gaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vLi4vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5cblxuXG5cblxuXG4vKipcbiAqIE9iamV0IFJvdXRlUmVzcG9uc2VSZXN0UmVhZGVyXG4gKiBAbWVtYmVyIHtPYmplY3R9IFJvdXRlUmVzcG9uc2VSZXN0UmVhZGVyXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFJvdXRlUmVzcG9uc2VSZXN0UmVhZGVyLlJFQURFUlMgLSBPYmpldCBjb250ZW5hbnQgZGVzIGZvbmN0aW9ucyBkZSBsZWN0dXJlLCBhcHBlbMOpZXMgXCJyZWFkZXJzXCJcbiAqICAgICAgZG9udCBjaGFxdWUgY2zDqSBjb3JyZXNwb25kIGF1IG5vbSBkJ3VuIHRhZyBkdSBYTUwgcXVlIGwnb24gc291aGFpdGUgbGlyZVxuICogICAgICBldCBsYSB2YWxldXIgYXNzb2Npw6llIGVzdCB1bmUgZm9uY3Rpb24gKG5vZGUsIGRhdGEpXG4gKiAgICAgIG/DuSBub2RlIGVzdCB1biBub2V1ZCBkdSBkb2N1bWVudCBET01cbiAqICAgICAgZXQgZGF0YSBlc3QgdW4gb2JqZXQgb8O5IGwnb24gc3RvY2tlIGxlcyBpbmZvcm1hdGlvbnMgbHVlcyBkYW5zIGxlIFhNTC5cbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gUm91dGVSZXNwb25zZVJlc3RSZWFkZXIucmVhZCAtIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgbGFuY2VyIGxhIGxlY3R1cmUgZCd1bmUgcsOpcG9uc2UgWE1MIGR1XG4gKiAgICAgIHNlcnZpY2UgZGUgY2FsY3VsIGQnaXRpbmVyYWlyZSwgw6AgbCdhaWRlIGRlcyByZWFkZXJzIGRlIGxhIGNsYXNzZS5cbiAqXG4gKi9cblxudmFyIFJvdXRlUmVzcG9uc2VSRVNUUmVhZGVyID0ge307XG5cblJvdXRlUmVzcG9uc2VSRVNUUmVhZGVyLlJFQURFUlMgPSB7XG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgcm91dGVSZXN1bHQgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19SZXNwb25zZV9tb2RlbF9Sb3V0ZVJlc3BvbnNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblxuICAgICAgICAvLyBvbiBib3VjbGUgc3VyIGxlcyBiYWxpc2VzIFwiZW5mYW50XCIgZGUgbGEgcsOpcG9uc2UgOlxuICAgICAgICAvLyBzdGF0dXMsIGRpc3RhbmNlLCBkdXJhdGlvbiwgZGlzdGFuY2VNZXRlcnMsIGR1cmF0aW9uU2Vjb25kcywgYm91bmRzLCBnZW9tZXRyeVdrdCwgc2ltcGxpZmllZFdrdCwgbGVnXG4gICAgICAgIF9fZ2V0Q2hpbGROb2Rlcyhub2RlLCByZXNwb25zZSk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIixcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgc3RhdHVzIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwiRVJST1JcIiB8fCBzdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBtZXNzYWdlIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2UubWVzc2FnZSA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgZGlzdGFuY2UgOiBmdW5jdGlvbiAobm9kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZS50b3RhbERpc3RhbmNlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBkdXJhdGlvblNlY29uZHMgOiBmdW5jdGlvbiAobm9kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZS50b3RhbFRpbWUgPSBwYXJzZUZsb2F0KF9fZ2V0Q2hpbGRWYWx1ZShub2RlKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIGJvdW5kcyA6IGZ1bmN0aW9uIChub2RlLCByZXNwb25zZSkge1xuICAgICAgICAvLyBnZXQgdmFsdWUgZXQgc3BsaXQgZXQgcGFyc2VGbG9hdFxuICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYmJveCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKS5zcGxpdCgvWyw7XS8pO1xuICAgICAgICAgICAgcmVzcG9uc2UuYmJveC5sZWZ0ID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgcmVzcG9uc2UuYmJveC5ib3R0b20gPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICByZXNwb25zZS5iYm94LnJpZ2h0ID0gcGFyc2VGbG9hdChjb29yZHNbMl0pO1xuICAgICAgICAgICAgcmVzcG9uc2UuYmJveC50b3AgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIGdlb21ldHJ5V2t0IDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGdlb21Xa3QgPSBub2RlLmlubmVySFRNTDtcblxuICAgICAgICAgICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgICAgICAgICAgdmFyIG9uV0tUU3VjY2VzcyA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uucm91dGVHZW9tZXRyeSA9IGpzb247XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgICAgICB2YXIgb25XS1RFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9GT1JNQVRcIiwgW1wiZ2VvbWV0cnlXa3RcIl0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGdldCBXS1QgR2VvbWV0cnkgZnJvbSBzdHJpbmdcbiAgICAgICAgICAgIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRm9ybWF0c19XS1RfX1tcImFcIiAvKiBkZWZhdWx0ICovXS50b0pzb24oZ2VvbVdrdCwgb25XS1RTdWNjZXNzLCBvbldLVEVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgc3RlcCA6IGZ1bmN0aW9uIChub2RlLCByZXNwb25zZSkge1xuICAgICAgICAvLyBjcsOpYXRpb24gZCd1bmUgbm91dmVsbGUgaW5zdHJ1Y3Rpb25cbiAgICAgICAgdmFyIHJvdXRlSW5zdHJ1Y3Rpb24gPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19SZXNwb25zZV9tb2RlbF9Sb3V0ZUluc3RydWN0aW9uX19bXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgLy8gbGVjdHVyZSBkZXMgaW5mb3JtYXRpb25zIGRlIGwnaW5zdHJ1Y3Rpb24gKGJhbGlzZXMgZW5mYW50cylcbiAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIGNoaWxkTmFtZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHsgLy8gMSA9PT0gbm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROYW1lID0gY2hpbGQubG9jYWxOYW1lIHx8IGNoaWxkLmJhc2VOYW1lIHx8IGNoaWxkLm5vZGVOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5hbWUgPT09IFwiZHVyYXRpb25TZWNvbmRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uZHVyYXRpb24gPSBfX2dldENoaWxkVmFsdWUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTmFtZSA9PT0gXCJkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmRpc3RhbmNlID0gX19nZXRDaGlsZFZhbHVlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09IFwibmF2SW5zdHJ1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbnN0cnVjdGlvbi5jb2RlID0gX19nZXRDaGlsZFZhbHVlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZE5hbWUgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gX19nZXRDaGlsZFZhbHVlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9uIHRlc3RlIGxlIGNvZGUgZGUgbCdpbnN0cnVjdGlvbiBwb3VyIHkgYWpvdXRlciBsYSBib25uZSBkZXNjcmlwdGlvblxuICAgICAgICBpZiAocm91dGVJbnN0cnVjdGlvbi5jb2RlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJvdXRlSW5zdHJ1Y3Rpb24uY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIlZhbGV1ciBub24gcmVuc2VpZ27DqWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbnN0cnVjdGlvbi5pbnN0cnVjdGlvbiA9IFwiVG91dCBkcm9pdCBcIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmluc3RydWN0aW9uID0gXCJDb250aW51ZXIgdG91dCBkcm9pdCBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQlwiOlxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmluc3RydWN0aW9uID0gXCJEZW1pLXRvdXIgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmluc3RydWN0aW9uID0gXCJUb3VybmVyIMOgIGdhdWNoZSBcIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPSBcIlRvdXJuZXIgw6AgZHJvaXRlIFwiICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkJMXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPSBcIlRvdXJuZXIgdHLDqHMgw6AgZ2F1Y2hlIFwiICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkJSXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPSBcIlRvdXJuZXIgdHLDqHMgw6AgZHJvaXRlIFwiICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPSBcIlRvdXJuZXIgbMOpZ8OocmVtZW50IMOgIGdhdWNoZSBcIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJGUlwiOlxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmluc3RydWN0aW9uID0gXCJUb3VybmVyIGzDqWfDqHJlbWVudCDDoCBkcm9pdGUgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicm91bmRfYWJvdXRfZW50cnlcIjpcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbnN0cnVjdGlvbi5pbnN0cnVjdGlvbiA9IFwiRW50csOpZSByb25kLXBvaW50IFwiICsgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJvdW5kX2Fib3V0X2V4aXRcIjpcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbnN0cnVjdGlvbi5pbnN0cnVjdGlvbiA9IFwiU29ydGllIHJvbmQtcG9pbnQgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5zdHJ1Y3Rpb24uaW5zdHJ1Y3Rpb24gPSBcIlByZW5kcmUgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluc3RydWN0aW9uLmluc3RydWN0aW9uID0gXCI/XCIgKyByb3V0ZUluc3RydWN0aW9uLmNvZGUgKyBcIj8gXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLnJvdXRlSW5zdHJ1Y3Rpb25zKSkge1xuICAgICAgICAgICAgcmVzcG9uc2Uucm91dGVJbnN0cnVjdGlvbnMucHVzaChyb3V0ZUluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuUm91dGVSZXNwb25zZVJFU1RSZWFkZXIucmVhZCA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgaWYgKHJvb3Qubm9kZU5hbWUgPT09IFwicm91dGVSZXN1bHRcIikge1xuICAgICAgICByZXNwb25zZSA9IFJvdXRlUmVzcG9uc2VSRVNUUmVhZGVyLlJFQURFUlNbXCJyb3V0ZVJlc3VsdFwiXShyb290KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycmV1ciBsb3JzIGRlIGxhIGxlY3R1cmUgZGUgbGEgcsOpcG9uc2UgOiBlbGxlIG4nZXN0IHBhcyBhdSBmb3JtYXQgYXR0ZW5kdS5cIik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMZWN0dXJlIGRlIGxhIHZhbGV1ciBkdSBwcmVtaWVyIGNoaWxkIGQndW4gbm9ldWQsIHNpIGVsbGUgZXhpc3RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUm91dGVSZXNwb25zZVJFU1RSZWFkZXJcbiAqIEBtZXRob2QgX19nZXRDaGlsZFZhbHVlXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgLSBhIERPTSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHZhbHVlIC0gdmFsZXVyIGR1IGZpcnN0Q2hpbGQgZHUgbm9ldWQgZW4gZW50csOpZSwgb3UgY2hhw65uZSB2aWRlLlxuICovXG5mdW5jdGlvbiBfX2dldENoaWxkVmFsdWUgKG5vZGUpIHtcbiAgICB2YXIgdGV4dE5vZGU7XG4gICAgdmFyIHZhbHVlID0gXCJcIjtcblxuICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlICYmIHRleHROb2RlLm5vZGVUeXBlID09PSAzKSB7IC8vIDMgPT09IG5vZGUuVEVYVF9OT0RFXG4gICAgICAgICAgICB2YWx1ZSA9IHRleHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUsOpY3Vww6lyYXRpb24gZGVzIG5vZXVkcyBlbmZhbnRzIMOgIHBhcnRpciBkJ3VuIG5vZXVkIGRvbm7DqSwgcG91ciBsZWN0dXJlIChyZWFkTm9kZSkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBSb3V0ZVJlc3BvbnNlUkVTVFJlYWRlclxuICogQG1ldGhvZCBfX2dldENoaWxkTm9kZXNcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBbZGF0YV0gLSBhbiBvYmplY3QgdG8gYmUgZmlsbGVkIHdpdGggbm9kZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0Q2hpbGROb2RlcyAobm9kZSwgZGF0YSkge1xuICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgdmFyIGNoaWxkTmFtZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHsgLy8gMSA9PT0gbm9kZS5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICBjaGlsZE5hbWUgPSBjaGlsZC5sb2NhbE5hbWUgfHwgY2hpbGQuYmFzZU5hbWUgfHwgY2hpbGQubm9kZU5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoUm91dGVSZXNwb25zZVJFU1RSZWFkZXIuUkVBREVSU1tjaGlsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBSb3V0ZVJlc3BvbnNlUkVTVFJlYWRlci5SRUFERVJTW2NoaWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlcihjaGlsZCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX19nZXRDaGlsZE5vZGVzKGNoaWxkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXNwb25zZVJFU1RSZWFkZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKipcbiAqIEFuYWx5c2UgZGUgbGEgcmVwb25zZSBPTFNcbiAqXG4gKiBAbW9kdWxlIFJvdXRlUmVzcG9uc2VPTFNSZWFkZXJcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Sb3V0ZS5Gb3JtYXRzLlJvdXRlUmVzcG9uc2VPTFNSZWFkZXJcbiAqIEB0b2RvIG5vdCB5ZXQgaW1wbGVtZW50ZWQgIVxuICogQHByaXZhdGVcbiAqL1xuXG5cblxuLyoqXG4gKiBPYmpldCBSb3V0ZVJlc3BvbnNlT0xTUmVhZGVyXG4gKiBAbWVtYmVyIHtPYmplY3R9IFJvdXRlUmVzcG9uc2VPTFNSZWFkZXJcbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gUm91dGVSZXNwb25zZU9MU1JlYWRlci5SRUFERVJTIC0gT2JqZXQgY29udGVuYW50IGRlcyBmb25jdGlvbnMgZGUgbGVjdHVyZSwgYXBwZWzDqWVzIFwicmVhZGVyc1wiXG4gKiAgICAgIGRvbnQgY2hhcXVlIGNsw6kgY29ycmVzcG9uZCBhdSBub20gZCd1biB0YWcgZHUgWE1MIHF1ZSBsJ29uIHNvdWhhaXRlIGxpcmVcbiAqICAgICAgZXQgbGEgdmFsZXVyIGFzc29jacOpZSBlc3QgdW5lIGZvbmN0aW9uIChub2RlLCBkYXRhKVxuICogICAgICBvw7kgbm9kZSBlc3QgdW4gbm9ldWQgZHUgZG9jdW1lbnQgRE9NXG4gKiAgICAgIGV0IGRhdGEgZXN0IHVuIG9iamV0IG/DuSBsJ29uIHN0b2NrZSBsZXMgaW5mb3JtYXRpb25zIGx1ZXMgZGFucyBsZSBYTUwuXG4gKlxuICogQHByb3BlcnR5IHtNZXRob2R9IFJvdXRlUmVzcG9uc2VPTFNSZWFkZXIucmVhZCAtICBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIGxhbmNlciBsYSBsZWN0dXJlIGQndW5lIHLDqXBvbnNlXG4gKiAgICAgIFhNTCBkdSBzZXJ2aWNlIGRlIGNhbGN1bCBkJ2l0aW5lcmFpcmUsIMOgIGwnYWlkZSBkZXMgcmVhZGVycyBkZSBsYSBjbGFzc2UuXG4gKi9cbnZhciBSb3V0ZVJlc3BvbnNlT0xTUmVhZGVyID0ge307XG5cbi8qKlxuICogT2JqZXQgY29udGVuYW50IGRlcyBmb25jdGlvbnMgZGUgbGVjdHVyZSwgYXBwZWzDqWVzIFwicmVhZGVyc1wiXG4gKiAgICAgIGRvbnQgY2hhcXVlIGNsw6kgY29ycmVzcG9uZCBhdSBub20gZCd1biB0YWcgZHUgWE1MIHF1ZSBsJ29uIHNvdWhhaXRlIGxpcmVcbiAqICAgICAgZXQgbGEgdmFsZXVyIGFzc29jacOpZSBlc3QgdW5lIGZvbmN0aW9uIChub2RlLCBkYXRhKVxuICogICAgICBvw7kgbm9kZSBlc3QgdW4gbm9ldWQgZHUgZG9jdW1lbnQgRE9NXG4gKiAgICAgIGV0IGRhdGEgZXN0IHVuIG9iamV0IG/DuSBsJ29uIHN0b2NrZSBsZXMgaW5mb3JtYXRpb25zIGx1ZXMgZGFucyBsZSBYTUwuXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUm91dGVSZXNwb25zZU9MU1JlYWRlclxuICovXG5Sb3V0ZVJlc3BvbnNlT0xTUmVhZGVyLlJFQURFUlMgPSB7XG4gICAgLypcbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBwYXMgZGUgcmVwb25zZSBlbiBKU09OIHBvdXIgbCdBUEkgT0xTLCB1bmlxdWVtZW50IGR1IFhNTCAhXG5cbiAgICAgICAgLy8gSU5GT1xuICAgICAgICAvLyBFeGVtcGxlIGQnZXJyZXVyIGR1IHNlcnZpY2VcbiAgICAgICAgLy8gPD94bWwgdmVyc2lvbj0gXCIxLjBcIiBlbmNvZGluZz0gXCJVVEYtOFwiIHN0YW5kYWxvbmU9IFwieWVzXCIgPz5cbiAgICAgICAgLy8gPFhMUyB2ZXJzaW9uPVwiMS4yXCIgeHNpIDogc2NoZW1hTG9jYXRpb24gPSBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzIGh0dHA6Ly9zY2hlbWFzLm9wZW5naXMubmV0L29scy8xLjIvb2xzQWxsLnhzZFwiIHhtbG5zIDogeGxzID0gXCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3hsc1wiIHhtbG5zPSBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzXCIgeG1sbnMgOiB4bHNleHQgPSBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQveGxzZXh0XCIgeG1sbnMgOiBnbWwgPSBcImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCIgLy8geG1sbnMgOiB4c2kgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXCIgPlxuICAgICAgICAvLyA8UmVzcG9uc2VIZWFkZXI+XG4gICAgICAgIC8vICAgICA8RXJyb3JMaXN0PlxuICAgICAgICAvLyAgICAgICAgIDxFcnJvciBtZXNzYWdlPVwiUm91dGluZyBlcnJvciA6IEVycm9yIGluIHNtYXJ0cm91dGluZyBjb20uZ2VvY29uY2VwdC5zbWFydHJvdXRpbmcuU21hcnRSb3V0aW5nTmF0aXZlRXhjZXB0aW9uIDogZmFpbGVkIHRvIGNvbm5lY3Qgd2F5cG9pbnQgeyA0OC44NDY1NzcsIDIuNDE2OTA3LCAwLjAwMDAwMCB9IGZhaWxlZCB0byBjb25uZWN0IHdheXBvaW50IHsgNDguODQ2NTc3LCAyLjQxNjkwNywgMC4wMDAwMDAgfSBcIiBlcnJvckNvZGU9XCJJbnRlcm5hbFNlcnZlckVycm9yXCIvPlxuICAgICAgICAvLyAgICAgPC9FcnJvckxpc3Q+XG4gICAgICAgIC8vIDwvUmVzcG9uc2VIZWFkZXI+XG4gICAgICAgIC8vIDxSZXNwb25zZSB2ZXJzaW9uPSBcIjEuMlwiIHJlcXVlc3RJRD0gXCJmODM1OGM3NC04YWVlLTQyMDMtOTBiOS0yYzcwZGI1OTk2YTFcIiAvPlxuICAgICAgICAvLyA8L1hMUz5cblxuICAgICAgICAvLyBJTkZPXG4gICAgICAgIC8vIEV4ZW1wbGUgZCdlcnJldXIgTkdpbnhcbiAgICAgICAgLy8gPEV4Y2VwdGlvblJlcG9ydD48RXhjZXB0aW9uIGV4Y2VwdGlvbkNvZGU9XCJNaXNzaW5nUGFyYW1ldGVyXCI+UmVzb3VyY2UgcGFyYW1ldGVyIG5vdCBmb3VuZDwvRXhjZXB0aW9uPjwvRXhjZXB0aW9uUmVwb3J0PlxuICAgICovXG59O1xuXG4vKipcbiAqIE3DqXRob2RlIHBlcm1ldHRhbnQgZGUgbGFuY2VyIGxhIGxlY3R1cmUgZCd1bmUgcsOpcG9uc2UgWE1MIGR1IHNlcnZpY2UgZGUgY2FsY3VsIGQnaXRpbmVyYWlyZSxcbiAqIMOgIGwnYWlkZSBkZXMgcmVhZGVycyBkZSBsYSBjbGFzc2UuXG4gKlxuICogQG1ldGhvZCBSb3V0ZVJlc3BvbnNlT0xTUmVhZGVyLnJlYWRcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdCAtIHJhY2luZSBkZSBsYSByw6lwb25zZSBYTUwgw6AgbGlyZVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFJvdXRlUmVzcG9uc2VPTFNSZWFkZXJcbiAqL1xuUm91dGVSZXNwb25zZU9MU1JlYWRlci5yZWFkID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAvLyBsb2dnZXJcbiAgICB2YXIgbG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJSb3V0ZVJlc3BvbnNlT0xTUmVhZGVyXCIpO1xuICAgIGxvZ2dlci5lcnJvcihcIm5vdCB5ZXQgaW1wbGVtZW50ZWQgIVwiKTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUm91dGVSZXNwb25zZU9MU1JlYWRlcik7XG5cblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Db21tb25TZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRGVmYXVsdFVybFNlcnZpY2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19SZXF1ZXN0X1Byb2Nlc3NJc29DdXJ2ZVJlcXVlc3RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fUmVzcG9uc2VfUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VGYWN0b3J5X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuXG5cblxuXG5cblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQXBwZWwgZHUgc2VydmljZSBkJ2lzb2Nocm9uZS9kaXN0YW5jZSBkdSBHw6lvcG9ydGFpbCA6XG4gKiAgICAgZW52b2kgZGUgbGEgcmVxdcOqdGUgY29uc3RydWl0ZSBzZWxvbiBsZXMgcGFyYW3DqHRyZXMgZW4gb3B0aW9ucyxcbiAqICAgICDDqXZlbnR1ZWxsZW1lbnQgcGFyc2luZyBldCBhbmFseXNlICBkZSBsYSByw6lwb25zZSxcbiAqICAgICByZXRvdXIgZCd1bmUgcsOpcG9uc2UgZW4gcGFyYW3DqHRyZSBkZSBsYSBmb25jdGlvbiBvblN1Y2Nlc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtHcC5TZXJ2aWNlcy5Db21tb25TZXJ2aWNlfVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlByb2Nlc3NJc29DdXJ2ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHNww6ljaWZpcXVlcyBhdSBzZXJ2aWNlICgrIGxlcyBvcHRpb25zIGhlcml0w6llcylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5vdXRwdXRGb3JtYXQgLSBMZSBmb3JtYXQgZGUgbGEgcsOpcG9uc2UgZHUgc2VydmljZSBpc28gOiAneG1sJyBvdSAnanNvbicuXG4gKiAgICAgIENlIHBhcmFtw6h0cmUgZMOpdGVybWluZXJhIGwnZXh0ZW5zaW9uICcueG1sJyBvdSAnLmpzb24nIGR1IHNlcnZpY2UuXG4gKiAgICAgIE7DqWNlc3NhaXJlIHNpIHNlcnZlclVybCBlc3QgcmVuc2VpZ27DqSBwb3VyIGNvbm5hw650cmUgbGUgZm9ybWF0IGRhbnMgbGVxdWVsIHNlcmEgZm91cm5pZSBsYSByw6lwb25zZSAocG91ciBzb24gdHJhaXRlbWVudCkuXG4gKiAgICAgIFBhciBkw6lmYXV0LCBjZSBwYXJhbcOodHJlIHZhdXQgJ2pzb24nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0gUG9pbnQgZGUgZMOpcGFydCBkdSBjYWxjdWwuXG4gKiAgICAgIENvb3Jkb25uw6llcyBleHByaW3DqWVzIGVuIGxvbmdpdHVkZXMsIGxhdGl0dWRlcyAoRVBTRzo0MzI2KVxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLnBvc2l0aW9uLnggLSBBYmNpc3NlIGR1IHBvaW50IGRlIGTDqXBhcnQgZHUgY2FsY3VsIGQnaXNvY2hyb25lL2Rpc3RhbmNlLlxuICogICAgICBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLnBvc2l0aW9uLnkgLSBPcmRvbm7DqWUgZHUgcG9pbnQgZGUgZMOpcGFydCBkdSBjYWxjdWwgZCdpc29jaHJvbmUvZGlzdGFuY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuc3JzIC0gUHJvamVjdGlvbi5cbiAqICAgICAgU3lzdMOobWUgZGUgY29vcmRvbm7DqWVzIGRhbnMgbGVxdWVsIGxlcyBjb29yZG9ubsOpZXMgZHUgcG9pbnQgwqsgbG9jYXRpb24gwrsgc29udCBleHByaW3DqWVzIGV0XG4gKiAgICAgIGRhbnMgbGVxdWVsIGxhIGfDqW9tw6l0cmllIGRlIGxhIGNvdXJiZSByw6lzdWx0YW50ZSBzZXJhIGV4cHJpbcOpZS5cbiAqICAgICAgUGFyIGTDqWZhdXQsIGxlIHN5c3TDqG1lIGRlIGNvb3Jkb25uw6llcyB1dGlsaXPDqSBzZXJhIMKrIEVQU0c6NDMyNiDCuy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZ3JhcGggPSBcInZvaXR1cmVcIl0gLSBOb20gZHUgZ3JhcGhlIMOgIHV0aWxpc2VyIHBvdXIgbGUgY2FsY3VsICjCqyBQaWV0b24gwrsgb3UgwqsgVm9pdHVyZSDCuykuXG4gKiAgICAgIExhIHZhbGV1ciBwYXIgZMOpZmF1dCBlc3QgOiDCq3ZvaXR1cmXCu1xuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IFtvcHRpb25zLmV4Y2x1c2lvbnNdIC0gQ3JpdMOocmVzIGQnZXhjbHVzaW9ucyDDoCBhcHBsaXF1ZXIgcG91ciBsZSBjYWxjdWwuXG4gKiAgICAgIE9uIHByw6ljaXNlIGljaSBsZSB0eXBlIGRlIHRyb27Dp29ucyBxdWUgbCdvbiBuZSB2ZXV0IHBhcyBxdWUgbCdpc29jaHJvbmUvZGlzdGFuY2UgZW1wcnVudGVcbiAqICAgICAgKHZhbGV1cnMgcG9zc2libGVzIDogwqsgdG9sbCDCuyAow6l2aXRlciBsZXMgcMOpYWdlcyksIMKrIGJyaWRnZSDCuywgwqsgdHVubmVsIMK7KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kID0gXCJ0aW1lXCJdIC0gTcOpdGhvZGUgdXRpbGlzw6llIHBvdXIgbGUgY2FsY3VsIGRlIGxhIGNvdXJiZSBpc28uXG4gKiAgICAgIExlcyB2YWxldXJzIHBvc3NpYmxlIHNvbnQgXCJ0aW1lXCIgcG91ciB1biBjYWxjdWwgZCdpc29jaHJvbmUsIFwiZGlzdGFuY2VcIiBwb3VyIHVuIGNhbGN1bCBkJ2lzb2Rpc3RhbmNlLlxuICogICAgICBQYXMgZGUgdmFsZXVyIHNww6ljaWZpw6kgw6lxdWl2YXV0IMOgIHVuIGNhbGN1bCBkJ2lzb2Nocm9uZS5cbiAqXG4gKiBAcGFyYW0ge0Zsb2F0fSBvcHRpb25zLnRpbWUgLSBEdXLDqWUgbWF4aW11bSAoZXhwcmltw6llIGVuIHNlY29uZGVzKSDDoCB1dGlsaXNlciBwb3VyIGxlIGNhbGN1bCBkZSBsYSBjb3VyYmUgw6AgcGFydGlyIGR1IG91IGp1c3F1J2F1IHBvaW50IMKrIGxvY2F0aW9uIMK7LlxuICogICAgICBDZSBwYXJhbcOodHJlIGRvaXQgw6p0cmUgcmVuc2VpZ27DqSBzaSBsJ29wdGlvbiBcIm3DqXRob2RcIiBhIGxhIHZhbGV1ciBcInRpbWVcIi5cbiAqICAgICAgU2kgbCdvcHRpb24gbWV0aG9kIG4nZXN0IHBhcyByZW5zZWlnbsOpZSwgY2UgcGFyYW3DqHRyZSBkb2l0IMOqdHJlIHJlbnNlaWduw6kuXG4gKlxuICogQHBhcmFtIHtGbG9hdH0gb3B0aW9ucy5kaXN0YW5jZSAtIERpc3RhbmNlIG1heGltdW0gKGV4cHJpbcOpZSBlbiBtZXRyZXMpIMOgIHV0aWxpc2VyIHBvdXIgbGUgY2FsY3VsIGRlIGxhIGNvdXJiZSDDoCBwYXJ0aXIgZHUgb3Ugaid1c3F1J2F1IHBvaW50IMKrIGxvY2F0aW9uIMK7LlxuICogICAgICBDZSBwYXJhbcOodHJlIGRvaXQgw6p0cmUgcmVuc2VpZ27DqSBzaSBsJ29wdGlvbiBcIm3DqXRob2RcIiBhIGxhIHZhbGV1ciBcIkRJU1RBTkNFXCIuXG4gKiAgICAgIFNpIGwnb3B0aW9uIFwibWV0aG9kXCIgbidlc3QgcGFzIHJlbnNlaWduw6llLCBjZSBwYXJhbcOodHJlIHNlcmEgaWdub3LDqS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldmVyc2UgPSBmYWxzZV0gLSBJbmRpcXVlIHNpIGxhIGfDqW9tw6l0cmllIHLDqXN1bHRhbnRlIGRvaXQgw6p0cmUgbGlzc8OpZSAowqsgdHJ1ZSDCuykgcG91ciBuZSBwYXMgYXZvaXIgZCdlZmZldCBkJ2VzY2FsaWVyLlxuICogICAgICBQYXIgZMOpZmF1dCwgbGEgdmFsZXVyIMKrIGZhbHNlIMK7IGVzdCBhcHBsaXF1w6llLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc21vb3RoaW5nID0gZmFsc2VdIC0gSW5kaXF1ZSBzaSBsYSBnw6lvbcOpdHJpZSByw6lzdWx0YW50ZSBkb2l0IMOqdHJlIGxpc3PDqWUgKMKrIHRydWUgwrspIHBvdXIgbmUgcGFzIGF2b2lyIGQnZWZmZXQgZCdlc2NhbGllci5cbiAqICAgICAgUGFyIGTDqWZhdXQsIGxhIHZhbGV1ciDCqyBmYWxzZSDCuyBlc3QgYXBwbGlxdcOpZS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmhvbGVzID0gZmFsc2VdIC0gSW5kaXF1ZSBzaSBsYSBnw6lvbcOpdHJpZSByw6lzdWx0YW50ZSAoc3VyZmFjZSkgZG9pdCDDqnRyZSByZXRvdXJuw6llIGF2ZWMgZGVzIHRyb3VzICjCqyB0cnVlIMK7KS5cbiAqICAgICAgUGFyIGTDqWZhdXQsIGxhIHZhbGV1ciDCqyBmYWxzZSDCuyBlc3QgYXBwbGlxdcOpZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB2YXIgb3B0aW9ucyA9IHtcbiAqICAgICAgLy8gb3B0aW9ucyBjb21tdW5lcyBhdXggc2VydmljZXNcbiAqICAgICAgYXBpS2V5IDogbnVsbCxcbiAqICAgICAgc2VydmVyVXJsIDogJ2h0dHA6Ly9sb2NhbGhvc3Qvc2VydmljZS8nLFxuICogICAgICBwcm90b2NvbCA6ICdKU09OUCcsIC8vIEpTT05QfFhIUlxuICogICAgICBwcm94eVVSTCA6IG51bGwsXG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgdGltZU91dCA6IDEwMDAwLCAvLyBtc1xuICogICAgICByYXdSZXNwb25zZSA6IGZhbHNlLCAvLyB0cnVlfGZhbHNlXG4gKiAgICAgIHNjb3BlIDogbnVsbCwgLy8gdGhpc1xuICogICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHt9LFxuICogICAgICBvbkZhaWx1cmUgOiBmdW5jdGlvbiAoZXJyb3IpIHt9LFxuICogICAgICAvLyBzcMOpY2lmaXF1ZSBhdSBzZXJ2aWNlXG4gKiAgICAgIHBvc2l0aW9uIDoge1xuICogICAgICAgICAgIHggOiAyLjMyNDI2NjQyOTgwNTgwNTMsXG4gKiAgICAgICAgICAgeSA6IDQ4Ljg2MTE4MDE3MzI0NzQ1XG4gKiAgICAgIH0sXG4gKiAgICAgIGRpc3RhbmNlIDogMjAwLFxuICogICAgICBbdGltZSA6IF1cbiAqICAgICAgbWV0aG9kIDogXCJkaXN0YW5jZVwiLFxuICogICAgICBleGNsdXNpb25zIDogW1wiQnJpZGdlXCIsIFwiVHVubmVsXCIsIFwiVG9sbFwiXSxcbiAqICAgICAgZ3JhcGggOiBcInZvaXR1cmVcIixcbiAqICAgICAgcmV2ZXJzZSA6IGZhbHNlLFxuICogICAgICBzbW9vdGhpbmcgOiBmYWxzZSxcbiAqICAgICAgaG9sZXMgOiBmYWxzZVxuICogIH07XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFByb2Nlc3NJc29DdXJ2ZSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9jZXNzSXNvQ3VydmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJDTEFTU19DT05TVFJVQ1RPUlwiLCBcIlByb2Nlc3NJc29DdXJ2ZVwiKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9tIGRlIGxhIGNsYXNzZSAoaGVyaXRhZ2UpXG4gICAgICogRklYTUUgaW5zdGFuY2Ugb3UgY2xhc3NlID9cbiAgICAgKi9cbiAgICB0aGlzLkNMQVNTTkFNRSA9IFwiUHJvY2Vzc0lzb0N1cnZlXCI7XG5cbiAgICAvLyBhcHBlbCBkdSBjb25zdHJ1Y3RldXIgcGFyIGhlcml0YWdlXG4gICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19Db21tb25TZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJHcC5TZXJ2aWNlcy5Qcm9jZXNzSXNvQ3VydmVcIik7XG4gICAgdGhpcy5sb2dnZXIudHJhY2UoXCJbQ29uc3RydWN0ZXVyIFByb2Nlc3NJc29DdXJ2ZSAob3B0aW9ucyldXCIpO1xuXG4gICAgaWYgKCFvcHRpb25zLnBvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJwb3NpdGlvblwiKSk7XG4gICAgfVxuXG4gICAgLy8gb24gbGFuY2UgdW5lIGV4Y2VwdGlvbiBhZmluIGQnZXZpdGVyIGF1IHNlcnZpY2UgZGUgbGUgZmFpcmUuLi5cbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi54ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJwb3NpdGlvbi54XCIpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi55ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlBBUkFNX01JU1NJTkdcIiwgXCJwb3NpdGlvbi55XCIpKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudGltZSAmJiAhb3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgKHMpICdkaXN0YW5jZScgbWlzc2luZy4gUGFyYW1ldGVyIHRpbWUgdG8gY2FsY3VsYXRlIGFuIGlzb2Nocm9uZSwgcGFyYW1ldGVyIGRpc3RhbmNlIGZvciBhbiBpc29kaXN0YW5jZVwiKTtcbiAgICB9XG5cbiAgICAvLyBzaSBvbiBhIHF1ZSBsZSBwYXJhbcOodHJlIFwiZGlzdGFuY2VcIiBlbiBlbnRyw6llLCBvbiBjYWxjdWxlIHVuZSBpc29kaXN0YW5jZS5cbiAgICAvLyBMZSBwYXJhbcOodHJlIFwibcOpdGhvZGVcIiBkb2l0IHBvdXIgYXZvaXIgdW5lIHLDqXBvbnNlIGR1IHNlcnZpY2UsIMOqdHJlIHBhc3PDqSDDoCBcImRpc3RhbmNlXCJcbiAgICBpZiAoIW9wdGlvbnMudGltZSAmJiBvcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tZXRob2QgPSBcImRpc3RhbmNlXCI7XG4gICAgICAgIC8vIG9uIHN1cHByaW1lIGwnw6l2ZW50dWVsIGF0dHJpYnV0IHRpbWUsIHLDqXNpZHUgZCd1biBhcHBlbCBhbnTDqXJpZXVyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGltZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy50aW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2kgb24gYSBxdWUgbGUgcGFyYW3DqHRyZSBcInRpbWVcIiBlbiBlbnRyw6llLCBvbiBjYWxjdWxlIHVuZSBpc29jaHJvbmUuXG4gICAgLy8gTGUgcGFyYW3DqHRyZSBcIm3DqXRob2RlXCIgZG9pdCBwb3VyIGF2b2lyIHVuZSByw6lwb25zZSBkdSBzZXJ2aWNlLCDDqnRyZSBwYXNzw6kgw6AgXCJ0aW1lXCJcbiAgICBpZiAob3B0aW9ucy50aW1lICYmICFvcHRpb25zLmRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5tZXRob2QgPSBcInRpbWVcIjtcbiAgICAgICAgLy8gb24gc3VwcHJpbWUgbCfDqXZlbnR1ZWwgYXR0cmlidXQgdGltZSwgcsOpc2lkdSBkJ3VuIGFwcGVsIGFudMOpcmlldXJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXN0YW5jZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF1IGNhcyBvw7kgb24gYSBuaSBsJ3VuLCBuaSBsJ2F1dHJlLi4uXG4gICAgdGhpcy5vcHRpb25zLm1ldGhvZCA9IHRoaXMub3B0aW9ucy5tZXRob2QgfHwgXCJ0aW1lXCI7XG5cbiAgICAvLyBvcHRpb25zIHBhciBkZWZhdXQgZHUgc2VydmljZVxuICAgIHRoaXMub3B0aW9ucy5leGNsdXNpb25zID0gb3B0aW9ucy5leGNsdXNpb25zIHx8IG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmdyYXBoID0gb3B0aW9ucy5ncmFwaCB8fCBcIlZvaXR1cmVcIjsgLy8gVE9ETyB0ZXN0IGRlIGxhIHZhbGV1ciDDoCBmYWlyZSAhXG4gICAgdGhpcy5vcHRpb25zLnJldmVyc2UgPSBvcHRpb25zLnJldmVyc2UgfHwgZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zLnNtb290aGluZyA9IG9wdGlvbnMuc21vb3RoaW5nIHx8IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucy5ob2xlcyA9IG9wdGlvbnMuaG9sZXMgfHwgZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zLnNycyA9IG9wdGlvbnMuc3JzIHx8IFwiRVBTRzo0MzI2XCI7XG5cbiAgICAvLyBvbiBwYXNzZSBsJ29wdGlvbiBvdXRwdXRGb3JtYXQgZW4gbWludXNjdWxlcyBhZmluIGQnw6l2aXRlciBkZXMgZXhjZXB0aW9ucy5cbiAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gKHR5cGVvZiBvcHRpb25zLm91dHB1dEZvcm1hdCA9PT0gXCJzdHJpbmdcIikgPyBvcHRpb25zLm91dHB1dEZvcm1hdC50b0xvd2VyQ2FzZSgpIDogXCJqc29uXCI7XG5cbiAgICAvLyBnZXN0aW9uIGRlIGwndXJsIGR1IHNlcnZpY2UgcGFyIGRlZmF1dFxuICAgIC8vIHNpIGwndXJsIG4nZXN0IHBhcyByZW5zZWlnbsOpZSwgaWwgZmF1dCB1dGlsaXNlciBsZXMgdXJscyBwYXIgZGVmYXV0XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2VydmVyVXJsKSB7XG4gICAgICAgIHZhciBsc3RVcmxCeURlZmF1bHQgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX0RlZmF1bHRVcmxTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uUHJvY2Vzc0lzb0N1cnZlLnVybCh0aGlzLm9wdGlvbnMuYXBpS2V5KTtcblxuICAgICAgICB2YXIgdXJsRm91bmQgPSBsc3RVcmxCeURlZmF1bHRbXCJpc29cIiArIFwiLVwiICsgdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdF07XG4gICAgICAgIGlmICghdXJsRm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVybCBieSBkZWZhdWx0IG5vdCBmb3VuZCAhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5zZXJ2ZXJVcmwgPSB1cmxGb3VuZDtcbiAgICAgICAgdGhpcy5sb2dnZXIudHJhY2UoXCJTZXJ2ZXVyIFVSTCBwYXIgZGVmYXV0IDogXCIgKyB0aGlzLm9wdGlvbnMuc2VydmVyVXJsKTtcbiAgICB9XG5cbiAgICAvLyBnZXN0aW9uIGR1IHR5cGUgZGUgc2VydmljZVxuICAgIC8vIHNpIGwnZXh0ZW5zaW9uIGRlIGwndXJsIGVzdCAuanNvbiBvdSAueG1sLCBvbiBzdXJjaGFyZ2UgbGUgZm9ybWF0IGRlIHNvcnRpZSAob3V0cHV0Rm9ybWF0KVxuICAgIHZhciBpZHggPSB0aGlzLm9wdGlvbnMuc2VydmVyVXJsLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLnNlcnZlclVybC5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgZXh0ZW5zaW9uLmxlbmd0aCA8IDUpIHsgLy8gRklYTUUgZXh0ZW5zaW9uIGRlIG1vaW5zIGRlIDQgY2FyLiAuLi5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiU2VydmV1ciBFeHRlbnNpb24gVVJMIDogXCIgKyBleHRlbnNpb24pO1xuICAgICAgICAgICAgc3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3V0cHV0Rm9ybWF0ID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgb2Ygc2VydmljZSA6IHVua25vd24gb3IgdW5zdXBwb3J0ZWQgKGpzb24gb3IgeG1sKSAhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsZW5kcyBtb2R1bGU6UHJvY2Vzc0lzb0N1cnZlI1xuICovXG5Qcm9jZXNzSXNvQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0NvbW1vblNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUsIHtcbiAgICAvLyB0b2RvXG4gICAgLy8gZ2V0dGVyL3NldHRlclxufSk7XG5cbi8qXG4gKiBDb25zdHJ1Y3RldXIgKGFsaWFzKVxuICovXG5Qcm9jZXNzSXNvQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJvY2Vzc0lzb0N1cnZlO1xuXG4vKipcbiAqIENyw6lhdGlvbiBkZSBsYSByZXF1w6p0ZSAob3ZlcndyaXRlKVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yICAgLSBjYWxsYmFjayBkZXMgZXJyZXVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyAtIGNhbGxiYWNrXG4gKi9cblByb2Nlc3NJc29DdXJ2ZS5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0ID0gZnVuY3Rpb24gKGVycm9yLCBzdWNjZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIG9Jc29DdXJ2ZSA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1JlcXVlc3RfUHJvY2Vzc0lzb0N1cnZlUmVxdWVzdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICghb0lzb0N1cnZlLnByb2Nlc3NSZXF1ZXN0U3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1V0aWxzX01lc3NhZ2VzUmVzb3VyY2VzX19bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZShcIlNFUlZJQ0VfUkVRVUVTVF9CVUlMRFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlcXVlc3QgPSBvSXNvQ3VydmUucmVxdWVzdFN0cmluZztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yLmNhbGwodGhpcywgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXShlLm1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1Y2Nlc3MuY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QpO1xufTtcblxuLyoqXG4gKiAob3ZlcndyaXRlKVxuICogQW5hbHlzZSBkZSBsYSByZXBvbnNlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25FcnJvciAgIC0gY2FsbGJhY2sgZGVzIGVycmV1cnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3VjY2VzcyAtIGNhbGxiYWNrIGRlIHN1Y2PDqHMgZGUgbCdhbmFseXNlIGRlIGxhIHLDqXBvbnNlXG4gKi9cblByb2Nlc3NJc29DdXJ2ZS5wcm90b3R5cGUuYW5hbHl6ZVJlc3BvbnNlID0gZnVuY3Rpb24gKG9uRXJyb3IsIG9uU3VjY2Vzcykge1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVzcG9uc2UgOiB0aGlzLnJlc3BvbnNlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0IDogdGhpcy5vcHRpb25zLm91dHB1dEZvcm1hdCxcbiAgICAgICAgICAgIHJhd1Jlc3BvbnNlIDogdGhpcy5vcHRpb25zLnJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgb25TdWNjZXNzIDogb25TdWNjZXNzLFxuICAgICAgICAgICAgb25FcnJvciA6IG9uRXJyb3IsXG4gICAgICAgICAgICBzY29wZSA6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1Jlc3BvbnNlX1Byb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlRmFjdG9yeV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmJ1aWxkKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IuY2FsbCh0aGlzLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJvY2Vzc0lzb0N1cnZlKTtcblxuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19tb2RlbF9Qcm9jZXNzSXNvQ3VydmVQYXJhbV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG5cblxuXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzc2UgZGUgZ2VzdGlvbiBkZXMgcmVxdcOqdGVzIHN1ciBsZSBzZXJ2aWNlIGRlIGNhbGN1bCBkJ2lzb3NjaHJvbmUvaXNvZGlzdGFuY2UuXG4gKiAgTGVzIHJlcXXDqnRlcyBwZXV2ZW50IMOqdHJlIGVuIG1vZGUgR0VUIG91IFBPU1QsXG4gKiAgZXQgbGUgZm9ybWF0IGRlIHNvcnRpIGVzdCBlbiBKU09OIG91IGVuIFhNTC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBHcC5TZXJ2aWNlcy5Qcm9jZXNzSXNvQ3VydmUuUmVxdWVzdC5Qcm9jZXNzSXNvQ3VydmVSZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIG9wdGlvbnMgPSB7XG4gKiAgICAgIGh0dHBNZXRob2QgOiAnR0VUJywgLy8gR0VUfFBPU1RcbiAqICAgICAgLy8gc3DDqWNpZmlxdWUgYXUgc2VydmljZVxuICogICAgICBleGNsdXNpb25zIDogWydCcmlkZ2UnLCAnVHVubmVsJ10sXG4gKiAgICAgIHBvc2l0aW9uIDoge1xuICogICAgICAgICAgeCA6IDIuMzI0MjY2NDI5ODA1ODA1MyxcbiAqICAgICAgICAgIHkgOiA0OC44NjExODAxNzMyNDc0NVxuICogICAgICB9LFxuICogICAgICBncmFwaCA6IFwiVm9pdHVyZVwiLFxuICogICAgICBtZXRob2QgOiAndGltZScsXG4gKiAgICAgIHRpbWUgOiAxMDAwLCAvL2Rpc3RhbmNlIDogMjAwXG4gKiAgICAgIHJldmVyc2UgOiBmYWxzZSxcbiAqICAgICAgc21vb3RoaW5nIDogZmFsc2UsXG4gKiAgICAgIGhvbGVzIDogZmFsc2UsXG4gKiAgICAgIHNycyA6ICdFUFNHOjQzMjYnXG4gKiAgfTtcbiAqXG4gKiB0cnkge1xuICpcbiAqICAgICAgdmFyIG9Jc29DdXJ2ZSA9IG5ldyBQcm9jZXNzSXNvQ3VydmVSZXF1ZXN0IChvcHRpb25zKTtcbiAqICAgICAgaWYgKCFvSXNvQ3VydmUucHJvY2Vzc1JlcXVlc3RTdHJpbmcgKCkpIHtcbiAqICAgICAgICAgIC8vIGVycm9yXG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIHZhciByZXF1ZXN0ID0gb0lzb0N1cnZlLnJlcXVlc3RTdHJpbmc7XG4gKlxuICogfSBjYXRjaCAoZSkge1xuICogICAgICAvLyBlcnJvclxuICogfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gUHJvY2Vzc0lzb0N1cnZlUmVxdWVzdCAob3B0aW9ucykge1xuICAgIHRoaXMubG9nZ2VyID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19Mb2dnZXJCeURlZmF1bHRfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRMb2dnZXIoXCJQcm9jZXNzSXNvQ3VydmVSZXF1ZXN0XCIpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBQcm9jZXNzSXNvQ3VydmVSZXF1ZXN0ICgpXVwiKTtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9jZXNzSXNvQ3VydmVSZXF1ZXN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvY2Vzc0lzb0N1cnZlUmVxdWVzdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIC8vIGV4aXN0YW5jZSBkZXMgb3B0aW9uc1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9FTVBUWVwiLCBcIm9wdGlvbnNcIikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlIGRlcyBvcHRpb25zXG4gICAgICovXG4gICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBNb2RlIEhUUFAuXG4gICAgICogUGFyIGRlZmF1dCwgXCJHRVRcIi5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IHRoaXMuc2V0dGluZ3MuaHR0cE1ldGhvZCB8fCBcIkdFVFwiO1xufVxuXG5Qcm9jZXNzSXNvQ3VydmVSZXF1ZXN0LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBsZW5kcyBtb2R1bGU6UHJvY2Vzc0lzb0N1cnZlUmVxdWVzdCNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJlcXXDqnRlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICByZXF1ZXN0U3RyaW5nIDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBQcm9jZXNzSXNvQ3VydmVSZXF1ZXN0LFxuXG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgZGUgbGEgcmVxdcOqdGUgKFBPU1QpXG4gICAgICogKiBfX1hfXyBfX1lfXyBfX1NSU19fIF9fR1JBUEhOQU1FX18gX19NRVRIT0RfXyAgKG9ibGlnYXRvaXJlKVxuICAgICAqICogX19SRVZFUlNFX18gX19TTU9PVEhJTkdfXyBfX0hPTEVTX18gICAgICAgICAgIChwYXIgZGVmYXV0KVxuICAgICAqICogX19USU1FX18gX19USU1FVkFMVUVfXyAgICAgICAgICAgICAgICAgICAgICAgIChjaG9peClcbiAgICAgKiAqIF9fRElTVEFOQ0VfXyBfX0RJU1RBTkNFVkFMVUVfXyAgICAgICAgICAgICAgICAoY2hvaXgpXG4gICAgICogKiBfX0VYQ0xVU0lPTlNfXyBfX0VYQ0xVU0lPTkZFQVRVUkVfXyBfX0VYQ0xVU0lPTlZBTFVFX18gKG9wdGlvbm5lbClcbiAgICAgKiAqIF9fUFJPRklMX18gX19QUk9GSUxJRF9fIF9fUFJPRklMTkFNRV9fICAgICAgICAgICAgICAgICAodHLDqHMgb3B0aW9ubmVsKVxuICAgICAqICogX19JRF9fIF9fSURWQUxVRV9fICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0csOocyBvcHRpb25uZWwpXG4gICAgICovXG4gICAgdGVtcGxhdGUgOiB7XG4gICAgICAgIGNvbnRhaW5lciA6IFwiPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz5cXG5cIiArXG4gICAgICAgICAgICBcIjxpc29jaHJvbmVSZXF1ZXN0PlxcblwiICtcbiAgICAgICAgICAgIFwiX19JRF9fXCIgK1xuICAgICAgICAgICAgXCJcXHQ8bG9jYXRpb24+XFxuXCIgK1xuICAgICAgICAgICAgXCJcXHRcXHQ8eD5fX1hfXzwveD5cXG5cIiArXG4gICAgICAgICAgICBcIlxcdFxcdDx5Pl9fWV9fPC95PlxcblwiICtcbiAgICAgICAgICAgIFwiXFx0PC9sb2NhdGlvbj5cXG5cIiArXG4gICAgICAgICAgICBcIlxcdDxzcnM+X19TUlNfXzwvc3JzPlxcblwiICtcbiAgICAgICAgICAgIFwiXFx0PGdyYXBoTmFtZT5fX0dSQVBITkFNRV9fPC9ncmFwaE5hbWU+XFxuXCIgK1xuICAgICAgICAgICAgXCJfX1BST0ZJTF9fXCIgK1xuICAgICAgICAgICAgXCJfX0VYQ0xVU0lPTlNfX1wiICtcbiAgICAgICAgICAgIFwiXFx0PG1ldGhvZD5fX01FVEhPRF9fPC9tZXRob2Q+XFxuXCIgK1xuICAgICAgICAgICAgXCJfX1RJTUVfX1wiICtcbiAgICAgICAgICAgIFwiX19ESVNUQU5DRV9fXCIgK1xuICAgICAgICAgICAgXCJcXHQ8cmV2ZXJzZT5fX1JFVkVSU0VfXzwvcmV2ZXJzZT5cXG5cIiArXG4gICAgICAgICAgICBcIlxcdDxzbW9vdGhpbmc+X19TTU9PVEhJTkdfXzwvc21vb3RoaW5nPlxcblwiICtcbiAgICAgICAgICAgIFwiXFx0PGhvbGVzPl9fSE9MRVNfXzwvaG9sZXM+XFxuXCIgK1xuICAgICAgICAgICAgXCI8L2lzb2Nocm9uZVJlcXVlc3Q+XCIsXG4gICAgICAgIGlkIDogXCJcXHQ8aWQ+X19JRFZBTFVFX188L2lkPlxcblwiLFxuICAgICAgICBwcm9maWwgOiBcIlxcdDxwcm9maWxlSWQ+X19QUk9GSUxJRF9fPC9wcm9maWxlSWQ+XFxuXCIgKyBcIlxcdDxwcm9maWxlTmFtZT5fX1BST0ZJTE5BTUVfXzwvcHJvZmlsZU5hbWU+XFxuXCIsXG4gICAgICAgIGV4Y2x1c2lvbnMgOiB7XG4gICAgICAgICAgICBjb250YWluZXIgOiBcIlxcdDxleGNsdXNpb25zPlxcblwiICtcbiAgICAgICAgICAgICAgICBcIl9fRVhDTFVTSU9ORkVBVFVSRV9fXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0PC9leGNsdXNpb25zPlxcblwiLFxuICAgICAgICAgICAgZmVhdHVyZSA6IFwiXFx0XFx0PGV4Y2x1c2lvbj5fX0VYQ0xVU0lPTlZBTFVFX188L2V4Y2x1c2lvbj5cIlxuICAgICAgICB9LFxuICAgICAgICB0aW1lIDogXCJcXHQ8dGltZT5fX1RJTUVWQUxVRV9fPC90aW1lPlxcblwiLFxuICAgICAgICBkaXN0YW5jZSA6IFwiXFx0PGRpc3RhbmNlPl9fRElTVEFOQ0VWQUxVRV9fPC9kaXN0YW5jZT5cXG5cIlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rpb24gZGUgbGEgcmVxdcOqdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdFVCAgb3V0IDpcbiAgICAgKiAgIC8vICAoaHR0cDovL3d4cy5pZ24uZnIvS0VZL2lzb2Nocm9uZS9pc29jaHJvbmUuanNvbj8pXG4gICAgICogICAvLyAgbG9jYXRpb249JlxuICAgICAqICAgLy8gIHRpbWU9JiBvdSBkaXN0YW5jZT0mXG4gICAgICogICAvLyAgbWV0aG9kPVwiRElTVEFOQ0V8VElNRVwiJlxuICAgICAqICAgLy8gIGdyYXBoPVBpZXRvbiZcbiAgICAgKiAgIC8vICBncmFwaE5hbWU9UGlldG9uJlxuICAgICAqICAgLy8gIGV4Y2x1c2lvbnM9JlxuICAgICAqICAgLy8gIHJldmVyc2U9MTAmXG4gICAgICogICAvLyAgc21vb3RoaW5nPSZcbiAgICAgKiAgIC8vICBob2xlcz0mXG4gICAgICogICAvLyAgc3JzPVxuICAgICAqXG4gICAgICogLy8gUE9TVCBvdXQgOlxuICAgICAqICAgLy8gPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG4gICAgICogICAvLyA8aXNvY2hyb25lUmVxdWVzdD5cbiAgICAgKiAgIC8vICAgPGlkPjE8L2lkPlxuICAgICAqICAgLy8gICA8bG9jYXRpb24+XG4gICAgICogICAvLyAgICAgPHg+LTEuNTU3MTg5PC94PlxuICAgICAqICAgLy8gICAgIDx5PjQ3LjIxNzEyMjwveT5cbiAgICAgKiAgIC8vICAgPC9sb2NhdGlvbj5cbiAgICAgKiAgIC8vICAgPHNycz48L3Nycz5cbiAgICAgKiAgIC8vICAgPGdyYXBoTmFtZT48L2dyYXBoTmFtZT5cbiAgICAgKiAgIC8vICAgPHByb2ZpbGVJZD48L3Byb2ZpbGVJZD5cbiAgICAgKiAgIC8vICAgPHByb2ZpbGVOYW1lPjwvcHJvZmlsZU5hbWU+XG4gICAgICogICAvLyAgIDxleGNsdXNpb25zPlxuICAgICAqICAgLy8gICAgIDxleGNsdXNpb24+PC9leGNsdXNpb24+XG4gICAgICogICAvLyAgICAgPGV4Y2x1c2lvbj48L2V4Y2x1c2lvbj5cbiAgICAgKiAgIC8vICAgPC9leGNsdXNpb25zPlxuICAgICAqICAgLy8gICA8bWV0aG9kPjwvbWV0aG9kPlxuICAgICAqICAgLy8gICA8dGltZT41MDwvdGltZT5cbiAgICAgKiAgIC8vICAgPGRpc3RhbmNlPjwvZGlzdGFuY2U+XG4gICAgICogICAvLyAgIDxyZXZlcnNlPjwvcmV2ZXJzZT5cbiAgICAgKiAgIC8vICAgPHNtb290aGluZz48L3Ntb290aGluZz5cbiAgICAgKiAgIC8vICAgPGhvbGVzPjwvaG9sZXM+XG4gICAgICogICAvLyA8L2lzb2Nocm9uZVJlcXVlc3Q+XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHByb2Nlc3NSZXF1ZXN0U3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IFwiXCI7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUHJvY2VzcyBHRVQgUmVxdWVzdFwiKTtcblxuICAgICAgICAgICAgICAgIC8vIE1hcHBpbmcgZGVzIG9wdGlvbnMgYXZlYyBsZSBzZXJ2aWNlIGRlIGwnQVBJIFJFU1RcbiAgICAgICAgICAgICAgICB2YXIgb1BhcmFtcyA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX21vZGVsX1Byb2Nlc3NJc29DdXJ2ZVBhcmFtX19bXCJhXCIgLyogZGVmYXVsdCAqL10odGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG9QYXJhbXMuZ2V0UGFyYW1zKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCArPSBcIiZcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ICs9IG8uayArIFwiPVwiICsgby52O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiUE9TVFwiOlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiUHJvY2VzcyBQT1NUIFJlcXVlc3RcIik7XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy50ZW1wbGF0ZS5jb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zIG5vbiBwcmlzZXMgZW4gY29tcHRlIGNhciBub24gaW1wbMOpbWVudMOpZXMgIVxuICAgICAgICAgICAgICAgIC8vIGNsZWFuIDogaWRcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKC9fX0lEX18vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW4gOiBwcm9maWxcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKC9fX1BST0ZJTF9fL2csIFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBvYmxpZ2F0b2lyZXNcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKC9fX1hfXy9nLCB0aGlzLnNldHRpbmdzLnBvc2l0aW9uLngpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fWV9fL2csIHRoaXMuc2V0dGluZ3MucG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSgvX19HUkFQSE5BTUVfXy9nLCB0aGlzLnNldHRpbmdzLmdyYXBoKTtcblxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgcGFyIGRlZmF1dFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fU1JTX18vZywgdGhpcy5zZXR0aW5ncy5zcnMpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fU01PT1RISU5HX18vZywgdGhpcy5zZXR0aW5ncy5zbW9vdGhpbmcpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fSE9MRVNfXy9nLCB0aGlzLnNldHRpbmdzLmhvbGVzKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKC9fX1JFVkVSU0VfXy9nLCB0aGlzLnNldHRpbmdzLnJldmVyc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucyBjb25kaXRpb25uZWxsZXNcblxuICAgICAgICAgICAgICAgIC8vIGV4Y2x1c2lvbnNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5leGNsdXNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBsRXhjbHVzaW9ucyA9IHRoaXMudGVtcGxhdGUuZXhjbHVzaW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGNsdXNpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBsRmVhdHVyZSA9IHRoaXMudGVtcGxhdGUuZXhjbHVzaW9ucy5mZWF0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wbEZlYXR1cmUgPSB0bXBsRmVhdHVyZS5yZXBsYWNlKC9fX0VYQ0xVU0lPTlZBTFVFX18vLCB0aGlzLnNldHRpbmdzLmV4Y2x1c2lvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVzaW9ucy5wdXNoKHRtcGxGZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0bXBsRXhjbHVzaW9ucyA9IHRtcGxFeGNsdXNpb25zLnJlcGxhY2UoL19fRVhDTFVTSU9ORkVBVFVSRV9fLywgZXhjbHVzaW9ucy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSgvX19FWENMVVNJT05TX18vZywgdG1wbEV4Y2x1c2lvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhbiBleGNsdXNpb25zXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSgvX19FWENMVVNJT05TX18vZywgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBsRGlzdGFuY2UgPSB0aGlzLnRlbXBsYXRlLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0bXBsRGlzdGFuY2UgPSB0bXBsRGlzdGFuY2UucmVwbGFjZSgvX19ESVNUQU5DRVZBTFVFX18vZywgdGhpcy5zZXR0aW5ncy5kaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fRElTVEFOQ0VfXy9nLCB0bXBsRGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSgvX19NRVRIT0RfXy9nLCBcImRpc3RhbmNlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhblxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fRElTVEFOQ0VfXy9nLCBcIlwiKTtcblxuICAgICAgICAgICAgICAgIC8vIHRpbWVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBsVGltZSA9IHRoaXMudGVtcGxhdGUudGltZTtcbiAgICAgICAgICAgICAgICAgICAgdG1wbFRpbWUgPSB0bXBsVGltZS5yZXBsYWNlKC9fX1RJTUVWQUxVRV9fL2csIHRoaXMuc2V0dGluZ3MudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fVElNRV9fL2csIHRtcGxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fTUVUSE9EX18vZywgXCJ0aW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjbGVhblxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL19fVElNRV9fL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTm8gb3RoZXIgSFRUUCBtZXRob2Qgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2aWNlICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ2dlci50cmFjZShyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U3RyaW5nID0gcmVxdWVzdDtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0U3RyaW5nO1xuICAgIH1cbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJvY2Vzc0lzb0N1cnZlUmVxdWVzdCk7XG5cblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICpcbiAqIENsYXNzZSBkZSBnZXN0aW9uIGRlcyBwYXJhbS4gZGVzIHJlcXXDqnRlcyBkdSBzZXJ2aWNlIGRlIGNhbGN1bCBkZXMgaXNvLlxuICogUGVybWV0IGxlIG1hcHBpbmcgYXZlYyBsZXMgb3B0aW9ucyBkdSBzZXJ2aWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlByb2Nlc3NJc29DdXJ2ZS5SZXF1ZXN0LlByb2Nlc3NJc29DdXJ2ZVBhcmFtXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKlxuICovXG5mdW5jdGlvbiBQcm9jZXNzSXNvQ3VydmVQYXJhbSAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9jZXNzSXNvQ3VydmVQYXJhbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb2Nlc3NJc29DdXJ2ZVBhcmFtIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcigpO1xuICAgIHRoaXMubG9nZ2VyLnRyYWNlKFwiW0NvbnN0cnVjdGV1ciBQcm9jZXNzSXNvQ3VydmVQYXJhbSAoKV1cIik7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zIGVuIHBhcmFtw6p0cmVzIGR1IGNvbnN0cnVjdGV1ci5cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gbWFwcGluZyBkZXMgb3B0aW9ucyBhdmVjIGwnQVBJIFJFU1RcblxuICAgIC8qKiBJZGVudGlmaWFudCBkZSBs4oCZaXNvY2hyb25lICovXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcblxuICAgIC8qKiBDb29yZG9ubsOpZXMgZGUgZMOpcGFydCAob3UgYXJyaXbDqWUgc2kgbGUgcmV2ZXJzZSBlc3Qgw6AgdHJ1ZSkuICovXG4gICAgdGhpcy5sb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIC8qKiBwcm9qZWN0aW9uIChjb2RlIEVQU0cgY29tbWUgZXBzZzo0MzI2IG91IHdnczg0KSAqL1xuICAgIHRoaXMuc3JzID0gdGhpcy5vcHRpb25zLnNycztcblxuICAgIC8qKlxuICAgICAqIFByb2ZpbCBkZSB2w6loaWN1bGUgw6AgdXRpbGlzZXIgcG91ciBsZSBjYWxjdWwuXG4gICAgICogVm9pdHVyZSBvdSBQaWV0b25cbiAgICAgKi9cbiAgICB0aGlzLmdyYXBoTmFtZSA9IHRoaXMub3B0aW9ucy5ncmFwaDtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpYW50IGV0IG5vbSBkdSB2w6loaWN1bGVcbiAgICAgKiBGSVhNRSBub24gdXRpbGlzw6lcbiAgICAgKi9cbiAgICB0aGlzLnByb2ZpbGVJZCA9IHRoaXMub3B0aW9ucy5wcm9maWxlSWQgfHwgbnVsbDsgLy8gVE9ETyAhXG4gICAgdGhpcy5wcm9maWxlTmFtZSA9IHRoaXMub3B0aW9ucy5wcm9maWxlTmFtZSB8fCBudWxsOyAvLyBUT0RPICFcblxuICAgIC8qKiBMaXN0ZSBkZXMgcsOoZ2xlcyBkZSByZXN0cmljdGlvbnMgw6AgdXRpbGlzZXIgKi9cbiAgICB0aGlzLmV4Y2x1c2lvbnMgPSB0aGlzLm9wdGlvbnMuZXhjbHVzaW9ucztcblxuICAgIHRoaXMucmV2ZXJzZSA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIHRoaXMuc21vb3RoaW5nID0gdGhpcy5vcHRpb25zLnNtb290aGluZztcbiAgICB0aGlzLmhvbGVzID0gdGhpcy5vcHRpb25zLmhvbGVzO1xuXG4gICAgLyoqXG4gICAgICogXCJ0aW1lXCIgcG91ciBpc29jaHJvbmUgb3UgXCJkaXN0YW5jZVwiIGZvciBpc29kaXN0YW5jZS5cbiAgICAgKiBQYXIgZGVmYXV0LCB0aW1lLi4uXG4gICAgICovXG4gICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb25zLm1ldGhvZDtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwidGltZVwiO1xuICAgICAgICAgICAgdGhpcy50aW1lID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpc3RhbmNlXCI6XG4gICAgICAgICAgICB0aGlzLm1ldGhvZCA9IFwiZGlzdGFuY2VcIjtcbiAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMuZGlzdGFuY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJQYXIgZGVmYXV0LCBvbiBjYWxjdWxlIHVuIGlzb2Nocm9uZSAhXCIpO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcInRpbWVcIjtcbiAgICB9XG59XG5cbi8qKlxuICogQ0xBU1NOQU1FXG4gKi9cblByb2Nlc3NJc29DdXJ2ZVBhcmFtLkNMQVNTTkFNRSA9IFwiUHJvY2Vzc0lzb0N1cnZlUGFyYW1cIjtcblxuUHJvY2Vzc0lzb0N1cnZlUGFyYW0ucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQGxlbmRzIG1vZHVsZTpQcm9jZXNzSXNvQ3VydmVQYXJhbSNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGV1ciAoYWxpYXMpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgOiBQcm9jZXNzSXNvQ3VydmVQYXJhbSxcblxuICAgIC8qKlxuICAgICAqIFJldG91cm5lIGxhIGxpc3RlIGRlcyBleGNsdXNpb25zXG4gICAgICovXG4gICAgZ2V0TG9jYXRpb24gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLnggKyBcIixcIiArIHRoaXMubG9jYXRpb24ueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0b3VybmUgbGEgbGlzdGUgZGVzIGV4Y2x1c2lvbnNcbiAgICAgKi9cbiAgICBnZXRFeGNsdXNpb25zIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdXNpb25zLmpvaW4oXCI7XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFibGVhdSBkZSBjbGVmcy92YWxldXJzIHBvdXIgcGFyYW0uXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5Qcm9jZXNzSXNvQ3VydmVQYXJhbS5wcm90b3R5cGUuZ2V0UGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXAgPSBbXTtcblxuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwibG9jYXRpb25cIixcbiAgICAgICAgdiA6IHRoaXMuZ2V0TG9jYXRpb24oKVxuICAgIH0pO1xuXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJzbW9vdGhpbmdcIixcbiAgICAgICAgdiA6IHRoaXMuc21vb3RoaW5nXG4gICAgfSk7XG5cbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcImhvbGVzXCIsXG4gICAgICAgIHYgOiB0aGlzLmhvbGVzXG4gICAgfSk7XG5cbiAgICBtYXAucHVzaCh7XG4gICAgICAgIGsgOiBcInJldmVyc2VcIixcbiAgICAgICAgdiA6IHRoaXMucmV2ZXJzZVxuICAgIH0pO1xuXG4gICAgbWFwLnB1c2goe1xuICAgICAgICBrIDogXCJtZXRob2RcIixcbiAgICAgICAgdiA6IHRoaXMubWV0aG9kXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy50aW1lKSB7XG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICAgIGsgOiBcInRpbWVcIixcbiAgICAgICAgICAgIHYgOiB0aGlzLnRpbWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzdGFuY2UpIHtcbiAgICAgICAgbWFwLnB1c2goe1xuICAgICAgICAgICAgayA6IFwiZGlzdGFuY2VcIixcbiAgICAgICAgICAgIHYgOiB0aGlzLmRpc3RhbmNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1hcC5wdXNoKHtcbiAgICAgICAgayA6IFwiZ3JhcGhOYW1lXCIsXG4gICAgICAgIHYgOiB0aGlzLmdyYXBoTmFtZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZXhjbHVzaW9ucykge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgICBrIDogXCJleGNsdXNpb25zXCIsXG4gICAgICAgICAgICB2IDogdGhpcy5nZXRFeGNsdXNpb25zKClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3JzKSB7XG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICAgIGsgOiBcInNyc1wiLFxuICAgICAgICAgICAgdiA6IHRoaXMuc3JzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb2Nlc3NJc29DdXJ2ZVBhcmFtKTtcblxuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTG9nZ2VyQnlEZWZhdWx0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0Zvcm1hdHNfWE1MX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fRm9ybWF0c19XS1RfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19Gb3JtYXRzX1Byb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19tb2RlbF9Qcm9jZXNzSXNvQ3VydmVSZXNwb25zZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKipcbiAqIEZhY3RvcnkgcG91ciBnw6luw6lyZXIgdW5lIHJlcG9uc2UgSlNPTiDDoCBwYXJ0aXIgZCd1biBYTUwgb3UgZCd1biBKU09OXG4gKiAoRmFjdG9yeSlcbiAqXG4gKiBAbW9kdWxlIFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlRmFjdG9yeVxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlByb2Nlc3NJc29DdXJ2ZS5SZXNwb25zZS5Qcm9jZXNzSXNvQ3VydmVSZXNwb25zZUZhY3RvcnlcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5cblxuXG5cblxuXG52YXIgUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VGYWN0b3J5ID0ge1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJmYWNlIHVuaXF1ZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZGVmaW5pZXMgZGFucyBsZSBjb21wb3NhbnQgUHJvY2Vzc0lzb0N1cnZlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAgICByZXNwb25zZSA6XG4gICAgICogICAgICBvdXRwdXRGb3JtYXQgOlxuICAgICAqICAgICAgcmF3UmVzcG9uc2UgOlxuICAgICAqICAgICAgc2NvcGUgOlxuICAgICAqICAgICAgb25TdWNjZXNzIDpcbiAgICAgKiAgICAgIG9uRXJyb3IgOlxuICAgICAqICAgfTtcbiAgICAgKlxuICAgICAqL1xuICAgIGJ1aWxkIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG4gICAgICAgIHZhciBsb2dnZXIgPSBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1V0aWxzX0xvZ2dlckJ5RGVmYXVsdF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldExvZ2dlcihcIlByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlRmFjdG9yeVwiKTtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFtcIlByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlRmFjdG9yeTo6YnVpbGQoKVwiXSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBudWxsO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50cmFjZShcImFuYWx5emUgcmVzcG9uc2UgOiByYXdcIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5vdXRwdXRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInhtbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFwiYW5hbHl6ZSByZXNwb25zZSA6IHhtbFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX0Zvcm1hdHNfWE1MX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX0Zvcm1hdHNfUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXJfX1tcImFcIiAvKiBkZWZhdWx0ICovXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgOiBtb2RlIFhIUiBuZSByZXRvdXJuZSBxdWUgZGVzIHN0cmluZyA/IEpTT05QIGF1c3NpIMOgIGNlIG5pdmVhdSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2V0WE1MU3RyaW5nKG9wdGlvbnMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2V0WE1MRG9jKG9wdGlvbnMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwLnBhcnNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05fMlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJcXG4gKHJhdyByZXNwb25zZSBzZXJ2aWNlIDogJ1wiICsgb3B0aW9ucy5yZXNwb25zZSArIFwiJylcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIiwgbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudHJhY2UoXCJhbmFseXplIHJlc3BvbnNlIDoganNvblwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEpTT05SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT05SZXNwb25zZSA9IEpTT04ucGFyc2Uob3B0aW9ucy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT05SZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuYWx5c2UgZGUgbGEgcmVwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT05SZXNwb25zZS5zdGF0dXMgPT09IFwiT0tcIiB8fCBKU09OUmVzcG9uc2Uuc3RhdHVzID09PSBcIm9rXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjcsOpYXRpb24gZGUgbCdvYmpldCBkZSByw6lwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19tb2RlbF9Qcm9jZXNzSXNvQ3VydmVSZXNwb25zZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1wbGlzc2FnZSBkZSBsJ29iamV0IGNyw6nDqSBhdmVjIGxlcyBhdHRyaWJ0dXRzIGRlIGxhIHLDqXBvbnNlIGR1IHNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnRpbWUgPSBKU09OUmVzcG9uc2UudGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5kaXN0YW5jZSA9IEpTT05SZXNwb25zZS5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tZXNzYWdlID0gSlNPTlJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaWQgPSBKU09OUmVzcG9uc2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3JzID0gSlNPTlJlc3BvbnNlLnNycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIGNhbGxiYWNrIGRlIGxhIHJlcG9uc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uV0tUU3VjY2VzcyA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmdlb21ldHJ5ID0ganNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIGNhbGxiYWNrIGQnZXJyZXVyICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbldLVEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiUEFSQU1fRk9STUFUXCIsIFwid2t0R2VvbWV0cnlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoXCJnZW9tZXRyeVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19Gb3JtYXRzX1dLVF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnRvSnNvbihKU09OUmVzcG9uc2Uud2t0R2VvbWV0cnksIG9uV0tUU3VjY2Vzcywgb25XS1RFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IEpTT05SZXNwb25zZS5sb2NhdGlvbi5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmxvY2F0aW9uLnggPSBjb29yZHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmxvY2F0aW9uLnkgPSBjb29yZHNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIG9wdGlvbnMucmVzcG9uc2UpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEpTT05SZXNwb25zZS5zdGF0dXMgPT09IFwiRVJST1JcIiB8fCBKU09OUmVzcG9uc2Uuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKU0hpbnQgYnVnIGlmIHZhciBtZXNzYWdlIGlzIHVzZWQgIT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzcyA9IEpTT05SZXNwb25zZS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3MgKz0gXCJcXG4gKHJhdyByZXNwb25zZSBzZXJ2aWNlIDogJ1wiICsgSlNPTlJlc3BvbnNlICsgXCInKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25FcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUsIG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBtZXNzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9GT1JNQVRcIiwgXCJqc29uXCIsIFwieG1sXCIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaW5mbyA6IGVuIGNhcyBkZSBwcm9ibMOobWVzIGRlIGRyb2l0cyAoY2zDqSBpbnZhbGlkZSBvdSBhdXRyZSksIGxhIHLDqXBvbnNlIGVzdCBhdSBmb3JtYXQgWE1MICEhXG4gICAgICAgICAgICAgICAgLy8gZXguIDxFeGNlcHRpb25SZXBvcnQ+PEV4Y2VwdGlvbiBleGNlcHRpb25Db2RlPVwiTWlzc2luZ1BhcmFtZXRlclwiPktleSBkb2VzIG5vdCBleGlzdCBvciBoYXMgZXhwaXJlZDwvRXhjZXB0aW9uPjwvRXhjZXB0aW9uUmVwb3J0PlxuICAgICAgICAgICAgICAgIC8vIG1haXMgbGUgc3RhdHV0IGVzdCA0MDMsIGwnZXJyZXVyIGVzdCBkb25jIHJlbW9udMOpZSBwbHVzIHTDtHQuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5leGNlcHRpb25SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yLmNhbGwob3B0aW9ucy5zY29wZSwgbmV3IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJTRVJWSUNFX1JFU1BPTlNFX0VYQ0VQVElPTlwiLCBkYXRhLmV4Y2VwdGlvblJlcG9ydCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlIDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlRZUEVfU1JWRVJSLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzIDogMjAwXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpIGxhIHLDqXBvbnNlIGVzdCB2aWRlLCBvbiBhcHBlbGxlIGxlIGNhbGxiYWNrIGQnZXJyZXVyXG4gICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IuY2FsbChvcHRpb25zLnNjb3BlLCBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19FeGNlcHRpb25zX0Vycm9yU2VydmljZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FTVBUWVwiKSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgdG91dCBzJ2VzdCBiaWVuIHBhc3PDqSwgb24gYXBwZWxsZSBsZSBjYWxsYmFjayBkZSBzdWNjw6hzXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSwgZGF0YSk7XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm9jZXNzSXNvQ3VydmVSZXNwb25zZUZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19Gb3JtYXRzX1dLVF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fUmVzcG9uc2VfbW9kZWxfUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyoqXG4gKiBBbmFseXNlIGRlIGxhIHJlcG9uc2UgWE1MXG4gKlxuICogQG1vZHVsZSBQcm9jZXNzSXNvQ3VydmVSZXNwb25zZVJlYWRlclxuICogQGFsaWFzIEdwLlNlcnZpY2VzLlByb2Nlc3NJc29DdXJ2ZS5Gb3JtYXRzLlByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyXG4gKiBAdG9kbyBub3QgeWV0IGltcGxlbWVudGVkICFcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5cblxuXG5cbi8qKlxuICogT2JqZXQgUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXJcbiAqXG4gKiBAbWVtYmVyIHtPYmplY3R9IFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyXG4gKlxuICogQHByb3BlcnR5IHtPYmplY3R9IFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLlJFQURFUlMgLSBPYmpldCBjb250ZW5hbnQgZGVzIGZvbmN0aW9ucyBkZSBsZWN0dXJlLCBhcHBlbMOpZXMgXCJyZWFkZXJzXCJcbiAqICAgICAgZG9udCBjaGFxdWUgY2zDqSBjb3JyZXNwb25kIGF1IG5vbSBkJ3VuIHRhZyBkdSBYTUwgcXVlIGwnb24gc291aGFpdGUgbGlyZVxuICogICAgICBldCBsYSB2YWxldXIgYXNzb2Npw6llIGVzdCB1bmUgZm9uY3Rpb24gKG5vZGUsIGRhdGEpXG4gKiAgICAgIG/DuSBub2RlIGVzdCB1biBub2V1ZCBkdSBkb2N1bWVudCBET01cbiAqICAgICAgZXQgZGF0YSBlc3QgdW4gb2JqZXQgb8O5IGwnb24gc3RvY2tlIGxlcyBpbmZvcm1hdGlvbnMgbHVlcyBkYW5zIGxlIFhNTC5cbiAqXG4gKiBAcHJvcGVydHkge01ldGhvZH0gUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIucmVhZCAtICBNw6l0aG9kZSBwZXJtZXR0YW50IGRlIGxhbmNlciBsYSBsZWN0dXJlIGQndW5lIHLDqXBvbnNlIFhNTFxuICogICAgICAgZHUgc2VydmljZSBkZSBjYWxjdWwgaXNvY2hyb25lL2lzb2Rpc3RhbmNlLCDDoCBsJ2FpZGUgZGVzIHJlYWRlcnMgZGUgbGEgY2xhc3NlLlxuICpcbiAqL1xuXG52YXIgUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIgPSB7fTtcblxuLypcbiAgICAvLyBJTkZPXG4gICAgLy8gRXhlbXBsZSBkJ2VycmV1ciBkdSBzZXJ2aWNlXG4gICAgLy8gPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCIgPz5cbiAgICAvLyA8aXNvY2hyb25lUmVzdWx0PlxuICAgIC8vICA8bWVzc2FnZT5Mb2NhdGlvbiBwb2ludCBtdXN0IGhhdmUgMiBjb21wb25lbnRzIHNlcGFyYXRlZCB3aXRoIGEgLDwvbWVzc2FnZT5cbiAgICAvLyAgPHN0YXR1cz5FUlJPUjwvc3RhdHVzPlxuICAgIC8vIDwvaXNvY2hyb25lUmVzdWx0PlxuXG4gICAgLy8gPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCIgPz5cbiAgICAvLyA8c2VydmljZVJlc3VsdD5cbiAgICAvLyAgIDxtZXNzYWdlPlNlcnZpY2VFeGNlcHRpb24gOiBFcnJvciBpbiBpc29jaHJvbiBjb21wdXRhdGlvbiBFcnJvciBpbiBzbWFydHJvdXRpbmcgbnVsbDwvbWVzc2FnZT5cbiAgICAvLyAgIDxzdGF0dXM+RVJST1I8L3N0YXR1cz5cbiAgICAvLyA8L3NlcnZpY2VSZXN1bHQ+XG5cbiAgICAvLyBJTkZPXG4gICAgLy8gRXhlbXBsZSBkJ2VycmV1ciBOR2lueFxuICAgIC8vIDxFeGNlcHRpb25SZXBvcnQ+PEV4Y2VwdGlvbiBleGNlcHRpb25Db2RlPVwiTWlzc2luZ1BhcmFtZXRlclwiPlJlc291cmNlIHBhcmFtZXRlciBub3QgZm91bmQ8L0V4Y2VwdGlvbj48L0V4Y2VwdGlvblJlcG9ydD5cbiovXG5cbi8qXG4gICAgLy8gSU5GT1xuICAgIC8vIEV4ZW1wbGUgZGUgcsOpcG9uc2UgZHUgc2VydmljZVxuXG4gICAgIC8vIDxJc29jaHJvbmVSZXN1bHQ+XG4gICAgIC8vICAgIDxzdGF0dXM+T0s8L3N0YXR1cz5cbiAgICAgLy8gICAgPGlkLz5cbiAgICAgLy8gICAgPGxvY2F0aW9uPi0xLjU1NzE4OSw0Ny4yMTcxMjI8L2xvY2F0aW9uPlxuICAgICAvLyAgICA8c3JzLz5cbiAgICAgLy8gICAgPGRpc3RhbmNlPjUwMDA8L2Rpc3RhbmNlPlxuICAgICAvLyAgICA8d2t0R2VvbWV0cnk+UE9MWUdPTiAoKC0xLjU0NTMxMiA0Ny4xNzgxNzgsIC0xLjU0NTMxMiA0Ny4xODA0MTgsIC4uLikpPC93a3RHZW9tZXRyeT5cbiAgICAgLy8gPC9Jc29jaHJvbmVSZXN1bHQ+XG5cbiAgICAvLyA8aXNvY2hyb25SZXN1bHQ+XG4gICAgLy8gICAgPHN0YXR1cz5PSzwvc3RhdHVzPlxuICAgIC8vICAgIDxpZD4xPC9pZD5cbiAgICAvLyAgICA8bG9jYXRpb24+LTEuNTU3MTg5LDQ3LjIxNzEyMjwvbG9jYXRpb24+XG4gICAgLy8gICAgPHNycy8+XG4gICAgLy8gICAgPHRpbWU+NTA8L3RpbWU+XG4gICAgLy8gICAgPHdrdEdlb21ldHJ5PlBPTFlHT04gKCgtMS41NTY4NjQgNDcuMjE2NDg3LCAtMS41NTY4NjQgNDcuMjE2OTQ4LCAuLi4pKTwvd2t0R2VvbWV0cnk+XG4gICAgLy8gPC9pc29jaHJvblJlc3VsdD5cbiovXG5cblByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLlJFQURFUlMgPSB7XG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgaXNvY2hyb25SZXN1bHQgOiBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICAvLyByYWNpbmUgZGUgbGEgcsOpcG9uc2UgWE1MIDogb24gY3LDqWUgbCdvYmpldCBkZSByw6lwb25zZVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19SZXNwb25zZV9tb2RlbF9Qcm9jZXNzSXNvQ3VydmVSZXNwb25zZV9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cbiAgICAgICAgaWYgKHJvb3QuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByb290LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbY2hpbGQubm9kZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbY2hpbGQubm9kZU5hbWVdKGNoaWxkLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIixcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGUgOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10uVFlQRV9TUlZFUlJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIG1lc3NhZ2UgOiBmdW5jdGlvbiAobm9kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBzdGF0dXMgOiBmdW5jdGlvbiAobm9kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IF9fZ2V0Q2hpbGRWYWx1ZShub2RlKTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJFUlJPUlwiIHx8IHN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIGlkIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaWQgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIGxvY2F0aW9uIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBfX2dldENoaWxkVmFsdWUobm9kZSk7XG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5sb2NhdGlvbikge1xuICAgICAgICAgICAgcmVzcG9uc2UubG9jYXRpb24ueCA9IHBhcnNlRmxvYXQoY29vcmRzLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgICByZXNwb25zZS5sb2NhdGlvbi55ID0gcGFyc2VGbG9hdChjb29yZHMuc3BsaXQoXCIsXCIpWzFdKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgc3JzIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2Uuc3JzID0gX19nZXRDaGlsZFZhbHVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBkaXN0YW5jZSA6IGZ1bmN0aW9uIChub2RlLCByZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRpc3RhbmNlID0gcGFyc2VGbG9hdChfX2dldENoaWxkVmFsdWUobm9kZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICB0aW1lIDogZnVuY3Rpb24gKG5vZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2UudGltZSA9IHBhcnNlRmxvYXQoX19nZXRDaGlsZFZhbHVlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgd2t0R2VvbWV0cnkgOiBmdW5jdGlvbiAobm9kZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgd2t0R2VvbWV0cnkgPSBub2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICAgICAgICAgIHZhciBvbldLVFN1Y2Nlc3MgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmdlb21ldHJ5ID0ganNvbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgICAgICAgICB2YXIgb25XS1RFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19VdGlsc19NZXNzYWdlc1Jlc291cmNlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2UoXCJQQVJBTV9GT1JNQVRcIiwgW1wid2t0R2VvbWV0cnlcIl0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5oYXNPd25Qcm9wZXJ0eShcImdlb21ldHJ5XCIpKSB7XG4gICAgICAgICAgICAgICAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19Gb3JtYXRzX1dLVF9fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnRvSnNvbih3a3RHZW9tZXRyeSwgb25XS1RTdWNjZXNzLCBvbldLVEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogVE9ETyA6IGpzZG9jIGJsb2NrICovXG4gICAgc2VydmljZVJlc3VsdCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIGVuIGNhcyBkJ2V4Y2VwdGlvbiBkdSBzZXJ2aWNlXG4gICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChQcm9jZXNzSXNvQ3VydmVSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkLm5vZGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzSXNvQ3VydmVSZXNwb25zZVJlYWRlci5SRUFERVJTW2NoaWxkLm5vZGVOYW1lXShjaGlsZCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIC8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cbiAgICBFeGNlcHRpb25SZXBvcnQgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IFwiRXhjZXB0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZXhjZXB0aW9uUmVwb3J0ID0gUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tcIkV4Y2VwdGlvblwiXShjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgLyoqIFRPRE8gOiBqc2RvYyBibG9jayAqL1xuICAgIEV4Y2VwdGlvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25SZXBvcnQgPSB7fTtcblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIGNvZGVcbiAgICAgICAgdmFyIGV4Y2VwdGlvbkNvZGUgPSBub2RlLmdldEF0dHJpYnV0ZShcImV4Y2VwdGlvbkNvZGVcIik7XG4gICAgICAgIGlmIChleGNlcHRpb25Db2RlKSB7XG4gICAgICAgICAgICBleGNlcHRpb25SZXBvcnQuZXhjZXB0aW9uQ29kZSA9IGV4Y2VwdGlvbkNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIGV4Y2VwdGlvblJlcG9ydC5leGNlcHRpb24gPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhjZXB0aW9uUmVwb3J0O1xuICAgIH1cbn07XG5cbi8qKiBUT0RPIDoganNkb2MgYmxvY2sgKi9cblByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLnJlYWQgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgIHZhciByZXNwb25zZTtcblxuICAgIGlmIChyb290Lm5vZGVOYW1lID09PSBcImlzb2Nocm9uUmVzdWx0XCIgfHwgcm9vdC5ub2RlTmFtZSA9PT0gXCJpc29jaHJvbmVSZXN1bHRcIiB8fCByb290Lm5vZGVOYW1lID09PSBcIklzb2Nocm9uZVJlc3VsdFwiKSB7XG4gICAgICAgIHJlc3BvbnNlID0gUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tcImlzb2Nocm9uUmVzdWx0XCJdKHJvb3QpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBlbHNlIGlmIChyb290Lm5vZGVOYW1lID09PSBcIkV4Y2VwdGlvblJlcG9ydFwiKSB7XG4gICAgICAgIHJlc3BvbnNlID0gUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tyb290Lm5vZGVOYW1lXShyb290KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gZWxzZSBpZiAoUHJvY2Vzc0lzb0N1cnZlUmVzcG9uc2VSZWFkZXIuUkVBREVSU1tyb290Lm5vZGVOYW1lXSkge1xuICAgICAgICByZXNwb25zZSA9IFByb2Nlc3NJc29DdXJ2ZVJlc3BvbnNlUmVhZGVyLlJFQURFUlNbcm9vdC5ub2RlTmFtZV0ocm9vdCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgdmFyIGVyck1zZyA9IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9FWENFUFRJT05cIixcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1NSVkVSUlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX0V4Y2VwdGlvbnNfRXJyb3JTZXJ2aWNlX19bXCJhXCIgLyogZGVmYXVsdCAqL10oe1xuICAgICAgICAgICAgbWVzc2FnZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVXRpbHNfTWVzc2FnZXNSZXNvdXJjZXNfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlKFwiU0VSVklDRV9SRVNQT05TRV9BTkFMWVNFXCIsIHJvb3Qubm9kZU5hbWUpLFxuICAgICAgICAgICAgdHlwZSA6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fRXhjZXB0aW9uc19FcnJvclNlcnZpY2VfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5UWVBFX1VOS0VSUlxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExlY3R1cmUgZGUgbGEgdmFsZXVyIGR1IHByZW1pZXIgY2hpbGQgZCd1biBub2V1ZCwgc2kgZWxsZSBleGlzdGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBQcm9jZXNzSXNvQ3VydmVSZXNwb25zZVJlYWRlclxuICogQG1ldGhvZCBfX2dldENoaWxkVmFsdWVcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSAtIGEgRE9NIG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdmFsdWUgLSB2YWxldXIgZHUgZmlyc3RDaGlsZCBkdSBub2V1ZCBlbiBlbnRyw6llLCBvdSBjaGHDrm5lIHZpZGUuXG4gKi9cbmZ1bmN0aW9uIF9fZ2V0Q2hpbGRWYWx1ZSAobm9kZSkge1xuICAgIHZhciB0ZXh0Tm9kZTtcbiAgICB2YXIgdmFsdWUgPSBcIlwiO1xuXG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUgJiYgdGV4dE5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gMyA9PT0gbm9kZS5URVhUX05PREVcbiAgICAgICAgICAgIHZhbHVlID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm9jZXNzSXNvQ3VydmVSZXNwb25zZVJlYWRlcik7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3BTZXJ2aWNlcy1zcmMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2VvcG9ydGFsLWFjY2Vzcy1saWIvZGlzdC9HcFNlcnZpY2VzLXNyYy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar LayerUtils = {\n\n    /**\n     * Obtenir le ZoomLevel à partir du ScaleDenominator\n     * @param {Number} scaleDenominator - the scale denominator\n     * @param {String} crs - the crs\n     *\n     * @returns {Integer} zoom level\n     */\n    getZoomLevelFromScaleDenominator: function getZoomLevelFromScaleDenominator(scaleDenominator, crs) {\n        // ------------------------------------------------- //\n        // Code issu de l'API Geoportal/Catalogue/Config.js  //\n        // ------------------------------------------------- //\n        //     var configuration = Gp.Config;\n        //     var general = configuration.generalOptions;\n        //     var layers  = configuration.layersContext;\n        //\n        //     for (var tms in general.tileMatrixSets) {\n        //         var tileMatrixSet = general.tileMatrixSets[tms];\n        //         // IGN's WMTS bug : epsg:nnnn instead of EPSG:nnnn\n        //         var crs = tileMatrixSet.supportedCRS = tileMatrixSet.supportedCRS.replace(/epsg/,\"EPSG\");\n        //\n        //         if (!Geoportal.Catalogue.CRSRESOLUTIONS.hasOwnProperty(crs)) {\n        //             var p= new OpenLayers.Projection(crs);\n        //             Geoportal.Catalogue.CRSRESOLUTIONS[crs]= [];\n        //             var matrixIds= tileMatrixSet.matrixIds;\n        //             for (var i= 0, li= matrixIds.length; i<li; ++i) {\n        //                 var mid= matrixIds[i];\n        //                 Geoportal.Catalogue.CRSRESOLUTIONS[crs].push(\n        //                     0.00028*mid.scaleDenominator\n        //                     /(OpenLayers.METERS_PER_INCH*OpenLayers.INCHES_PER_UNIT[p.getUnits()]));\n        //                     mid.supportedCRS= mid.supportedCRS.replace(/epsg/,\"EPSG\");\n        //                 }\n        //                 Geoportal.Catalogue.CRSRESOLUTIONS[crs].sort(function (a,b){ return b-a; });\n        //             }\n        //         }\n        //         var llR= Geoportal.Catalogue.CRSRESOLUTIONS['CRS:84'];\n        //         if (!llR) {\n        //             llR= Geoportal.Catalogue.CRSRESOLUTIONS['CRS:84']= general.resolutions.slice();\n        //         }\n        //         var wmR= Geoportal.Catalogue.CRSRESOLUTIONS['EPSG:3857'];\n        //         if (!wmR) {//FIXME : should never happened !!\n        //             // reproject resolutions from CRS84 to WebMercator (transform resolutions from degree/px to meter/px)\n        //             wmR= Geoportal.Catalogue.CRSRESOLUTIONS['EPSG:3857']= new Array(llR.length);\n        //             for (var i= 0, len= llR.length; i<len; i++) {\n        //                 var pt= new OpenLayers.LonLat(llR[i], 0);\n        //                 pt.transform(OpenLayers.Projection.CRS84, OpenLayers.Projection.WebMercator);\n        //                 wmR[i]= pt.lon;\n        //             }\n        //         }\n        //         Geoportal.Catalogue.RESOLUTIONS= wmR;\n        //\n        //         var getResolutionsFromCRS= function(crs) {\n        //             if (OpenLayers.Projection.WebMercator.isAliasOf(crs)) {\n        //                 return wmR;\n        //             }\n        //             if (OpenLayers.Projection.CRS84.isAliasOf(crs)) {\n        //                 return llR;\n        //             }\n        //             return Geoportal.Catalogue.CRSRESOLUTIONS[crs]?Geoportal.Catalogue.CRSRESOLUTIONS[crs]:null ;\n        //         };\n        //\n        //         var retrieveZoomFromResolution= function(resolutions, resolution) {\n        //             for (var i= 0, li= resolutions.length; i<li; i++) {\n        //                 if (resolutions[i]-resolution <= resolutions[li-1]) {\n        //                     return i;\n        //                 }\n        //             }\n        //             return -1;\n        //         };\n        //\n        //         var getZoomLevelFromScaleDenominator= function(scaleDenominator,crs) {\n        //             var resolution= scaleDenominator * 0.00028;\n        //             var R= getResolutionsFromCRS(crs);\n        //             if (R) {\n        //                 return retrieveZoomFromResolution(R,resolution);\n        //             }\n        //             resolution= resolution/(OpenLayers.METERS_PER_INCH * OpenLayers.INCHES_PER_UNIT[\"degrees\"]);\n        //             return retrieveZoomFromResolution(llR,resolution);\n        //         };\n        //\n        //         var getZoomLevelFromResolution= function(resolution,crs){\n        //             var R= getResolutionsFromCRS(crs);\n        //             if (R) {\n        //                 return retrieveZoomFromResolution(R,resolution);\n        //             }\n        //             var pt0= new OpenLayers.LonLat(0, 0);\n        //             var pt1= new OpenLayers.LonLat(1, 0);\n        //             pt0.transform(new OpenLayers.Projection(crs),OpenLayers.Projection.CRS84);\n        //             pt1.transform(new OpenLayers.Projection(crs),OpenLayers.Projection.CRS84);\n        //             resolution= resolution*(Math.abs(pt1.lon-pt0.lon));\n        //             return retrieveZoomFromResolution(llR,resolution);\n        //         };\n\n        // par defaut, on utilise la projection WebMercator (EPSG:3857 = PM)\n        // soit la liste des resolutions natives\n        var resolutionsNatives = {};\n        switch (crs) {\n            case \"EPSG:2154\":\n                resolutionsNatives = {\n                    0: 104579.224549894,\n                    1: 52277.5323537905,\n                    2: 26135.4870785954,\n                    3: 13066.8913818,\n                    4: 6533.2286041135,\n                    5: 3266.5595244627,\n                    6: 1633.2660045974,\n                    7: 816.629554986,\n                    8: 408.3139146768,\n                    9: 204.1567415109,\n                    10: 102.0783167832,\n                    11: 51.0391448966,\n                    12: 25.5195690743,\n                    13: 12.7597836936,\n                    14: 6.379891636,\n                    15: 3.1899457653,\n                    16: 1.5949728695,\n                    17: 0.7974864315,\n                    18: 0.3987432149,\n                    19: 0.1993716073,\n                    20: 0.0996858037,\n                    21: 0.0498429018\n                };\n                break;\n            default:\n                resolutionsNatives = {\n                    0: 156543.033928041,\n                    1: 78271.51696402048,\n                    2: 39135.758482010235,\n                    3: 19567.87924100512,\n                    4: 9783.93962050256,\n                    5: 4891.96981025128,\n                    6: 2445.98490512564,\n                    7: 1222.99245256282,\n                    8: 611.49622628141,\n                    9: 305.7481131407048,\n                    10: 152.8740565703525,\n                    11: 76.43702828517624,\n                    12: 38.21851414258813,\n                    13: 19.10925707129406,\n                    14: 9.554628535647032,\n                    15: 4.777314267823516,\n                    16: 2.388657133911758,\n                    17: 1.194328566955879,\n                    18: 0.5971642834779395,\n                    19: 0.2985821417389697,\n                    20: 0.1492910708694849,\n                    21: 0.0746455354347424\n                };\n                break;\n        }\n\n        // gestion des autres SRS\n        // TODO\n        // if (crs) {\n        // }\n\n        var resolution = scaleDenominator * 0.00028;\n\n        for (var index in resolutionsNatives) {\n            if (resolutionsNatives.hasOwnProperty(index)) {\n                if (resolutionsNatives[index] <= resolution) {\n                    index = parseInt(index, 10);\n                    return index;\n                }\n            }\n        }\n\n        return 0; // -1 ?\n    },\n\n    /**\n     * Get attributions list for a layer, based on current zoom and extent\n     *\n     * @param {Object} params - function params\n     * @param {Array.<Float>} params.extent - map current geographical extent (EPSG:4326) : [top, left, bottom, right] = [maxy, minx, miny, maxx]\n     * @param {Number} params.zoom - map current zoom\n     * @param {String} params.crs - map current projection code (ex \"EPSG:2154\")\n     * @param {Boolean} params.visibility - layer visibility\n     * @param {Gp.Services.Config.Originator} params.originators - resource originators (from Gp.Config.layers[].originators)\n     * @returns {Object} attributions - associative array, mapping originators url (keys) with their properties : html attributions elements\n     */\n    getAttributions: function getAttributions(params) {\n        var zoom = params.zoom;\n\n        var attributions = [];\n\n        if (params.originators != null && params.visibility) {\n            // drawLogo = boolean, true if attribution should be displayed (zoom, extent), false otherwise\n            var drawLogo;\n            for (var j = 0, jl = params.originators.length; j < jl; j++) {\n                drawLogo = true;\n                var originator = params.originators[j];\n\n                var constraints = params.originators[j].constraints || [];\n                for (var k = 0, kl = constraints.length; k < kl; k++) {\n                    var constraint = constraints[k];\n                    drawLogo = true;\n\n                    var minZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.maxScaleDenominator, params.crs);\n                    var maxZoomLevel = this.getZoomLevelFromScaleDenominator(constraint.minScaleDenominator, params.crs) || 21;\n\n                    // min zoom constraints\n                    if (minZoomLevel && minZoomLevel > zoom) {\n                        drawLogo = false;\n                    }\n\n                    // max zoom constraints\n                    if (drawLogo && maxZoomLevel !== null && maxZoomLevel < zoom) {\n                        drawLogo = false;\n                    }\n\n                    // bbox constraints\n                    var bbox = constraint.bbox;\n                    if (drawLogo && bbox) {\n                        drawLogo = false;\n                        var viewExtent = params.extent;\n                        if (viewExtent) {\n                            var bounds = [bbox.top, bbox.left, bbox.bottom, bbox.right];\n                            if (this.intersects(viewExtent, bounds)) {\n                                // at least one constraint matches the map ones\n                                drawLogo = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (drawLogo) {\n                    // on a un originator qui correspond au zoom et à l'étendue.\n\n                    var logo = originator.logo;\n                    var url = originator.url;\n                    var name = originator.name ? originator.name : \"\";\n                    var text = originator.attribution;\n\n                    var container = document.createElement(\"div\");\n                    container.className = \"gp-control-attribution\";\n\n                    // on crée un lien dans tous les cas (même s'il ne pointe pas vers une référence), pour avoir accès à la class CSS (pour surcharge)\n                    var link = null;\n                    link = document.createElement(\"a\");\n                    link.className = \"gp-control-attribution-link\";\n                    link.target = \"_blank\";\n                    container.appendChild(link);\n                    if (url) {\n                        link.href = url;\n                    }\n\n                    var bImage = !!logo;\n                    var image = null;\n                    // si on a un logo, on l'affiche à l'interieur du lien\n                    if (bImage) {\n                        image = document.createElement(\"img\");\n                        if (link) {\n                            image.className = \"gp-control-attribution-image\";\n                            link.appendChild(image);\n                        } else {\n                            image.className = \"\";\n                            container.appendChild(image);\n                        }\n                        image.src = logo; // FIXME : mixContent !\n                        image.title = text || name;\n                        image.style.height = \"30px\";\n                        image.style.width = \"30px\";\n                    } else {\n                        // sinon, on affiche le nom de l'originator, ou sa description ou l'url.\n                        if (name) {\n                            link.textContent = name;\n                        } else if (text) {\n                            link.textContent = text;\n                        } else if (url) {\n                            link.textContent = url;\n                        } else {\n                            link.textContent = \"\";\n                        }\n                    }\n\n                    attributions.push(container.innerHTML + \" \");\n                }\n            }\n        }\n\n        return attributions;\n    },\n\n    /**\n     * Determines if one extent (extent1) intersects another (extent2)\n     *\n     * @param {Array.<Float>} extent1 - First extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]\n     * @param {Array.<Float>} extent2 - Second extent : [top, left, bottom, right] = [maxy, minx, miny, maxx]\n     * @return {Boolean} intersects - True if the two extents intersect, false otherwise.\n     */\n    intersects: function intersects(extent1, extent2) {\n        var intersectsX = extent1[1] <= extent2[3] && extent2[1] <= extent1[3];\n        var intersectsY = extent1[2] <= extent2[0] && extent2[2] <= extent1[0];\n        return intersectsX && intersectsY;\n    }\n};\n\nexports.default = LayerUtils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL0xheWVyVXRpbHMuanM/NDdlYiJdLCJuYW1lcyI6WyJMYXllclV0aWxzIiwiZ2V0Wm9vbUxldmVsRnJvbVNjYWxlRGVub21pbmF0b3IiLCJzY2FsZURlbm9taW5hdG9yIiwiY3JzIiwicmVzb2x1dGlvbnNOYXRpdmVzIiwicmVzb2x1dGlvbiIsImluZGV4IiwiaGFzT3duUHJvcGVydHkiLCJwYXJzZUludCIsImdldEF0dHJpYnV0aW9ucyIsInBhcmFtcyIsInpvb20iLCJhdHRyaWJ1dGlvbnMiLCJvcmlnaW5hdG9ycyIsInZpc2liaWxpdHkiLCJkcmF3TG9nbyIsImoiLCJqbCIsImxlbmd0aCIsIm9yaWdpbmF0b3IiLCJjb25zdHJhaW50cyIsImsiLCJrbCIsImNvbnN0cmFpbnQiLCJtaW5ab29tTGV2ZWwiLCJtYXhTY2FsZURlbm9taW5hdG9yIiwibWF4Wm9vbUxldmVsIiwibWluU2NhbGVEZW5vbWluYXRvciIsImJib3giLCJ2aWV3RXh0ZW50IiwiZXh0ZW50IiwiYm91bmRzIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwiaW50ZXJzZWN0cyIsImxvZ28iLCJ1cmwiLCJuYW1lIiwidGV4dCIsImF0dHJpYnV0aW9uIiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwibGluayIsInRhcmdldCIsImFwcGVuZENoaWxkIiwiaHJlZiIsImJJbWFnZSIsImltYWdlIiwic3JjIiwidGl0bGUiLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwidGV4dENvbnRlbnQiLCJwdXNoIiwiaW5uZXJIVE1MIiwiZXh0ZW50MSIsImV4dGVudDIiLCJpbnRlcnNlY3RzWCIsImludGVyc2VjdHNZIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUlBLGFBQWE7O0FBRWI7Ozs7Ozs7QUFPQUMsc0NBQW1DLDBDQUFVQyxnQkFBVixFQUE0QkMsR0FBNUIsRUFBaUM7QUFDaEU7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KipcbiAgICAgKiBPYnRlbmlyIGxlIFpvb21MZXZlbCDDoCBwYXJ0aXIgZHUgU2NhbGVEZW5vbWluYXRvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZURlbm9taW5hdG9yIC0gdGhlIHNjYWxlIGRlbm9taW5hdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNycyAtIHRoZSBjcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfSB6b29tIGxldmVsXG4gICAgICovXG4gICAgZ2V0Wm9vbUxldmVsRnJvbVNjYWxlRGVub21pbmF0b3IgOiBmdW5jdGlvbiAoc2NhbGVEZW5vbWluYXRvciwgY3JzKSB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cbiAgICAgICAgLy8gQ29kZSBpc3N1IGRlIGwnQVBJIEdlb3BvcnRhbC9DYXRhbG9ndWUvQ29uZmlnLmpzICAvL1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgIC8vICAgICB2YXIgY29uZmlndXJhdGlvbiA9IEdwLkNvbmZpZztcbiAgICAgICAgLy8gICAgIHZhciBnZW5lcmFsID0gY29uZmlndXJhdGlvbi5nZW5lcmFsT3B0aW9ucztcbiAgICAgICAgLy8gICAgIHZhciBsYXllcnMgID0gY29uZmlndXJhdGlvbi5sYXllcnNDb250ZXh0O1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgZm9yICh2YXIgdG1zIGluIGdlbmVyYWwudGlsZU1hdHJpeFNldHMpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIgdGlsZU1hdHJpeFNldCA9IGdlbmVyYWwudGlsZU1hdHJpeFNldHNbdG1zXTtcbiAgICAgICAgLy8gICAgICAgICAvLyBJR04ncyBXTVRTIGJ1ZyA6IGVwc2c6bm5ubiBpbnN0ZWFkIG9mIEVQU0c6bm5ublxuICAgICAgICAvLyAgICAgICAgIHZhciBjcnMgPSB0aWxlTWF0cml4U2V0LnN1cHBvcnRlZENSUyA9IHRpbGVNYXRyaXhTZXQuc3VwcG9ydGVkQ1JTLnJlcGxhY2UoL2Vwc2cvLFwiRVBTR1wiKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICBpZiAoIUdlb3BvcnRhbC5DYXRhbG9ndWUuQ1JTUkVTT0xVVElPTlMuaGFzT3duUHJvcGVydHkoY3JzKSkge1xuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgcD0gbmV3IE9wZW5MYXllcnMuUHJvamVjdGlvbihjcnMpO1xuICAgICAgICAvLyAgICAgICAgICAgICBHZW9wb3J0YWwuQ2F0YWxvZ3VlLkNSU1JFU09MVVRJT05TW2Nyc109IFtdO1xuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgbWF0cml4SWRzPSB0aWxlTWF0cml4U2V0Lm1hdHJpeElkcztcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICh2YXIgaT0gMCwgbGk9IG1hdHJpeElkcy5sZW5ndGg7IGk8bGk7ICsraSkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdmFyIG1pZD0gbWF0cml4SWRzW2ldO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgR2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1tjcnNdLnB1c2goXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgMC4wMDAyOCptaWQuc2NhbGVEZW5vbWluYXRvclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8oT3BlbkxheWVycy5NRVRFUlNfUEVSX0lOQ0gqT3BlbkxheWVycy5JTkNIRVNfUEVSX1VOSVRbcC5nZXRVbml0cygpXSkpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIG1pZC5zdXBwb3J0ZWRDUlM9IG1pZC5zdXBwb3J0ZWRDUlMucmVwbGFjZSgvZXBzZy8sXCJFUFNHXCIpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgR2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1tjcnNdLnNvcnQoZnVuY3Rpb24gKGEsYil7IHJldHVybiBiLWE7IH0pO1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIHZhciBsbFI9IEdlb3BvcnRhbC5DYXRhbG9ndWUuQ1JTUkVTT0xVVElPTlNbJ0NSUzo4NCddO1xuICAgICAgICAvLyAgICAgICAgIGlmICghbGxSKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgIGxsUj0gR2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1snQ1JTOjg0J109IGdlbmVyYWwucmVzb2x1dGlvbnMuc2xpY2UoKTtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgdmFyIHdtUj0gR2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1snRVBTRzozODU3J107XG4gICAgICAgIC8vICAgICAgICAgaWYgKCF3bVIpIHsvL0ZJWE1FIDogc2hvdWxkIG5ldmVyIGhhcHBlbmVkICEhXG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIHJlcHJvamVjdCByZXNvbHV0aW9ucyBmcm9tIENSUzg0IHRvIFdlYk1lcmNhdG9yICh0cmFuc2Zvcm0gcmVzb2x1dGlvbnMgZnJvbSBkZWdyZWUvcHggdG8gbWV0ZXIvcHgpXG4gICAgICAgIC8vICAgICAgICAgICAgIHdtUj0gR2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1snRVBTRzozODU3J109IG5ldyBBcnJheShsbFIubGVuZ3RoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgZm9yICh2YXIgaT0gMCwgbGVuPSBsbFIubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YXIgcHQ9IG5ldyBPcGVuTGF5ZXJzLkxvbkxhdChsbFJbaV0sIDApO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgcHQudHJhbnNmb3JtKE9wZW5MYXllcnMuUHJvamVjdGlvbi5DUlM4NCwgT3BlbkxheWVycy5Qcm9qZWN0aW9uLldlYk1lcmNhdG9yKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHdtUltpXT0gcHQubG9uO1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIEdlb3BvcnRhbC5DYXRhbG9ndWUuUkVTT0xVVElPTlM9IHdtUjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICB2YXIgZ2V0UmVzb2x1dGlvbnNGcm9tQ1JTPSBmdW5jdGlvbihjcnMpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKE9wZW5MYXllcnMuUHJvamVjdGlvbi5XZWJNZXJjYXRvci5pc0FsaWFzT2YoY3JzKSkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgcmV0dXJuIHdtUjtcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICBpZiAoT3BlbkxheWVycy5Qcm9qZWN0aW9uLkNSUzg0LmlzQWxpYXNPZihjcnMpKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gbGxSO1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgIHJldHVybiBHZW9wb3J0YWwuQ2F0YWxvZ3VlLkNSU1JFU09MVVRJT05TW2Nyc10/R2VvcG9ydGFsLkNhdGFsb2d1ZS5DUlNSRVNPTFVUSU9OU1tjcnNdOm51bGwgO1xuICAgICAgICAvLyAgICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgdmFyIHJldHJpZXZlWm9vbUZyb21SZXNvbHV0aW9uPSBmdW5jdGlvbihyZXNvbHV0aW9ucywgcmVzb2x1dGlvbikge1xuICAgICAgICAvLyAgICAgICAgICAgICBmb3IgKHZhciBpPSAwLCBsaT0gcmVzb2x1dGlvbnMubGVuZ3RoOyBpPGxpOyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGlmIChyZXNvbHV0aW9uc1tpXS1yZXNvbHV0aW9uIDw9IHJlc29sdXRpb25zW2xpLTFdKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyAgICAgICAgIH07XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgdmFyIGdldFpvb21MZXZlbEZyb21TY2FsZURlbm9taW5hdG9yPSBmdW5jdGlvbihzY2FsZURlbm9taW5hdG9yLGNycykge1xuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgcmVzb2x1dGlvbj0gc2NhbGVEZW5vbWluYXRvciAqIDAuMDAwMjg7XG4gICAgICAgIC8vICAgICAgICAgICAgIHZhciBSPSBnZXRSZXNvbHV0aW9uc0Zyb21DUlMoY3JzKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKFIpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHJldHVybiByZXRyaWV2ZVpvb21Gcm9tUmVzb2x1dGlvbihSLHJlc29sdXRpb24pO1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgIHJlc29sdXRpb249IHJlc29sdXRpb24vKE9wZW5MYXllcnMuTUVURVJTX1BFUl9JTkNIICogT3BlbkxheWVycy5JTkNIRVNfUEVSX1VOSVRbXCJkZWdyZWVzXCJdKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgcmV0dXJuIHJldHJpZXZlWm9vbUZyb21SZXNvbHV0aW9uKGxsUixyZXNvbHV0aW9uKTtcbiAgICAgICAgLy8gICAgICAgICB9O1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgIHZhciBnZXRab29tTGV2ZWxGcm9tUmVzb2x1dGlvbj0gZnVuY3Rpb24ocmVzb2x1dGlvbixjcnMpe1xuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgUj0gZ2V0UmVzb2x1dGlvbnNGcm9tQ1JTKGNycyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIGlmIChSKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gcmV0cmlldmVab29tRnJvbVJlc29sdXRpb24oUixyZXNvbHV0aW9uKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICB2YXIgcHQwPSBuZXcgT3BlbkxheWVycy5Mb25MYXQoMCwgMCk7XG4gICAgICAgIC8vICAgICAgICAgICAgIHZhciBwdDE9IG5ldyBPcGVuTGF5ZXJzLkxvbkxhdCgxLCAwKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgcHQwLnRyYW5zZm9ybShuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKGNycyksT3BlbkxheWVycy5Qcm9qZWN0aW9uLkNSUzg0KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgcHQxLnRyYW5zZm9ybShuZXcgT3BlbkxheWVycy5Qcm9qZWN0aW9uKGNycyksT3BlbkxheWVycy5Qcm9qZWN0aW9uLkNSUzg0KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgcmVzb2x1dGlvbj0gcmVzb2x1dGlvbiooTWF0aC5hYnMocHQxLmxvbi1wdDAubG9uKSk7XG4gICAgICAgIC8vICAgICAgICAgICAgIHJldHVybiByZXRyaWV2ZVpvb21Gcm9tUmVzb2x1dGlvbihsbFIscmVzb2x1dGlvbik7XG4gICAgICAgIC8vICAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXIgZGVmYXV0LCBvbiB1dGlsaXNlIGxhIHByb2plY3Rpb24gV2ViTWVyY2F0b3IgKEVQU0c6Mzg1NyA9IFBNKVxuICAgICAgICAvLyBzb2l0IGxhIGxpc3RlIGRlcyByZXNvbHV0aW9ucyBuYXRpdmVzXG4gICAgICAgIHZhciByZXNvbHV0aW9uc05hdGl2ZXMgPSB7fTtcbiAgICAgICAgc3dpdGNoIChjcnMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFUFNHOjIxNTRcIjpcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uc05hdGl2ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIDAgOiAxMDQ1NzkuMjI0NTQ5ODk0LFxuICAgICAgICAgICAgICAgICAgICAxIDogNTIyNzcuNTMyMzUzNzkwNSxcbiAgICAgICAgICAgICAgICAgICAgMiA6IDI2MTM1LjQ4NzA3ODU5NTQsXG4gICAgICAgICAgICAgICAgICAgIDMgOiAxMzA2Ni44OTEzODE4LFxuICAgICAgICAgICAgICAgICAgICA0IDogNjUzMy4yMjg2MDQxMTM1LFxuICAgICAgICAgICAgICAgICAgICA1IDogMzI2Ni41NTk1MjQ0NjI3LFxuICAgICAgICAgICAgICAgICAgICA2IDogMTYzMy4yNjYwMDQ1OTc0LFxuICAgICAgICAgICAgICAgICAgICA3IDogODE2LjYyOTU1NDk4NixcbiAgICAgICAgICAgICAgICAgICAgOCA6IDQwOC4zMTM5MTQ2NzY4LFxuICAgICAgICAgICAgICAgICAgICA5IDogMjA0LjE1Njc0MTUxMDksXG4gICAgICAgICAgICAgICAgICAgIDEwIDogMTAyLjA3ODMxNjc4MzIsXG4gICAgICAgICAgICAgICAgICAgIDExIDogNTEuMDM5MTQ0ODk2NixcbiAgICAgICAgICAgICAgICAgICAgMTIgOiAyNS41MTk1NjkwNzQzLFxuICAgICAgICAgICAgICAgICAgICAxMyA6IDEyLjc1OTc4MzY5MzYsXG4gICAgICAgICAgICAgICAgICAgIDE0IDogNi4zNzk4OTE2MzYsXG4gICAgICAgICAgICAgICAgICAgIDE1IDogMy4xODk5NDU3NjUzLFxuICAgICAgICAgICAgICAgICAgICAxNiA6IDEuNTk0OTcyODY5NSxcbiAgICAgICAgICAgICAgICAgICAgMTcgOiAwLjc5NzQ4NjQzMTUsXG4gICAgICAgICAgICAgICAgICAgIDE4IDogMC4zOTg3NDMyMTQ5LFxuICAgICAgICAgICAgICAgICAgICAxOSA6IDAuMTk5MzcxNjA3MyxcbiAgICAgICAgICAgICAgICAgICAgMjAgOiAwLjA5OTY4NTgwMzcsXG4gICAgICAgICAgICAgICAgICAgIDIxIDogMC4wNDk4NDI5MDE4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbnNOYXRpdmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAwIDogMTU2NTQzLjAzMzkyODA0MSxcbiAgICAgICAgICAgICAgICAgICAgMSA6IDc4MjcxLjUxNjk2NDAyMDQ4LFxuICAgICAgICAgICAgICAgICAgICAyIDogMzkxMzUuNzU4NDgyMDEwMjM1LFxuICAgICAgICAgICAgICAgICAgICAzIDogMTk1NjcuODc5MjQxMDA1MTIsXG4gICAgICAgICAgICAgICAgICAgIDQgOiA5NzgzLjkzOTYyMDUwMjU2LFxuICAgICAgICAgICAgICAgICAgICA1IDogNDg5MS45Njk4MTAyNTEyOCxcbiAgICAgICAgICAgICAgICAgICAgNiA6IDI0NDUuOTg0OTA1MTI1NjQsXG4gICAgICAgICAgICAgICAgICAgIDcgOiAxMjIyLjk5MjQ1MjU2MjgyLFxuICAgICAgICAgICAgICAgICAgICA4IDogNjExLjQ5NjIyNjI4MTQxLFxuICAgICAgICAgICAgICAgICAgICA5IDogMzA1Ljc0ODExMzE0MDcwNDgsXG4gICAgICAgICAgICAgICAgICAgIDEwIDogMTUyLjg3NDA1NjU3MDM1MjUsXG4gICAgICAgICAgICAgICAgICAgIDExIDogNzYuNDM3MDI4Mjg1MTc2MjQsXG4gICAgICAgICAgICAgICAgICAgIDEyIDogMzguMjE4NTE0MTQyNTg4MTMsXG4gICAgICAgICAgICAgICAgICAgIDEzIDogMTkuMTA5MjU3MDcxMjk0MDYsXG4gICAgICAgICAgICAgICAgICAgIDE0IDogOS41NTQ2Mjg1MzU2NDcwMzIsXG4gICAgICAgICAgICAgICAgICAgIDE1IDogNC43NzczMTQyNjc4MjM1MTYsXG4gICAgICAgICAgICAgICAgICAgIDE2IDogMi4zODg2NTcxMzM5MTE3NTgsXG4gICAgICAgICAgICAgICAgICAgIDE3IDogMS4xOTQzMjg1NjY5NTU4NzksXG4gICAgICAgICAgICAgICAgICAgIDE4IDogMC41OTcxNjQyODM0Nzc5Mzk1LFxuICAgICAgICAgICAgICAgICAgICAxOSA6IDAuMjk4NTgyMTQxNzM4OTY5NyxcbiAgICAgICAgICAgICAgICAgICAgMjAgOiAwLjE0OTI5MTA3MDg2OTQ4NDksXG4gICAgICAgICAgICAgICAgICAgIDIxIDogMC4wNzQ2NDU1MzU0MzQ3NDI0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdlc3Rpb24gZGVzIGF1dHJlcyBTUlNcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBpZiAoY3JzKSB7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHNjYWxlRGVub21pbmF0b3IgKiAwLjAwMDI4O1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4IGluIHJlc29sdXRpb25zTmF0aXZlcykge1xuICAgICAgICAgICAgaWYgKHJlc29sdXRpb25zTmF0aXZlcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x1dGlvbnNOYXRpdmVzW2luZGV4XSA8PSByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwOyAvLyAtMSA/XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhdHRyaWJ1dGlvbnMgbGlzdCBmb3IgYSBsYXllciwgYmFzZWQgb24gY3VycmVudCB6b29tIGFuZCBleHRlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBmdW5jdGlvbiBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxGbG9hdD59IHBhcmFtcy5leHRlbnQgLSBtYXAgY3VycmVudCBnZW9ncmFwaGljYWwgZXh0ZW50IChFUFNHOjQzMjYpIDogW3RvcCwgbGVmdCwgYm90dG9tLCByaWdodF0gPSBbbWF4eSwgbWlueCwgbWlueSwgbWF4eF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnpvb20gLSBtYXAgY3VycmVudCB6b29tXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jcnMgLSBtYXAgY3VycmVudCBwcm9qZWN0aW9uIGNvZGUgKGV4IFwiRVBTRzoyMTU0XCIpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMudmlzaWJpbGl0eSAtIGxheWVyIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0dwLlNlcnZpY2VzLkNvbmZpZy5PcmlnaW5hdG9yfSBwYXJhbXMub3JpZ2luYXRvcnMgLSByZXNvdXJjZSBvcmlnaW5hdG9ycyAoZnJvbSBHcC5Db25maWcubGF5ZXJzW10ub3JpZ2luYXRvcnMpXG4gICAgICogQHJldHVybnMge09iamVjdH0gYXR0cmlidXRpb25zIC0gYXNzb2NpYXRpdmUgYXJyYXksIG1hcHBpbmcgb3JpZ2luYXRvcnMgdXJsIChrZXlzKSB3aXRoIHRoZWlyIHByb3BlcnRpZXMgOiBodG1sIGF0dHJpYnV0aW9ucyBlbGVtZW50c1xuICAgICAqL1xuICAgIGdldEF0dHJpYnV0aW9ucyA6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHpvb20gPSBwYXJhbXMuem9vbTtcblxuICAgICAgICB2YXIgYXR0cmlidXRpb25zID0gW107XG5cbiAgICAgICAgaWYgKHBhcmFtcy5vcmlnaW5hdG9ycyAhPSBudWxsICYmIHBhcmFtcy52aXNpYmlsaXR5KSB7XG4gICAgICAgICAgICAvLyBkcmF3TG9nbyA9IGJvb2xlYW4sIHRydWUgaWYgYXR0cmlidXRpb24gc2hvdWxkIGJlIGRpc3BsYXllZCAoem9vbSwgZXh0ZW50KSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAgICB2YXIgZHJhd0xvZ287XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSBwYXJhbXMub3JpZ2luYXRvcnMubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICAgIGRyYXdMb2dvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYXRvciA9IHBhcmFtcy5vcmlnaW5hdG9yc1tqXTtcblxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IHBhcmFtcy5vcmlnaW5hdG9yc1tqXS5jb25zdHJhaW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2wgPSBjb25zdHJhaW50cy5sZW5ndGg7IGsgPCBrbDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50ID0gY29uc3RyYWludHNba107XG4gICAgICAgICAgICAgICAgICAgIGRyYXdMb2dvID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluWm9vbUxldmVsID0gdGhpcy5nZXRab29tTGV2ZWxGcm9tU2NhbGVEZW5vbWluYXRvcihjb25zdHJhaW50Lm1heFNjYWxlRGVub21pbmF0b3IsIHBhcmFtcy5jcnMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Wm9vbUxldmVsID0gdGhpcy5nZXRab29tTGV2ZWxGcm9tU2NhbGVEZW5vbWluYXRvcihjb25zdHJhaW50Lm1pblNjYWxlRGVub21pbmF0b3IsIHBhcmFtcy5jcnMpIHx8IDIxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbiB6b29tIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5ab29tTGV2ZWwgJiYgKG1pblpvb21MZXZlbCA+IHpvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3TG9nbyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHpvb20gY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdMb2dvICYmIG1heFpvb21MZXZlbCAhPT0gbnVsbCAmJiAobWF4Wm9vbUxldmVsIDwgem9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdMb2dvID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBiYm94IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYm94ID0gY29uc3RyYWludC5iYm94O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhd0xvZ28gJiYgYmJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0xvZ28gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3RXh0ZW50ID0gcGFyYW1zLmV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aWV3RXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IFtiYm94LnRvcCwgYmJveC5sZWZ0LCBiYm94LmJvdHRvbSwgYmJveC5yaWdodF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0cyh2aWV3RXh0ZW50LCBib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IG9uZSBjb25zdHJhaW50IG1hdGNoZXMgdGhlIG1hcCBvbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdMb2dvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdMb2dvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGEgdW4gb3JpZ2luYXRvciBxdWkgY29ycmVzcG9uZCBhdSB6b29tIGV0IMOgIGwnw6l0ZW5kdWUuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ28gPSBvcmlnaW5hdG9yLmxvZ287XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBvcmlnaW5hdG9yLnVybDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvcmlnaW5hdG9yLm5hbWUgPyBvcmlnaW5hdG9yLm5hbWUgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IG9yaWdpbmF0b3IuYXR0cmlidXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImdwLWNvbnRyb2wtYXR0cmlidXRpb25cIjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjcsOpZSB1biBsaWVuIGRhbnMgdG91cyBsZXMgY2FzIChtw6ptZSBzJ2lsIG5lIHBvaW50ZSBwYXMgdmVycyB1bmUgcsOpZsOpcmVuY2UpLCBwb3VyIGF2b2lyIGFjY8OocyDDoCBsYSBjbGFzcyBDU1MgKHBvdXIgc3VyY2hhcmdlKVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGluay5jbGFzc05hbWUgPSBcImdwLWNvbnRyb2wtYXR0cmlidXRpb24tbGlua1wiO1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJJbWFnZSA9ICEhKGxvZ28pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBzaSBvbiBhIHVuIGxvZ28sIG9uIGwnYWZmaWNoZSDDoCBsJ2ludGVyaWV1ciBkdSBsaWVuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuY2xhc3NOYW1lID0gXCJncC1jb250cm9sLWF0dHJpYnV0aW9uLWltYWdlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluay5hcHBlbmRDaGlsZChpbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmNsYXNzTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IGxvZ287IC8vIEZJWE1FIDogbWl4Q29udGVudCAhXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS50aXRsZSA9IHRleHQgfHwgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0eWxlLmhlaWdodCA9IFwiMzBweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3R5bGUud2lkdGggPSBcIjMwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbm9uLCBvbiBhZmZpY2hlIGxlIG5vbSBkZSBsJ29yaWdpbmF0b3IsIG91IHNhIGRlc2NyaXB0aW9uIG91IGwndXJsLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmsudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKGNvbnRhaW5lci5pbm5lckhUTUwgKyBcIiBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBvbmUgZXh0ZW50IChleHRlbnQxKSBpbnRlcnNlY3RzIGFub3RoZXIgKGV4dGVudDIpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxGbG9hdD59IGV4dGVudDEgLSBGaXJzdCBleHRlbnQgOiBbdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0XSA9IFttYXh5LCBtaW54LCBtaW55LCBtYXh4XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEZsb2F0Pn0gZXh0ZW50MiAtIFNlY29uZCBleHRlbnQgOiBbdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0XSA9IFttYXh5LCBtaW54LCBtaW55LCBtYXh4XVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGludGVyc2VjdHMgLSBUcnVlIGlmIHRoZSB0d28gZXh0ZW50cyBpbnRlcnNlY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzIDogZnVuY3Rpb24gKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdHNYID0gKGV4dGVudDFbMV0gPD0gZXh0ZW50MlszXSkgJiYgKGV4dGVudDJbMV0gPD0gZXh0ZW50MVszXSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3RzWSA9IChleHRlbnQxWzJdIDw9IGV4dGVudDJbMF0pICYmIChleHRlbnQyWzJdIDw9IGV4dGVudDFbMF0pO1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0c1ggJiYgaW50ZXJzZWN0c1k7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJVdGlscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vVXRpbHMvTGF5ZXJVdGlscy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_8__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJpdG93bnNcIixcImNvbW1vbmpzXCI6XCJpdG93bnNcIixcImFtZFwiOlwiaXRvd25zXCIsXCJyb290XCI6XCJpdG93bnNcIn0/OTI2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qczJcIjpcIml0b3duc1wiLFwiY29tbW9uanNcIjpcIml0b3duc1wiLFwiYW1kXCI6XCJpdG93bnNcIixcInJvb3RcIjpcIml0b3duc1wifVxuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.itownsExtended = exports.itownsExtDate = exports.itownsExtVersion = exports.LayerUtils = undefined;\n\nvar _gp = __webpack_require__(6);\n\nObject.keys(_gp).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _gp[key];\n    }\n  });\n});\n\nvar _LayerUtils = __webpack_require__(7);\n\nObject.defineProperty(exports, \"LayerUtils\", {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_LayerUtils).default;\n  }\n});\n\nvar _itowns = __webpack_require__(8);\n\nvar Itowns = _interopRequireWildcard(_itowns);\n\nvar _MousePosition = __webpack_require__(12);\n\nvar _MousePosition2 = _interopRequireDefault(_MousePosition);\n\nvar _LayerSwitcher = __webpack_require__(20);\n\nvar _LayerSwitcher2 = _interopRequireDefault(_LayerSwitcher);\n\nvar _Attributions = __webpack_require__(23);\n\nvar _Attributions2 = _interopRequireDefault(_Attributions);\n\nvar _Scale = __webpack_require__(25);\n\nvar _Scale2 = _interopRequireDefault(_Scale);\n\nvar _MiniGlobe = __webpack_require__(27);\n\nvar _MiniGlobe2 = _interopRequireDefault(_MiniGlobe);\n\nvar _LayerWMTS = __webpack_require__(29);\n\nvar _LayerWMTS2 = _interopRequireDefault(_LayerWMTS);\n\nvar _LayerWMS = __webpack_require__(30);\n\nvar _LayerWMS2 = _interopRequireDefault(_LayerWMS);\n\nvar _LayerElevation = __webpack_require__(31);\n\nvar _LayerElevation2 = _interopRequireDefault(_LayerElevation);\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\n__webpack_require__(32);\n\n__webpack_require__(54);\n\nvar _package = __webpack_require__(55);\n\nvar _package2 = _interopRequireDefault(_package);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Adds extensions properties in the Gp namespace\nvar itownsExtVersion = exports.itownsExtVersion = _package2.default.itownsExtVersion;\nvar itownsExtDate = exports.itownsExtDate = new Date().toISOString().split(\"T\")[0];\n\n// creation of the namespace for the itowns extensions\nItowns.control = {};\nItowns.control.MousePosition = _MousePosition2.default;\nItowns.control.LayerSwitcher = _LayerSwitcher2.default;\nItowns.control.Attributions = _Attributions2.default;\nItowns.control.Scale = _Scale2.default;\nItowns.control.MiniGlobe = _MiniGlobe2.default;\nItowns.layer = {};\nItowns.layer.GeoportalWMTS = _LayerWMTS2.default;\nItowns.layer.GeoportalWMS = _LayerWMS2.default;\nItowns.layer.GeoportalElevation = _LayerElevation2.default;\nItowns.GlobeViewExtended = _GlobeViewExtended2.default;\n\nexports.itownsExtended = Itowns;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0dwUGx1Z2luSXRvd25zLmpzPzFlYjgiXSwibmFtZXMiOlsiZGVmYXVsdCIsIkl0b3ducyIsIml0b3duc0V4dFZlcnNpb24iLCJQa2ciLCJpdG93bnNFeHREYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJjb250cm9sIiwiTW91c2VQb3NpdGlvbiIsIkxheWVyU3dpdGNoZXIiLCJBdHRyaWJ1dGlvbnMiLCJTY2FsZSIsIk1pbmlHbG9iZSIsImxheWVyIiwiR2VvcG9ydGFsV01UUyIsIkdlb3BvcnRhbFdNUyIsIkdlb3BvcnRhbEVsZXZhdGlvbiIsIkdsb2JlVmlld0V4dGVuZGVkIiwiaXRvd25zRXh0ZW5kZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7OzsrQ0FHUUEsTzs7OztBQWpCUjs7SUFBWUMsTTs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNPLElBQU1DLDhDQUFtQkMsa0JBQUlELGdCQUE3QjtBQUNBLElBQU1FLHdDQUFnQixJQUFJQyxJQUFKLEdBQVdDLFdBQVgsR0FBeUJDLEtBQXpCLENBQStCLEdBQS9CLEVBQW9DLENBQXBDLENBQXRCOztBQUVQO0FBQ0FOLE9BQU9PLE9BQVAsR0FBaUIsRUFBakI7QUFDQVAsT0FBT08sT0FBUCxDQUFlQyxhQUFmLEdBQStCQSx1QkFBL0I7QUFDQVIsT0FBT08sT0FBUCxDQUFlRSxhQUFmLEdBQStCQSx1QkFBL0I7QUFDQVQsT0FBT08sT0FBUCxDQUFlRyxZQUFmLEdBQThCQSxzQkFBOUI7QUFDQVYsT0FBT08sT0FBUCxDQUFlSSxLQUFmLEdBQXVCQSxlQUF2QjtBQUNBWCxPQUFPTyxPQUFQLENBQWVLLFNBQWYsR0FBMkJBLG1CQUEzQjtBQUNBWixPQUFPYSxLQUFQLEdBQWUsRUFBZjtBQUNBYixPQUFPYSxLQUFQLENBQWFDLGFBQWIsR0FBNkJBLG1CQUE3QjtBQUNBZCxPQUFPYSxLQUFQLENBQWFFLFlBQWIsR0FBNEJBLGtCQUE1QjtBQUNBZixPQUFPYSxLQUFQLENBQWFHLGtCQUFiLEdBQWtDQSx3QkFBbEM7QUFDQWhCLE9BQU9pQixpQkFBUCxHQUEyQkEsMkJBQTNCOztRQUVrQkMsYyxHQUFWbEIsTSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSXRvd25zIGZyb20gXCJpdG93bnNcIjtcbmltcG9ydCBNb3VzZVBvc2l0aW9uIGZyb20gXCIuL0NvbnRyb2xzL01vdXNlUG9zaXRpb25cIjtcbmltcG9ydCBMYXllclN3aXRjaGVyIGZyb20gXCIuL0NvbnRyb2xzL0xheWVyU3dpdGNoZXJcIjtcbmltcG9ydCBBdHRyaWJ1dGlvbnMgZnJvbSBcIi4vQ29udHJvbHMvQXR0cmlidXRpb25zXCI7XG5pbXBvcnQgU2NhbGUgZnJvbSBcIi4vQ29udHJvbHMvU2NhbGVcIjtcbmltcG9ydCBNaW5pR2xvYmUgZnJvbSBcIi4vQ29udHJvbHMvTWluaUdsb2JlXCI7XG5pbXBvcnQgR2VvcG9ydGFsV01UUyBmcm9tIFwiLi9MYXllci9MYXllcldNVFNcIjtcbmltcG9ydCBHZW9wb3J0YWxXTVMgZnJvbSBcIi4vTGF5ZXIvTGF5ZXJXTVNcIjtcbmltcG9ydCBHZW9wb3J0YWxFbGV2YXRpb24gZnJvbSBcIi4vTGF5ZXIvTGF5ZXJFbGV2YXRpb25cIjtcbmltcG9ydCBHbG9iZVZpZXdFeHRlbmRlZCBmcm9tIFwiLi9HbG9iZVZpZXdFeHRlbmRlZFwiO1xuaW1wb3J0IFwiLi9DU1NcIjtcbmltcG9ydCBcIi4uL0NvbW1vbi9VdGlscy9BdXRvTG9hZENvbmZpZ1wiO1xuaW1wb3J0IFBrZyBmcm9tIFwiLi4vLi4vcGFja2FnZVwiO1xuXG5leHBvcnQgKiBmcm9tIFwiZ3BcIjtcblxuLy8gQWRkcyB0aGUgZXh0ZW5zaW9ucyBwcm9wZXJ0aWVzIGluIHRoZSBHcCBuYW1lc3BhY2VcbmV4cG9ydCB7ZGVmYXVsdCBhcyBMYXllclV0aWxzfSBmcm9tIFwiLi4vQ29tbW9uL1V0aWxzL0xheWVyVXRpbHNcIjtcblxuLy8gQWRkcyBleHRlbnNpb25zIHByb3BlcnRpZXMgaW4gdGhlIEdwIG5hbWVzcGFjZVxuZXhwb3J0IGNvbnN0IGl0b3duc0V4dFZlcnNpb24gPSBQa2cuaXRvd25zRXh0VmVyc2lvbjtcbmV4cG9ydCBjb25zdCBpdG93bnNFeHREYXRlID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KFwiVFwiKVswXTtcblxuLy8gY3JlYXRpb24gb2YgdGhlIG5hbWVzcGFjZSBmb3IgdGhlIGl0b3ducyBleHRlbnNpb25zXG5JdG93bnMuY29udHJvbCA9IHt9O1xuSXRvd25zLmNvbnRyb2wuTW91c2VQb3NpdGlvbiA9IE1vdXNlUG9zaXRpb247XG5JdG93bnMuY29udHJvbC5MYXllclN3aXRjaGVyID0gTGF5ZXJTd2l0Y2hlcjtcbkl0b3ducy5jb250cm9sLkF0dHJpYnV0aW9ucyA9IEF0dHJpYnV0aW9ucztcbkl0b3ducy5jb250cm9sLlNjYWxlID0gU2NhbGU7XG5JdG93bnMuY29udHJvbC5NaW5pR2xvYmUgPSBNaW5pR2xvYmU7XG5JdG93bnMubGF5ZXIgPSB7fTtcbkl0b3ducy5sYXllci5HZW9wb3J0YWxXTVRTID0gR2VvcG9ydGFsV01UUztcbkl0b3ducy5sYXllci5HZW9wb3J0YWxXTVMgPSBHZW9wb3J0YWxXTVM7XG5JdG93bnMubGF5ZXIuR2VvcG9ydGFsRWxldmF0aW9uID0gR2VvcG9ydGFsRWxldmF0aW9uO1xuSXRvd25zLkdsb2JlVmlld0V4dGVuZGVkID0gR2xvYmVWaWV3RXh0ZW5kZWQ7XG5cbmV4cG9ydCB7SXRvd25zIGFzIGl0b3duc0V4dGVuZGVkfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9JdG93bnMvR3BQbHVnaW5JdG93bnMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_10__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJ4bWxkb21cIixcImNvbW1vbmpzXCI6XCJ4bWxkb21cIixcImFtZFwiOlwicmVxdWlyZVwifT9lOTFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzEwX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJ4bWxkb21cIixcImNvbW1vbmpzXCI6XCJ4bWxkb21cIixcImFtZFwiOlwicmVxdWlyZVwifVxuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_11__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanMyXCI6XCJyZXF1ZXN0XCIsXCJjb21tb25qc1wiOlwicmVxdWVzdFwiLFwiYW1kXCI6XCJyZXF1aXJlXCJ9PzE2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qczJcIjpcInJlcXVlc3RcIixcImNvbW1vbmpzXCI6XCJyZXF1ZXN0XCIsXCJhbWRcIjpcInJlcXVpcmVcIn1cbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _proj = __webpack_require__(13);\n\nvar _proj2 = _interopRequireDefault(_proj);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nvar _gp = __webpack_require__(6);\n\nvar _gp2 = _interopRequireDefault(_gp);\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _CheckRightManagement = __webpack_require__(15);\n\nvar _CheckRightManagement2 = _interopRequireDefault(_CheckRightManagement);\n\nvar _SelectorID = __webpack_require__(3);\n\nvar _SelectorID2 = _interopRequireDefault(_SelectorID);\n\nvar _MousePositionDOM = __webpack_require__(17);\n\nvar _MousePositionDOM2 = _interopRequireDefault(_MousePositionDOM);\n\nvar _Widget = __webpack_require__(4);\n\nvar _Widget2 = _interopRequireDefault(_Widget);\n\nvar _PositionFormater = __webpack_require__(18);\n\nvar _PositionFormater2 = _interopRequireDefault(_PositionFormater);\n\nvar _CRS = __webpack_require__(19);\n\nvar _CRS2 = _interopRequireDefault(_CRS);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"MousePosition\");\n\n/**\n * @classdesc\n *\n * MousePosition Control.\n *\n * @constructor\n * @alias itowns.control.MousePosition\n * @extends {itowns.control.Control}\n * @param {Object} options - options for function call.\n * @param {Boolean} [options.collapsed = true] - Specify if MousePosition control should be collapsed at startup. Default is true.\n * @param {Array}   [options.systems] - list of projection systems, default are Geographical (\"EPSG:4326\"), Web Mercator (\"EPSG:3857\"), Lambert 93 (\"EPSG:2154\") and extended Lambert 2 (\"EPSG:27572\").\n *      Each array element (=system) is an object with following properties :\n * @param {String}  options.systems.crs - Proj4 crs alias (from proj4 defs). e.g. : \"EPSG:4326\". Required\n * @param {String}  [options.systems.label] - CRS label to be displayed in control. Default is crs code (e.g. \"EPSG:4326\")\n * @param {String}  options.systems.type - CRS units type for coordinates conversion : \"Geographical\" or \"Metric\". Default: \"Metric\"\n * @param {Object}  [options.systems.geoBBox] - Aera covered by the system (WGS84 coordinates).\n * @param {Number}  options.systems.geoBBox.right - Right bound.\n * @param {Number}  options.systems.geoBBox.left - Left bound.\n * @param {Number}  options.systems.geoBBox.top - Top bound.\n * @param {Number}  options.systems.geoBBox.bottom - Bottom bound.\n * @param {Array}   [options.units] - list of coordinates units, to be displayed in control units list.\n *      Values may be \"DEC\" (decimal degrees), \"DMS\" (sexagecimal), \"RAD\" (radians) and \"GON\" (grades) for geographical coordinates,\n *      and \"M\" or \"KM\" for metric coordinates\n * @param {Array}   [options.displayAltitude = true] - activate (true) or deactivate (false) the altitude panel. True by default\n * @param {Array}   [options.displayCoordinates = true] - activate (true) or deactivate (false) the coordinates panel. True by default\n * @param {Object}  [options.altitude] - elevation configuration\n * @param {Object}  [options.altitude.serviceOptions] - options of elevation service\n * @param {Number}  [options.altitude.responseDelay] - latency for altitude request, 500 ms by default\n * @param {Number}  [options.altitude.triggerDelay] - immobilisation time of movement on the globe to trigger the elevation calculation, 200 ms by default\n * @example\n *  var mousePosition = new itowns.control.MousePosition({\n *      collapsed : false,\n *      displayCoordinates : true,\n *      displayAltitude : true,\n *      altitude : {\n *           triggerDelay : 100,\n *           responseDelay : 500,\n *           serviceOptions : {}\n *      },\n *      systems : [\n *       {\n *          crs : \"EPSG:3857\",\n *          label : \"Mercator\",\n *          type : \"Metric\"\n *        },\n *       {\n *          crs : \"EPSG:32620\",\n *          label : \"UTM 20N (Guadeloupe, Martinique)\",\n *          type : \"Metric\",\n *          geoBBox : {\n *              left: -66.00,\n *              bottom : 0.00,\n *              right : -60.00,\n *              top : 84.00\n *          }\n *        }\n *      ],\n *      units : [\"DEC\", \"DMS\"]\n *  });\n */\nfunction MousePosition(options) {\n    options = options || {};\n\n    if (!(this instanceof MousePosition)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    if (options && (typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        throw new Error(\"ERROR WRONG_TYPE : options should be an object\");\n    }\n\n    this._initialize(options);\n\n    this._callbacks = {};\n\n    // init control DOM container\n    var container = this._initContainer(options);\n    var targetDiv = document.getElementById(options.target) || null;\n    _Widget2.default.call(this, {\n        name: \"MousePosition\",\n        element: container,\n        target: targetDiv\n    });\n};\n\n/**\n * @lends module:MousePosition\n */\nMousePosition.prototype = Object.create(_Widget2.default.prototype, {});\n\n_Utils2.default.assign(MousePosition.prototype, _MousePositionDOM2.default);\n\n/**\n * Constructor (alias)\n */\nMousePosition.prototype.constructor = MousePosition;\n\n/**\n * Bind globe to control\n *\n * @param {GlobeViewExtended} globe - the globe\n */\nMousePosition.prototype.setGlobe = function (globe) {\n    if (globe) {\n        // In the case of the adding of a control to the globe\n        this._centerElement = this._createMapCenter();\n        globe.getTargetElement().appendChild(this._centerElement);\n\n        // defines the callback on the map to retrieve the coordinates\n        this._callbacks.mouseMove = this.onMouseMove.bind(this);\n\n        // valid event for desktop mode\n        if (!this.collapsed) {\n            if (this._isDesktop) {\n                globe.listen(_GlobeViewExtended2.default.EVENTS.MOUSE_MOVE, this._callbacks.mouseMove);\n            } else {\n                globe.listen(_GlobeViewExtended2.default.EVENTS.CENTER_CHANGED, this.onGlobeMove);\n            }\n        }\n    } else if (globe == null) {\n        // if globe == null we remove the MP control\n        // deletes the listener associated to the mousePosition control\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.MOUSE_MOVE, this._callbacks.mouseMove);\n        // deletes the mousePosition control DOM\n        while (this.getElement().hasChildNodes()) {\n            this.getElement().removeChild(this.getElement().lastChild);\n        }\n        this.getElement().parentNode.removeChild(this.getElement());\n        this._globe.getTargetElement().removeChild(this._centerElement);\n    }\n    // call original setGlobe method\n    _Widget2.default.prototype.setGlobe.call(this, globe);\n};\n\n// ################################################################### //\n// #################### user interface methods ####################### //\n// ################################################################### //\n\n/**\n * Sets additional projection system\n *\n * @param {Object} system - Projection system defined in the Itowns/CRS/CRS.js class\n * @param {String} system.crs - Proj4 crs alias (from proj4 defs) e.g. \"EPSG:4326\"\n * @param {String} [system.label] - CRS label to be displayed in control. Default is system.crs alias\n * @param {String} [system.type] - CRS units type for coordinates conversion (one of control options.units). Default is \"Metric\"\n */\nMousePosition.prototype.addSystem = function (system) {\n    if ((typeof system === \"undefined\" ? \"undefined\" : _typeof(system)) !== \"object\") {\n        logger.error(\"MousePosition:addSystem - system parameter should be an object\");\n        return;\n    }\n    if (!system.crs) {\n        logger.error(\"crs not defined !\");\n        return;\n    }\n    if (!system.label) {\n        logger.warn(\"crs label not defined, use crs code by default.\");\n        system.label = system.crs;\n    }\n    if (!system.type) {\n        logger.warn(\"type srs not defined, use 'Metric' by default.\");\n        system.type = \"Metric\";\n    }\n\n    // 1. adds system to control systems\n    for (var j = 0; j < this._projectionSystems.length; j++) {\n        var obj = this._projectionSystems[j];\n        if (system.crs === obj.crs) {\n            // warn user\n            logger.warn(\"crs '{}' already configured\", obj.crs);\n        }\n    }\n\n    system.code = this._projectionSystems.length;\n    this._projectionSystems.push(system);\n\n    // 2. adds system settings option to container (if it was already build)\n    var selectSystem = document.getElementById(this._addUID(\"GPmousePositionProjectionSystem\"));\n    if (selectSystem) {\n        var option = document.createElement(\"option\");\n        option.value = system.code;\n        option.text = system.label;\n        selectSystem.appendChild(option);\n    }\n};\n\n/**\n * Sets additional projection systems\n *\n * @param {Array} systems - Array of system object, with following properties :\n * @param {String} systems.crs - Proj4 CRS alias (from proj4 defs) e.g. \"EPSG:4326\"\n * @param {String} systems.label - CRS label (for coordinates conversion)\n * @param {String} systems.type - CRS units type to be displayed in control (one of control options.units). Default is \"Metric\"\n */\nMousePosition.prototype.addSystems = function (systems) {\n    if (!systems) {\n        return;\n    }\n    if (!Array.isArray(systems)) {\n        logger.error(\"MousePosition:addSystems - systems parameter should be an array\");\n        return;\n    }\n    for (var i = 0; i < systems.length; i++) {\n        this.addSystem(systems[i]);\n    }\n};\n\n/**\n * Removes projection system (in case there are several system with same code, only the first one will be removed)\n *\n * @param {String} systemCrs - CRS alias (from proj4 defs)\n */\nMousePosition.prototype.removeSystem = function (systemCrs) {\n    if (!systemCrs || typeof systemCrs !== \"string\") {\n        logger.error(\"MousePosition:removeSystem - systemCode parameter should be a string\");\n        return;\n    }\n\n    var systemCode = null;\n    // finds system in control projection systems list\n    for (var i = 0; i < this._projectionSystems.length; i++) {\n        var proj = this._projectionSystems[i];\n        if (systemCrs === proj.crs) {\n            systemCode = proj.code;\n            // removes system from control projection systems list\n            this._projectionSystems.splice(i, 1);\n            break;\n        }\n    }\n\n    if (systemCode == null) {\n        logger.warn(\"MousePosition:removeSystem - system not found\");\n        return;\n    }\n\n    // re-initialization of codes\n    var oldNewCodeGlobe = [];\n    for (var ii = 0; ii < this._projectionSystems.length; ii++) {\n        oldNewCodeGlobe[Number(this._projectionSystems[ii].code)] = ii;\n        this._projectionSystems[ii].code = ii;\n    }\n\n    // finds system in control container systems list\n    var indexChildToRemove = null;\n    var systemList = document.getElementById(this._addUID(\"GPmousePositionProjectionSystem\"));\n    for (var j = 0; j < systemList.childNodes.length; j++) {\n        if (systemCode === systemList.childNodes[j].value) {\n            indexChildToRemove = j;\n            continue;\n        }\n        systemList.childNodes[j].value = oldNewCodeGlobe[Number(systemList.childNodes[j].value)];\n    }\n    // removes system from control container systems list\n    if (indexChildToRemove != null) {\n        systemList.removeChild(systemList.childNodes[indexChildToRemove]);\n    }\n\n    // choose arbitrarily a new current system if needed\n    if (this._currentProjectionSystems.code === systemCode) {\n        systemList.childNodes[0].setAttribute(\"selected\", \"selected\");\n        this._setCurrentSystem(systemList.childNodes[0].value);\n    }\n};\n\n/**\n * Sets control units (to be displayed)\n *\n * @param {Array} units - list of all coordinates units, to be displayed in control units list.\n *      Values may be \"DEC\" (decimal degrees), \"DMS\" (sexagecimal), \"RAD\" (radians) and \"GON\" (grades) for geographical coordinates,\n *      and \"M\" or \"KM\" for metric coordinates\n */\nMousePosition.prototype.setUnits = function (units) {\n    if (!units || !Array.isArray(units)) {\n        return;\n    }\n    this.options.units = units;\n    this._projectionUnits = {};\n    this._initProjectionUnits();\n    if (this._currentProjectionType) {\n        this._setTypeUnitsPanel(this._currentProjectionType);\n    }\n};\n\n/**\n * Sets control altitude options (useless if displayAltitude == false)\n *\n * @param {Object} options - altitude options\n * @param {Object}  [options.serviceOptions] - options of elevation service\n * @param {Number}  [options.responseDelay] - latency for elevation request, 500 ms by default\n * @param {Number}  [options.triggerDelay] - immobilisation time of movement on the globe to trigger the elevation calculation, 200 ms by default\n */\nMousePosition.prototype.setAltitudeOptions = function (options) {\n    if (!options || (typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        return;\n    }\n    this.options.altitude.triggerDelay = options.triggerDelay;\n    this.options.altitude.responseDelay = options.responseDelay;\n    if (options.serviceOptions) {\n        for (var opt in options.serviceOptions) {\n            if (options.serviceOptions.hasOwnProperty(opt)) {\n                this.options.altitude.serviceOptions[opt] = options.serviceOptions[opt];\n            }\n        }\n    }\n};\n\n/**\n * Displays or hides elevation panel\n *\n * @param {Boolean} displayAltitude - true to display elevation panel, false to hide it\n */\nMousePosition.prototype.displayAltitude = function (displayAltitude) {\n    if (displayAltitude === undefined) {\n        return;\n    }\n    if (typeof this._noRightManagement === \"undefined\") {\n        this._checkRightsManagement();\n    }\n    this.options.displayAltitude = displayAltitude;\n    this._setElevationPanel(displayAltitude);\n};\n\n/**\n * Displays or hides coordinates panel\n *\n * @param {Boolean} displayCoordinates - true to display coordinates panel, false to hide it\n */\nMousePosition.prototype.displayCoordinates = function (displayCoordinates) {\n    if (displayCoordinates === undefined) {\n        return;\n    }\n    this.options.displayCoordinates = displayCoordinates;\n    this._setCoordinatesPanel(displayCoordinates);\n    this._setSettingsPanel(displayCoordinates);\n};\n\n/**\n * Collapses or displays control main container\n *\n * @param {Boolean} collapsed - True to collapse control, False to display it\n */\nMousePosition.prototype.setCollapsed = function (collapsed) {\n    if (collapsed === undefined) {\n        logger.error(\"MousePosition:setCollapsed - missing collapsed parameter\");\n        return;\n    }\n    if (collapsed && this.collapsed || !collapsed && !this.collapsed) {\n        return;\n    }\n    if (!this._isDesktop) {\n        document.getElementById(this._addUID(\"GPmapCenter\")).className = collapsed ? \"\" : \"GPmapCenterVisible\";\n    }\n    // simulates the opening of the panel after a click\n    this.onShowMousePositionClick();\n    this._showMousePositionContainer.checked = !collapsed;\n};\n\n// ################################################################### //\n// ######################## initialize control ####################### //\n// ################################################################### //\n\n/**\n * Initializes control (called by MousePosition constructor)\n *\n * @method _initialize\n * @param {Object} options - control options (set by user)\n * @private\n */\nMousePosition.prototype._initialize = function (options) {\n    // Set default options\n    // {Object} control options - set by user or by default\n    this.options = options || {};\n    this.options.collapsed = options.collapsed !== undefined ? options.collapsed : true;\n    /** {Boolean} specify if MousePosition control is collapsed (true) or not (false) */\n    this.collapsed = this.options.collapsed;\n    this.options.units = options.units || [];\n    this.options.displayAltitude = options.displayAltitude !== undefined ? options.displayAltitude : true;\n    this.options.displayCoordinates = options.displayCoordinates !== undefined ? options.displayCoordinates : true;\n    this.options.systems = options.systems || [];\n    if (options.altitude) {\n        var altitude = options.altitude;\n        this.options.altitude = {\n            triggerDelay: altitude.triggerDelay !== undefined ? altitude.triggerDelay : 200,\n            responseDelay: altitude.responseDelay !== undefined ? altitude.responseDelay : 500,\n            serviceOptions: altitude.serviceOptions || {},\n            noDataValue: altitude.noDataValue !== undefined ? altitude.noDataValue : -99999,\n            noDataValueTolerance: altitude.noDataValueTolerance !== undefined ? altitude.noDataValueTolerance : 90000\n        };\n    } else {\n        this.options.altitude = {\n            triggerDelay: 200,\n            responseDelay: 500,\n            serviceOptions: {}\n        };\n    }\n\n    // id of the widget : usefull to suffix the CSS ids (to handle cases with several widgets on the same page)\n    this._uid = _SelectorID2.default.generate();\n\n    // initialization of the projections systems\n    this._projectionSystems = [];\n    this._initProjectionSystems();\n\n    // initialization of the units systems\n    this._projectionUnits = {};\n    this._initProjectionUnits();\n\n    // support detect : desktop or tactile\n    this._isDesktop = _Utils2.default.detectSupport();\n\n    // implements a timer threshold\n    if (this.options.altitude.triggerDelay < 100) {\n        this.options.altitude.triggerDelay = 100;\n    }\n\n    // {Number} timer on movestopped delay (altitude calculation)\n    this._timer = this.options.altitude.triggerDelay;\n\n    // {Object} Selected projection system\n    this._currentProjectionSystems = this._projectionSystems[0];\n\n    // {String} Selected projection units typs : Geographical or metric\n    this._currentProjectionType = this._projectionSystems[0].type;\n\n    // {String} Selected projection unit\n    this._currentProjectionUnits = this._projectionUnits[this._currentProjectionType][0].code;\n\n    // {Object} Projection units container (DOM Element)\n    this._projectionUnitsContainer = null;\n\n    // {Object} control panel container (DOM Element)\n    this._showMousePositionContainer = null;\n\n    // management of the altitude panel display\n    if (!this.options.displayAltitude && !this.options.displayCoordinates) {\n        // reactivate the display of coordinates, to not display an empty panel\n        this.options.displayCoordinates = true;\n    }\n\n    // rights management on resources and services\n    // if we want an altitude calculation, we check the alti resources rights...\n    if (this.options.displayAltitude) {\n        this._checkRightsManagement();\n    }\n};\n\n/**\n * this method is called by the constructor and initialize the projection\n * systems.\n * getting coordinates in the requested projection :\n * see this.onMousePositionProjectionSystemChange()\n *\n * @method _initProjectionSystems\n * @private\n */\nMousePosition.prototype._initProjectionSystems = function () {\n    // user has the possibility to modify the list of systems to display\n    // Ex. this.options.systems\n\n    // available projection systems vy default\n    var projectionSystemsByDefault = [{\n        label: \"Géographique\",\n        crs: \"EPSG:4326\",\n        type: \"Geographical\"\n    }, {\n        label: \"Mercator\",\n        crs: \"EPSG:3857\",\n        type: \"Metric\"\n    }, {\n        label: \"Lambert 93\",\n        crs: \"EPSG:2154\",\n        type: \"Metric\",\n        geoBBox: {\n            left: -9.86,\n            bottom: 41.15,\n            right: 10.38,\n            top: 51.56\n        }\n    }, {\n        label: \"Lambert II étendu\",\n        crs: \"EPSG:27572\",\n        type: \"Metric\",\n        geoBBox: {\n            left: -4.87,\n            bottom: 42.33,\n            right: 8.23,\n            top: 51.14\n        }\n    }];\n\n    var systems = this.options.systems;\n    for (var i = 0; i < systems.length; i++) {\n        // definition of a reference system\n        var sys = systems[i];\n        this.addSystem(sys);\n    }\n\n    if (this._projectionSystems.length === 0) {\n        // we add the default projection systems\n        for (var ii = 0; ii < projectionSystemsByDefault.length; ii++) {\n            this.addSystem(projectionSystemsByDefault[ii]);\n        }\n    }\n};\n\n/**\n * this method is called by the constructor and initialize the units.\n * getting coordinates in the requested units :\n * see this.onMousePositionProjectionUnitsChange()\n *\n * @method _initProjectionUnits\n * @private\n */\nMousePosition.prototype._initProjectionUnits = function () {\n    // user has the possibility to modify the list of units to display\n    // Ex.\n    // this.options.units : [\"DEC\", \"DMS\"]\n\n    // available units systems by default\n    var projectionUnitsByDefault = {\n        Geographical: [{\n            code: \"DEC\",\n            label: \"degrés décimaux\",\n            convert: this._displayDEC\n        }, {\n            code: \"DMS\",\n            label: \"degrés sexagésimaux\",\n            convert: this._displayDMS\n        }, {\n            code: \"RAD\",\n            label: \"radians\",\n            convert: this._displayRAD\n        }, {\n            code: \"GON\",\n            label: \"grades\",\n            convert: this._displayGON\n        }],\n        Metric: [{\n            code: \"M\",\n            label: \"mètres\",\n            convert: this._displayMeter\n        }, {\n            code: \"KM\",\n            label: \"kilomètres\",\n            convert: this._displayKMeter\n        }]\n    };\n\n    var units = this.options.units;\n\n    for (var type in projectionUnitsByDefault) {\n        if (projectionUnitsByDefault.hasOwnProperty(type)) {\n            var found = false;\n            for (var j = 0; j < projectionUnitsByDefault[type].length; j++) {\n                var obj = projectionUnitsByDefault[type][j];\n                for (var i = 0; i < units.length; i++) {\n                    var unit = units[i];\n                    if (obj.code === unit) {\n                        found = true;\n                        if (!this._projectionUnits[type]) {\n                            this._projectionUnits[type] = [];\n                        }\n                        this._projectionUnits[type].push(obj);\n                    }\n                }\n            }\n            if (!found) {\n                this._projectionUnits[type] = projectionUnitsByDefault[type];\n            }\n        }\n    }\n\n    // in case of...\n    if (_typeof(this._projectionUnits) === \"object\" && Object.keys(this._projectionUnits).length === 0) {\n        this._projectionUnits = projectionUnitsByDefault;\n    }\n};\n\n/**\n * this method is called by constructor\n * and check the rights to resources\n *\n * @method _checkRightsManagement\n * @private\n */\nMousePosition.prototype._checkRightsManagement = function () {\n    var rightManagement = _CheckRightManagement2.default.check({\n        key: this.options.apiKey,\n        resources: [\"SERVICE_CALCUL_ALTIMETRIQUE_RSC\"],\n        services: [\"Elevation\"]\n    });\n\n    this._noRightManagement = !rightManagement;\n\n    // retrieves the usefull infos\n    // on this control, we do not care about the ressource bescause it is unique\n    // Ex : the API key from the autoconfiguration if it has not been given\n    if (!this.options.apiKey) {\n        this.options.apiKey = rightManagement.key;\n    }\n};\n\n// ################################################################### //\n// ######################## methods handle dom ####################### //\n// ################################################################### //\n\n/**\n * Create control main container (called by MousePosition constructor)\n *\n * @method _initContainer\n * @param {Object} options - options\n * @param {Boolean} options.collapsed - Specify if MousePosition control should be collapsed\n * @param {Array}   options.displayAltitude - activate (true) or deactivate (false) the altitude panel\n * @param {Array}   options.displayCoordinates - activate (true) or deactivate (false) the coordinates panel\n * @returns {DOMElement} container - widget container\n * @private\n */\nMousePosition.prototype._initContainer = function (options) {\n    // creates the main container\n    var container = this._createMainContainerElement();\n\n    var inputShow = this._showMousePositionContainer = this._createShowMousePositionElement();\n    if (!options.collapsed) {\n        inputShow.checked = \"checked\";\n    }\n    container.appendChild(inputShow);\n\n    var picto = this._createShowMousePositionPictoElement(this._isDesktop);\n    container.appendChild(picto);\n\n    var panel = this._createMousePositionPanelElement(options.displayAltitude, options.displayCoordinates);\n    var settings = this._createMousePositionSettingsElement(options.displayCoordinates);\n    var systems = this._projectionSystemsContainer = this._createMousePositionSettingsSystemsElement(this._projectionSystems);\n    var units = this._projectionUnitsContainer = this._createMousePositionSettingsUnitsElement(this._projectionUnits[this._currentProjectionType]);\n\n    settings.appendChild(systems);\n    settings.appendChild(units);\n    panel.appendChild(settings);\n    container.appendChild(panel);\n\n    return container;\n};\n\n/**\n * this method is called by this.()\n * and it changes the elevation view panel into the dom.\n *\n * @method _setElevationPanel\n * @param {Boolean} active - true:active, false:disable\n * @private\n */\nMousePosition.prototype._setElevationPanel = function (active) {\n    var div = null;\n\n    if (!active) {\n        div = document.getElementById(\"GPmousePositionAltitude-\" + this._uid);\n        div.style.display = \"none\";\n    } else {\n        if (this._noRightManagement) {\n            div = document.getElementById(\"GPmousePositionAlt-\" + this._uid);\n            div.innerHTML = \"No rights!\";\n        } else {\n            div = document.getElementById(\"GPmousePositionAltitude-\" + this._uid);\n            div.style.display = \"\";\n        }\n    }\n};\n\n/**\n * this method is called by this.()\n * and it changes the coordinate view panel into the dom.\n *\n * @method _setCoordinatesPanel\n * @param {Boolean} active - true:active, false:disable\n * @private\n */\nMousePosition.prototype._setCoordinatesPanel = function (active) {\n    var div = document.getElementById(\"GPmousePositionCoordinate-\" + this._uid);\n    if (!active) {\n        div.style.display = \"none\";\n    } else {\n        div.style.display = \"\";\n    }\n};\n\n/**\n * this method is called by this.()\n * and it changes the settings view panel into the dom.\n *\n * @method _setSettingsPanel\n * @param {Boolean} active - true:active, false:disable\n * @private\n */\nMousePosition.prototype._setSettingsPanel = function (active) {\n    var divPicto = document.getElementById(\"GPshowMousePositionSettingsPicto-\" + this._uid);\n    var divPanel = document.getElementById(\"GPmousePositionSettings-\" + this._uid);\n    if (!active) {\n        divPicto.style.display = \"none\";\n        divPanel.style.display = \"none\";\n    } else {\n        divPicto.style.display = \"\";\n        divPanel.style.display = \"\";\n    }\n};\n\n/**\n * this method is called by this.onMousePositionProjectionSystemChange()\n * when changes to a metric or a geographical units.\n *\n * @method _setTypeUnitsPanel\n * @param {String} type - Geographical or Metric\n * @private\n */\nMousePosition.prototype._setTypeUnitsPanel = function (type) {\n    var container = this._projectionUnitsContainer;\n\n    // deletes the childNodes\n    while (container.firstChild) {\n        container.removeChild(container.firstChild);\n    }\n\n    var units = this._projectionUnits[type];\n    for (var j = 0; j < units.length; j++) {\n        var obj = units[j];\n        var option = document.createElement(\"option\");\n        option.value = obj.code ? obj.code : j;\n        option.text = obj.label || j;\n        // option.label = obj.label;\n        container.appendChild(option);\n    }\n\n    // the new type of system\n    this._currentProjectionType = type;\n    // as the system changed, the unit system has to change too !\n    this._currentProjectionUnits = this._projectionUnits[type][0].code;\n};\n\n// ################################################################### //\n// ######################## method units convert ##################### //\n// ################################################################### //\n\n/**\n * degreedecimal\n *\n * @method _displayDEC\n * @param {Object} coords - coordinatesobject {lon, lat}\n * @return {Object} coordinate - coordinate object : {lat : 48, lng : 2} par exemple\n * @private\n */\nMousePosition.prototype._displayDEC = function (coords) {\n    var coordinate = {};\n    coordinate.lat = _PositionFormater2.default.roundToDecimal(coords.lat, 6);\n    coordinate.lng = _PositionFormater2.default.roundToDecimal(coords.lon, 6);\n    return coordinate;\n};\n\n/**\n * degreedecimal2sexagecimal\n *\n * @method _displayDMS\n * @param {Object} coords - coordinates object {lon, lat}\n * @return {Object} coordinate - coordinate object : {lng : \"2° 00′ 00″ E\", lat : \"48° 00′ 00″ N\"} par exemple\n * @private\n */\nMousePosition.prototype._displayDMS = function (coords) {\n    var coordinate = {};\n    coordinate.lat = _PositionFormater2.default.decimalLatToDMS(coords.lat);\n    coordinate.lng = _PositionFormater2.default.decimalLongToDMS(coords.lon);\n    return coordinate;\n};\n\n/**\n * degreedecimal2radian\n *\n * @method _displayRAD\n * @param {Object} coords - coordinates object {lon, lat}\n * @return {Object} coordinate - coordinate object : {lat : \"0.02837864\", lng : \"0.84300269\"} par exemple\n * @private\n */\nMousePosition.prototype._displayRAD = function (coords) {\n    var coordinate = {};\n    coordinate.lat = _PositionFormater2.default.decimalToRadian(coords.lat);\n    coordinate.lng = _PositionFormater2.default.decimalToRadian(coords.lon);\n    return coordinate;\n};\n\n/**\n * degreedecimal2grade\n *\n * @method _displayGON\n * @param {Object} coords - coordinates object {lon, lat}\n * @return {Object} coordinate - coordinate object : {lat : \"4.09545898\", lng : \"53.68751528\"} par exemple\n * @private\n */\nMousePosition.prototype._displayGON = function (coords) {\n    var coordinate = {};\n    coordinate.lat = _PositionFormater2.default.decimalToGrade(coords.lat);\n    coordinate.lng = _PositionFormater2.default.decimalToGrade(coords.lon);\n    return coordinate;\n};\n\n/**\n * meter\n *\n * @method _displayMeter\n * @param {Object} coords - coords object {lon, lat}\n * @return {Object} coordinate - coordinate object : {x : \"148593.58\", y : \"6176560.95\"} par exemple\n * @private\n */\nMousePosition.prototype._displayMeter = function (coords) {\n    // on recoit toujours des coordonnées metriques\n    var coordinate = {};\n    coordinate.x = coords.lon.toFixed(2);\n    coordinate.y = coords.lat.toFixed(2);\n    coordinate.unit = \"m\";\n    return coordinate;\n};\n\n/**\n * kilometer\n *\n * @method _displayKMeter\n * @param {Object} coords - coords object {lon, lat}\n * @return {Object} coordinate - coordinate object : {x : \"214.96\", y : \"6250.09\"} par exemple\n * @private\n */\nMousePosition.prototype._displayKMeter = function (coords) {\n    var coordinate = {};\n    coordinate.x = (coords.lon / 1000).toFixed(2);\n    coordinate.y = (coords.lat / 1000).toFixed(2);\n    coordinate.unit = \"km\";\n    return coordinate;\n};\n\n// ################################################################### //\n// ##################### handlers events to control ################## //\n// ################################################################### //\n\n/**\n * this sends the coordinates to the panel.\n * (cf. this.GPdisplayCoords() into the DOM functions)\n *\n * @method _setCoordinate\n * @param {Array} coords - coordinate object {lon, lat}\n * @private\n */\nMousePosition.prototype._setCoordinate = function (coords) {\n    // structure\n    // coords\n    //      {\n    //          lon: 5,\n    //          lat : 48\n    //      }\n    //\n    // structure for the coordinates depending on the system type :\n    // {x:, y:, unit:} or {lng:, lat:} or {lon:, lat:} or {e:, n:, unit:}...\n\n    var coord = [];\n    var coordinates = {};\n\n    // transforms the point in the wanted coords system\n    var oSrs = this._currentProjectionSystems;\n    var crsProp = oSrs.crs;\n\n    if (!oSrs || !crsProp) {\n        logger.error(\"system crs not found\");\n        return;\n    }\n    // reproject coordinates from their CRS of origin (WGS84) to the wanted CRS (crsProp)\n    if (crsProp !== \"EPSG:4326\") {\n        coord = (0, _proj2.default)(_CRS2.default[crsProp], [coords.lon, coords.lat]);\n        // projected values are affected to the coord var\n        coordinates.lon = coord[0];\n        coordinates.lat = coord[1];\n    } else {\n        coordinates = coords;\n    }\n\n    // system type : Geographical or Metric\n\n    var type = this._currentProjectionSystems.type;\n\n    // checks for a formatting function in the wanted unit\n    var convert = null;\n    var units = this._projectionUnits[type];\n\n    for (var i = 0; i < units.length; i++) {\n        if (units[i].code === this._currentProjectionUnits) {\n            convert = units[i].convert;\n            break;\n        }\n    }\n    if (!convert || typeof convert !== \"function\") {\n        logger.warn(\"coordinates format function not found\");\n        return;\n    } else {\n        coord = convert(coordinates);\n    }\n\n    if (!coord || Object.keys(coord).length === 0) {\n        return;\n    }\n\n    this.GPdisplayCoords(coord);\n};\n\n/**\n * this sends the coordinates to the panel.\n * (cf. this.GPdisplayElevation() into the DOM functions)\n *\n * @method _setElevation\n * @param {Object} coords - Coordinate position object {lon, lat}\n * @private\n */\nMousePosition.prototype._setElevation = function (coords) {\n    // management of the timer of the altitude service request\n    var delay = this.options.altitude.responseDelay;\n    this.GPdisplayElevation(coords, delay);\n};\n\n/**\n * this method is triggered when the mouse or the globe is stopped.\n * (cf. onMouseMove and onGlobeMove)\n *\n * @method onMoveStopped\n * @param {Object} coords - Coordinate position object {lon, lat}\n * @private\n */\nMousePosition.prototype.onMoveStopped = function (coords) {\n    this._setElevation(coords);\n};\n\n/**\n * this method is an handler event to control. The event is 'mousemove' on\n * the globe. The handler sends the coordinates to the panel.\n * (cf. this.GPdisplayCoords() into the DOM functions)\n *\n * @method onMouseMove\n * @param {Object} e - HTMLElement\n * @private\n */\nMousePosition.prototype.onMouseMove = function (e) {\n    var self = this;\n\n    var position = this.getGlobe().getCoordinateFromMouseEvent(e);\n    if (!position) {\n        this.GPdisplayCoords({\n            lon: \"---\",\n            lat: \"---\"\n        });\n        this.GPresetElevation();\n        return;\n    }\n\n    var coordinate = {\n        lon: position.longitude(),\n        lat: position.latitude()\n    };\n\n    this._setCoordinate(coordinate);\n\n    // calculation of the altitude after a time limit from the moment where the mouse movement is stopped\n    if (this.options.displayAltitude) {\n        clearTimeout(this._timer);\n        this._timer = setTimeout(function () {\n            self.onMoveStopped(coordinate);\n        }, this.options.altitude.triggerDelay);\n    }\n};\n\n/**\n * this method is an handler event to control. The event is 'moveend' on\n * the globe. The handler sends the coordinates to the panel.\n * (cf. this.GPdisplayCoords() into the DOM functions)\n *\n * @method onGlobeMove\n * @private\n */\nMousePosition.prototype.onGlobeMove = function () {\n\n    // var self = this;\n\n    // info: coordinate = [x, y]\n    // var coordinate = e.coordinate;\n    // if ( !e.map || !e.map.getView() ) {\n    //     return;\n    // }\n    // var crs = e.map.getView().getProjection();\n    //\n    // this._setCoordinate(coordinate, crs);\n    //\n    // // calcul de l'altitude après un certain délai après l'arrêt du mouvement de la carte\n    // clearTimeout(this._timer);\n    // this._timer = setTimeout( function () {\n    //     self.onMoveStopped(coordinate, crs);\n    // }, this.options.altitude.triggerDelay);\n};\n\n// ################################################################### //\n// ####################### handlers events to dom #################### //\n// ################################################################### //\n\n/**\n * this method is called by this.GPdisplayElevation() in the dom, and\n * it executes a request to the elevation service.\n *\n * @method onRequestAltitude\n * @param {Object} coordinate - {lat:..., lng:...}\n * @param {Function} callback - function callback\n * @private\n */\nMousePosition.prototype.onRequestAltitude = function (coordinate, callback) {\n    // INFORMATION\n    // we launch the request to the altitude services\n    // we implement callbacks in order to retrieve results or errors\n    // from the service.\n    // The result is displayed in a DOM element.\n    // The error messages are display in the dev console (?)\n\n    if (!coordinate || Object.keys(coordinate).length === 0) {\n        return;\n    }\n\n    // if we do not want any altitude calculation, we just stop !\n    if (!this.options.displayAltitude) {\n        return;\n    }\n\n    // if we don not have the rights on the requested resource, we just stop !\n    if (this._noRightManagement) {\n        logger.warn(\"contract key configuration has no rights to load geoportal elevation \");\n        document.getElementById(this._addUID(\"GPmousePositionAlt\")).innerHTML = \"No rights!\";\n        return;\n    }\n\n    // we retrieve the service options...\n    var options = this.options.altitude.serviceOptions || {};\n\n    // ... and the coordinates...\n    options.zonly = true;\n    options.positions = [{\n        lon: coordinate.lon,\n        lat: coordinate.lat\n    }];\n\n    // ... and the callbacks\n    options.scope = this;\n\n    if (!options.rawResponse) {\n        // in the general case\n        options.onSuccess = function (results) {\n            if (results && Object.keys(results)) {\n                callback.call(this, results.elevations[0].z);\n            }\n        };\n    } else {\n        options.onSuccess = function (results) {\n            logger.info(\"alti service raw response : \", results);\n        };\n    }\n\n    options.onFailure = function (error) {\n        logger.error(\"[getAltitude] \" + error.message);\n    };\n    // in the case of the API key is not given as option of the service,\n    // we use the key of the autoconf, or the key given in the control options\n    options.apiKey = options.apiKey || this.options.apiKey;\n\n    _gp2.default.Services.getAltitude(options);\n};\n\n/**\n * this method is called by event 'click' on 'GPshowMousePositionPicto' tag label\n * (cf. this._createShowMousePositionPictoElement),\n * and toggles event 'mousemove' on globe.\n *\n * @method onShowMousePositionClick\n * @private\n */\nMousePosition.prototype.onShowMousePositionClick = function () {\n    // checked : true - panel close\n    // checked : false - panel open\n    var globe = this.getGlobe();\n\n    this.collapsed = this._showMousePositionContainer.checked;\n\n    // event triggered when opening/closing the panel\n    // and depending on the mode : desktop or tactile!\n    if (this._showMousePositionContainer.checked) {\n        // FIXME handle or not mobile case\n        if (this._isDesktop) {\n            globe.forget(_GlobeViewExtended2.default.EVENTS.MOUSE_MOVE, this._callbacks.mouseMove);\n        } else {\n            globe.forget(_GlobeViewExtended2.default.EVENTS.CENTER_CHANGED, this.onGlobeMove);\n        }\n    } else {\n        // FIXME handle or not mobile case\n        if (this._isDesktop) {\n            globe.listen(_GlobeViewExtended2.default.EVENTS.MOUSE_MOVE, this._callbacks.mouseMove);\n        } else {\n            globe.listen(_GlobeViewExtended2.default.EVENTS.CENTER_CHANGED, this.onGlobeMove);\n        }\n    }\n\n    // FIXME\n    // we handle here the panel display..., but this is not really the good\n    // place to do it...\n    this._setElevationPanel(this.options.displayAltitude);\n    this._setCoordinatesPanel(this.options.displayCoordinates);\n    if (!this.options.displayCoordinates) {\n        this._setSettingsPanel(false);\n    }\n};\n\n/**\n * this method is called by event 'change' on 'GPmousePositionProjectionSystem'\n * tag select (cf. this._createMousePositionSettingsElement),\n * and selects the system projection.\n *\n * @method onMousePositionProjectionSystemChange\n * @param {Object} e - HTMLElement\n * @private\n */\nMousePosition.prototype.onMousePositionProjectionSystemChange = function (e) {\n    var idx = e.target.selectedIndex; // index\n    var value = e.target.options[idx].value; // crs\n\n    this._setCurrentSystem(value);\n};\n\n/**\n * this method selects the current system projection.\n *\n * @method _setCurrentSystem\n * @param {Object} systemCode - inner code (rank in array _projectionSystems)\n * @private\n */\nMousePosition.prototype._setCurrentSystem = function (systemCode) {\n    // if we change of system type, we must change the unit type too !\n    var type = null;\n    for (var i = 0; i < this._projectionSystems.length; ++i) {\n        if (this._projectionSystems[i].code === systemCode) {\n            type = this._projectionSystems[i].type;\n            break;\n        }\n    }\n\n    if (!type) {\n        logger.log(\"system not found in projection systems container\");\n        return;\n    }\n\n    if (type !== this._currentProjectionType) {\n        this._setTypeUnitsPanel(type);\n    }\n\n    // registers the current system\n    this._currentProjectionSystems = this._projectionSystems[Number(systemCode)];\n\n    // simulates a movement in tactile mode to update the results\n    if (!this._isDesktop) {\n        this.onGlobeMove();\n    }\n};\n\n/**\n * this method is called by event 'mouseover' on 'GPmousePositionProjectionSystem'\n * tag select (cf. this._createMousePositionSettingsElement),\n * and selects the system projection whose geoBBox interstects the current view extent.\n *\n * @method onMousePositionProjectionSystemMouseOver\n * @private\n */\nMousePosition.prototype.onMousePositionProjectionSystemMouseOver = function () {\n    // globe infos\n    var globe = this.getGlobe();\n    if (!globe) {\n        return;\n    }\n\n    var globeExtent = globe.getExtent();\n\n    // clear select\n    var systemList = document.getElementById(this._addUID(\"GPmousePositionProjectionSystem\"));\n    systemList.innerHTML = \"\";\n\n    var option;\n\n    // add systems whose extent intersects the globe extent\n    for (var j = 0; j < this._projectionSystems.length; j++) {\n        var proj = this._projectionSystems[j];\n        if (proj.geoBBox) {\n            // bboxes intersection test\n            if (globeExtent.west() > proj.geoBBox.right || globeExtent.south() > proj.geoBBox.top || globeExtent.east() < proj.geoBBox.left || globeExtent.north() < proj.geoBBox.bottom) {\n                if (proj === this._currentProjectionSystems) {\n                    option = document.createElement(\"option\");\n                    option.value = proj.code;\n                    option.text = proj.label || j;\n                    option.setAttribute(\"selected\", \"selected\");\n                    option.setAttribute(\"disabled\", \"disabled\");\n\n                    systemList.appendChild(option);\n                }\n                continue; // do not intersect\n            }\n        }\n        option = document.createElement(\"option\");\n        option.value = proj.code;\n        option.text = proj.label || j;\n        if (proj === this._currentProjectionSystems) {\n            option.setAttribute(\"selected\", \"selected\");\n        }\n\n        systemList.appendChild(option);\n    }\n};\n\n/**\n * this method is called by event 'change' on 'GPmousePositionProjectionUnits'\n * tag select (cf. this._createMousePositionSettingsElement),\n * and selects the units projection.\n *\n * @method onMousePositionProjectionUnitsChange\n * @param {Object} e - HTMLElement\n * @private\n */\nMousePosition.prototype.onMousePositionProjectionUnitsChange = function (e) {\n    var idx = e.target.selectedIndex;\n    var value = e.target.options[idx].value;\n\n    this._currentProjectionUnits = value;\n\n    // simulates a movement in tactile mode to update the results\n    if (!this._isDesktop) {\n        this.onGlobeMove();\n    }\n};\n\nexports.default = MousePosition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL01vdXNlUG9zaXRpb24uanM/OWRmNCJdLCJuYW1lcyI6WyJsb2dnZXIiLCJMb2dnZXIiLCJnZXRMb2dnZXIiLCJNb3VzZVBvc2l0aW9uIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIkVycm9yIiwiX2luaXRpYWxpemUiLCJfY2FsbGJhY2tzIiwiY29udGFpbmVyIiwiX2luaXRDb250YWluZXIiLCJ0YXJnZXREaXYiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwidGFyZ2V0IiwiV2lkZ2V0IiwiY2FsbCIsIm5hbWUiLCJlbGVtZW50IiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiVXRpbHMiLCJhc3NpZ24iLCJNb3VzZVBvc2l0aW9uRE9NIiwiY29uc3RydWN0b3IiLCJzZXRHbG9iZSIsImdsb2JlIiwiX2NlbnRlckVsZW1lbnQiLCJfY3JlYXRlTWFwQ2VudGVyIiwiZ2V0VGFyZ2V0RWxlbWVudCIsImFwcGVuZENoaWxkIiwibW91c2VNb3ZlIiwib25Nb3VzZU1vdmUiLCJiaW5kIiwiY29sbGFwc2VkIiwiX2lzRGVza3RvcCIsImxpc3RlbiIsIkdsb2JlVmlld0V4dGVuZGVkIiwiRVZFTlRTIiwiTU9VU0VfTU9WRSIsIkNFTlRFUl9DSEFOR0VEIiwib25HbG9iZU1vdmUiLCJfZ2xvYmUiLCJmb3JnZXQiLCJnZXRFbGVtZW50IiwiaGFzQ2hpbGROb2RlcyIsInJlbW92ZUNoaWxkIiwibGFzdENoaWxkIiwicGFyZW50Tm9kZSIsImFkZFN5c3RlbSIsInN5c3RlbSIsImVycm9yIiwiY3JzIiwibGFiZWwiLCJ3YXJuIiwidHlwZSIsImoiLCJfcHJvamVjdGlvblN5c3RlbXMiLCJsZW5ndGgiLCJvYmoiLCJjb2RlIiwicHVzaCIsInNlbGVjdFN5c3RlbSIsIl9hZGRVSUQiLCJvcHRpb24iLCJjcmVhdGVFbGVtZW50IiwidmFsdWUiLCJ0ZXh0IiwiYWRkU3lzdGVtcyIsInN5c3RlbXMiLCJBcnJheSIsImlzQXJyYXkiLCJpIiwicmVtb3ZlU3lzdGVtIiwic3lzdGVtQ3JzIiwic3lzdGVtQ29kZSIsInByb2oiLCJzcGxpY2UiLCJvbGROZXdDb2RlR2xvYmUiLCJpaSIsIk51bWJlciIsImluZGV4Q2hpbGRUb1JlbW92ZSIsInN5c3RlbUxpc3QiLCJjaGlsZE5vZGVzIiwiX2N1cnJlbnRQcm9qZWN0aW9uU3lzdGVtcyIsInNldEF0dHJpYnV0ZSIsIl9zZXRDdXJyZW50U3lzdGVtIiwic2V0VW5pdHMiLCJ1bml0cyIsIl9wcm9qZWN0aW9uVW5pdHMiLCJfaW5pdFByb2plY3Rpb25Vbml0cyIsIl9jdXJyZW50UHJvamVjdGlvblR5cGUiLCJfc2V0VHlwZVVuaXRzUGFuZWwiLCJzZXRBbHRpdHVkZU9wdGlvbnMiLCJhbHRpdHVkZSIsInRyaWdnZXJEZWxheSIsInJlc3BvbnNlRGVsYXkiLCJzZXJ2aWNlT3B0aW9ucyIsIm9wdCIsImhhc093blByb3BlcnR5IiwiZGlzcGxheUFsdGl0dWRlIiwidW5kZWZpbmVkIiwiX25vUmlnaHRNYW5hZ2VtZW50IiwiX2NoZWNrUmlnaHRzTWFuYWdlbWVudCIsIl9zZXRFbGV2YXRpb25QYW5lbCIsImRpc3BsYXlDb29yZGluYXRlcyIsIl9zZXRDb29yZGluYXRlc1BhbmVsIiwiX3NldFNldHRpbmdzUGFuZWwiLCJzZXRDb2xsYXBzZWQiLCJjbGFzc05hbWUiLCJvblNob3dNb3VzZVBvc2l0aW9uQ2xpY2siLCJfc2hvd01vdXNlUG9zaXRpb25Db250YWluZXIiLCJjaGVja2VkIiwibm9EYXRhVmFsdWUiLCJub0RhdGFWYWx1ZVRvbGVyYW5jZSIsIl91aWQiLCJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJfaW5pdFByb2plY3Rpb25TeXN0ZW1zIiwiZGV0ZWN0U3VwcG9ydCIsIl90aW1lciIsIl9jdXJyZW50UHJvamVjdGlvblVuaXRzIiwiX3Byb2plY3Rpb25Vbml0c0NvbnRhaW5lciIsInByb2plY3Rpb25TeXN0ZW1zQnlEZWZhdWx0IiwiZ2VvQkJveCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInRvcCIsInN5cyIsInByb2plY3Rpb25Vbml0c0J5RGVmYXVsdCIsIkdlb2dyYXBoaWNhbCIsImNvbnZlcnQiLCJfZGlzcGxheURFQyIsIl9kaXNwbGF5RE1TIiwiX2Rpc3BsYXlSQUQiLCJfZGlzcGxheUdPTiIsIk1ldHJpYyIsIl9kaXNwbGF5TWV0ZXIiLCJfZGlzcGxheUtNZXRlciIsImZvdW5kIiwidW5pdCIsImtleXMiLCJyaWdodE1hbmFnZW1lbnQiLCJSaWdodE1hbmFnZW1lbnQiLCJjaGVjayIsImtleSIsImFwaUtleSIsInJlc291cmNlcyIsInNlcnZpY2VzIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IiwiaW5wdXRTaG93IiwiX2NyZWF0ZVNob3dNb3VzZVBvc2l0aW9uRWxlbWVudCIsInBpY3RvIiwiX2NyZWF0ZVNob3dNb3VzZVBvc2l0aW9uUGljdG9FbGVtZW50IiwicGFuZWwiLCJfY3JlYXRlTW91c2VQb3NpdGlvblBhbmVsRWxlbWVudCIsInNldHRpbmdzIiwiX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQiLCJfcHJvamVjdGlvblN5c3RlbXNDb250YWluZXIiLCJfY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzU3lzdGVtc0VsZW1lbnQiLCJfY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzVW5pdHNFbGVtZW50IiwiYWN0aXZlIiwiZGl2Iiwic3R5bGUiLCJkaXNwbGF5IiwiaW5uZXJIVE1MIiwiZGl2UGljdG8iLCJkaXZQYW5lbCIsImZpcnN0Q2hpbGQiLCJjb29yZHMiLCJjb29yZGluYXRlIiwibGF0IiwiUG9zaXRpb25Gb3JtYXRlciIsInJvdW5kVG9EZWNpbWFsIiwibG5nIiwibG9uIiwiZGVjaW1hbExhdFRvRE1TIiwiZGVjaW1hbExvbmdUb0RNUyIsImRlY2ltYWxUb1JhZGlhbiIsImRlY2ltYWxUb0dyYWRlIiwieCIsInRvRml4ZWQiLCJ5IiwiX3NldENvb3JkaW5hdGUiLCJjb29yZCIsImNvb3JkaW5hdGVzIiwib1NycyIsImNyc1Byb3AiLCJDUlMiLCJHUGRpc3BsYXlDb29yZHMiLCJfc2V0RWxldmF0aW9uIiwiZGVsYXkiLCJHUGRpc3BsYXlFbGV2YXRpb24iLCJvbk1vdmVTdG9wcGVkIiwiZSIsInNlbGYiLCJwb3NpdGlvbiIsImdldEdsb2JlIiwiZ2V0Q29vcmRpbmF0ZUZyb21Nb3VzZUV2ZW50IiwiR1ByZXNldEVsZXZhdGlvbiIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIm9uUmVxdWVzdEFsdGl0dWRlIiwiY2FsbGJhY2siLCJ6b25seSIsInBvc2l0aW9ucyIsInNjb3BlIiwicmF3UmVzcG9uc2UiLCJvblN1Y2Nlc3MiLCJyZXN1bHRzIiwiZWxldmF0aW9ucyIsInoiLCJpbmZvIiwib25GYWlsdXJlIiwibWVzc2FnZSIsIkdwIiwiU2VydmljZXMiLCJnZXRBbHRpdHVkZSIsIm9uTW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1DaGFuZ2UiLCJpZHgiLCJzZWxlY3RlZEluZGV4IiwibG9nIiwib25Nb3VzZVBvc2l0aW9uUHJvamVjdGlvblN5c3RlbU1vdXNlT3ZlciIsImdsb2JlRXh0ZW50IiwiZ2V0RXh0ZW50Iiwid2VzdCIsInNvdXRoIiwiZWFzdCIsIm5vcnRoIiwib25Nb3VzZVBvc2l0aW9uUHJvamVjdGlvblVuaXRzQ2hhbmdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUlBLFNBQVNDLDBCQUFPQyxTQUFQLENBQWlCLGVBQWpCLENBQWI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTREQSxTQUFTQyxhQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUM3QkEsY0FBVUEsV0FBVyxFQUFyQjs7QUFF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LENBVVk7QUFDYjtBQUNKO0FBQ0RBLGlCQUFTckQsU0FBU3NELGFBQVQsQ0FBdUIsUUFBdkIsQ0FBVDtBQUNBRCxlQUFPRSxLQUFQLEdBQWVVLEtBQUtoQixJQUFwQjtBQUNBSSxlQUFPRyxJQUFQLEdBQWNTLEtBQUt2QixLQUFMLElBQWNHLENBQTVCO0FBQ0EsWUFBSW9CLFNBQVMsS0FBS1EseUJBQWxCLEVBQTZDO0FBQ3pDcEIsbUJBQU9xQixZQUFQLENBQW9CLFVBQXBCLEVBQWdDLFVBQWhDO0FBQ0g7O0FBRURILG1CQUFXcEQsV0FBWCxDQUF1QmtDLE1BQXZCO0FBQ0g7QUFDSixDQTlDRDs7QUFnREE7Ozs7Ozs7OztBQVNBOUQsY0FBY2dCLFNBQWQsQ0FBd0JzTixvQ0FBeEIsR0FBK0QsVUFBVXJDLENBQVYsRUFBYTtBQUN4RSxRQUFJMkIsTUFBTTNCLEVBQUV0TCxNQUFGLENBQVNrTixhQUFuQjtBQUNBLFFBQUk3SixRQUFRaUksRUFBRXRMLE1BQUYsQ0FBU1YsT0FBVCxDQUFpQjJOLEdBQWpCLEVBQXNCNUosS0FBbEM7O0FBRUEsU0FBS3VELHVCQUFMLEdBQStCdkQsS0FBL0I7O0FBRUE7QUFDQSxRQUFJLENBQUMsS0FBSy9CLFVBQVYsRUFBc0I7QUFDbEIsYUFBS00sV0FBTDtBQUNIO0FBQ0osQ0FWRDs7a0JBWWV2QyxhIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHByb2o0IGZyb20gXCJwcm9qNFwiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IEdwIGZyb20gXCJncFwiO1xuaW1wb3J0IEdsb2JlVmlld0V4dGVuZGVkIGZyb20gXCIuLi9HbG9iZVZpZXdFeHRlbmRlZFwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHNcIjtcbmltcG9ydCBSaWdodE1hbmFnZW1lbnQgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9DaGVja1JpZ2h0TWFuYWdlbWVudFwiO1xuaW1wb3J0IFNlbGVjdG9ySUQgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9TZWxlY3RvcklEXCI7XG5pbXBvcnQgTW91c2VQb3NpdGlvbkRPTSBmcm9tIFwiLi4vLi4vQ29tbW9uL0NvbnRyb2xzL01vdXNlUG9zaXRpb25ET01cIjtcbmltcG9ydCBXaWRnZXQgZnJvbSBcIi4vV2lkZ2V0XCI7XG5pbXBvcnQgUG9zaXRpb25Gb3JtYXRlciBmcm9tIFwiLi9VdGlscy9Qb3NpdGlvbkZvcm1hdGVyXCI7XG5pbXBvcnQgQ1JTIGZyb20gXCIuLi9DUlMvQ1JTXCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiTW91c2VQb3NpdGlvblwiKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKlxuICogTW91c2VQb3NpdGlvbiBDb250cm9sLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIGl0b3ducy5jb250cm9sLk1vdXNlUG9zaXRpb25cbiAqIEBleHRlbmRzIHtpdG93bnMuY29udHJvbC5Db250cm9sfVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBmdW5jdGlvbiBjYWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb2xsYXBzZWQgPSB0cnVlXSAtIFNwZWNpZnkgaWYgTW91c2VQb3NpdGlvbiBjb250cm9sIHNob3VsZCBiZSBjb2xsYXBzZWQgYXQgc3RhcnR1cC4gRGVmYXVsdCBpcyB0cnVlLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5zeXN0ZW1zXSAtIGxpc3Qgb2YgcHJvamVjdGlvbiBzeXN0ZW1zLCBkZWZhdWx0IGFyZSBHZW9ncmFwaGljYWwgKFwiRVBTRzo0MzI2XCIpLCBXZWIgTWVyY2F0b3IgKFwiRVBTRzozODU3XCIpLCBMYW1iZXJ0IDkzIChcIkVQU0c6MjE1NFwiKSBhbmQgZXh0ZW5kZWQgTGFtYmVydCAyIChcIkVQU0c6Mjc1NzJcIikuXG4gKiAgICAgIEVhY2ggYXJyYXkgZWxlbWVudCAoPXN5c3RlbSkgaXMgYW4gb2JqZWN0IHdpdGggZm9sbG93aW5nIHByb3BlcnRpZXMgOlxuICogQHBhcmFtIHtTdHJpbmd9ICBvcHRpb25zLnN5c3RlbXMuY3JzIC0gUHJvajQgY3JzIGFsaWFzIChmcm9tIHByb2o0IGRlZnMpLiBlLmcuIDogXCJFUFNHOjQzMjZcIi4gUmVxdWlyZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgW29wdGlvbnMuc3lzdGVtcy5sYWJlbF0gLSBDUlMgbGFiZWwgdG8gYmUgZGlzcGxheWVkIGluIGNvbnRyb2wuIERlZmF1bHQgaXMgY3JzIGNvZGUgKGUuZy4gXCJFUFNHOjQzMjZcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSAgb3B0aW9ucy5zeXN0ZW1zLnR5cGUgLSBDUlMgdW5pdHMgdHlwZSBmb3IgY29vcmRpbmF0ZXMgY29udmVyc2lvbiA6IFwiR2VvZ3JhcGhpY2FsXCIgb3IgXCJNZXRyaWNcIi4gRGVmYXVsdDogXCJNZXRyaWNcIlxuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9ucy5zeXN0ZW1zLmdlb0JCb3hdIC0gQWVyYSBjb3ZlcmVkIGJ5IHRoZSBzeXN0ZW0gKFdHUzg0IGNvb3JkaW5hdGVzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgb3B0aW9ucy5zeXN0ZW1zLmdlb0JCb3gucmlnaHQgLSBSaWdodCBib3VuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgb3B0aW9ucy5zeXN0ZW1zLmdlb0JCb3gubGVmdCAtIExlZnQgYm91bmQuXG4gKiBAcGFyYW0ge051bWJlcn0gIG9wdGlvbnMuc3lzdGVtcy5nZW9CQm94LnRvcCAtIFRvcCBib3VuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSAgb3B0aW9ucy5zeXN0ZW1zLmdlb0JCb3guYm90dG9tIC0gQm90dG9tIGJvdW5kLlxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy51bml0c10gLSBsaXN0IG9mIGNvb3JkaW5hdGVzIHVuaXRzLCB0byBiZSBkaXNwbGF5ZWQgaW4gY29udHJvbCB1bml0cyBsaXN0LlxuICogICAgICBWYWx1ZXMgbWF5IGJlIFwiREVDXCIgKGRlY2ltYWwgZGVncmVlcyksIFwiRE1TXCIgKHNleGFnZWNpbWFsKSwgXCJSQURcIiAocmFkaWFucykgYW5kIFwiR09OXCIgKGdyYWRlcykgZm9yIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyxcbiAqICAgICAgYW5kIFwiTVwiIG9yIFwiS01cIiBmb3IgbWV0cmljIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5fSAgIFtvcHRpb25zLmRpc3BsYXlBbHRpdHVkZSA9IHRydWVdIC0gYWN0aXZhdGUgKHRydWUpIG9yIGRlYWN0aXZhdGUgKGZhbHNlKSB0aGUgYWx0aXR1ZGUgcGFuZWwuIFRydWUgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtBcnJheX0gICBbb3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMgPSB0cnVlXSAtIGFjdGl2YXRlICh0cnVlKSBvciBkZWFjdGl2YXRlIChmYWxzZSkgdGhlIGNvb3JkaW5hdGVzIHBhbmVsLiBUcnVlIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnMuYWx0aXR1ZGVdIC0gZWxldmF0aW9uIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSAgW29wdGlvbnMuYWx0aXR1ZGUuc2VydmljZU9wdGlvbnNdIC0gb3B0aW9ucyBvZiBlbGV2YXRpb24gc2VydmljZVxuICogQHBhcmFtIHtOdW1iZXJ9ICBbb3B0aW9ucy5hbHRpdHVkZS5yZXNwb25zZURlbGF5XSAtIGxhdGVuY3kgZm9yIGFsdGl0dWRlIHJlcXVlc3QsIDUwMCBtcyBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLmFsdGl0dWRlLnRyaWdnZXJEZWxheV0gLSBpbW1vYmlsaXNhdGlvbiB0aW1lIG9mIG1vdmVtZW50IG9uIHRoZSBnbG9iZSB0byB0cmlnZ2VyIHRoZSBlbGV2YXRpb24gY2FsY3VsYXRpb24sIDIwMCBtcyBieSBkZWZhdWx0XG4gKiBAZXhhbXBsZVxuICogIHZhciBtb3VzZVBvc2l0aW9uID0gbmV3IGl0b3ducy5jb250cm9sLk1vdXNlUG9zaXRpb24oe1xuICogICAgICBjb2xsYXBzZWQgOiBmYWxzZSxcbiAqICAgICAgZGlzcGxheUNvb3JkaW5hdGVzIDogdHJ1ZSxcbiAqICAgICAgZGlzcGxheUFsdGl0dWRlIDogdHJ1ZSxcbiAqICAgICAgYWx0aXR1ZGUgOiB7XG4gKiAgICAgICAgICAgdHJpZ2dlckRlbGF5IDogMTAwLFxuICogICAgICAgICAgIHJlc3BvbnNlRGVsYXkgOiA1MDAsXG4gKiAgICAgICAgICAgc2VydmljZU9wdGlvbnMgOiB7fVxuICogICAgICB9LFxuICogICAgICBzeXN0ZW1zIDogW1xuICogICAgICAge1xuICogICAgICAgICAgY3JzIDogXCJFUFNHOjM4NTdcIixcbiAqICAgICAgICAgIGxhYmVsIDogXCJNZXJjYXRvclwiLFxuICogICAgICAgICAgdHlwZSA6IFwiTWV0cmljXCJcbiAqICAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICAgY3JzIDogXCJFUFNHOjMyNjIwXCIsXG4gKiAgICAgICAgICBsYWJlbCA6IFwiVVRNIDIwTiAoR3VhZGVsb3VwZSwgTWFydGluaXF1ZSlcIixcbiAqICAgICAgICAgIHR5cGUgOiBcIk1ldHJpY1wiLFxuICogICAgICAgICAgZ2VvQkJveCA6IHtcbiAqICAgICAgICAgICAgICBsZWZ0OiAtNjYuMDAsXG4gKiAgICAgICAgICAgICAgYm90dG9tIDogMC4wMCxcbiAqICAgICAgICAgICAgICByaWdodCA6IC02MC4wMCxcbiAqICAgICAgICAgICAgICB0b3AgOiA4NC4wMFxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgXSxcbiAqICAgICAgdW5pdHMgOiBbXCJERUNcIiwgXCJETVNcIl1cbiAqICB9KTtcbiAqL1xuZnVuY3Rpb24gTW91c2VQb3NpdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdXNlUG9zaXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFUlJPUiBDTEFTU19DT05TVFJVQ1RPUlwiKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUiBXUk9OR19UWVBFIDogb3B0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblxuICAgIC8vIGluaXQgY29udHJvbCBET00gY29udGFpbmVyXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2luaXRDb250YWluZXIob3B0aW9ucyk7XG4gICAgdmFyIHRhcmdldERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMudGFyZ2V0KSB8fCBudWxsO1xuICAgIFdpZGdldC5jYWxsKFxuICAgICAgICB0aGlzLCB7XG4gICAgICAgICAgICBuYW1lIDogXCJNb3VzZVBvc2l0aW9uXCIsXG4gICAgICAgICAgICBlbGVtZW50IDogY29udGFpbmVyLFxuICAgICAgICAgICAgdGFyZ2V0IDogdGFyZ2V0RGl2XG4gICAgICAgIH1cbiAgICApO1xufTtcblxuLyoqXG4gKiBAbGVuZHMgbW9kdWxlOk1vdXNlUG9zaXRpb25cbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdpZGdldC5wcm90b3R5cGUsIHt9KTtcblxuVXRpbHMuYXNzaWduKE1vdXNlUG9zaXRpb24ucHJvdG90eXBlLCBNb3VzZVBvc2l0aW9uRE9NKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciAoYWxpYXMpXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VQb3NpdGlvbjtcblxuLyoqXG4gKiBCaW5kIGdsb2JlIHRvIGNvbnRyb2xcbiAqXG4gKiBAcGFyYW0ge0dsb2JlVmlld0V4dGVuZGVkfSBnbG9iZSAtIHRoZSBnbG9iZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5zZXRHbG9iZSA9IGZ1bmN0aW9uIChnbG9iZSkge1xuICAgIGlmIChnbG9iZSkgeyAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgYWRkaW5nIG9mIGEgY29udHJvbCB0byB0aGUgZ2xvYmVcbiAgICAgICAgdGhpcy5fY2VudGVyRWxlbWVudCA9IHRoaXMuX2NyZWF0ZU1hcENlbnRlcigpO1xuICAgICAgICBnbG9iZS5nZXRUYXJnZXRFbGVtZW50KCkuYXBwZW5kQ2hpbGQodGhpcy5fY2VudGVyRWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGVmaW5lcyB0aGUgY2FsbGJhY2sgb24gdGhlIG1hcCB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcblxuICAgICAgICAvLyB2YWxpZCBldmVudCBmb3IgZGVza3RvcCBtb2RlXG4gICAgICAgIGlmICghdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Rlc2t0b3ApIHtcbiAgICAgICAgICAgICAgICBnbG9iZS5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLk1PVVNFX01PVkUsIHRoaXMuX2NhbGxiYWNrcy5tb3VzZU1vdmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbG9iZS5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkNFTlRFUl9DSEFOR0VELCB0aGlzLm9uR2xvYmVNb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2xvYmUgPT0gbnVsbCkgeyAvLyBpZiBnbG9iZSA9PSBudWxsIHdlIHJlbW92ZSB0aGUgTVAgY29udHJvbFxuICAgICAgICAvLyBkZWxldGVzIHRoZSBsaXN0ZW5lciBhc3NvY2lhdGVkIHRvIHRoZSBtb3VzZVBvc2l0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy5fZ2xvYmUuZm9yZ2V0KEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5NT1VTRV9NT1ZFLCB0aGlzLl9jYWxsYmFja3MubW91c2VNb3ZlKTtcbiAgICAgICAgLy8gZGVsZXRlcyB0aGUgbW91c2VQb3NpdGlvbiBjb250cm9sIERPTVxuICAgICAgICB3aGlsZSAodGhpcy5nZXRFbGVtZW50KCkuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5yZW1vdmVDaGlsZCh0aGlzLmdldEVsZW1lbnQoKS5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCgpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5nZXRFbGVtZW50KCkpO1xuICAgICAgICB0aGlzLl9nbG9iZS5nZXRUYXJnZXRFbGVtZW50KCkucmVtb3ZlQ2hpbGQodGhpcy5fY2VudGVyRWxlbWVudCk7XG4gICAgfVxuICAgIC8vIGNhbGwgb3JpZ2luYWwgc2V0R2xvYmUgbWV0aG9kXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5zZXRHbG9iZS5jYWxsKHRoaXMsIGdsb2JlKTtcbn07XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIHVzZXIgaW50ZXJmYWNlIG1ldGhvZHMgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBTZXRzIGFkZGl0aW9uYWwgcHJvamVjdGlvbiBzeXN0ZW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3lzdGVtIC0gUHJvamVjdGlvbiBzeXN0ZW0gZGVmaW5lZCBpbiB0aGUgSXRvd25zL0NSUy9DUlMuanMgY2xhc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXN0ZW0uY3JzIC0gUHJvajQgY3JzIGFsaWFzIChmcm9tIHByb2o0IGRlZnMpIGUuZy4gXCJFUFNHOjQzMjZcIlxuICogQHBhcmFtIHtTdHJpbmd9IFtzeXN0ZW0ubGFiZWxdIC0gQ1JTIGxhYmVsIHRvIGJlIGRpc3BsYXllZCBpbiBjb250cm9sLiBEZWZhdWx0IGlzIHN5c3RlbS5jcnMgYWxpYXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3lzdGVtLnR5cGVdIC0gQ1JTIHVuaXRzIHR5cGUgZm9yIGNvb3JkaW5hdGVzIGNvbnZlcnNpb24gKG9uZSBvZiBjb250cm9sIG9wdGlvbnMudW5pdHMpLiBEZWZhdWx0IGlzIFwiTWV0cmljXCJcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuYWRkU3lzdGVtID0gZnVuY3Rpb24gKHN5c3RlbSkge1xuICAgIGlmICh0eXBlb2Ygc3lzdGVtICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk1vdXNlUG9zaXRpb246YWRkU3lzdGVtIC0gc3lzdGVtIHBhcmFtZXRlciBzaG91bGQgYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3lzdGVtLmNycykge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJjcnMgbm90IGRlZmluZWQgIVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXN5c3RlbS5sYWJlbCkge1xuICAgICAgICBsb2dnZXIud2FybihcImNycyBsYWJlbCBub3QgZGVmaW5lZCwgdXNlIGNycyBjb2RlIGJ5IGRlZmF1bHQuXCIpO1xuICAgICAgICBzeXN0ZW0ubGFiZWwgPSBzeXN0ZW0uY3JzO1xuICAgIH1cbiAgICBpZiAoIXN5c3RlbS50eXBlKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwidHlwZSBzcnMgbm90IGRlZmluZWQsIHVzZSAnTWV0cmljJyBieSBkZWZhdWx0LlwiKTtcbiAgICAgICAgc3lzdGVtLnR5cGUgPSBcIk1ldHJpY1wiO1xuICAgIH1cblxuICAgIC8vIDEuIGFkZHMgc3lzdGVtIHRvIGNvbnRyb2wgc3lzdGVtc1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fcHJvamVjdGlvblN5c3RlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zW2pdO1xuICAgICAgICBpZiAoc3lzdGVtLmNycyA9PT0gb2JqLmNycykge1xuICAgICAgICAgICAgLy8gd2FybiB1c2VyXG4gICAgICAgICAgICBsb2dnZXIud2FybihcImNycyAne30nIGFscmVhZHkgY29uZmlndXJlZFwiLCBvYmouY3JzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN5c3RlbS5jb2RlID0gdGhpcy5fcHJvamVjdGlvblN5c3RlbXMubGVuZ3RoO1xuICAgIHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zLnB1c2goc3lzdGVtKTtcblxuICAgIC8vIDIuIGFkZHMgc3lzdGVtIHNldHRpbmdzIG9wdGlvbiB0byBjb250YWluZXIgKGlmIGl0IHdhcyBhbHJlYWR5IGJ1aWxkKVxuICAgIHZhciBzZWxlY3RTeXN0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uU3lzdGVtXCIpKTtcbiAgICBpZiAoc2VsZWN0U3lzdGVtKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBzeXN0ZW0uY29kZTtcbiAgICAgICAgb3B0aW9uLnRleHQgPSBzeXN0ZW0ubGFiZWw7XG4gICAgICAgIHNlbGVjdFN5c3RlbS5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0cyBhZGRpdGlvbmFsIHByb2plY3Rpb24gc3lzdGVtc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHN5c3RlbXMgLSBBcnJheSBvZiBzeXN0ZW0gb2JqZWN0LCB3aXRoIGZvbGxvd2luZyBwcm9wZXJ0aWVzIDpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXN0ZW1zLmNycyAtIFByb2o0IENSUyBhbGlhcyAoZnJvbSBwcm9qNCBkZWZzKSBlLmcuIFwiRVBTRzo0MzI2XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXN0ZW1zLmxhYmVsIC0gQ1JTIGxhYmVsIChmb3IgY29vcmRpbmF0ZXMgY29udmVyc2lvbilcbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXN0ZW1zLnR5cGUgLSBDUlMgdW5pdHMgdHlwZSB0byBiZSBkaXNwbGF5ZWQgaW4gY29udHJvbCAob25lIG9mIGNvbnRyb2wgb3B0aW9ucy51bml0cykuIERlZmF1bHQgaXMgXCJNZXRyaWNcIlxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5hZGRTeXN0ZW1zID0gZnVuY3Rpb24gKHN5c3RlbXMpIHtcbiAgICBpZiAoIXN5c3RlbXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3lzdGVtcykpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTW91c2VQb3NpdGlvbjphZGRTeXN0ZW1zIC0gc3lzdGVtcyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3lzdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZFN5c3RlbShzeXN0ZW1zW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgcHJvamVjdGlvbiBzeXN0ZW0gKGluIGNhc2UgdGhlcmUgYXJlIHNldmVyYWwgc3lzdGVtIHdpdGggc2FtZSBjb2RlLCBvbmx5IHRoZSBmaXJzdCBvbmUgd2lsbCBiZSByZW1vdmVkKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXN0ZW1DcnMgLSBDUlMgYWxpYXMgKGZyb20gcHJvajQgZGVmcylcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUucmVtb3ZlU3lzdGVtID0gZnVuY3Rpb24gKHN5c3RlbUNycykge1xuICAgIGlmICghc3lzdGVtQ3JzIHx8IHR5cGVvZiBzeXN0ZW1DcnMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTW91c2VQb3NpdGlvbjpyZW1vdmVTeXN0ZW0gLSBzeXN0ZW1Db2RlIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3lzdGVtQ29kZSA9IG51bGw7XG4gICAgLy8gZmluZHMgc3lzdGVtIGluIGNvbnRyb2wgcHJvamVjdGlvbiBzeXN0ZW1zIGxpc3RcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9qID0gdGhpcy5fcHJvamVjdGlvblN5c3RlbXNbaV07XG4gICAgICAgIGlmIChzeXN0ZW1DcnMgPT09IHByb2ouY3JzKSB7XG4gICAgICAgICAgICBzeXN0ZW1Db2RlID0gcHJvai5jb2RlO1xuICAgICAgICAgICAgLy8gcmVtb3ZlcyBzeXN0ZW0gZnJvbSBjb250cm9sIHByb2plY3Rpb24gc3lzdGVtcyBsaXN0XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzeXN0ZW1Db2RlID09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJNb3VzZVBvc2l0aW9uOnJlbW92ZVN5c3RlbSAtIHN5c3RlbSBub3QgZm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZS1pbml0aWFsaXphdGlvbiBvZiBjb2Rlc1xuICAgIHZhciBvbGROZXdDb2RlR2xvYmUgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdGhpcy5fcHJvamVjdGlvblN5c3RlbXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIG9sZE5ld0NvZGVHbG9iZVtOdW1iZXIodGhpcy5fcHJvamVjdGlvblN5c3RlbXNbaWldLmNvZGUpXSA9IGlpO1xuICAgICAgICB0aGlzLl9wcm9qZWN0aW9uU3lzdGVtc1tpaV0uY29kZSA9IGlpO1xuICAgIH1cblxuICAgIC8vIGZpbmRzIHN5c3RlbSBpbiBjb250cm9sIGNvbnRhaW5lciBzeXN0ZW1zIGxpc3RcbiAgICB2YXIgaW5kZXhDaGlsZFRvUmVtb3ZlID0gbnVsbDtcbiAgICB2YXIgc3lzdGVtTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1cIikpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3lzdGVtTGlzdC5jaGlsZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChzeXN0ZW1Db2RlID09PSBzeXN0ZW1MaXN0LmNoaWxkTm9kZXNbal0udmFsdWUpIHtcbiAgICAgICAgICAgIGluZGV4Q2hpbGRUb1JlbW92ZSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzeXN0ZW1MaXN0LmNoaWxkTm9kZXNbal0udmFsdWUgPSBvbGROZXdDb2RlR2xvYmVbTnVtYmVyKHN5c3RlbUxpc3QuY2hpbGROb2Rlc1tqXS52YWx1ZSldO1xuICAgIH1cbiAgICAvLyByZW1vdmVzIHN5c3RlbSBmcm9tIGNvbnRyb2wgY29udGFpbmVyIHN5c3RlbXMgbGlzdFxuICAgIGlmIChpbmRleENoaWxkVG9SZW1vdmUgIT0gbnVsbCkge1xuICAgICAgICBzeXN0ZW1MaXN0LnJlbW92ZUNoaWxkKHN5c3RlbUxpc3QuY2hpbGROb2Rlc1tpbmRleENoaWxkVG9SZW1vdmVdKTtcbiAgICB9XG5cbiAgICAvLyBjaG9vc2UgYXJiaXRyYXJpbHkgYSBuZXcgY3VycmVudCBzeXN0ZW0gaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQcm9qZWN0aW9uU3lzdGVtcy5jb2RlID09PSBzeXN0ZW1Db2RlKSB7XG4gICAgICAgIHN5c3RlbUxpc3QuY2hpbGROb2Rlc1swXS5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCBcInNlbGVjdGVkXCIpO1xuICAgICAgICB0aGlzLl9zZXRDdXJyZW50U3lzdGVtKHN5c3RlbUxpc3QuY2hpbGROb2Rlc1swXS52YWx1ZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIGNvbnRyb2wgdW5pdHMgKHRvIGJlIGRpc3BsYXllZClcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB1bml0cyAtIGxpc3Qgb2YgYWxsIGNvb3JkaW5hdGVzIHVuaXRzLCB0byBiZSBkaXNwbGF5ZWQgaW4gY29udHJvbCB1bml0cyBsaXN0LlxuICogICAgICBWYWx1ZXMgbWF5IGJlIFwiREVDXCIgKGRlY2ltYWwgZGVncmVlcyksIFwiRE1TXCIgKHNleGFnZWNpbWFsKSwgXCJSQURcIiAocmFkaWFucykgYW5kIFwiR09OXCIgKGdyYWRlcykgZm9yIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlcyxcbiAqICAgICAgYW5kIFwiTVwiIG9yIFwiS01cIiBmb3IgbWV0cmljIGNvb3JkaW5hdGVzXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLnNldFVuaXRzID0gZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgaWYgKCF1bml0cyB8fCAhQXJyYXkuaXNBcnJheSh1bml0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMudW5pdHMgPSB1bml0cztcbiAgICB0aGlzLl9wcm9qZWN0aW9uVW5pdHMgPSB7fTtcbiAgICB0aGlzLl9pbml0UHJvamVjdGlvblVuaXRzKCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQcm9qZWN0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLl9zZXRUeXBlVW5pdHNQYW5lbCh0aGlzLl9jdXJyZW50UHJvamVjdGlvblR5cGUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0cyBjb250cm9sIGFsdGl0dWRlIG9wdGlvbnMgKHVzZWxlc3MgaWYgZGlzcGxheUFsdGl0dWRlID09IGZhbHNlKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYWx0aXR1ZGUgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9ICBbb3B0aW9ucy5zZXJ2aWNlT3B0aW9uc10gLSBvcHRpb25zIG9mIGVsZXZhdGlvbiBzZXJ2aWNlXG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLnJlc3BvbnNlRGVsYXldIC0gbGF0ZW5jeSBmb3IgZWxldmF0aW9uIHJlcXVlc3QsIDUwMCBtcyBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gIFtvcHRpb25zLnRyaWdnZXJEZWxheV0gLSBpbW1vYmlsaXNhdGlvbiB0aW1lIG9mIG1vdmVtZW50IG9uIHRoZSBnbG9iZSB0byB0cmlnZ2VyIHRoZSBlbGV2YXRpb24gY2FsY3VsYXRpb24sIDIwMCBtcyBieSBkZWZhdWx0XG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLnNldEFsdGl0dWRlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLmFsdGl0dWRlLnRyaWdnZXJEZWxheSA9IG9wdGlvbnMudHJpZ2dlckRlbGF5O1xuICAgIHRoaXMub3B0aW9ucy5hbHRpdHVkZS5yZXNwb25zZURlbGF5ID0gb3B0aW9ucy5yZXNwb25zZURlbGF5O1xuICAgIGlmIChvcHRpb25zLnNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25zLnNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZXJ2aWNlT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsdGl0dWRlLnNlcnZpY2VPcHRpb25zW29wdF0gPSBvcHRpb25zLnNlcnZpY2VPcHRpb25zW29wdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIG9yIGhpZGVzIGVsZXZhdGlvbiBwYW5lbFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzcGxheUFsdGl0dWRlIC0gdHJ1ZSB0byBkaXNwbGF5IGVsZXZhdGlvbiBwYW5lbCwgZmFsc2UgdG8gaGlkZSBpdFxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5kaXNwbGF5QWx0aXR1ZGUgPSBmdW5jdGlvbiAoZGlzcGxheUFsdGl0dWRlKSB7XG4gICAgaWYgKGRpc3BsYXlBbHRpdHVkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9ub1JpZ2h0TWFuYWdlbWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLl9jaGVja1JpZ2h0c01hbmFnZW1lbnQoKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLmRpc3BsYXlBbHRpdHVkZSA9IGRpc3BsYXlBbHRpdHVkZTtcbiAgICB0aGlzLl9zZXRFbGV2YXRpb25QYW5lbChkaXNwbGF5QWx0aXR1ZGUpO1xufTtcblxuLyoqXG4gKiBEaXNwbGF5cyBvciBoaWRlcyBjb29yZGluYXRlcyBwYW5lbFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzcGxheUNvb3JkaW5hdGVzIC0gdHJ1ZSB0byBkaXNwbGF5IGNvb3JkaW5hdGVzIHBhbmVsLCBmYWxzZSB0byBoaWRlIGl0XG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLmRpc3BsYXlDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5Q29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoZGlzcGxheUNvb3JkaW5hdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMuZGlzcGxheUNvb3JkaW5hdGVzID0gZGlzcGxheUNvb3JkaW5hdGVzO1xuICAgIHRoaXMuX3NldENvb3JkaW5hdGVzUGFuZWwoZGlzcGxheUNvb3JkaW5hdGVzKTtcbiAgICB0aGlzLl9zZXRTZXR0aW5nc1BhbmVsKGRpc3BsYXlDb29yZGluYXRlcyk7XG59O1xuXG4vKipcbiAqIENvbGxhcHNlcyBvciBkaXNwbGF5cyBjb250cm9sIG1haW4gY29udGFpbmVyXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsYXBzZWQgLSBUcnVlIHRvIGNvbGxhcHNlIGNvbnRyb2wsIEZhbHNlIHRvIGRpc3BsYXkgaXRcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuc2V0Q29sbGFwc2VkID0gZnVuY3Rpb24gKGNvbGxhcHNlZCkge1xuICAgIGlmIChjb2xsYXBzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJNb3VzZVBvc2l0aW9uOnNldENvbGxhcHNlZCAtIG1pc3NpbmcgY29sbGFwc2VkIHBhcmFtZXRlclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGNvbGxhcHNlZCAmJiB0aGlzLmNvbGxhcHNlZCkgfHwgKCFjb2xsYXBzZWQgJiYgIXRoaXMuY29sbGFwc2VkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNEZXNrdG9wKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbWFwQ2VudGVyXCIpKS5jbGFzc05hbWUgPSBjb2xsYXBzZWQgPyBcIlwiIDogXCJHUG1hcENlbnRlclZpc2libGVcIjtcbiAgICB9XG4gICAgLy8gc2ltdWxhdGVzIHRoZSBvcGVuaW5nIG9mIHRoZSBwYW5lbCBhZnRlciBhIGNsaWNrXG4gICAgdGhpcy5vblNob3dNb3VzZVBvc2l0aW9uQ2xpY2soKTtcbiAgICB0aGlzLl9zaG93TW91c2VQb3NpdGlvbkNvbnRhaW5lci5jaGVja2VkID0gIWNvbGxhcHNlZDtcbn07XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBpbml0aWFsaXplIGNvbnRyb2wgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBJbml0aWFsaXplcyBjb250cm9sIChjYWxsZWQgYnkgTW91c2VQb3NpdGlvbiBjb25zdHJ1Y3RvcilcbiAqXG4gKiBAbWV0aG9kIF9pbml0aWFsaXplXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbnRyb2wgb3B0aW9ucyAoc2V0IGJ5IHVzZXIpXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIC8vIHtPYmplY3R9IGNvbnRyb2wgb3B0aW9ucyAtIHNldCBieSB1c2VyIG9yIGJ5IGRlZmF1bHRcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucy5jb2xsYXBzZWQgPSAob3B0aW9ucy5jb2xsYXBzZWQgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNvbGxhcHNlZCA6IHRydWU7XG4gICAgLyoqIHtCb29sZWFufSBzcGVjaWZ5IGlmIE1vdXNlUG9zaXRpb24gY29udHJvbCBpcyBjb2xsYXBzZWQgKHRydWUpIG9yIG5vdCAoZmFsc2UpICovXG4gICAgdGhpcy5jb2xsYXBzZWQgPSB0aGlzLm9wdGlvbnMuY29sbGFwc2VkO1xuICAgIHRoaXMub3B0aW9ucy51bml0cyA9IG9wdGlvbnMudW5pdHMgfHwgW107XG4gICAgdGhpcy5vcHRpb25zLmRpc3BsYXlBbHRpdHVkZSA9IChvcHRpb25zLmRpc3BsYXlBbHRpdHVkZSAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuZGlzcGxheUFsdGl0dWRlIDogdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMuZGlzcGxheUNvb3JkaW5hdGVzID0gKG9wdGlvbnMuZGlzcGxheUNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMgOiB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5zeXN0ZW1zID0gb3B0aW9ucy5zeXN0ZW1zIHx8IFtdO1xuICAgIGlmIChvcHRpb25zLmFsdGl0dWRlKSB7XG4gICAgICAgIHZhciBhbHRpdHVkZSA9IG9wdGlvbnMuYWx0aXR1ZGU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hbHRpdHVkZSA9IHtcbiAgICAgICAgICAgIHRyaWdnZXJEZWxheSA6IChhbHRpdHVkZS50cmlnZ2VyRGVsYXkgIT09IHVuZGVmaW5lZCkgPyBhbHRpdHVkZS50cmlnZ2VyRGVsYXkgOiAyMDAsXG4gICAgICAgICAgICByZXNwb25zZURlbGF5IDogKGFsdGl0dWRlLnJlc3BvbnNlRGVsYXkgIT09IHVuZGVmaW5lZCkgPyBhbHRpdHVkZS5yZXNwb25zZURlbGF5IDogNTAwLFxuICAgICAgICAgICAgc2VydmljZU9wdGlvbnMgOiBhbHRpdHVkZS5zZXJ2aWNlT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgIG5vRGF0YVZhbHVlIDogKGFsdGl0dWRlLm5vRGF0YVZhbHVlICE9PSB1bmRlZmluZWQpID8gYWx0aXR1ZGUubm9EYXRhVmFsdWUgOiAtOTk5OTksXG4gICAgICAgICAgICBub0RhdGFWYWx1ZVRvbGVyYW5jZSA6IChhbHRpdHVkZS5ub0RhdGFWYWx1ZVRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkKSA/IGFsdGl0dWRlLm5vRGF0YVZhbHVlVG9sZXJhbmNlIDogOTAwMDBcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYWx0aXR1ZGUgPSB7XG4gICAgICAgICAgICB0cmlnZ2VyRGVsYXkgOiAyMDAsXG4gICAgICAgICAgICByZXNwb25zZURlbGF5IDogNTAwLFxuICAgICAgICAgICAgc2VydmljZU9wdGlvbnMgOiB7fVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGlkIG9mIHRoZSB3aWRnZXQgOiB1c2VmdWxsIHRvIHN1ZmZpeCB0aGUgQ1NTIGlkcyAodG8gaGFuZGxlIGNhc2VzIHdpdGggc2V2ZXJhbCB3aWRnZXRzIG9uIHRoZSBzYW1lIHBhZ2UpXG4gICAgdGhpcy5fdWlkID0gU2VsZWN0b3JJRC5nZW5lcmF0ZSgpO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gb2YgdGhlIHByb2plY3Rpb25zIHN5c3RlbXNcbiAgICB0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcyA9IFtdO1xuICAgIHRoaXMuX2luaXRQcm9qZWN0aW9uU3lzdGVtcygpO1xuXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gb2YgdGhlIHVuaXRzIHN5c3RlbXNcbiAgICB0aGlzLl9wcm9qZWN0aW9uVW5pdHMgPSB7fTtcbiAgICB0aGlzLl9pbml0UHJvamVjdGlvblVuaXRzKCk7XG5cbiAgICAvLyBzdXBwb3J0IGRldGVjdCA6IGRlc2t0b3Agb3IgdGFjdGlsZVxuICAgIHRoaXMuX2lzRGVza3RvcCA9IFV0aWxzLmRldGVjdFN1cHBvcnQoKTtcblxuICAgIC8vIGltcGxlbWVudHMgYSB0aW1lciB0aHJlc2hvbGRcbiAgICBpZiAodGhpcy5vcHRpb25zLmFsdGl0dWRlLnRyaWdnZXJEZWxheSA8IDEwMCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYWx0aXR1ZGUudHJpZ2dlckRlbGF5ID0gMTAwO1xuICAgIH1cblxuICAgIC8vIHtOdW1iZXJ9IHRpbWVyIG9uIG1vdmVzdG9wcGVkIGRlbGF5IChhbHRpdHVkZSBjYWxjdWxhdGlvbilcbiAgICB0aGlzLl90aW1lciA9IHRoaXMub3B0aW9ucy5hbHRpdHVkZS50cmlnZ2VyRGVsYXk7XG5cbiAgICAvLyB7T2JqZWN0fSBTZWxlY3RlZCBwcm9qZWN0aW9uIHN5c3RlbVxuICAgIHRoaXMuX2N1cnJlbnRQcm9qZWN0aW9uU3lzdGVtcyA9IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zWzBdO1xuXG4gICAgLy8ge1N0cmluZ30gU2VsZWN0ZWQgcHJvamVjdGlvbiB1bml0cyB0eXBzIDogR2VvZ3JhcGhpY2FsIG9yIG1ldHJpY1xuICAgIHRoaXMuX2N1cnJlbnRQcm9qZWN0aW9uVHlwZSA9IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zWzBdLnR5cGU7XG5cbiAgICAvLyB7U3RyaW5nfSBTZWxlY3RlZCBwcm9qZWN0aW9uIHVuaXRcbiAgICB0aGlzLl9jdXJyZW50UHJvamVjdGlvblVuaXRzID0gdGhpcy5fcHJvamVjdGlvblVuaXRzW3RoaXMuX2N1cnJlbnRQcm9qZWN0aW9uVHlwZV1bMF0uY29kZTtcblxuICAgIC8vIHtPYmplY3R9IFByb2plY3Rpb24gdW5pdHMgY29udGFpbmVyIChET00gRWxlbWVudClcbiAgICB0aGlzLl9wcm9qZWN0aW9uVW5pdHNDb250YWluZXIgPSBudWxsO1xuXG4gICAgLy8ge09iamVjdH0gY29udHJvbCBwYW5lbCBjb250YWluZXIgKERPTSBFbGVtZW50KVxuICAgIHRoaXMuX3Nob3dNb3VzZVBvc2l0aW9uQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIG1hbmFnZW1lbnQgb2YgdGhlIGFsdGl0dWRlIHBhbmVsIGRpc3BsYXlcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5QWx0aXR1ZGUgJiYgIXRoaXMub3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgLy8gcmVhY3RpdmF0ZSB0aGUgZGlzcGxheSBvZiBjb29yZGluYXRlcywgdG8gbm90IGRpc3BsYXkgYW4gZW1wdHkgcGFuZWxcbiAgICAgICAgdGhpcy5vcHRpb25zLmRpc3BsYXlDb29yZGluYXRlcyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gcmlnaHRzIG1hbmFnZW1lbnQgb24gcmVzb3VyY2VzIGFuZCBzZXJ2aWNlc1xuICAgIC8vIGlmIHdlIHdhbnQgYW4gYWx0aXR1ZGUgY2FsY3VsYXRpb24sIHdlIGNoZWNrIHRoZSBhbHRpIHJlc291cmNlcyByaWdodHMuLi5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXlBbHRpdHVkZSkge1xuICAgICAgICB0aGlzLl9jaGVja1JpZ2h0c01hbmFnZW1lbnQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IgYW5kIGluaXRpYWxpemUgdGhlIHByb2plY3Rpb25cbiAqIHN5c3RlbXMuXG4gKiBnZXR0aW5nIGNvb3JkaW5hdGVzIGluIHRoZSByZXF1ZXN0ZWQgcHJvamVjdGlvbiA6XG4gKiBzZWUgdGhpcy5vbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uU3lzdGVtQ2hhbmdlKClcbiAqXG4gKiBAbWV0aG9kIF9pbml0UHJvamVjdGlvblN5c3RlbXNcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9pbml0UHJvamVjdGlvblN5c3RlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdXNlciBoYXMgdGhlIHBvc3NpYmlsaXR5IHRvIG1vZGlmeSB0aGUgbGlzdCBvZiBzeXN0ZW1zIHRvIGRpc3BsYXlcbiAgICAvLyBFeC4gdGhpcy5vcHRpb25zLnN5c3RlbXNcblxuICAgIC8vIGF2YWlsYWJsZSBwcm9qZWN0aW9uIHN5c3RlbXMgdnkgZGVmYXVsdFxuICAgIHZhciBwcm9qZWN0aW9uU3lzdGVtc0J5RGVmYXVsdCA9IFt7XG4gICAgICAgIGxhYmVsIDogXCJHw6lvZ3JhcGhpcXVlXCIsXG4gICAgICAgIGNycyA6IFwiRVBTRzo0MzI2XCIsXG4gICAgICAgIHR5cGUgOiBcIkdlb2dyYXBoaWNhbFwiXG4gICAgfSwge1xuICAgICAgICBsYWJlbCA6IFwiTWVyY2F0b3JcIixcbiAgICAgICAgY3JzIDogXCJFUFNHOjM4NTdcIixcbiAgICAgICAgdHlwZSA6IFwiTWV0cmljXCJcbiAgICB9LCB7XG4gICAgICAgIGxhYmVsIDogXCJMYW1iZXJ0IDkzXCIsXG4gICAgICAgIGNycyA6IFwiRVBTRzoyMTU0XCIsXG4gICAgICAgIHR5cGUgOiBcIk1ldHJpY1wiLFxuICAgICAgICBnZW9CQm94IDoge1xuICAgICAgICAgICAgbGVmdCA6IC05Ljg2LFxuICAgICAgICAgICAgYm90dG9tIDogNDEuMTUsXG4gICAgICAgICAgICByaWdodCA6IDEwLjM4LFxuICAgICAgICAgICAgdG9wIDogNTEuNTZcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgbGFiZWwgOiBcIkxhbWJlcnQgSUkgw6l0ZW5kdVwiLFxuICAgICAgICBjcnMgOiBcIkVQU0c6Mjc1NzJcIixcbiAgICAgICAgdHlwZSA6IFwiTWV0cmljXCIsXG4gICAgICAgIGdlb0JCb3ggOiB7XG4gICAgICAgICAgICBsZWZ0IDogLTQuODcsXG4gICAgICAgICAgICBib3R0b20gOiA0Mi4zMyxcbiAgICAgICAgICAgIHJpZ2h0IDogOC4yMyxcbiAgICAgICAgICAgIHRvcCA6IDUxLjE0XG4gICAgICAgIH1cbiAgICB9XTtcblxuICAgIHZhciBzeXN0ZW1zID0gdGhpcy5vcHRpb25zLnN5c3RlbXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeXN0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGRlZmluaXRpb24gb2YgYSByZWZlcmVuY2Ugc3lzdGVtXG4gICAgICAgIHZhciBzeXMgPSBzeXN0ZW1zW2ldO1xuICAgICAgICB0aGlzLmFkZFN5c3RlbShzeXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gd2UgYWRkIHRoZSBkZWZhdWx0IHByb2plY3Rpb24gc3lzdGVtc1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgcHJvamVjdGlvblN5c3RlbXNCeURlZmF1bHQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN5c3RlbShwcm9qZWN0aW9uU3lzdGVtc0J5RGVmYXVsdFtpaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFuZCBpbml0aWFsaXplIHRoZSB1bml0cy5cbiAqIGdldHRpbmcgY29vcmRpbmF0ZXMgaW4gdGhlIHJlcXVlc3RlZCB1bml0cyA6XG4gKiBzZWUgdGhpcy5vbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uVW5pdHNDaGFuZ2UoKVxuICpcbiAqIEBtZXRob2QgX2luaXRQcm9qZWN0aW9uVW5pdHNcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9pbml0UHJvamVjdGlvblVuaXRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHVzZXIgaGFzIHRoZSBwb3NzaWJpbGl0eSB0byBtb2RpZnkgdGhlIGxpc3Qgb2YgdW5pdHMgdG8gZGlzcGxheVxuICAgIC8vIEV4LlxuICAgIC8vIHRoaXMub3B0aW9ucy51bml0cyA6IFtcIkRFQ1wiLCBcIkRNU1wiXVxuXG4gICAgLy8gYXZhaWxhYmxlIHVuaXRzIHN5c3RlbXMgYnkgZGVmYXVsdFxuICAgIHZhciBwcm9qZWN0aW9uVW5pdHNCeURlZmF1bHQgPSB7XG4gICAgICAgIEdlb2dyYXBoaWNhbCA6IFt7XG4gICAgICAgICAgICBjb2RlIDogXCJERUNcIixcbiAgICAgICAgICAgIGxhYmVsIDogXCJkZWdyw6lzIGTDqWNpbWF1eFwiLFxuICAgICAgICAgICAgY29udmVydCA6IHRoaXMuX2Rpc3BsYXlERUNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29kZSA6IFwiRE1TXCIsXG4gICAgICAgICAgICBsYWJlbCA6IFwiZGVncsOpcyBzZXhhZ8Opc2ltYXV4XCIsXG4gICAgICAgICAgICBjb252ZXJ0IDogdGhpcy5fZGlzcGxheURNU1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb2RlIDogXCJSQURcIixcbiAgICAgICAgICAgIGxhYmVsIDogXCJyYWRpYW5zXCIsXG4gICAgICAgICAgICBjb252ZXJ0IDogdGhpcy5fZGlzcGxheVJBRFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb2RlIDogXCJHT05cIixcbiAgICAgICAgICAgIGxhYmVsIDogXCJncmFkZXNcIixcbiAgICAgICAgICAgIGNvbnZlcnQgOiB0aGlzLl9kaXNwbGF5R09OXG4gICAgICAgIH1dLFxuICAgICAgICBNZXRyaWMgOiBbe1xuICAgICAgICAgICAgY29kZSA6IFwiTVwiLFxuICAgICAgICAgICAgbGFiZWwgOiBcIm3DqHRyZXNcIixcbiAgICAgICAgICAgIGNvbnZlcnQgOiB0aGlzLl9kaXNwbGF5TWV0ZXJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29kZSA6IFwiS01cIixcbiAgICAgICAgICAgIGxhYmVsIDogXCJraWxvbcOodHJlc1wiLFxuICAgICAgICAgICAgY29udmVydCA6IHRoaXMuX2Rpc3BsYXlLTWV0ZXJcbiAgICAgICAgfV1cbiAgICB9O1xuXG4gICAgdmFyIHVuaXRzID0gdGhpcy5vcHRpb25zLnVuaXRzO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiBwcm9qZWN0aW9uVW5pdHNCeURlZmF1bHQpIHtcbiAgICAgICAgaWYgKHByb2plY3Rpb25Vbml0c0J5RGVmYXVsdC5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb2plY3Rpb25Vbml0c0J5RGVmYXVsdFt0eXBlXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBwcm9qZWN0aW9uVW5pdHNCeURlZmF1bHRbdHlwZV1bal07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pdCA9IHVuaXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmNvZGUgPT09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvamVjdGlvblVuaXRzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvamVjdGlvblVuaXRzW3R5cGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9qZWN0aW9uVW5pdHNbdHlwZV0ucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2plY3Rpb25Vbml0c1t0eXBlXSA9IHByb2plY3Rpb25Vbml0c0J5RGVmYXVsdFt0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugb2YuLi5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3Byb2plY3Rpb25Vbml0cyA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh0aGlzLl9wcm9qZWN0aW9uVW5pdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9qZWN0aW9uVW5pdHMgPSBwcm9qZWN0aW9uVW5pdHNCeURlZmF1bHQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgY29uc3RydWN0b3JcbiAqIGFuZCBjaGVjayB0aGUgcmlnaHRzIHRvIHJlc291cmNlc1xuICpcbiAqIEBtZXRob2QgX2NoZWNrUmlnaHRzTWFuYWdlbWVudFxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX2NoZWNrUmlnaHRzTWFuYWdlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmlnaHRNYW5hZ2VtZW50ID0gUmlnaHRNYW5hZ2VtZW50LmNoZWNrKHtcbiAgICAgICAga2V5IDogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgcmVzb3VyY2VzIDogW1wiU0VSVklDRV9DQUxDVUxfQUxUSU1FVFJJUVVFX1JTQ1wiXSxcbiAgICAgICAgc2VydmljZXMgOiBbXCJFbGV2YXRpb25cIl1cbiAgICB9KTtcblxuICAgIHRoaXMuX25vUmlnaHRNYW5hZ2VtZW50ID0gIXJpZ2h0TWFuYWdlbWVudDtcblxuICAgIC8vIHJldHJpZXZlcyB0aGUgdXNlZnVsbCBpbmZvc1xuICAgIC8vIG9uIHRoaXMgY29udHJvbCwgd2UgZG8gbm90IGNhcmUgYWJvdXQgdGhlIHJlc3NvdXJjZSBiZXNjYXVzZSBpdCBpcyB1bmlxdWVcbiAgICAvLyBFeCA6IHRoZSBBUEkga2V5IGZyb20gdGhlIGF1dG9jb25maWd1cmF0aW9uIGlmIGl0IGhhcyBub3QgYmVlbiBnaXZlblxuICAgIGlmICghdGhpcy5vcHRpb25zLmFwaUtleSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXBpS2V5ID0gcmlnaHRNYW5hZ2VtZW50LmtleTtcbiAgICB9XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgbWV0aG9kcyBoYW5kbGUgZG9tICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogQ3JlYXRlIGNvbnRyb2wgbWFpbiBjb250YWluZXIgKGNhbGxlZCBieSBNb3VzZVBvc2l0aW9uIGNvbnN0cnVjdG9yKVxuICpcbiAqIEBtZXRob2QgX2luaXRDb250YWluZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbGxhcHNlZCAtIFNwZWNpZnkgaWYgTW91c2VQb3NpdGlvbiBjb250cm9sIHNob3VsZCBiZSBjb2xsYXBzZWRcbiAqIEBwYXJhbSB7QXJyYXl9ICAgb3B0aW9ucy5kaXNwbGF5QWx0aXR1ZGUgLSBhY3RpdmF0ZSAodHJ1ZSkgb3IgZGVhY3RpdmF0ZSAoZmFsc2UpIHRoZSBhbHRpdHVkZSBwYW5lbFxuICogQHBhcmFtIHtBcnJheX0gICBvcHRpb25zLmRpc3BsYXlDb29yZGluYXRlcyAtIGFjdGl2YXRlICh0cnVlKSBvciBkZWFjdGl2YXRlIChmYWxzZSkgdGhlIGNvb3JkaW5hdGVzIHBhbmVsXG4gKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyIC0gd2lkZ2V0IGNvbnRhaW5lclxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX2luaXRDb250YWluZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGNyZWF0ZXMgdGhlIG1haW4gY29udGFpbmVyXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50KCk7XG5cbiAgICB2YXIgaW5wdXRTaG93ID0gdGhpcy5fc2hvd01vdXNlUG9zaXRpb25Db250YWluZXIgPSB0aGlzLl9jcmVhdGVTaG93TW91c2VQb3NpdGlvbkVsZW1lbnQoKTtcbiAgICBpZiAoIW9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgIGlucHV0U2hvdy5jaGVja2VkID0gXCJjaGVja2VkXCI7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dFNob3cpO1xuXG4gICAgdmFyIHBpY3RvID0gdGhpcy5fY3JlYXRlU2hvd01vdXNlUG9zaXRpb25QaWN0b0VsZW1lbnQodGhpcy5faXNEZXNrdG9wKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocGljdG8pO1xuXG4gICAgdmFyIHBhbmVsID0gdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblBhbmVsRWxlbWVudChvcHRpb25zLmRpc3BsYXlBbHRpdHVkZSwgb3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMpO1xuICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQob3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMpO1xuICAgIHZhciBzeXN0ZW1zID0gdGhpcy5fcHJvamVjdGlvblN5c3RlbXNDb250YWluZXIgPSB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uU2V0dGluZ3NTeXN0ZW1zRWxlbWVudCh0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcyk7XG4gICAgdmFyIHVuaXRzID0gdGhpcy5fcHJvamVjdGlvblVuaXRzQ29udGFpbmVyID0gdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzVW5pdHNFbGVtZW50KHRoaXMuX3Byb2plY3Rpb25Vbml0c1t0aGlzLl9jdXJyZW50UHJvamVjdGlvblR5cGVdKTtcblxuICAgIHNldHRpbmdzLmFwcGVuZENoaWxkKHN5c3RlbXMpO1xuICAgIHNldHRpbmdzLmFwcGVuZENoaWxkKHVuaXRzKTtcbiAgICBwYW5lbC5hcHBlbmRDaGlsZChzZXR0aW5ncyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBhbmVsKTtcblxuICAgIHJldHVybiBjb250YWluZXI7XG59O1xuXG4vKipcbiAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGlzLigpXG4gKiBhbmQgaXQgY2hhbmdlcyB0aGUgZWxldmF0aW9uIHZpZXcgcGFuZWwgaW50byB0aGUgZG9tLlxuICpcbiAqIEBtZXRob2QgX3NldEVsZXZhdGlvblBhbmVsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZSAtIHRydWU6YWN0aXZlLCBmYWxzZTpkaXNhYmxlXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5fc2V0RWxldmF0aW9uUGFuZWwgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgdmFyIGRpdiA9IG51bGw7XG5cbiAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICBkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkdQbW91c2VQb3NpdGlvbkFsdGl0dWRlLVwiICsgdGhpcy5fdWlkKTtcbiAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fbm9SaWdodE1hbmFnZW1lbnQpIHtcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiR1Btb3VzZVBvc2l0aW9uQWx0LVwiICsgdGhpcy5fdWlkKTtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIk5vIHJpZ2h0cyFcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiR1Btb3VzZVBvc2l0aW9uQWx0aXR1ZGUtXCIgKyB0aGlzLl91aWQpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy4oKVxuICogYW5kIGl0IGNoYW5nZXMgdGhlIGNvb3JkaW5hdGUgdmlldyBwYW5lbCBpbnRvIHRoZSBkb20uXG4gKlxuICogQG1ldGhvZCBfc2V0Q29vcmRpbmF0ZXNQYW5lbFxuICogQHBhcmFtIHtCb29sZWFufSBhY3RpdmUgLSB0cnVlOmFjdGl2ZSwgZmFsc2U6ZGlzYWJsZVxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX3NldENvb3JkaW5hdGVzUGFuZWwgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiR1Btb3VzZVBvc2l0aW9uQ29vcmRpbmF0ZS1cIiArIHRoaXMuX3VpZCk7XG4gICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy4oKVxuICogYW5kIGl0IGNoYW5nZXMgdGhlIHNldHRpbmdzIHZpZXcgcGFuZWwgaW50byB0aGUgZG9tLlxuICpcbiAqIEBtZXRob2QgX3NldFNldHRpbmdzUGFuZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aXZlIC0gdHJ1ZTphY3RpdmUsIGZhbHNlOmRpc2FibGVcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9zZXRTZXR0aW5nc1BhbmVsID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgIHZhciBkaXZQaWN0byA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiR1BzaG93TW91c2VQb3NpdGlvblNldHRpbmdzUGljdG8tXCIgKyB0aGlzLl91aWQpO1xuICAgIHZhciBkaXZQYW5lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiR1Btb3VzZVBvc2l0aW9uU2V0dGluZ3MtXCIgKyB0aGlzLl91aWQpO1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgIGRpdlBpY3RvLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZGl2UGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdlBpY3RvLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICBkaXZQYW5lbC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICB9XG59O1xuXG4vKipcbiAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGlzLm9uTW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1DaGFuZ2UoKVxuICogd2hlbiBjaGFuZ2VzIHRvIGEgbWV0cmljIG9yIGEgZ2VvZ3JhcGhpY2FsIHVuaXRzLlxuICpcbiAqIEBtZXRob2QgX3NldFR5cGVVbml0c1BhbmVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEdlb2dyYXBoaWNhbCBvciBNZXRyaWNcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9zZXRUeXBlVW5pdHNQYW5lbCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3Byb2plY3Rpb25Vbml0c0NvbnRhaW5lcjtcblxuICAgIC8vIGRlbGV0ZXMgdGhlIGNoaWxkTm9kZXNcbiAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICB2YXIgdW5pdHMgPSB0aGlzLl9wcm9qZWN0aW9uVW5pdHNbdHlwZV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgb2JqID0gdW5pdHNbal07XG4gICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSAob2JqLmNvZGUpID8gb2JqLmNvZGUgOiBqO1xuICAgICAgICBvcHRpb24udGV4dCA9IG9iai5sYWJlbCB8fCBqO1xuICAgICAgICAvLyBvcHRpb24ubGFiZWwgPSBvYmoubGFiZWw7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgIH1cblxuICAgIC8vIHRoZSBuZXcgdHlwZSBvZiBzeXN0ZW1cbiAgICB0aGlzLl9jdXJyZW50UHJvamVjdGlvblR5cGUgPSB0eXBlO1xuICAgIC8vIGFzIHRoZSBzeXN0ZW0gY2hhbmdlZCwgdGhlIHVuaXQgc3lzdGVtIGhhcyB0byBjaGFuZ2UgdG9vICFcbiAgICB0aGlzLl9jdXJyZW50UHJvamVjdGlvblVuaXRzID0gdGhpcy5fcHJvamVjdGlvblVuaXRzW3R5cGVdWzBdLmNvZGU7XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgbWV0aG9kIHVuaXRzIGNvbnZlcnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogZGVncmVlZGVjaW1hbFxuICpcbiAqIEBtZXRob2QgX2Rpc3BsYXlERUNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBjb29yZGluYXRlc29iamVjdCB7bG9uLCBsYXR9XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvb3JkaW5hdGUgLSBjb29yZGluYXRlIG9iamVjdCA6IHtsYXQgOiA0OCwgbG5nIDogMn0gcGFyIGV4ZW1wbGVcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9kaXNwbGF5REVDID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIHZhciBjb29yZGluYXRlID0ge307XG4gICAgY29vcmRpbmF0ZS5sYXQgPSBQb3NpdGlvbkZvcm1hdGVyLnJvdW5kVG9EZWNpbWFsKGNvb3Jkcy5sYXQsIDYpO1xuICAgIGNvb3JkaW5hdGUubG5nID0gUG9zaXRpb25Gb3JtYXRlci5yb3VuZFRvRGVjaW1hbChjb29yZHMubG9uLCA2KTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZTtcbn07XG5cbi8qKlxuICogZGVncmVlZGVjaW1hbDJzZXhhZ2VjaW1hbFxuICpcbiAqIEBtZXRob2QgX2Rpc3BsYXlETVNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBjb29yZGluYXRlcyBvYmplY3Qge2xvbiwgbGF0fVxuICogQHJldHVybiB7T2JqZWN0fSBjb29yZGluYXRlIC0gY29vcmRpbmF0ZSBvYmplY3QgOiB7bG5nIDogXCIywrAgMDDigLIgMDDigLMgRVwiLCBsYXQgOiBcIjQ4wrAgMDDigLIgMDDigLMgTlwifSBwYXIgZXhlbXBsZVxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX2Rpc3BsYXlETVMgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgdmFyIGNvb3JkaW5hdGUgPSB7fTtcbiAgICBjb29yZGluYXRlLmxhdCA9IFBvc2l0aW9uRm9ybWF0ZXIuZGVjaW1hbExhdFRvRE1TKGNvb3Jkcy5sYXQpO1xuICAgIGNvb3JkaW5hdGUubG5nID0gUG9zaXRpb25Gb3JtYXRlci5kZWNpbWFsTG9uZ1RvRE1TKGNvb3Jkcy5sb24pO1xuICAgIHJldHVybiBjb29yZGluYXRlO1xufTtcblxuLyoqXG4gKiBkZWdyZWVkZWNpbWFsMnJhZGlhblxuICpcbiAqIEBtZXRob2QgX2Rpc3BsYXlSQURcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBjb29yZGluYXRlcyBvYmplY3Qge2xvbiwgbGF0fVxuICogQHJldHVybiB7T2JqZWN0fSBjb29yZGluYXRlIC0gY29vcmRpbmF0ZSBvYmplY3QgOiB7bGF0IDogXCIwLjAyODM3ODY0XCIsIGxuZyA6IFwiMC44NDMwMDI2OVwifSBwYXIgZXhlbXBsZVxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX2Rpc3BsYXlSQUQgPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgdmFyIGNvb3JkaW5hdGUgPSB7fTtcbiAgICBjb29yZGluYXRlLmxhdCA9IFBvc2l0aW9uRm9ybWF0ZXIuZGVjaW1hbFRvUmFkaWFuKGNvb3Jkcy5sYXQpO1xuICAgIGNvb3JkaW5hdGUubG5nID0gUG9zaXRpb25Gb3JtYXRlci5kZWNpbWFsVG9SYWRpYW4oY29vcmRzLmxvbik7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG59O1xuXG4vKipcbiAqIGRlZ3JlZWRlY2ltYWwyZ3JhZGVcbiAqXG4gKiBAbWV0aG9kIF9kaXNwbGF5R09OXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0gY29vcmRpbmF0ZXMgb2JqZWN0IHtsb24sIGxhdH1cbiAqIEByZXR1cm4ge09iamVjdH0gY29vcmRpbmF0ZSAtIGNvb3JkaW5hdGUgb2JqZWN0IDoge2xhdCA6IFwiNC4wOTU0NTg5OFwiLCBsbmcgOiBcIjUzLjY4NzUxNTI4XCJ9IHBhciBleGVtcGxlXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5fZGlzcGxheUdPTiA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IHt9O1xuICAgIGNvb3JkaW5hdGUubGF0ID0gUG9zaXRpb25Gb3JtYXRlci5kZWNpbWFsVG9HcmFkZShjb29yZHMubGF0KTtcbiAgICBjb29yZGluYXRlLmxuZyA9IFBvc2l0aW9uRm9ybWF0ZXIuZGVjaW1hbFRvR3JhZGUoY29vcmRzLmxvbik7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG59O1xuXG4vKipcbiAqIG1ldGVyXG4gKlxuICogQG1ldGhvZCBfZGlzcGxheU1ldGVyXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0gY29vcmRzIG9iamVjdCB7bG9uLCBsYXR9XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvb3JkaW5hdGUgLSBjb29yZGluYXRlIG9iamVjdCA6IHt4IDogXCIxNDg1OTMuNThcIiwgeSA6IFwiNjE3NjU2MC45NVwifSBwYXIgZXhlbXBsZVxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUuX2Rpc3BsYXlNZXRlciA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAvLyBvbiByZWNvaXQgdG91am91cnMgZGVzIGNvb3Jkb25uw6llcyBtZXRyaXF1ZXNcbiAgICB2YXIgY29vcmRpbmF0ZSA9IHt9O1xuICAgIGNvb3JkaW5hdGUueCA9IGNvb3Jkcy5sb24udG9GaXhlZCgyKTtcbiAgICBjb29yZGluYXRlLnkgPSBjb29yZHMubGF0LnRvRml4ZWQoMik7XG4gICAgY29vcmRpbmF0ZS51bml0ID0gXCJtXCI7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGU7XG59O1xuXG4vKipcbiAqIGtpbG9tZXRlclxuICpcbiAqIEBtZXRob2QgX2Rpc3BsYXlLTWV0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBjb29yZHMgb2JqZWN0IHtsb24sIGxhdH1cbiAqIEByZXR1cm4ge09iamVjdH0gY29vcmRpbmF0ZSAtIGNvb3JkaW5hdGUgb2JqZWN0IDoge3ggOiBcIjIxNC45NlwiLCB5IDogXCI2MjUwLjA5XCJ9IHBhciBleGVtcGxlXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5fZGlzcGxheUtNZXRlciA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IHt9O1xuICAgIGNvb3JkaW5hdGUueCA9IChjb29yZHMubG9uIC8gMTAwMCkudG9GaXhlZCgyKTtcbiAgICBjb29yZGluYXRlLnkgPSAoY29vcmRzLmxhdCAvIDEwMDApLnRvRml4ZWQoMik7XG4gICAgY29vcmRpbmF0ZS51bml0ID0gXCJrbVwiO1xuICAgIHJldHVybiBjb29yZGluYXRlO1xufTtcblxuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIGhhbmRsZXJzIGV2ZW50cyB0byBjb250cm9sICMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4vKipcbiAqIHRoaXMgc2VuZHMgdGhlIGNvb3JkaW5hdGVzIHRvIHRoZSBwYW5lbC5cbiAqIChjZi4gdGhpcy5HUGRpc3BsYXlDb29yZHMoKSBpbnRvIHRoZSBET00gZnVuY3Rpb25zKVxuICpcbiAqIEBtZXRob2QgX3NldENvb3JkaW5hdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyAtIGNvb3JkaW5hdGUgb2JqZWN0IHtsb24sIGxhdH1cbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9zZXRDb29yZGluYXRlID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIC8vIHN0cnVjdHVyZVxuICAgIC8vIGNvb3Jkc1xuICAgIC8vICAgICAge1xuICAgIC8vICAgICAgICAgIGxvbjogNSxcbiAgICAvLyAgICAgICAgICBsYXQgOiA0OFxuICAgIC8vICAgICAgfVxuICAgIC8vXG4gICAgLy8gc3RydWN0dXJlIGZvciB0aGUgY29vcmRpbmF0ZXMgZGVwZW5kaW5nIG9uIHRoZSBzeXN0ZW0gdHlwZSA6XG4gICAgLy8ge3g6LCB5OiwgdW5pdDp9IG9yIHtsbmc6LCBsYXQ6fSBvciB7bG9uOiwgbGF0On0gb3Ige2U6LCBuOiwgdW5pdDp9Li4uXG5cbiAgICB2YXIgY29vcmQgPSBbXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSB7fTtcblxuICAgIC8vIHRyYW5zZm9ybXMgdGhlIHBvaW50IGluIHRoZSB3YW50ZWQgY29vcmRzIHN5c3RlbVxuICAgIHZhciBvU3JzID0gdGhpcy5fY3VycmVudFByb2plY3Rpb25TeXN0ZW1zO1xuICAgIHZhciBjcnNQcm9wID0gb1Nycy5jcnM7XG5cbiAgICBpZiAoIW9TcnMgfHwgIWNyc1Byb3ApIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwic3lzdGVtIGNycyBub3QgZm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcmVwcm9qZWN0IGNvb3JkaW5hdGVzIGZyb20gdGhlaXIgQ1JTIG9mIG9yaWdpbiAoV0dTODQpIHRvIHRoZSB3YW50ZWQgQ1JTIChjcnNQcm9wKVxuICAgIGlmIChjcnNQcm9wICE9PSBcIkVQU0c6NDMyNlwiKSB7XG4gICAgICAgIGNvb3JkID0gcHJvajQoQ1JTW2Nyc1Byb3BdLCBbY29vcmRzLmxvbiwgY29vcmRzLmxhdF0pO1xuICAgICAgICAvLyBwcm9qZWN0ZWQgdmFsdWVzIGFyZSBhZmZlY3RlZCB0byB0aGUgY29vcmQgdmFyXG4gICAgICAgIGNvb3JkaW5hdGVzLmxvbiA9IGNvb3JkWzBdO1xuICAgICAgICBjb29yZGluYXRlcy5sYXQgPSBjb29yZFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb29yZGluYXRlcyA9IGNvb3JkcztcbiAgICB9XG5cbiAgICAvLyBzeXN0ZW0gdHlwZSA6IEdlb2dyYXBoaWNhbCBvciBNZXRyaWNcblxuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudFByb2plY3Rpb25TeXN0ZW1zLnR5cGU7XG5cbiAgICAvLyBjaGVja3MgZm9yIGEgZm9ybWF0dGluZyBmdW5jdGlvbiBpbiB0aGUgd2FudGVkIHVuaXRcbiAgICB2YXIgY29udmVydCA9IG51bGw7XG4gICAgdmFyIHVuaXRzID0gdGhpcy5fcHJvamVjdGlvblVuaXRzW3R5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodW5pdHNbaV0uY29kZSA9PT0gdGhpcy5fY3VycmVudFByb2plY3Rpb25Vbml0cykge1xuICAgICAgICAgICAgY29udmVydCA9IHVuaXRzW2ldLmNvbnZlcnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbnZlcnQgfHwgdHlwZW9mIGNvbnZlcnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBsb2dnZXIud2FybihcImNvb3JkaW5hdGVzIGZvcm1hdCBmdW5jdGlvbiBub3QgZm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb29yZCA9IGNvbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgIH1cblxuICAgIGlmICghY29vcmQgfHwgT2JqZWN0LmtleXMoY29vcmQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5HUGRpc3BsYXlDb29yZHMoY29vcmQpO1xufTtcblxuLyoqXG4gKiB0aGlzIHNlbmRzIHRoZSBjb29yZGluYXRlcyB0byB0aGUgcGFuZWwuXG4gKiAoY2YuIHRoaXMuR1BkaXNwbGF5RWxldmF0aW9uKCkgaW50byB0aGUgRE9NIGZ1bmN0aW9ucylcbiAqXG4gKiBAbWV0aG9kIF9zZXRFbGV2YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBDb29yZGluYXRlIHBvc2l0aW9uIG9iamVjdCB7bG9uLCBsYXR9XG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5fc2V0RWxldmF0aW9uID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgIC8vIG1hbmFnZW1lbnQgb2YgdGhlIHRpbWVyIG9mIHRoZSBhbHRpdHVkZSBzZXJ2aWNlIHJlcXVlc3RcbiAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdGlvbnMuYWx0aXR1ZGUucmVzcG9uc2VEZWxheTtcbiAgICB0aGlzLkdQZGlzcGxheUVsZXZhdGlvbihjb29yZHMsIGRlbGF5KTtcbn07XG5cbi8qKlxuICogdGhpcyBtZXRob2QgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vdXNlIG9yIHRoZSBnbG9iZSBpcyBzdG9wcGVkLlxuICogKGNmLiBvbk1vdXNlTW92ZSBhbmQgb25HbG9iZU1vdmUpXG4gKlxuICogQG1ldGhvZCBvbk1vdmVTdG9wcGVkXG4gKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0gQ29vcmRpbmF0ZSBwb3NpdGlvbiBvYmplY3Qge2xvbiwgbGF0fVxuICogQHByaXZhdGVcbiAqL1xuTW91c2VQb3NpdGlvbi5wcm90b3R5cGUub25Nb3ZlU3RvcHBlZCA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICB0aGlzLl9zZXRFbGV2YXRpb24oY29vcmRzKTtcbn07XG5cbi8qKlxuICogdGhpcyBtZXRob2QgaXMgYW4gaGFuZGxlciBldmVudCB0byBjb250cm9sLiBUaGUgZXZlbnQgaXMgJ21vdXNlbW92ZScgb25cbiAqIHRoZSBnbG9iZS4gVGhlIGhhbmRsZXIgc2VuZHMgdGhlIGNvb3JkaW5hdGVzIHRvIHRoZSBwYW5lbC5cbiAqIChjZi4gdGhpcy5HUGRpc3BsYXlDb29yZHMoKSBpbnRvIHRoZSBET00gZnVuY3Rpb25zKVxuICpcbiAqIEBtZXRob2Qgb25Nb3VzZU1vdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gSFRNTEVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldEdsb2JlKCkuZ2V0Q29vcmRpbmF0ZUZyb21Nb3VzZUV2ZW50KGUpO1xuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5HUGRpc3BsYXlDb29yZHMoe1xuICAgICAgICAgICAgbG9uIDogXCItLS1cIixcbiAgICAgICAgICAgIGxhdCA6IFwiLS0tXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuR1ByZXNldEVsZXZhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkaW5hdGUgPSB7XG4gICAgICAgIGxvbiA6IHBvc2l0aW9uLmxvbmdpdHVkZSgpLFxuICAgICAgICBsYXQgOiBwb3NpdGlvbi5sYXRpdHVkZSgpXG4gICAgfTtcblxuICAgIHRoaXMuX3NldENvb3JkaW5hdGUoY29vcmRpbmF0ZSk7XG5cbiAgICAvLyBjYWxjdWxhdGlvbiBvZiB0aGUgYWx0aXR1ZGUgYWZ0ZXIgYSB0aW1lIGxpbWl0IGZyb20gdGhlIG1vbWVudCB3aGVyZSB0aGUgbW91c2UgbW92ZW1lbnQgaXMgc3RvcHBlZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheUFsdGl0dWRlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLm9uTW92ZVN0b3BwZWQoY29vcmRpbmF0ZSk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5hbHRpdHVkZS50cmlnZ2VyRGVsYXkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogdGhpcyBtZXRob2QgaXMgYW4gaGFuZGxlciBldmVudCB0byBjb250cm9sLiBUaGUgZXZlbnQgaXMgJ21vdmVlbmQnIG9uXG4gKiB0aGUgZ2xvYmUuIFRoZSBoYW5kbGVyIHNlbmRzIHRoZSBjb29yZGluYXRlcyB0byB0aGUgcGFuZWwuXG4gKiAoY2YuIHRoaXMuR1BkaXNwbGF5Q29vcmRzKCkgaW50byB0aGUgRE9NIGZ1bmN0aW9ucylcbiAqXG4gKiBAbWV0aG9kIG9uR2xvYmVNb3ZlXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5vbkdsb2JlTW92ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGluZm86IGNvb3JkaW5hdGUgPSBbeCwgeV1cbiAgICAvLyB2YXIgY29vcmRpbmF0ZSA9IGUuY29vcmRpbmF0ZTtcbiAgICAvLyBpZiAoICFlLm1hcCB8fCAhZS5tYXAuZ2V0VmlldygpICkge1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuICAgIC8vIHZhciBjcnMgPSBlLm1hcC5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpO1xuICAgIC8vXG4gICAgLy8gdGhpcy5fc2V0Q29vcmRpbmF0ZShjb29yZGluYXRlLCBjcnMpO1xuICAgIC8vXG4gICAgLy8gLy8gY2FsY3VsIGRlIGwnYWx0aXR1ZGUgYXByw6hzIHVuIGNlcnRhaW4gZMOpbGFpIGFwcsOocyBsJ2FycsOqdCBkdSBtb3V2ZW1lbnQgZGUgbGEgY2FydGVcbiAgICAvLyBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIC8vIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICBzZWxmLm9uTW92ZVN0b3BwZWQoY29vcmRpbmF0ZSwgY3JzKTtcbiAgICAvLyB9LCB0aGlzLm9wdGlvbnMuYWx0aXR1ZGUudHJpZ2dlckRlbGF5KTtcbn07XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIGhhbmRsZXJzIGV2ZW50cyB0byBkb20gIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhpcy5HUGRpc3BsYXlFbGV2YXRpb24oKSBpbiB0aGUgZG9tLCBhbmRcbiAqIGl0IGV4ZWN1dGVzIGEgcmVxdWVzdCB0byB0aGUgZWxldmF0aW9uIHNlcnZpY2UuXG4gKlxuICogQG1ldGhvZCBvblJlcXVlc3RBbHRpdHVkZVxuICogQHBhcmFtIHtPYmplY3R9IGNvb3JkaW5hdGUgLSB7bGF0Oi4uLiwgbG5nOi4uLn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLm9uUmVxdWVzdEFsdGl0dWRlID0gZnVuY3Rpb24gKGNvb3JkaW5hdGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gSU5GT1JNQVRJT05cbiAgICAvLyB3ZSBsYXVuY2ggdGhlIHJlcXVlc3QgdG8gdGhlIGFsdGl0dWRlIHNlcnZpY2VzXG4gICAgLy8gd2UgaW1wbGVtZW50IGNhbGxiYWNrcyBpbiBvcmRlciB0byByZXRyaWV2ZSByZXN1bHRzIG9yIGVycm9yc1xuICAgIC8vIGZyb20gdGhlIHNlcnZpY2UuXG4gICAgLy8gVGhlIHJlc3VsdCBpcyBkaXNwbGF5ZWQgaW4gYSBET00gZWxlbWVudC5cbiAgICAvLyBUaGUgZXJyb3IgbWVzc2FnZXMgYXJlIGRpc3BsYXkgaW4gdGhlIGRldiBjb25zb2xlICg/KVxuXG4gICAgaWYgKCFjb29yZGluYXRlIHx8IE9iamVjdC5rZXlzKGNvb3JkaW5hdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG8gbm90IHdhbnQgYW55IGFsdGl0dWRlIGNhbGN1bGF0aW9uLCB3ZSBqdXN0IHN0b3AgIVxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXlBbHRpdHVkZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uIG5vdCBoYXZlIHRoZSByaWdodHMgb24gdGhlIHJlcXVlc3RlZCByZXNvdXJjZSwgd2UganVzdCBzdG9wICFcbiAgICBpZiAodGhpcy5fbm9SaWdodE1hbmFnZW1lbnQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm8gcmlnaHRzIHRvIGxvYWQgZ2VvcG9ydGFsIGVsZXZhdGlvbiBcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkFsdFwiKSkuaW5uZXJIVE1MID0gXCJObyByaWdodHMhXCI7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSByZXRyaWV2ZSB0aGUgc2VydmljZSBvcHRpb25zLi4uXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYWx0aXR1ZGUuc2VydmljZU9wdGlvbnMgfHwge307XG5cbiAgICAvLyAuLi4gYW5kIHRoZSBjb29yZGluYXRlcy4uLlxuICAgIG9wdGlvbnMuem9ubHkgPSB0cnVlO1xuICAgIG9wdGlvbnMucG9zaXRpb25zID0gW3tcbiAgICAgICAgbG9uIDogY29vcmRpbmF0ZS5sb24sXG4gICAgICAgIGxhdCA6IGNvb3JkaW5hdGUubGF0XG4gICAgfV07XG5cbiAgICAvLyAuLi4gYW5kIHRoZSBjYWxsYmFja3NcbiAgICBvcHRpb25zLnNjb3BlID0gdGhpcztcblxuICAgIGlmICghb3B0aW9ucy5yYXdSZXNwb25zZSkge1xuICAgICAgICAvLyBpbiB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzICYmIE9iamVjdC5rZXlzKHJlc3VsdHMpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCByZXN1bHRzLmVsZXZhdGlvbnNbMF0ueik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJhbHRpIHNlcnZpY2UgcmF3IHJlc3BvbnNlIDogXCIsIHJlc3VsdHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIG9wdGlvbnMub25GYWlsdXJlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIltnZXRBbHRpdHVkZV0gXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9O1xuICAgIC8vIGluIHRoZSBjYXNlIG9mIHRoZSBBUEkga2V5IGlzIG5vdCBnaXZlbiBhcyBvcHRpb24gb2YgdGhlIHNlcnZpY2UsXG4gICAgLy8gd2UgdXNlIHRoZSBrZXkgb2YgdGhlIGF1dG9jb25mLCBvciB0aGUga2V5IGdpdmVuIGluIHRoZSBjb250cm9sIG9wdGlvbnNcbiAgICBvcHRpb25zLmFwaUtleSA9IG9wdGlvbnMuYXBpS2V5IHx8IHRoaXMub3B0aW9ucy5hcGlLZXk7XG5cbiAgICBHcC5TZXJ2aWNlcy5nZXRBbHRpdHVkZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IGV2ZW50ICdjbGljaycgb24gJ0dQc2hvd01vdXNlUG9zaXRpb25QaWN0bycgdGFnIGxhYmVsXG4gKiAoY2YuIHRoaXMuX2NyZWF0ZVNob3dNb3VzZVBvc2l0aW9uUGljdG9FbGVtZW50KSxcbiAqIGFuZCB0b2dnbGVzIGV2ZW50ICdtb3VzZW1vdmUnIG9uIGdsb2JlLlxuICpcbiAqIEBtZXRob2Qgb25TaG93TW91c2VQb3NpdGlvbkNsaWNrXG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5vblNob3dNb3VzZVBvc2l0aW9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2hlY2tlZCA6IHRydWUgLSBwYW5lbCBjbG9zZVxuICAgIC8vIGNoZWNrZWQgOiBmYWxzZSAtIHBhbmVsIG9wZW5cbiAgICB2YXIgZ2xvYmUgPSB0aGlzLmdldEdsb2JlKCk7XG5cbiAgICB0aGlzLmNvbGxhcHNlZCA9IHRoaXMuX3Nob3dNb3VzZVBvc2l0aW9uQ29udGFpbmVyLmNoZWNrZWQ7XG5cbiAgICAvLyBldmVudCB0cmlnZ2VyZWQgd2hlbiBvcGVuaW5nL2Nsb3NpbmcgdGhlIHBhbmVsXG4gICAgLy8gYW5kIGRlcGVuZGluZyBvbiB0aGUgbW9kZSA6IGRlc2t0b3Agb3IgdGFjdGlsZSFcbiAgICBpZiAodGhpcy5fc2hvd01vdXNlUG9zaXRpb25Db250YWluZXIuY2hlY2tlZCkge1xuICAgICAgICAvLyBGSVhNRSBoYW5kbGUgb3Igbm90IG1vYmlsZSBjYXNlXG4gICAgICAgIGlmICh0aGlzLl9pc0Rlc2t0b3ApIHtcbiAgICAgICAgICAgIGdsb2JlLmZvcmdldChHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTU9VU0VfTU9WRSwgdGhpcy5fY2FsbGJhY2tzLm1vdXNlTW92ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iZS5mb3JnZXQoR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkNFTlRFUl9DSEFOR0VELCB0aGlzLm9uR2xvYmVNb3ZlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FIGhhbmRsZSBvciBub3QgbW9iaWxlIGNhc2VcbiAgICAgICAgaWYgKHRoaXMuX2lzRGVza3RvcCkge1xuICAgICAgICAgICAgZ2xvYmUubGlzdGVuKEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5NT1VTRV9NT1ZFLCB0aGlzLl9jYWxsYmFja3MubW91c2VNb3ZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JlLmxpc3RlbihHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuQ0VOVEVSX0NIQU5HRUQsIHRoaXMub25HbG9iZU1vdmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRklYTUVcbiAgICAvLyB3ZSBoYW5kbGUgaGVyZSB0aGUgcGFuZWwgZGlzcGxheS4uLiwgYnV0IHRoaXMgaXMgbm90IHJlYWxseSB0aGUgZ29vZFxuICAgIC8vIHBsYWNlIHRvIGRvIGl0Li4uXG4gICAgdGhpcy5fc2V0RWxldmF0aW9uUGFuZWwodGhpcy5vcHRpb25zLmRpc3BsYXlBbHRpdHVkZSk7XG4gICAgdGhpcy5fc2V0Q29vcmRpbmF0ZXNQYW5lbCh0aGlzLm9wdGlvbnMuZGlzcGxheUNvb3JkaW5hdGVzKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5fc2V0U2V0dGluZ3NQYW5lbChmYWxzZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgZXZlbnQgJ2NoYW5nZScgb24gJ0dQbW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW0nXG4gKiB0YWcgc2VsZWN0IChjZi4gdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzRWxlbWVudCksXG4gKiBhbmQgc2VsZWN0cyB0aGUgc3lzdGVtIHByb2plY3Rpb24uXG4gKlxuICogQG1ldGhvZCBvbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uU3lzdGVtQ2hhbmdlXG4gKiBAcGFyYW0ge09iamVjdH0gZSAtIEhUTUxFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICovXG5Nb3VzZVBvc2l0aW9uLnByb3RvdHlwZS5vbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uU3lzdGVtQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaWR4ID0gZS50YXJnZXQuc2VsZWN0ZWRJbmRleDsgLy8gaW5kZXhcbiAgICB2YXIgdmFsdWUgPSBlLnRhcmdldC5vcHRpb25zW2lkeF0udmFsdWU7IC8vIGNyc1xuXG4gICAgdGhpcy5fc2V0Q3VycmVudFN5c3RlbSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIHRoaXMgbWV0aG9kIHNlbGVjdHMgdGhlIGN1cnJlbnQgc3lzdGVtIHByb2plY3Rpb24uXG4gKlxuICogQG1ldGhvZCBfc2V0Q3VycmVudFN5c3RlbVxuICogQHBhcmFtIHtPYmplY3R9IHN5c3RlbUNvZGUgLSBpbm5lciBjb2RlIChyYW5rIGluIGFycmF5IF9wcm9qZWN0aW9uU3lzdGVtcylcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLl9zZXRDdXJyZW50U3lzdGVtID0gZnVuY3Rpb24gKHN5c3RlbUNvZGUpIHtcbiAgICAvLyBpZiB3ZSBjaGFuZ2Ugb2Ygc3lzdGVtIHR5cGUsIHdlIG11c3QgY2hhbmdlIHRoZSB1bml0IHR5cGUgdG9vICFcbiAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5fcHJvamVjdGlvblN5c3RlbXNbaV0uY29kZSA9PT0gc3lzdGVtQ29kZSkge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zW2ldLnR5cGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgICBsb2dnZXIubG9nKFwic3lzdGVtIG5vdCBmb3VuZCBpbiBwcm9qZWN0aW9uIHN5c3RlbXMgY29udGFpbmVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09IHRoaXMuX2N1cnJlbnRQcm9qZWN0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLl9zZXRUeXBlVW5pdHNQYW5lbCh0eXBlKTtcbiAgICB9XG5cbiAgICAvLyByZWdpc3RlcnMgdGhlIGN1cnJlbnQgc3lzdGVtXG4gICAgdGhpcy5fY3VycmVudFByb2plY3Rpb25TeXN0ZW1zID0gdGhpcy5fcHJvamVjdGlvblN5c3RlbXNbTnVtYmVyKHN5c3RlbUNvZGUpXTtcblxuICAgIC8vIHNpbXVsYXRlcyBhIG1vdmVtZW50IGluIHRhY3RpbGUgbW9kZSB0byB1cGRhdGUgdGhlIHJlc3VsdHNcbiAgICBpZiAoIXRoaXMuX2lzRGVza3RvcCkge1xuICAgICAgICB0aGlzLm9uR2xvYmVNb3ZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgZXZlbnQgJ21vdXNlb3Zlcicgb24gJ0dQbW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW0nXG4gKiB0YWcgc2VsZWN0IChjZi4gdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzRWxlbWVudCksXG4gKiBhbmQgc2VsZWN0cyB0aGUgc3lzdGVtIHByb2plY3Rpb24gd2hvc2UgZ2VvQkJveCBpbnRlcnN0ZWN0cyB0aGUgY3VycmVudCB2aWV3IGV4dGVudC5cbiAqXG4gKiBAbWV0aG9kIG9uTW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1Nb3VzZU92ZXJcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLm9uTW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1Nb3VzZU92ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZ2xvYmUgaW5mb3NcbiAgICB2YXIgZ2xvYmUgPSB0aGlzLmdldEdsb2JlKCk7XG4gICAgaWYgKCFnbG9iZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdsb2JlRXh0ZW50ID0gZ2xvYmUuZ2V0RXh0ZW50KCk7XG5cbiAgICAvLyBjbGVhciBzZWxlY3RcbiAgICB2YXIgc3lzdGVtTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1cIikpO1xuICAgIHN5c3RlbUxpc3QuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIHZhciBvcHRpb247XG5cbiAgICAvLyBhZGQgc3lzdGVtcyB3aG9zZSBleHRlbnQgaW50ZXJzZWN0cyB0aGUgZ2xvYmUgZXh0ZW50XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9wcm9qZWN0aW9uU3lzdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvaiA9IHRoaXMuX3Byb2plY3Rpb25TeXN0ZW1zW2pdO1xuICAgICAgICBpZiAocHJvai5nZW9CQm94KSB7XG4gICAgICAgICAgICAvLyBiYm94ZXMgaW50ZXJzZWN0aW9uIHRlc3RcbiAgICAgICAgICAgIGlmIChnbG9iZUV4dGVudC53ZXN0KCkgPiBwcm9qLmdlb0JCb3gucmlnaHQgfHxcbiAgICAgICAgICAgICAgICBnbG9iZUV4dGVudC5zb3V0aCgpID4gcHJvai5nZW9CQm94LnRvcCB8fFxuICAgICAgICAgICAgICAgIGdsb2JlRXh0ZW50LmVhc3QoKSA8IHByb2ouZ2VvQkJveC5sZWZ0IHx8XG4gICAgICAgICAgICAgICAgZ2xvYmVFeHRlbnQubm9ydGgoKSA8IHByb2ouZ2VvQkJveC5ib3R0b21cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9qID09PSB0aGlzLl9jdXJyZW50UHJvamVjdGlvblN5c3RlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gcHJvai5jb2RlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24udGV4dCA9IHByb2oubGFiZWwgfHwgajtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN5c3RlbUxpc3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGRvIG5vdCBpbnRlcnNlY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBwcm9qLmNvZGU7XG4gICAgICAgIG9wdGlvbi50ZXh0ID0gcHJvai5sYWJlbCB8fCBqO1xuICAgICAgICBpZiAocHJvaiA9PT0gdGhpcy5fY3VycmVudFByb2plY3Rpb25TeXN0ZW1zKSB7XG4gICAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN5c3RlbUxpc3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBldmVudCAnY2hhbmdlJyBvbiAnR1Btb3VzZVBvc2l0aW9uUHJvamVjdGlvblVuaXRzJ1xuICogdGFnIHNlbGVjdCAoY2YuIHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQpLFxuICogYW5kIHNlbGVjdHMgdGhlIHVuaXRzIHByb2plY3Rpb24uXG4gKlxuICogQG1ldGhvZCBvbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uVW5pdHNDaGFuZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gSFRNTEVsZW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbk1vdXNlUG9zaXRpb24ucHJvdG90eXBlLm9uTW91c2VQb3NpdGlvblByb2plY3Rpb25Vbml0c0NoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGlkeCA9IGUudGFyZ2V0LnNlbGVjdGVkSW5kZXg7XG4gICAgdmFyIHZhbHVlID0gZS50YXJnZXQub3B0aW9uc1tpZHhdLnZhbHVlO1xuXG4gICAgdGhpcy5fY3VycmVudFByb2plY3Rpb25Vbml0cyA9IHZhbHVlO1xuXG4gICAgLy8gc2ltdWxhdGVzIGEgbW92ZW1lbnQgaW4gdGFjdGlsZSBtb2RlIHRvIHVwZGF0ZSB0aGUgcmVzdWx0c1xuICAgIGlmICghdGhpcy5faXNEZXNrdG9wKSB7XG4gICAgICAgIHRoaXMub25HbG9iZU1vdmUoKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVBvc2l0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9Db250cm9scy9Nb3VzZVBvc2l0aW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.proj4 = factory());\n}(this, (function () { 'use strict';\n\n\tvar globals = function(defs) {\n\t  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n\t  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n\t  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n\t  defs.WGS84 = defs['EPSG:4326'];\n\t  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n\t  defs.GOOGLE = defs['EPSG:3857'];\n\t  defs['EPSG:900913'] = defs['EPSG:3857'];\n\t  defs['EPSG:102113'] = defs['EPSG:3857'];\n\t};\n\n\tvar PJD_3PARAM = 1;\n\tvar PJD_7PARAM = 2;\n\tvar PJD_WGS84 = 4; // WGS84 or equivalent\n\tvar PJD_NODATUM = 5; // WGS84 or equivalent\n\tvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n\tvar HALF_PI = Math.PI/2;\n\t// ellipoid pj_set_ell.c\n\tvar SIXTH = 0.1666666666666666667;\n\t/* 1/6 */\n\tvar RA4 = 0.04722222222222222222;\n\t/* 17/360 */\n\tvar RA6 = 0.02215608465608465608;\n\tvar EPSLN = 1.0e-10;\n\t// you'd think you could use Number.EPSILON above but that makes\n\t// Mollweide get into an infinate loop.\n\n\tvar D2R = 0.01745329251994329577;\n\tvar R2D = 57.29577951308232088;\n\tvar FORTPI = Math.PI/4;\n\tvar TWO_PI = Math.PI * 2;\n\t// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n\t// degree range by a tiny amount don't get wrapped. This prevents points that\n\t// have drifted from their original location along the 180th meridian (due to\n\t// floating point error) from changing their sign.\n\tvar SPI = 3.14159265359;\n\n\tvar exports$1 = {};\n\texports$1.greenwich = 0.0; //\"0dE\",\n\texports$1.lisbon = -9.131906111111; //\"9d07'54.862\\\"W\",\n\texports$1.paris = 2.337229166667; //\"2d20'14.025\\\"E\",\n\texports$1.bogota = -74.080916666667; //\"74d04'51.3\\\"W\",\n\texports$1.madrid = -3.687938888889; //\"3d41'16.58\\\"W\",\n\texports$1.rome = 12.452333333333; //\"12d27'8.4\\\"E\",\n\texports$1.bern = 7.439583333333; //\"7d26'22.5\\\"E\",\n\texports$1.jakarta = 106.807719444444; //\"106d48'27.79\\\"E\",\n\texports$1.ferro = -17.666666666667; //\"17d40'W\",\n\texports$1.brussels = 4.367975; //\"4d22'4.71\\\"E\",\n\texports$1.stockholm = 18.058277777778; //\"18d3'29.8\\\"E\",\n\texports$1.athens = 23.7163375; //\"23d42'58.815\\\"E\",\n\texports$1.oslo = 10.722916666667; //\"10d43'22.5\\\"E\"\n\n\tvar units = {\n\t  ft: {to_meter: 0.3048},\n\t  'us-ft': {to_meter: 1200 / 3937}\n\t};\n\n\tvar ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\n\tfunction match(obj, key) {\n\t  if (obj[key]) {\n\t    return obj[key];\n\t  }\n\t  var keys = Object.keys(obj);\n\t  var lkey = key.toLowerCase().replace(ignoredChar, '');\n\t  var i = -1;\n\t  var testkey, processedKey;\n\t  while (++i < keys.length) {\n\t    testkey = keys[i];\n\t    processedKey = testkey.toLowerCase().replace(ignoredChar, '');\n\t    if (processedKey === lkey) {\n\t      return obj[testkey];\n\t    }\n\t  }\n\t}\n\n\tvar parseProj = function(defData) {\n\t  var self = {};\n\t  var paramObj = defData.split('+').map(function(v) {\n\t    return v.trim();\n\t  }).filter(function(a) {\n\t    return a;\n\t  }).reduce(function(p, a) {\n\t    var split = a.split('=');\n\t    split.push(true);\n\t    p[split[0].toLowerCase()] = split[1];\n\t    return p;\n\t  }, {});\n\t  var paramName, paramVal, paramOutname;\n\t  var params = {\n\t    proj: 'projName',\n\t    datum: 'datumCode',\n\t    rf: function(v) {\n\t      self.rf = parseFloat(v);\n\t    },\n\t    lat_0: function(v) {\n\t      self.lat0 = v * D2R;\n\t    },\n\t    lat_1: function(v) {\n\t      self.lat1 = v * D2R;\n\t    },\n\t    lat_2: function(v) {\n\t      self.lat2 = v * D2R;\n\t    },\n\t    lat_ts: function(v) {\n\t      self.lat_ts = v * D2R;\n\t    },\n\t    lon_0: function(v) {\n\t      self.long0 = v * D2R;\n\t    },\n\t    lon_1: function(v) {\n\t      self.long1 = v * D2R;\n\t    },\n\t    lon_2: function(v) {\n\t      self.long2 = v * D2R;\n\t    },\n\t    alpha: function(v) {\n\t      self.alpha = parseFloat(v) * D2R;\n\t    },\n\t    lonc: function(v) {\n\t      self.longc = v * D2R;\n\t    },\n\t    x_0: function(v) {\n\t      self.x0 = parseFloat(v);\n\t    },\n\t    y_0: function(v) {\n\t      self.y0 = parseFloat(v);\n\t    },\n\t    k_0: function(v) {\n\t      self.k0 = parseFloat(v);\n\t    },\n\t    k: function(v) {\n\t      self.k0 = parseFloat(v);\n\t    },\n\t    a: function(v) {\n\t      self.a = parseFloat(v);\n\t    },\n\t    b: function(v) {\n\t      self.b = parseFloat(v);\n\t    },\n\t    r_a: function() {\n\t      self.R_A = true;\n\t    },\n\t    zone: function(v) {\n\t      self.zone = parseInt(v, 10);\n\t    },\n\t    south: function() {\n\t      self.utmSouth = true;\n\t    },\n\t    towgs84: function(v) {\n\t      self.datum_params = v.split(\",\").map(function(a) {\n\t        return parseFloat(a);\n\t      });\n\t    },\n\t    to_meter: function(v) {\n\t      self.to_meter = parseFloat(v);\n\t    },\n\t    units: function(v) {\n\t      self.units = v;\n\t      var unit = match(units, v);\n\t      if (unit) {\n\t        self.to_meter = unit.to_meter;\n\t      }\n\t    },\n\t    from_greenwich: function(v) {\n\t      self.from_greenwich = v * D2R;\n\t    },\n\t    pm: function(v) {\n\t      var pm = match(exports$1, v);\n\t      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;\n\t    },\n\t    nadgrids: function(v) {\n\t      if (v === '@null') {\n\t        self.datumCode = 'none';\n\t      }\n\t      else {\n\t        self.nadgrids = v;\n\t      }\n\t    },\n\t    axis: function(v) {\n\t      var legalAxis = \"ewnsud\";\n\t      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n\t        self.axis = v;\n\t      }\n\t    }\n\t  };\n\t  for (paramName in paramObj) {\n\t    paramVal = paramObj[paramName];\n\t    if (paramName in params) {\n\t      paramOutname = params[paramName];\n\t      if (typeof paramOutname === 'function') {\n\t        paramOutname(paramVal);\n\t      }\n\t      else {\n\t        self[paramOutname] = paramVal;\n\t      }\n\t    }\n\t    else {\n\t      self[paramName] = paramVal;\n\t    }\n\t  }\n\t  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n\t    self.datumCode = self.datumCode.toLowerCase();\n\t  }\n\t  return self;\n\t};\n\n\tvar NEUTRAL = 1;\n\tvar KEYWORD = 2;\n\tvar NUMBER = 3;\n\tvar QUOTED = 4;\n\tvar AFTERQUOTE = 5;\n\tvar ENDED = -1;\n\tvar whitespace = /\\s/;\n\tvar latin = /[A-Za-z]/;\n\tvar keyword = /[A-Za-z84]/;\n\tvar endThings = /[,\\]]/;\n\tvar digets = /[\\d\\.E\\-\\+]/;\n\t// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\n\tfunction Parser(text) {\n\t  if (typeof text !== 'string') {\n\t    throw new Error('not a string');\n\t  }\n\t  this.text = text.trim();\n\t  this.level = 0;\n\t  this.place = 0;\n\t  this.root = null;\n\t  this.stack = [];\n\t  this.currentObject = null;\n\t  this.state = NEUTRAL;\n\t}\n\tParser.prototype.readCharicter = function() {\n\t  var char = this.text[this.place++];\n\t  if (this.state !== QUOTED) {\n\t    while (whitespace.test(char)) {\n\t      if (this.place >= this.text.length) {\n\t        return;\n\t      }\n\t      char = this.text[this.place++];\n\t    }\n\t  }\n\t  switch (this.state) {\n\t    case NEUTRAL:\n\t      return this.neutral(char);\n\t    case KEYWORD:\n\t      return this.keyword(char)\n\t    case QUOTED:\n\t      return this.quoted(char);\n\t    case AFTERQUOTE:\n\t      return this.afterquote(char);\n\t    case NUMBER:\n\t      return this.number(char);\n\t    case ENDED:\n\t      return;\n\t  }\n\t};\n\tParser.prototype.afterquote = function(char) {\n\t  if (char === '\"') {\n\t    this.word += '\"';\n\t    this.state = QUOTED;\n\t    return;\n\t  }\n\t  if (endThings.test(char)) {\n\t    this.word = this.word.trim();\n\t    this.afterItem(char);\n\t    return;\n\t  }\n\t  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n\t};\n\tParser.prototype.afterItem = function(char) {\n\t  if (char === ',') {\n\t    if (this.word !== null) {\n\t      this.currentObject.push(this.word);\n\t    }\n\t    this.word = null;\n\t    this.state = NEUTRAL;\n\t    return;\n\t  }\n\t  if (char === ']') {\n\t    this.level--;\n\t    if (this.word !== null) {\n\t      this.currentObject.push(this.word);\n\t      this.word = null;\n\t    }\n\t    this.state = NEUTRAL;\n\t    this.currentObject = this.stack.pop();\n\t    if (!this.currentObject) {\n\t      this.state = ENDED;\n\t    }\n\n\t    return;\n\t  }\n\t};\n\tParser.prototype.number = function(char) {\n\t  if (digets.test(char)) {\n\t    this.word += char;\n\t    return;\n\t  }\n\t  if (endThings.test(char)) {\n\t    this.word = parseFloat(this.word);\n\t    this.afterItem(char);\n\t    return;\n\t  }\n\t  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n\t};\n\tParser.prototype.quoted = function(char) {\n\t  if (char === '\"') {\n\t    this.state = AFTERQUOTE;\n\t    return;\n\t  }\n\t  this.word += char;\n\t  return;\n\t};\n\tParser.prototype.keyword = function(char) {\n\t  if (keyword.test(char)) {\n\t    this.word += char;\n\t    return;\n\t  }\n\t  if (char === '[') {\n\t    var newObjects = [];\n\t    newObjects.push(this.word);\n\t    this.level++;\n\t    if (this.root === null) {\n\t      this.root = newObjects;\n\t    } else {\n\t      this.currentObject.push(newObjects);\n\t    }\n\t    this.stack.push(this.currentObject);\n\t    this.currentObject = newObjects;\n\t    this.state = NEUTRAL;\n\t    return;\n\t  }\n\t  if (endThings.test(char)) {\n\t    this.afterItem(char);\n\t    return;\n\t  }\n\t  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n\t};\n\tParser.prototype.neutral = function(char) {\n\t  if (latin.test(char)) {\n\t    this.word = char;\n\t    this.state = KEYWORD;\n\t    return;\n\t  }\n\t  if (char === '\"') {\n\t    this.word = '';\n\t    this.state = QUOTED;\n\t    return;\n\t  }\n\t  if (digets.test(char)) {\n\t    this.word = char;\n\t    this.state = NUMBER;\n\t    return;\n\t  }\n\t  if (endThings.test(char)) {\n\t    this.afterItem(char);\n\t    return;\n\t  }\n\t  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n\t};\n\tParser.prototype.output = function() {\n\t  while (this.place < this.text.length) {\n\t    this.readCharicter();\n\t  }\n\t  if (this.state === ENDED) {\n\t    return this.root;\n\t  }\n\t  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n\t};\n\n\tfunction parseString(txt) {\n\t  var parser = new Parser(txt);\n\t  return parser.output();\n\t}\n\n\tfunction mapit(obj, key, value) {\n\t  if (Array.isArray(key)) {\n\t    value.unshift(key);\n\t    key = null;\n\t  }\n\t  var thing = key ? {} : obj;\n\n\t  var out = value.reduce(function(newObj, item) {\n\t    sExpr(item, newObj);\n\t    return newObj\n\t  }, thing);\n\t  if (key) {\n\t    obj[key] = out;\n\t  }\n\t}\n\n\tfunction sExpr(v, obj) {\n\t  if (!Array.isArray(v)) {\n\t    obj[v] = true;\n\t    return;\n\t  }\n\t  var key = v.shift();\n\t  if (key === 'PARAMETER') {\n\t    key = v.shift();\n\t  }\n\t  if (v.length === 1) {\n\t    if (Array.isArray(v[0])) {\n\t      obj[key] = {};\n\t      sExpr(v[0], obj[key]);\n\t      return;\n\t    }\n\t    obj[key] = v[0];\n\t    return;\n\t  }\n\t  if (!v.length) {\n\t    obj[key] = true;\n\t    return;\n\t  }\n\t  if (key === 'TOWGS84') {\n\t    obj[key] = v;\n\t    return;\n\t  }\n\t  if (!Array.isArray(key)) {\n\t    obj[key] = {};\n\t  }\n\n\t  var i;\n\t  switch (key) {\n\t    case 'UNIT':\n\t    case 'PRIMEM':\n\t    case 'VERT_DATUM':\n\t      obj[key] = {\n\t        name: v[0].toLowerCase(),\n\t        convert: v[1]\n\t      };\n\t      if (v.length === 3) {\n\t        sExpr(v[2], obj[key]);\n\t      }\n\t      return;\n\t    case 'SPHEROID':\n\t    case 'ELLIPSOID':\n\t      obj[key] = {\n\t        name: v[0],\n\t        a: v[1],\n\t        rf: v[2]\n\t      };\n\t      if (v.length === 4) {\n\t        sExpr(v[3], obj[key]);\n\t      }\n\t      return;\n\t    case 'PROJECTEDCRS':\n\t    case 'PROJCRS':\n\t    case 'GEOGCS':\n\t    case 'GEOCCS':\n\t    case 'PROJCS':\n\t    case 'LOCAL_CS':\n\t    case 'GEODCRS':\n\t    case 'GEODETICCRS':\n\t    case 'GEODETICDATUM':\n\t    case 'EDATUM':\n\t    case 'ENGINEERINGDATUM':\n\t    case 'VERT_CS':\n\t    case 'VERTCRS':\n\t    case 'VERTICALCRS':\n\t    case 'COMPD_CS':\n\t    case 'COMPOUNDCRS':\n\t    case 'ENGINEERINGCRS':\n\t    case 'ENGCRS':\n\t    case 'FITTED_CS':\n\t    case 'LOCAL_DATUM':\n\t    case 'DATUM':\n\t      v[0] = ['name', v[0]];\n\t      mapit(obj, key, v);\n\t      return;\n\t    default:\n\t      i = -1;\n\t      while (++i < v.length) {\n\t        if (!Array.isArray(v[i])) {\n\t          return sExpr(v, obj[key]);\n\t        }\n\t      }\n\t      return mapit(obj, key, v);\n\t  }\n\t}\n\n\tvar D2R$1 = 0.01745329251994329577;\n\tfunction rename(obj, params) {\n\t  var outName = params[0];\n\t  var inName = params[1];\n\t  if (!(outName in obj) && (inName in obj)) {\n\t    obj[outName] = obj[inName];\n\t    if (params.length === 3) {\n\t      obj[outName] = params[2](obj[outName]);\n\t    }\n\t  }\n\t}\n\n\tfunction d2r(input) {\n\t  return input * D2R$1;\n\t}\n\n\tfunction cleanWKT(wkt) {\n\t  if (wkt.type === 'GEOGCS') {\n\t    wkt.projName = 'longlat';\n\t  } else if (wkt.type === 'LOCAL_CS') {\n\t    wkt.projName = 'identity';\n\t    wkt.local = true;\n\t  } else {\n\t    if (typeof wkt.PROJECTION === 'object') {\n\t      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n\t    } else {\n\t      wkt.projName = wkt.PROJECTION;\n\t    }\n\t  }\n\t  if (wkt.UNIT) {\n\t    wkt.units = wkt.UNIT.name.toLowerCase();\n\t    if (wkt.units === 'metre') {\n\t      wkt.units = 'meter';\n\t    }\n\t    if (wkt.UNIT.convert) {\n\t      if (wkt.type === 'GEOGCS') {\n\t        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n\t          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n\t        }\n\t      } else {\n\t        wkt.to_meter = wkt.UNIT.convert, 10;\n\t      }\n\t    }\n\t  }\n\t  var geogcs = wkt.GEOGCS;\n\t  if (wkt.type === 'GEOGCS') {\n\t    geogcs = wkt;\n\t  }\n\t  if (geogcs) {\n\t    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n\t    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n\t    //}\n\t    if (geogcs.DATUM) {\n\t      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n\t    } else {\n\t      wkt.datumCode = geogcs.name.toLowerCase();\n\t    }\n\t    if (wkt.datumCode.slice(0, 2) === 'd_') {\n\t      wkt.datumCode = wkt.datumCode.slice(2);\n\t    }\n\t    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n\t      wkt.datumCode = 'nzgd49';\n\t    }\n\t    if (wkt.datumCode === 'wgs_1984') {\n\t      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n\t        wkt.sphere = true;\n\t      }\n\t      wkt.datumCode = 'wgs84';\n\t    }\n\t    if (wkt.datumCode.slice(-6) === '_ferro') {\n\t      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n\t    }\n\t    if (wkt.datumCode.slice(-8) === '_jakarta') {\n\t      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n\t    }\n\t    if (~wkt.datumCode.indexOf('belge')) {\n\t      wkt.datumCode = 'rnb72';\n\t    }\n\t    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n\t      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n\t      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n\t        wkt.ellps = 'intl';\n\t      }\n\n\t      wkt.a = geogcs.DATUM.SPHEROID.a;\n\t      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n\t    }\n\t    if (~wkt.datumCode.indexOf('osgb_1936')) {\n\t      wkt.datumCode = 'osgb36';\n\t    }\n\t    if (~wkt.datumCode.indexOf('osni_1952')) {\n\t      wkt.datumCode = 'osni52';\n\t    }\n\t    if (~wkt.datumCode.indexOf('tm65')\n\t      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n\t      wkt.datumCode = 'ire65';\n\t    }\n\t  }\n\t  if (wkt.b && !isFinite(wkt.b)) {\n\t    wkt.b = wkt.a;\n\t  }\n\n\t  function toMeter(input) {\n\t    var ratio = wkt.to_meter || 1;\n\t    return input * ratio;\n\t  }\n\t  var renamer = function(a) {\n\t    return rename(wkt, a);\n\t  };\n\t  var list = [\n\t    ['standard_parallel_1', 'Standard_Parallel_1'],\n\t    ['standard_parallel_2', 'Standard_Parallel_2'],\n\t    ['false_easting', 'False_Easting'],\n\t    ['false_northing', 'False_Northing'],\n\t    ['central_meridian', 'Central_Meridian'],\n\t    ['latitude_of_origin', 'Latitude_Of_Origin'],\n\t    ['latitude_of_origin', 'Central_Parallel'],\n\t    ['scale_factor', 'Scale_Factor'],\n\t    ['k0', 'scale_factor'],\n\t    ['latitude_of_center', 'Latitude_of_center'],\n\t    ['lat0', 'latitude_of_center', d2r],\n\t    ['longitude_of_center', 'Longitude_Of_Center'],\n\t    ['longc', 'longitude_of_center', d2r],\n\t    ['x0', 'false_easting', toMeter],\n\t    ['y0', 'false_northing', toMeter],\n\t    ['long0', 'central_meridian', d2r],\n\t    ['lat0', 'latitude_of_origin', d2r],\n\t    ['lat0', 'standard_parallel_1', d2r],\n\t    ['lat1', 'standard_parallel_1', d2r],\n\t    ['lat2', 'standard_parallel_2', d2r],\n\t    ['alpha', 'azimuth', d2r],\n\t    ['srsCode', 'name']\n\t  ];\n\t  list.forEach(renamer);\n\t  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n\t    wkt.long0 = wkt.longc;\n\t  }\n\t  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n\t    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n\t    wkt.lat_ts = wkt.lat1;\n\t  }\n\t}\n\tvar wkt = function(wkt) {\n\t  var lisp = parseString(wkt);\n\t  var type = lisp.shift();\n\t  var name = lisp.shift();\n\t  lisp.unshift(['name', name]);\n\t  lisp.unshift(['type', type]);\n\t  var obj = {};\n\t  sExpr(lisp, obj);\n\t  cleanWKT(obj);\n\t  return obj;\n\t};\n\n\tfunction defs(name) {\n\t  /*global console*/\n\t  var that = this;\n\t  if (arguments.length === 2) {\n\t    var def = arguments[1];\n\t    if (typeof def === 'string') {\n\t      if (def.charAt(0) === '+') {\n\t        defs[name] = parseProj(arguments[1]);\n\t      }\n\t      else {\n\t        defs[name] = wkt(arguments[1]);\n\t      }\n\t    } else {\n\t      defs[name] = def;\n\t    }\n\t  }\n\t  else if (arguments.length === 1) {\n\t    if (Array.isArray(name)) {\n\t      return name.map(function(v) {\n\t        if (Array.isArray(v)) {\n\t          defs.apply(that, v);\n\t        }\n\t        else {\n\t          defs(v);\n\t        }\n\t      });\n\t    }\n\t    else if (typeof name === 'string') {\n\t      if (name in defs) {\n\t        return defs[name];\n\t      }\n\t    }\n\t    else if ('EPSG' in name) {\n\t      defs['EPSG:' + name.EPSG] = name;\n\t    }\n\t    else if ('ESRI' in name) {\n\t      defs['ESRI:' + name.ESRI] = name;\n\t    }\n\t    else if ('IAU2000' in name) {\n\t      defs['IAU2000:' + name.IAU2000] = name;\n\t    }\n\t    else {\n\t      console.log(name);\n\t    }\n\t    return;\n\t  }\n\n\n\t}\n\tglobals(defs);\n\n\tfunction testObj(code){\n\t  return typeof code === 'string';\n\t}\n\tfunction testDef(code){\n\t  return code in defs;\n\t}\n\t var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; \n\tfunction testWKT(code){\n\t  return codeWords.some(function (word) {\n\t    return code.indexOf(word) > -1;\n\t  });\n\t}\n\tfunction testProj(code){\n\t  return code[0] === '+';\n\t}\n\tfunction parse(code){\n\t  if (testObj(code)) {\n\t    //check to see if this is a WKT string\n\t    if (testDef(code)) {\n\t      return defs[code];\n\t    }\n\t    if (testWKT(code)) {\n\t      return wkt(code);\n\t    }\n\t    if (testProj(code)) {\n\t      return parseProj(code);\n\t    }\n\t  }else{\n\t    return code;\n\t  }\n\t}\n\n\tvar extend = function(destination, source) {\n\t  destination = destination || {};\n\t  var value, property;\n\t  if (!source) {\n\t    return destination;\n\t  }\n\t  for (property in source) {\n\t    value = source[property];\n\t    if (value !== undefined) {\n\t      destination[property] = value;\n\t    }\n\t  }\n\t  return destination;\n\t};\n\n\tvar msfnz = function(eccent, sinphi, cosphi) {\n\t  var con = eccent * sinphi;\n\t  return cosphi / (Math.sqrt(1 - con * con));\n\t};\n\n\tvar sign = function(x) {\n\t  return x<0 ? -1 : 1;\n\t};\n\n\tvar adjust_lon = function(x) {\n\t  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n\t};\n\n\tvar tsfnz = function(eccent, phi, sinphi) {\n\t  var con = eccent * sinphi;\n\t  var com = 0.5 * eccent;\n\t  con = Math.pow(((1 - con) / (1 + con)), com);\n\t  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n\t};\n\n\tvar phi2z = function(eccent, ts) {\n\t  var eccnth = 0.5 * eccent;\n\t  var con, dphi;\n\t  var phi = HALF_PI - 2 * Math.atan(ts);\n\t  for (var i = 0; i <= 15; i++) {\n\t    con = eccent * Math.sin(phi);\n\t    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n\t    phi += dphi;\n\t    if (Math.abs(dphi) <= 0.0000000001) {\n\t      return phi;\n\t    }\n\t  }\n\t  //console.log(\"phi2z has NoConvergence\");\n\t  return -9999;\n\t};\n\n\tfunction init() {\n\t  var con = this.b / this.a;\n\t  this.es = 1 - con * con;\n\t  if(!('x0' in this)){\n\t    this.x0 = 0;\n\t  }\n\t  if(!('y0' in this)){\n\t    this.y0 = 0;\n\t  }\n\t  this.e = Math.sqrt(this.es);\n\t  if (this.lat_ts) {\n\t    if (this.sphere) {\n\t      this.k0 = Math.cos(this.lat_ts);\n\t    }\n\t    else {\n\t      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n\t    }\n\t  }\n\t  else {\n\t    if (!this.k0) {\n\t      if (this.k) {\n\t        this.k0 = this.k;\n\t      }\n\t      else {\n\t        this.k0 = 1;\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/* Mercator forward equations--mapping lat,long to x,y\n\t  --------------------------------------------------*/\n\n\tfunction forward(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  // convert to radians\n\t  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n\t    return null;\n\t  }\n\n\t  var x, y;\n\t  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n\t    return null;\n\t  }\n\t  else {\n\t    if (this.sphere) {\n\t      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n\t      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n\t    }\n\t    else {\n\t      var sinphi = Math.sin(lat);\n\t      var ts = tsfnz(this.e, lat, sinphi);\n\t      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n\t      y = this.y0 - this.a * this.k0 * Math.log(ts);\n\t    }\n\t    p.x = x;\n\t    p.y = y;\n\t    return p;\n\t  }\n\t}\n\n\t/* Mercator inverse equations--mapping x,y to lat/long\n\t  --------------------------------------------------*/\n\tfunction inverse(p) {\n\n\t  var x = p.x - this.x0;\n\t  var y = p.y - this.y0;\n\t  var lon, lat;\n\n\t  if (this.sphere) {\n\t    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n\t  }\n\t  else {\n\t    var ts = Math.exp(-y / (this.a * this.k0));\n\t    lat = phi2z(this.e, ts);\n\t    if (lat === -9999) {\n\t      return null;\n\t    }\n\t  }\n\t  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$1 = [\"Mercator\", \"Popular Visualisation Pseudo Mercator\", \"Mercator_1SP\", \"Mercator_Auxiliary_Sphere\", \"merc\"];\n\tvar merc = {\n\t  init: init,\n\t  forward: forward,\n\t  inverse: inverse,\n\t  names: names$1\n\t};\n\n\tfunction init$1() {\n\t  //no-op for longlat\n\t}\n\n\tfunction identity(pt) {\n\t  return pt;\n\t}\n\tvar names$2 = [\"longlat\", \"identity\"];\n\tvar longlat = {\n\t  init: init$1,\n\t  forward: identity,\n\t  inverse: identity,\n\t  names: names$2\n\t};\n\n\tvar projs = [merc, longlat];\n\tvar names$$1 = {};\n\tvar projStore = [];\n\n\tfunction add(proj, i) {\n\t  var len = projStore.length;\n\t  if (!proj.names) {\n\t    console.log(i);\n\t    return true;\n\t  }\n\t  projStore[len] = proj;\n\t  proj.names.forEach(function(n) {\n\t    names$$1[n.toLowerCase()] = len;\n\t  });\n\t  return this;\n\t}\n\n\tfunction get(name) {\n\t  if (!name) {\n\t    return false;\n\t  }\n\t  var n = name.toLowerCase();\n\t  if (typeof names$$1[n] !== 'undefined' && projStore[names$$1[n]]) {\n\t    return projStore[names$$1[n]];\n\t  }\n\t}\n\n\tfunction start() {\n\t  projs.forEach(add);\n\t}\n\tvar projections = {\n\t  start: start,\n\t  add: add,\n\t  get: get\n\t};\n\n\tvar exports$2 = {};\n\texports$2.MERIT = {\n\t  a: 6378137.0,\n\t  rf: 298.257,\n\t  ellipseName: \"MERIT 1983\"\n\t};\n\n\texports$2.SGS85 = {\n\t  a: 6378136.0,\n\t  rf: 298.257,\n\t  ellipseName: \"Soviet Geodetic System 85\"\n\t};\n\n\texports$2.GRS80 = {\n\t  a: 6378137.0,\n\t  rf: 298.257222101,\n\t  ellipseName: \"GRS 1980(IUGG, 1980)\"\n\t};\n\n\texports$2.IAU76 = {\n\t  a: 6378140.0,\n\t  rf: 298.257,\n\t  ellipseName: \"IAU 1976\"\n\t};\n\n\texports$2.airy = {\n\t  a: 6377563.396,\n\t  b: 6356256.910,\n\t  ellipseName: \"Airy 1830\"\n\t};\n\n\texports$2.APL4 = {\n\t  a: 6378137,\n\t  rf: 298.25,\n\t  ellipseName: \"Appl. Physics. 1965\"\n\t};\n\n\texports$2.NWL9D = {\n\t  a: 6378145.0,\n\t  rf: 298.25,\n\t  ellipseName: \"Naval Weapons Lab., 1965\"\n\t};\n\n\texports$2.mod_airy = {\n\t  a: 6377340.189,\n\t  b: 6356034.446,\n\t  ellipseName: \"Modified Airy\"\n\t};\n\n\texports$2.andrae = {\n\t  a: 6377104.43,\n\t  rf: 300.0,\n\t  ellipseName: \"Andrae 1876 (Den., Iclnd.)\"\n\t};\n\n\texports$2.aust_SA = {\n\t  a: 6378160.0,\n\t  rf: 298.25,\n\t  ellipseName: \"Australian Natl & S. Amer. 1969\"\n\t};\n\n\texports$2.GRS67 = {\n\t  a: 6378160.0,\n\t  rf: 298.2471674270,\n\t  ellipseName: \"GRS 67(IUGG 1967)\"\n\t};\n\n\texports$2.bessel = {\n\t  a: 6377397.155,\n\t  rf: 299.1528128,\n\t  ellipseName: \"Bessel 1841\"\n\t};\n\n\texports$2.bess_nam = {\n\t  a: 6377483.865,\n\t  rf: 299.1528128,\n\t  ellipseName: \"Bessel 1841 (Namibia)\"\n\t};\n\n\texports$2.clrk66 = {\n\t  a: 6378206.4,\n\t  b: 6356583.8,\n\t  ellipseName: \"Clarke 1866\"\n\t};\n\n\texports$2.clrk80 = {\n\t  a: 6378249.145,\n\t  rf: 293.4663,\n\t  ellipseName: \"Clarke 1880 mod.\"\n\t};\n\n\texports$2.clrk58 = {\n\t  a: 6378293.645208759,\n\t  rf: 294.2606763692654,\n\t  ellipseName: \"Clarke 1858\"\n\t};\n\n\texports$2.CPM = {\n\t  a: 6375738.7,\n\t  rf: 334.29,\n\t  ellipseName: \"Comm. des Poids et Mesures 1799\"\n\t};\n\n\texports$2.delmbr = {\n\t  a: 6376428.0,\n\t  rf: 311.5,\n\t  ellipseName: \"Delambre 1810 (Belgium)\"\n\t};\n\n\texports$2.engelis = {\n\t  a: 6378136.05,\n\t  rf: 298.2566,\n\t  ellipseName: \"Engelis 1985\"\n\t};\n\n\texports$2.evrst30 = {\n\t  a: 6377276.345,\n\t  rf: 300.8017,\n\t  ellipseName: \"Everest 1830\"\n\t};\n\n\texports$2.evrst48 = {\n\t  a: 6377304.063,\n\t  rf: 300.8017,\n\t  ellipseName: \"Everest 1948\"\n\t};\n\n\texports$2.evrst56 = {\n\t  a: 6377301.243,\n\t  rf: 300.8017,\n\t  ellipseName: \"Everest 1956\"\n\t};\n\n\texports$2.evrst69 = {\n\t  a: 6377295.664,\n\t  rf: 300.8017,\n\t  ellipseName: \"Everest 1969\"\n\t};\n\n\texports$2.evrstSS = {\n\t  a: 6377298.556,\n\t  rf: 300.8017,\n\t  ellipseName: \"Everest (Sabah & Sarawak)\"\n\t};\n\n\texports$2.fschr60 = {\n\t  a: 6378166.0,\n\t  rf: 298.3,\n\t  ellipseName: \"Fischer (Mercury Datum) 1960\"\n\t};\n\n\texports$2.fschr60m = {\n\t  a: 6378155.0,\n\t  rf: 298.3,\n\t  ellipseName: \"Fischer 1960\"\n\t};\n\n\texports$2.fschr68 = {\n\t  a: 6378150.0,\n\t  rf: 298.3,\n\t  ellipseName: \"Fischer 1968\"\n\t};\n\n\texports$2.helmert = {\n\t  a: 6378200.0,\n\t  rf: 298.3,\n\t  ellipseName: \"Helmert 1906\"\n\t};\n\n\texports$2.hough = {\n\t  a: 6378270.0,\n\t  rf: 297.0,\n\t  ellipseName: \"Hough\"\n\t};\n\n\texports$2.intl = {\n\t  a: 6378388.0,\n\t  rf: 297.0,\n\t  ellipseName: \"International 1909 (Hayford)\"\n\t};\n\n\texports$2.kaula = {\n\t  a: 6378163.0,\n\t  rf: 298.24,\n\t  ellipseName: \"Kaula 1961\"\n\t};\n\n\texports$2.lerch = {\n\t  a: 6378139.0,\n\t  rf: 298.257,\n\t  ellipseName: \"Lerch 1979\"\n\t};\n\n\texports$2.mprts = {\n\t  a: 6397300.0,\n\t  rf: 191.0,\n\t  ellipseName: \"Maupertius 1738\"\n\t};\n\n\texports$2.new_intl = {\n\t  a: 6378157.5,\n\t  b: 6356772.2,\n\t  ellipseName: \"New International 1967\"\n\t};\n\n\texports$2.plessis = {\n\t  a: 6376523.0,\n\t  rf: 6355863.0,\n\t  ellipseName: \"Plessis 1817 (France)\"\n\t};\n\n\texports$2.krass = {\n\t  a: 6378245.0,\n\t  rf: 298.3,\n\t  ellipseName: \"Krassovsky, 1942\"\n\t};\n\n\texports$2.SEasia = {\n\t  a: 6378155.0,\n\t  b: 6356773.3205,\n\t  ellipseName: \"Southeast Asia\"\n\t};\n\n\texports$2.walbeck = {\n\t  a: 6376896.0,\n\t  b: 6355834.8467,\n\t  ellipseName: \"Walbeck\"\n\t};\n\n\texports$2.WGS60 = {\n\t  a: 6378165.0,\n\t  rf: 298.3,\n\t  ellipseName: \"WGS 60\"\n\t};\n\n\texports$2.WGS66 = {\n\t  a: 6378145.0,\n\t  rf: 298.25,\n\t  ellipseName: \"WGS 66\"\n\t};\n\n\texports$2.WGS7 = {\n\t  a: 6378135.0,\n\t  rf: 298.26,\n\t  ellipseName: \"WGS 72\"\n\t};\n\n\tvar WGS84 = exports$2.WGS84 = {\n\t  a: 6378137.0,\n\t  rf: 298.257223563,\n\t  ellipseName: \"WGS 84\"\n\t};\n\n\texports$2.sphere = {\n\t  a: 6370997.0,\n\t  b: 6370997.0,\n\t  ellipseName: \"Normal Sphere (r=6370997)\"\n\t};\n\n\tfunction eccentricity(a, b, rf, R_A) {\n\t  var a2 = a * a; // used in geocentric\n\t  var b2 = b * b; // used in geocentric\n\t  var es = (a2 - b2) / a2; // e ^ 2\n\t  var e = 0;\n\t  if (R_A) {\n\t    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));\n\t    a2 = a * a;\n\t    es = 0;\n\t  } else {\n\t    e = Math.sqrt(es); // eccentricity\n\t  }\n\t  var ep2 = (a2 - b2) / b2; // used in geocentric\n\t  return {\n\t    es: es,\n\t    e: e,\n\t    ep2: ep2\n\t  };\n\t}\n\tfunction sphere(a, b, rf, ellps, sphere) {\n\t  if (!a) { // do we have an ellipsoid?\n\t    var ellipse = match(exports$2, ellps);\n\t    if (!ellipse) {\n\t      ellipse = WGS84;\n\t    }\n\t    a = ellipse.a;\n\t    b = ellipse.b;\n\t    rf = ellipse.rf;\n\t  }\n\n\t  if (rf && !b) {\n\t    b = (1.0 - 1.0 / rf) * a;\n\t  }\n\t  if (rf === 0 || Math.abs(a - b) < EPSLN) {\n\t    sphere = true;\n\t    b = a;\n\t  }\n\t  return {\n\t    a: a,\n\t    b: b,\n\t    rf: rf,\n\t    sphere: sphere\n\t  };\n\t}\n\n\tvar exports$3 = {};\n\texports$3.wgs84 = {\n\t  towgs84: \"0,0,0\",\n\t  ellipse: \"WGS84\",\n\t  datumName: \"WGS84\"\n\t};\n\n\texports$3.ch1903 = {\n\t  towgs84: \"674.374,15.056,405.346\",\n\t  ellipse: \"bessel\",\n\t  datumName: \"swiss\"\n\t};\n\n\texports$3.ggrs87 = {\n\t  towgs84: \"-199.87,74.79,246.62\",\n\t  ellipse: \"GRS80\",\n\t  datumName: \"Greek_Geodetic_Reference_System_1987\"\n\t};\n\n\texports$3.nad83 = {\n\t  towgs84: \"0,0,0\",\n\t  ellipse: \"GRS80\",\n\t  datumName: \"North_American_Datum_1983\"\n\t};\n\n\texports$3.nad27 = {\n\t  nadgrids: \"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat\",\n\t  ellipse: \"clrk66\",\n\t  datumName: \"North_American_Datum_1927\"\n\t};\n\n\texports$3.potsdam = {\n\t  towgs84: \"606.0,23.0,413.0\",\n\t  ellipse: \"bessel\",\n\t  datumName: \"Potsdam Rauenberg 1950 DHDN\"\n\t};\n\n\texports$3.carthage = {\n\t  towgs84: \"-263.0,6.0,431.0\",\n\t  ellipse: \"clark80\",\n\t  datumName: \"Carthage 1934 Tunisia\"\n\t};\n\n\texports$3.hermannskogel = {\n\t  towgs84: \"653.0,-212.0,449.0\",\n\t  ellipse: \"bessel\",\n\t  datumName: \"Hermannskogel\"\n\t};\n\n\texports$3.osni52 = {\n\t  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n\t  ellipse: \"airy\",\n\t  datumName: \"Irish National\"\n\t};\n\n\texports$3.ire65 = {\n\t  towgs84: \"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15\",\n\t  ellipse: \"mod_airy\",\n\t  datumName: \"Ireland 1965\"\n\t};\n\n\texports$3.rassadiran = {\n\t  towgs84: \"-133.63,-157.5,-158.62\",\n\t  ellipse: \"intl\",\n\t  datumName: \"Rassadiran\"\n\t};\n\n\texports$3.nzgd49 = {\n\t  towgs84: \"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993\",\n\t  ellipse: \"intl\",\n\t  datumName: \"New Zealand Geodetic Datum 1949\"\n\t};\n\n\texports$3.osgb36 = {\n\t  towgs84: \"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894\",\n\t  ellipse: \"airy\",\n\t  datumName: \"Airy 1830\"\n\t};\n\n\texports$3.s_jtsk = {\n\t  towgs84: \"589,76,480\",\n\t  ellipse: 'bessel',\n\t  datumName: 'S-JTSK (Ferro)'\n\t};\n\n\texports$3.beduaram = {\n\t  towgs84: '-106,-87,188',\n\t  ellipse: 'clrk80',\n\t  datumName: 'Beduaram'\n\t};\n\n\texports$3.gunung_segara = {\n\t  towgs84: '-403,684,41',\n\t  ellipse: 'bessel',\n\t  datumName: 'Gunung Segara Jakarta'\n\t};\n\n\texports$3.rnb72 = {\n\t  towgs84: \"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1\",\n\t  ellipse: \"intl\",\n\t  datumName: \"Reseau National Belge 1972\"\n\t};\n\n\tfunction datum(datumCode, datum_params, a, b, es, ep2) {\n\t  var out = {};\n\n\t  if (datumCode === undefined || datumCode === 'none') {\n\t    out.datum_type = PJD_NODATUM;\n\t  } else {\n\t    out.datum_type = PJD_WGS84;\n\t  }\n\n\t  if (datum_params) {\n\t    out.datum_params = datum_params.map(parseFloat);\n\t    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {\n\t      out.datum_type = PJD_3PARAM;\n\t    }\n\t    if (out.datum_params.length > 3) {\n\t      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {\n\t        out.datum_type = PJD_7PARAM;\n\t        out.datum_params[3] *= SEC_TO_RAD;\n\t        out.datum_params[4] *= SEC_TO_RAD;\n\t        out.datum_params[5] *= SEC_TO_RAD;\n\t        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;\n\t      }\n\t    }\n\t  }\n\n\t  out.a = a; //datum object also uses these values\n\t  out.b = b;\n\t  out.es = es;\n\t  out.ep2 = ep2;\n\t  return out;\n\t}\n\n\tfunction Projection$1(srsCode,callback) {\n\t  if (!(this instanceof Projection$1)) {\n\t    return new Projection$1(srsCode);\n\t  }\n\t  callback = callback || function(error){\n\t    if(error){\n\t      throw error;\n\t    }\n\t  };\n\t  var json = parse(srsCode);\n\t  if(typeof json !== 'object'){\n\t    callback(srsCode);\n\t    return;\n\t  }\n\t  var ourProj = Projection$1.projections.get(json.projName);\n\t  if(!ourProj){\n\t    callback(srsCode);\n\t    return;\n\t  }\n\t  if (json.datumCode && json.datumCode !== 'none') {\n\t    var datumDef = match(exports$3, json.datumCode);\n\t    if (datumDef) {\n\t      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n\t      json.ellps = datumDef.ellipse;\n\t      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n\t    }\n\t  }\n\t  json.k0 = json.k0 || 1.0;\n\t  json.axis = json.axis || 'enu';\n\t  json.ellps = json.ellps || 'wgs84';\n\t  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);\n\t  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);\n\t  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);\n\n\t  extend(this, json); // transfer everything over from the projection because we don't know what we'll need\n\t  extend(this, ourProj); // transfer all the methods from the projection\n\n\t  // copy the 4 things over we calulated in deriveConstants.sphere\n\t  this.a = sphere_.a;\n\t  this.b = sphere_.b;\n\t  this.rf = sphere_.rf;\n\t  this.sphere = sphere_.sphere;\n\n\t  // copy the 3 things we calculated in deriveConstants.eccentricity\n\t  this.es = ecc.es;\n\t  this.e = ecc.e;\n\t  this.ep2 = ecc.ep2;\n\n\t  // add in the datum object\n\t  this.datum = datumObj;\n\n\t  // init the projection\n\t  this.init();\n\n\t  // legecy callback from back in the day when it went to spatialreference.org\n\t  callback(null, this);\n\n\t}\n\tProjection$1.projections = projections;\n\tProjection$1.projections.start();\n\n\tfunction compareDatums(source, dest) {\n\t  if (source.datum_type !== dest.datum_type) {\n\t    return false; // false, datums are not equal\n\t  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {\n\t    // the tolerance for es is to ensure that GRS80 and WGS84\n\t    // are considered identical\n\t    return false;\n\t  } else if (source.datum_type === PJD_3PARAM) {\n\t    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);\n\t  } else if (source.datum_type === PJD_7PARAM) {\n\t    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);\n\t  } else {\n\t    return true; // datums are equal\n\t  }\n\t} // cs_compare_datums()\n\n\t/*\n\t * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n\t * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n\t * according to the current ellipsoid parameters.\n\t *\n\t *    Latitude  : Geodetic latitude in radians                     (input)\n\t *    Longitude : Geodetic longitude in radians                    (input)\n\t *    Height    : Geodetic height, in meters                       (input)\n\t *    X         : Calculated Geocentric X coordinate, in meters    (output)\n\t *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n\t *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n\t *\n\t */\n\tfunction geodeticToGeocentric(p, es, a) {\n\t  var Longitude = p.x;\n\t  var Latitude = p.y;\n\t  var Height = p.z ? p.z : 0; //Z value not always supplied\n\n\t  var Rn; /*  Earth radius at location  */\n\t  var Sin_Lat; /*  Math.sin(Latitude)  */\n\t  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n\t  var Cos_Lat; /*  Math.cos(Latitude)  */\n\n\t  /*\n\t   ** Don't blow up if Latitude is just a little out of the value\n\t   ** range as it may just be a rounding issue.  Also removed longitude\n\t   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n\t   */\n\t  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n\t    Latitude = -HALF_PI;\n\t  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n\t    Latitude = HALF_PI;\n\t  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n\t    /* Latitude out of range */\n\t    //..reportError('geocent:lat out of range:' + Latitude);\n\t    return null;\n\t  }\n\n\t  if (Longitude > Math.PI) {\n\t    Longitude -= (2 * Math.PI);\n\t  }\n\t  Sin_Lat = Math.sin(Latitude);\n\t  Cos_Lat = Math.cos(Latitude);\n\t  Sin2_Lat = Sin_Lat * Sin_Lat;\n\t  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));\n\t  return {\n\t    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),\n\t    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),\n\t    z: ((Rn * (1 - es)) + Height) * Sin_Lat\n\t  };\n\t} // cs_geodetic_to_geocentric()\n\n\tfunction geocentricToGeodetic(p, es, a, b) {\n\t  /* local defintions and variables */\n\t  /* end-criterium of loop, accuracy of sin(Latitude) */\n\t  var genau = 1e-12;\n\t  var genau2 = (genau * genau);\n\t  var maxiter = 30;\n\n\t  var P; /* distance between semi-minor axis and location */\n\t  var RR; /* distance between center and location */\n\t  var CT; /* sin of geocentric latitude */\n\t  var ST; /* cos of geocentric latitude */\n\t  var RX;\n\t  var RK;\n\t  var RN; /* Earth radius at location */\n\t  var CPHI0; /* cos of start or old geodetic latitude in iterations */\n\t  var SPHI0; /* sin of start or old geodetic latitude in iterations */\n\t  var CPHI; /* cos of searched geodetic latitude */\n\t  var SPHI; /* sin of searched geodetic latitude */\n\t  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n\t  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n\t  var X = p.x;\n\t  var Y = p.y;\n\t  var Z = p.z ? p.z : 0.0; //Z value not always supplied\n\t  var Longitude;\n\t  var Latitude;\n\t  var Height;\n\n\t  P = Math.sqrt(X * X + Y * Y);\n\t  RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n\t  /*      special cases for latitude and longitude */\n\t  if (P / a < genau) {\n\n\t    /*  special case, if P=0. (X=0., Y=0.) */\n\t    Longitude = 0.0;\n\n\t    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n\t     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n\t    if (RR / a < genau) {\n\t      Latitude = HALF_PI;\n\t      Height = -b;\n\t      return {\n\t        x: p.x,\n\t        y: p.y,\n\t        z: p.z\n\t      };\n\t    }\n\t  } else {\n\t    /*  ellipsoidal (geodetic) longitude\n\t     *  interval: -PI < Longitude <= +PI */\n\t    Longitude = Math.atan2(Y, X);\n\t  }\n\n\t  /* --------------------------------------------------------------\n\t   * Following iterative algorithm was developped by\n\t   * \"Institut for Erdmessung\", University of Hannover, July 1988.\n\t   * Internet: www.ife.uni-hannover.de\n\t   * Iterative computation of CPHI,SPHI and Height.\n\t   * Iteration of CPHI and SPHI to 10**-12 radian resp.\n\t   * 2*10**-7 arcsec.\n\t   * --------------------------------------------------------------\n\t   */\n\t  CT = Z / RR;\n\t  ST = P / RR;\n\t  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);\n\t  CPHI0 = ST * (1.0 - es) * RX;\n\t  SPHI0 = CT * RX;\n\t  iter = 0;\n\n\t  /* loop to find sin(Latitude) resp. Latitude\n\t   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n\t  do {\n\t    iter++;\n\t    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);\n\n\t    /*  ellipsoidal (geodetic) height */\n\t    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);\n\n\t    RK = es * RN / (RN + Height);\n\t    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n\t    CPHI = ST * (1.0 - RK) * RX;\n\t    SPHI = CT * RX;\n\t    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n\t    CPHI0 = CPHI;\n\t    SPHI0 = SPHI;\n\t  }\n\t  while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n\t  /*      ellipsoidal (geodetic) latitude */\n\t  Latitude = Math.atan(SPHI / Math.abs(CPHI));\n\t  return {\n\t    x: Longitude,\n\t    y: Latitude,\n\t    z: Height\n\t  };\n\t} // cs_geocentric_to_geodetic()\n\n\t/****************************************************************/\n\t// pj_geocentic_to_wgs84( p )\n\t//  p = point to transform in geocentric coordinates (x,y,z)\n\n\n\t/** point object, nothing fancy, just allows values to be\n\t    passed back and forth by reference rather than by value.\n\t    Other point classes may be used as long as they have\n\t    x and y properties, which will get modified in the transform method.\n\t*/\n\tfunction geocentricToWgs84(p, datum_type, datum_params) {\n\n\t  if (datum_type === PJD_3PARAM) {\n\t    // if( x[io] === HUGE_VAL )\n\t    //    continue;\n\t    return {\n\t      x: p.x + datum_params[0],\n\t      y: p.y + datum_params[1],\n\t      z: p.z + datum_params[2],\n\t    };\n\t  } else if (datum_type === PJD_7PARAM) {\n\t    var Dx_BF = datum_params[0];\n\t    var Dy_BF = datum_params[1];\n\t    var Dz_BF = datum_params[2];\n\t    var Rx_BF = datum_params[3];\n\t    var Ry_BF = datum_params[4];\n\t    var Rz_BF = datum_params[5];\n\t    var M_BF = datum_params[6];\n\t    // if( x[io] === HUGE_VAL )\n\t    //    continue;\n\t    return {\n\t      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,\n\t      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,\n\t      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF\n\t    };\n\t  }\n\t} // cs_geocentric_to_wgs84\n\n\t/****************************************************************/\n\t// pj_geocentic_from_wgs84()\n\t//  coordinate system definition,\n\t//  point to transform in geocentric coordinates (x,y,z)\n\tfunction geocentricFromWgs84(p, datum_type, datum_params) {\n\n\t  if (datum_type === PJD_3PARAM) {\n\t    //if( x[io] === HUGE_VAL )\n\t    //    continue;\n\t    return {\n\t      x: p.x - datum_params[0],\n\t      y: p.y - datum_params[1],\n\t      z: p.z - datum_params[2],\n\t    };\n\n\t  } else if (datum_type === PJD_7PARAM) {\n\t    var Dx_BF = datum_params[0];\n\t    var Dy_BF = datum_params[1];\n\t    var Dz_BF = datum_params[2];\n\t    var Rx_BF = datum_params[3];\n\t    var Ry_BF = datum_params[4];\n\t    var Rz_BF = datum_params[5];\n\t    var M_BF = datum_params[6];\n\t    var x_tmp = (p.x - Dx_BF) / M_BF;\n\t    var y_tmp = (p.y - Dy_BF) / M_BF;\n\t    var z_tmp = (p.z - Dz_BF) / M_BF;\n\t    //if( x[io] === HUGE_VAL )\n\t    //    continue;\n\n\t    return {\n\t      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,\n\t      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,\n\t      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp\n\t    };\n\t  } //cs_geocentric_from_wgs84()\n\t}\n\n\tfunction checkParams(type) {\n\t  return (type === PJD_3PARAM || type === PJD_7PARAM);\n\t}\n\n\tvar datum_transform = function(source, dest, point) {\n\t  // Short cut if the datums are identical.\n\t  if (compareDatums(source, dest)) {\n\t    return point; // in this case, zero is sucess,\n\t    // whereas cs_compare_datums returns 1 to indicate TRUE\n\t    // confusing, should fix this\n\t  }\n\n\t  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n\t  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n\t    return point;\n\t  }\n\n\t  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n\t  // Do we need to go through geocentric coordinates?\n\t  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n\t    return point;\n\t  }\n\n\t  // Convert to geocentric coordinates.\n\t  point = geodeticToGeocentric(point, source.es, source.a);\n\t  // Convert between datums\n\t  if (checkParams(source.datum_type)) {\n\t    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n\t  }\n\t  if (checkParams(dest.datum_type)) {\n\t    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n\t  }\n\t  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);\n\n\t};\n\n\tvar adjust_axis = function(crs, denorm, point) {\n\t  var xin = point.x,\n\t    yin = point.y,\n\t    zin = point.z || 0.0;\n\t  var v, t, i;\n\t  var out = {};\n\t  for (i = 0; i < 3; i++) {\n\t    if (denorm && i === 2 && point.z === undefined) {\n\t      continue;\n\t    }\n\t    if (i === 0) {\n\t      v = xin;\n\t      t = 'x';\n\t    }\n\t    else if (i === 1) {\n\t      v = yin;\n\t      t = 'y';\n\t    }\n\t    else {\n\t      v = zin;\n\t      t = 'z';\n\t    }\n\t    switch (crs.axis[i]) {\n\t    case 'e':\n\t      out[t] = v;\n\t      break;\n\t    case 'w':\n\t      out[t] = -v;\n\t      break;\n\t    case 'n':\n\t      out[t] = v;\n\t      break;\n\t    case 's':\n\t      out[t] = -v;\n\t      break;\n\t    case 'u':\n\t      if (point[t] !== undefined) {\n\t        out.z = v;\n\t      }\n\t      break;\n\t    case 'd':\n\t      if (point[t] !== undefined) {\n\t        out.z = -v;\n\t      }\n\t      break;\n\t    default:\n\t      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n\t      return null;\n\t    }\n\t  }\n\t  return out;\n\t};\n\n\tvar toPoint = function (array){\n\t  var out = {\n\t    x: array[0],\n\t    y: array[1]\n\t  };\n\t  if (array.length>2) {\n\t    out.z = array[2];\n\t  }\n\t  if (array.length>3) {\n\t    out.m = array[3];\n\t  }\n\t  return out;\n\t};\n\n\tvar checkSanity = function (point) {\n\t  checkCoord(point.x);\n\t  checkCoord(point.y);\n\t};\n\tfunction checkCoord(num) {\n\t  if (typeof Number.isFinite === 'function') {\n\t    if (Number.isFinite(num)) {\n\t      return;\n\t    }\n\t    throw new TypeError('coordinates must be finite numbers');\n\t  }\n\t  if (typeof num !== 'number' || num !== num || !isFinite(num)) {\n\t    throw new TypeError('coordinates must be finite numbers');\n\t  }\n\t}\n\n\tfunction checkNotWGS(source, dest) {\n\t  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n\t}\n\n\tfunction transform(source, dest, point) {\n\t  var wgs84;\n\t  if (Array.isArray(point)) {\n\t    point = toPoint(point);\n\t  }\n\t  checkSanity(point);\n\t  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n\t  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n\t    wgs84 = new Projection$1('WGS84');\n\t    point = transform(source, wgs84, point);\n\t    source = wgs84;\n\t  }\n\t  // DGR, 2010/11/12\n\t  if (source.axis !== 'enu') {\n\t    point = adjust_axis(source, false, point);\n\t  }\n\t  // Transform source points to long/lat, if they aren't already.\n\t  if (source.projName === 'longlat') {\n\t    point = {\n\t      x: point.x * D2R,\n\t      y: point.y * D2R\n\t    };\n\t  }\n\t  else {\n\t    if (source.to_meter) {\n\t      point = {\n\t        x: point.x * source.to_meter,\n\t        y: point.y * source.to_meter\n\t      };\n\t    }\n\t    point = source.inverse(point); // Convert Cartesian to longlat\n\t  }\n\t  // Adjust for the prime meridian if necessary\n\t  if (source.from_greenwich) {\n\t    point.x += source.from_greenwich;\n\t  }\n\n\t  // Convert datums if needed, and if possible.\n\t  point = datum_transform(source.datum, dest.datum, point);\n\n\t  // Adjust for the prime meridian if necessary\n\t  if (dest.from_greenwich) {\n\t    point = {\n\t      x: point.x - dest.from_greenwich,\n\t      y: point.y\n\t    };\n\t  }\n\n\t  if (dest.projName === 'longlat') {\n\t    // convert radians to decimal degrees\n\t    point = {\n\t      x: point.x * R2D,\n\t      y: point.y * R2D\n\t    };\n\t  } else { // else project\n\t    point = dest.forward(point);\n\t    if (dest.to_meter) {\n\t      point = {\n\t        x: point.x / dest.to_meter,\n\t        y: point.y / dest.to_meter\n\t      };\n\t    }\n\t  }\n\n\t  // DGR, 2010/11/12\n\t  if (dest.axis !== 'enu') {\n\t    return adjust_axis(dest, true, point);\n\t  }\n\n\t  return point;\n\t}\n\n\tvar wgs84 = Projection$1('WGS84');\n\n\tfunction transformer(from, to, coords) {\n\t  var transformedArray, out, keys;\n\t  if (Array.isArray(coords)) {\n\t    transformedArray = transform(from, to, coords);\n\t    if (coords.length === 3) {\n\t      return [transformedArray.x, transformedArray.y, transformedArray.z];\n\t    }\n\t    else {\n\t      return [transformedArray.x, transformedArray.y];\n\t    }\n\t  }\n\t  else {\n\t    out = transform(from, to, coords);\n\t    keys = Object.keys(coords);\n\t    if (keys.length === 2) {\n\t      return out;\n\t    }\n\t    keys.forEach(function (key) {\n\t      if (key === 'x' || key === 'y') {\n\t        return;\n\t      }\n\t      out[key] = coords[key];\n\t    });\n\t    return out;\n\t  }\n\t}\n\n\tfunction checkProj(item) {\n\t  if (item instanceof Projection$1) {\n\t    return item;\n\t  }\n\t  if (item.oProj) {\n\t    return item.oProj;\n\t  }\n\t  return Projection$1(item);\n\t}\n\tfunction proj4$1(fromProj, toProj, coord) {\n\t  fromProj = checkProj(fromProj);\n\t  var single = false;\n\t  var obj;\n\t  if (typeof toProj === 'undefined') {\n\t    toProj = fromProj;\n\t    fromProj = wgs84;\n\t    single = true;\n\t  }\n\t  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n\t    coord = toProj;\n\t    toProj = fromProj;\n\t    fromProj = wgs84;\n\t    single = true;\n\t  }\n\t  toProj = checkProj(toProj);\n\t  if (coord) {\n\t    return transformer(fromProj, toProj, coord);\n\t  }\n\t  else {\n\t    obj = {\n\t      forward: function(coords) {\n\t        return transformer(fromProj, toProj, coords);\n\t      },\n\t      inverse: function(coords) {\n\t        return transformer(toProj, fromProj, coords);\n\t      }\n\t    };\n\t    if (single) {\n\t      obj.oProj = toProj;\n\t    }\n\t    return obj;\n\t  }\n\t}\n\n\t/**\n\t * UTM zones are grouped, and assigned to one of a group of 6\n\t * sets.\n\t *\n\t * {int} @private\n\t */\n\tvar NUM_100K_SETS = 6;\n\n\t/**\n\t * The column letters (for easting) of the lower left value, per\n\t * set.\n\t *\n\t * {string} @private\n\t */\n\tvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n\t/**\n\t * The row letters (for northing) of the lower left value, per\n\t * set.\n\t *\n\t * {string} @private\n\t */\n\tvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\n\tvar A = 65; // A\n\tvar I = 73; // I\n\tvar O = 79; // O\n\tvar V = 86; // V\n\tvar Z = 90; // Z\n\tvar mgrs = {\n\t  forward: forward$1,\n\t  inverse: inverse$1,\n\t  toPoint: toPoint$1\n\t};\n\t/**\n\t * Conversion of lat/lon to MGRS.\n\t *\n\t * @param {object} ll Object literal with lat and lon properties on a\n\t *     WGS84 ellipsoid.\n\t * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n\t *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n\t * @return {string} the MGRS string for the given location and accuracy.\n\t */\n\tfunction forward$1(ll, accuracy) {\n\t  accuracy = accuracy || 5; // default accuracy 1m\n\t  return encode(LLtoUTM({\n\t    lat: ll[1],\n\t    lon: ll[0]\n\t  }), accuracy);\n\t}\n\n\t/**\n\t * Conversion of MGRS to lat/lon.\n\t *\n\t * @param {string} mgrs MGRS string.\n\t * @return {array} An array with left (longitude), bottom (latitude), right\n\t *     (longitude) and top (latitude) values in WGS84, representing the\n\t *     bounding box for the provided MGRS reference.\n\t */\n\tfunction inverse$1(mgrs) {\n\t  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n\t  if (bbox.lat && bbox.lon) {\n\t    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n\t  }\n\t  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n\t}\n\n\tfunction toPoint$1(mgrs) {\n\t  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n\t  if (bbox.lat && bbox.lon) {\n\t    return [bbox.lon, bbox.lat];\n\t  }\n\t  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n\t}\n\t/**\n\t * Conversion from degrees to radians.\n\t *\n\t * @private\n\t * @param {number} deg the angle in degrees.\n\t * @return {number} the angle in radians.\n\t */\n\tfunction degToRad(deg) {\n\t  return (deg * (Math.PI / 180.0));\n\t}\n\n\t/**\n\t * Conversion from radians to degrees.\n\t *\n\t * @private\n\t * @param {number} rad the angle in radians.\n\t * @return {number} the angle in degrees.\n\t */\n\tfunction radToDeg(rad) {\n\t  return (180.0 * (rad / Math.PI));\n\t}\n\n\t/**\n\t * Converts a set of Longitude and Latitude co-ordinates to UTM\n\t * using the WGS84 ellipsoid.\n\t *\n\t * @private\n\t * @param {object} ll Object literal with lat and lon properties\n\t *     representing the WGS84 coordinate to be converted.\n\t * @return {object} Object literal containing the UTM value with easting,\n\t *     northing, zoneNumber and zoneLetter properties, and an optional\n\t *     accuracy property in digits. Returns null if the conversion failed.\n\t */\n\tfunction LLtoUTM(ll) {\n\t  var Lat = ll.lat;\n\t  var Long = ll.lon;\n\t  var a = 6378137.0; //ellip.radius;\n\t  var eccSquared = 0.00669438; //ellip.eccsq;\n\t  var k0 = 0.9996;\n\t  var LongOrigin;\n\t  var eccPrimeSquared;\n\t  var N, T, C, A, M;\n\t  var LatRad = degToRad(Lat);\n\t  var LongRad = degToRad(Long);\n\t  var LongOriginRad;\n\t  var ZoneNumber;\n\t  // (int)\n\t  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n\t  //Make sure the longitude 180.00 is in Zone 60\n\t  if (Long === 180) {\n\t    ZoneNumber = 60;\n\t  }\n\n\t  // Special zone for Norway\n\t  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n\t    ZoneNumber = 32;\n\t  }\n\n\t  // Special zones for Svalbard\n\t  if (Lat >= 72.0 && Lat < 84.0) {\n\t    if (Long >= 0.0 && Long < 9.0) {\n\t      ZoneNumber = 31;\n\t    }\n\t    else if (Long >= 9.0 && Long < 21.0) {\n\t      ZoneNumber = 33;\n\t    }\n\t    else if (Long >= 21.0 && Long < 33.0) {\n\t      ZoneNumber = 35;\n\t    }\n\t    else if (Long >= 33.0 && Long < 42.0) {\n\t      ZoneNumber = 37;\n\t    }\n\t  }\n\n\t  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n\t  // in middle of\n\t  // zone\n\t  LongOriginRad = degToRad(LongOrigin);\n\n\t  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n\t  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n\t  T = Math.tan(LatRad) * Math.tan(LatRad);\n\t  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n\t  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n\t  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n\t  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n\t  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n\t  if (Lat < 0.0) {\n\t    UTMNorthing += 10000000.0; //10000000 meter offset for\n\t    // southern hemisphere\n\t  }\n\n\t  return {\n\t    northing: Math.round(UTMNorthing),\n\t    easting: Math.round(UTMEasting),\n\t    zoneNumber: ZoneNumber,\n\t    zoneLetter: getLetterDesignator(Lat)\n\t  };\n\t}\n\n\t/**\n\t * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n\t * class where the Zone can be specified as a single string eg.\"60N\" which\n\t * is then broken down into the ZoneNumber and ZoneLetter.\n\t *\n\t * @private\n\t * @param {object} utm An object literal with northing, easting, zoneNumber\n\t *     and zoneLetter properties. If an optional accuracy property is\n\t *     provided (in meters), a bounding box will be returned instead of\n\t *     latitude and longitude.\n\t * @return {object} An object literal containing either lat and lon values\n\t *     (if no accuracy was provided), or top, right, bottom and left values\n\t *     for the bounding box calculated according to the provided accuracy.\n\t *     Returns null if the conversion failed.\n\t */\n\tfunction UTMtoLL(utm) {\n\n\t  var UTMNorthing = utm.northing;\n\t  var UTMEasting = utm.easting;\n\t  var zoneLetter = utm.zoneLetter;\n\t  var zoneNumber = utm.zoneNumber;\n\t  // check the ZoneNummber is valid\n\t  if (zoneNumber < 0 || zoneNumber > 60) {\n\t    return null;\n\t  }\n\n\t  var k0 = 0.9996;\n\t  var a = 6378137.0; //ellip.radius;\n\t  var eccSquared = 0.00669438; //ellip.eccsq;\n\t  var eccPrimeSquared;\n\t  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n\t  var N1, T1, C1, R1, D, M;\n\t  var LongOrigin;\n\t  var mu, phi1Rad;\n\n\t  // remove 500,000 meter offset for longitude\n\t  var x = UTMEasting - 500000.0;\n\t  var y = UTMNorthing;\n\n\t  // We must know somehow if we are in the Northern or Southern\n\t  // hemisphere, this is the only time we use the letter So even\n\t  // if the Zone letter isn't exactly correct it should indicate\n\t  // the hemisphere correctly\n\t  if (zoneLetter < 'N') {\n\t    y -= 10000000.0; // remove 10,000,000 meter offset used\n\t    // for southern hemisphere\n\t  }\n\n\t  // There are 60 zones with zone 1 being at West -180 to -174\n\t  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n\t  // in middle of\n\t  // zone\n\n\t  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n\t  M = y / k0;\n\t  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n\t  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n\t  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n\t  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n\t  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n\t  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n\t  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n\t  D = x / (N1 * k0);\n\n\t  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n\t  lat = radToDeg(lat);\n\n\t  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n\t  lon = LongOrigin + radToDeg(lon);\n\n\t  var result;\n\t  if (utm.accuracy) {\n\t    var topRight = UTMtoLL({\n\t      northing: utm.northing + utm.accuracy,\n\t      easting: utm.easting + utm.accuracy,\n\t      zoneLetter: utm.zoneLetter,\n\t      zoneNumber: utm.zoneNumber\n\t    });\n\t    result = {\n\t      top: topRight.lat,\n\t      right: topRight.lon,\n\t      bottom: lat,\n\t      left: lon\n\t    };\n\t  }\n\t  else {\n\t    result = {\n\t      lat: lat,\n\t      lon: lon\n\t    };\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Calculates the MGRS letter designator for the given latitude.\n\t *\n\t * @private\n\t * @param {number} lat The latitude in WGS84 to get the letter designator\n\t *     for.\n\t * @return {char} The letter designator.\n\t */\n\tfunction getLetterDesignator(lat) {\n\t  //This is here as an error flag to show that the Latitude is\n\t  //outside MGRS limits\n\t  var LetterDesignator = 'Z';\n\n\t  if ((84 >= lat) && (lat >= 72)) {\n\t    LetterDesignator = 'X';\n\t  }\n\t  else if ((72 > lat) && (lat >= 64)) {\n\t    LetterDesignator = 'W';\n\t  }\n\t  else if ((64 > lat) && (lat >= 56)) {\n\t    LetterDesignator = 'V';\n\t  }\n\t  else if ((56 > lat) && (lat >= 48)) {\n\t    LetterDesignator = 'U';\n\t  }\n\t  else if ((48 > lat) && (lat >= 40)) {\n\t    LetterDesignator = 'T';\n\t  }\n\t  else if ((40 > lat) && (lat >= 32)) {\n\t    LetterDesignator = 'S';\n\t  }\n\t  else if ((32 > lat) && (lat >= 24)) {\n\t    LetterDesignator = 'R';\n\t  }\n\t  else if ((24 > lat) && (lat >= 16)) {\n\t    LetterDesignator = 'Q';\n\t  }\n\t  else if ((16 > lat) && (lat >= 8)) {\n\t    LetterDesignator = 'P';\n\t  }\n\t  else if ((8 > lat) && (lat >= 0)) {\n\t    LetterDesignator = 'N';\n\t  }\n\t  else if ((0 > lat) && (lat >= -8)) {\n\t    LetterDesignator = 'M';\n\t  }\n\t  else if ((-8 > lat) && (lat >= -16)) {\n\t    LetterDesignator = 'L';\n\t  }\n\t  else if ((-16 > lat) && (lat >= -24)) {\n\t    LetterDesignator = 'K';\n\t  }\n\t  else if ((-24 > lat) && (lat >= -32)) {\n\t    LetterDesignator = 'J';\n\t  }\n\t  else if ((-32 > lat) && (lat >= -40)) {\n\t    LetterDesignator = 'H';\n\t  }\n\t  else if ((-40 > lat) && (lat >= -48)) {\n\t    LetterDesignator = 'G';\n\t  }\n\t  else if ((-48 > lat) && (lat >= -56)) {\n\t    LetterDesignator = 'F';\n\t  }\n\t  else if ((-56 > lat) && (lat >= -64)) {\n\t    LetterDesignator = 'E';\n\t  }\n\t  else if ((-64 > lat) && (lat >= -72)) {\n\t    LetterDesignator = 'D';\n\t  }\n\t  else if ((-72 > lat) && (lat >= -80)) {\n\t    LetterDesignator = 'C';\n\t  }\n\t  return LetterDesignator;\n\t}\n\n\t/**\n\t * Encodes a UTM location as MGRS string.\n\t *\n\t * @private\n\t * @param {object} utm An object literal with easting, northing,\n\t *     zoneLetter, zoneNumber\n\t * @param {number} accuracy Accuracy in digits (1-5).\n\t * @return {string} MGRS string for the given UTM location.\n\t */\n\tfunction encode(utm, accuracy) {\n\t  // prepend with leading zeroes\n\t  var seasting = \"00000\" + utm.easting,\n\t    snorthing = \"00000\" + utm.northing;\n\n\t  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n\t}\n\n\t/**\n\t * Get the two letter 100k designator for a given UTM easting,\n\t * northing and zone number value.\n\t *\n\t * @private\n\t * @param {number} easting\n\t * @param {number} northing\n\t * @param {number} zoneNumber\n\t * @return the two letter 100k designator for the given UTM location.\n\t */\n\tfunction get100kID(easting, northing, zoneNumber) {\n\t  var setParm = get100kSetForZone(zoneNumber);\n\t  var setColumn = Math.floor(easting / 100000);\n\t  var setRow = Math.floor(northing / 100000) % 20;\n\t  return getLetter100kID(setColumn, setRow, setParm);\n\t}\n\n\t/**\n\t * Given a UTM zone number, figure out the MGRS 100K set it is in.\n\t *\n\t * @private\n\t * @param {number} i An UTM zone number.\n\t * @return {number} the 100k set the UTM zone is in.\n\t */\n\tfunction get100kSetForZone(i) {\n\t  var setParm = i % NUM_100K_SETS;\n\t  if (setParm === 0) {\n\t    setParm = NUM_100K_SETS;\n\t  }\n\n\t  return setParm;\n\t}\n\n\t/**\n\t * Get the two-letter MGRS 100k designator given information\n\t * translated from the UTM northing, easting and zone number.\n\t *\n\t * @private\n\t * @param {number} column the column index as it relates to the MGRS\n\t *        100k set spreadsheet, created from the UTM easting.\n\t *        Values are 1-8.\n\t * @param {number} row the row index as it relates to the MGRS 100k set\n\t *        spreadsheet, created from the UTM northing value. Values\n\t *        are from 0-19.\n\t * @param {number} parm the set block, as it relates to the MGRS 100k set\n\t *        spreadsheet, created from the UTM zone. Values are from\n\t *        1-60.\n\t * @return two letter MGRS 100k code.\n\t */\n\tfunction getLetter100kID(column, row, parm) {\n\t  // colOrigin and rowOrigin are the letters at the origin of the set\n\t  var index = parm - 1;\n\t  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n\t  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n\t  // colInt and rowInt are the letters to build to return\n\t  var colInt = colOrigin + column - 1;\n\t  var rowInt = rowOrigin + row;\n\t  var rollover = false;\n\n\t  if (colInt > Z) {\n\t    colInt = colInt - Z + A - 1;\n\t    rollover = true;\n\t  }\n\n\t  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n\t    colInt++;\n\t  }\n\n\t  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n\t    colInt++;\n\n\t    if (colInt === I) {\n\t      colInt++;\n\t    }\n\t  }\n\n\t  if (colInt > Z) {\n\t    colInt = colInt - Z + A - 1;\n\t  }\n\n\t  if (rowInt > V) {\n\t    rowInt = rowInt - V + A - 1;\n\t    rollover = true;\n\t  }\n\t  else {\n\t    rollover = false;\n\t  }\n\n\t  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n\t    rowInt++;\n\t  }\n\n\t  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n\t    rowInt++;\n\n\t    if (rowInt === I) {\n\t      rowInt++;\n\t    }\n\t  }\n\n\t  if (rowInt > V) {\n\t    rowInt = rowInt - V + A - 1;\n\t  }\n\n\t  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n\t  return twoLetter;\n\t}\n\n\t/**\n\t * Decode the UTM parameters from a MGRS string.\n\t *\n\t * @private\n\t * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n\t * @return {object} An object literal with easting, northing, zoneLetter,\n\t *     zoneNumber and accuracy (in meters) properties.\n\t */\n\tfunction decode(mgrsString) {\n\n\t  if (mgrsString && mgrsString.length === 0) {\n\t    throw (\"MGRSPoint coverting from nothing\");\n\t  }\n\n\t  var length = mgrsString.length;\n\n\t  var hunK = null;\n\t  var sb = \"\";\n\t  var testChar;\n\t  var i = 0;\n\n\t  // get Zone number\n\t  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n\t    if (i >= 2) {\n\t      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n\t    }\n\t    sb += testChar;\n\t    i++;\n\t  }\n\n\t  var zoneNumber = parseInt(sb, 10);\n\n\t  if (i === 0 || i + 3 > length) {\n\t    // A good MGRS string has to be 4-5 digits long,\n\t    // ##AAA/#AAA at least.\n\t    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n\t  }\n\n\t  var zoneLetter = mgrsString.charAt(i++);\n\n\t  // Should we check the zone letter here? Why not.\n\t  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n\t    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n\t  }\n\n\t  hunK = mgrsString.substring(i, i += 2);\n\n\t  var set = get100kSetForZone(zoneNumber);\n\n\t  var east100k = getEastingFromChar(hunK.charAt(0), set);\n\t  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n\t  // We have a bug where the northing may be 2000000 too low.\n\t  // How\n\t  // do we know when to roll over?\n\n\t  while (north100k < getMinNorthing(zoneLetter)) {\n\t    north100k += 2000000;\n\t  }\n\n\t  // calculate the char index for easting/northing separator\n\t  var remainder = length - i;\n\n\t  if (remainder % 2 !== 0) {\n\t    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n\t  }\n\n\t  var sep = remainder / 2;\n\n\t  var sepEasting = 0.0;\n\t  var sepNorthing = 0.0;\n\t  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n\t  if (sep > 0) {\n\t    accuracyBonus = 100000.0 / Math.pow(10, sep);\n\t    sepEastingString = mgrsString.substring(i, i + sep);\n\t    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n\t    sepNorthingString = mgrsString.substring(i + sep);\n\t    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n\t  }\n\n\t  easting = sepEasting + east100k;\n\t  northing = sepNorthing + north100k;\n\n\t  return {\n\t    easting: easting,\n\t    northing: northing,\n\t    zoneLetter: zoneLetter,\n\t    zoneNumber: zoneNumber,\n\t    accuracy: accuracyBonus\n\t  };\n\t}\n\n\t/**\n\t * Given the first letter from a two-letter MGRS 100k zone, and given the\n\t * MGRS table set for the zone number, figure out the easting value that\n\t * should be added to the other, secondary easting value.\n\t *\n\t * @private\n\t * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n\t * @param {number} set The MGRS table set for the zone number.\n\t * @return {number} The easting value for the given letter and set.\n\t */\n\tfunction getEastingFromChar(e, set) {\n\t  // colOrigin is the letter at the origin of the set for the\n\t  // column\n\t  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n\t  var eastingValue = 100000.0;\n\t  var rewindMarker = false;\n\n\t  while (curCol !== e.charCodeAt(0)) {\n\t    curCol++;\n\t    if (curCol === I) {\n\t      curCol++;\n\t    }\n\t    if (curCol === O) {\n\t      curCol++;\n\t    }\n\t    if (curCol > Z) {\n\t      if (rewindMarker) {\n\t        throw (\"Bad character: \" + e);\n\t      }\n\t      curCol = A;\n\t      rewindMarker = true;\n\t    }\n\t    eastingValue += 100000.0;\n\t  }\n\n\t  return eastingValue;\n\t}\n\n\t/**\n\t * Given the second letter from a two-letter MGRS 100k zone, and given the\n\t * MGRS table set for the zone number, figure out the northing value that\n\t * should be added to the other, secondary northing value. You have to\n\t * remember that Northings are determined from the equator, and the vertical\n\t * cycle of letters mean a 2000000 additional northing meters. This happens\n\t * approx. every 18 degrees of latitude. This method does *NOT* count any\n\t * additional northings. You have to figure out how many 2000000 meters need\n\t * to be added for the zone letter of the MGRS coordinate.\n\t *\n\t * @private\n\t * @param {char} n Second letter of the MGRS 100k zone\n\t * @param {number} set The MGRS table set number, which is dependent on the\n\t *     UTM zone number.\n\t * @return {number} The northing value for the given letter and set.\n\t */\n\tfunction getNorthingFromChar(n, set) {\n\n\t  if (n > 'V') {\n\t    throw (\"MGRSPoint given invalid Northing \" + n);\n\t  }\n\n\t  // rowOrigin is the letter at the origin of the set for the\n\t  // column\n\t  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n\t  var northingValue = 0.0;\n\t  var rewindMarker = false;\n\n\t  while (curRow !== n.charCodeAt(0)) {\n\t    curRow++;\n\t    if (curRow === I) {\n\t      curRow++;\n\t    }\n\t    if (curRow === O) {\n\t      curRow++;\n\t    }\n\t    // fixing a bug making whole application hang in this loop\n\t    // when 'n' is a wrong character\n\t    if (curRow > V) {\n\t      if (rewindMarker) { // making sure that this loop ends\n\t        throw (\"Bad character: \" + n);\n\t      }\n\t      curRow = A;\n\t      rewindMarker = true;\n\t    }\n\t    northingValue += 100000.0;\n\t  }\n\n\t  return northingValue;\n\t}\n\n\t/**\n\t * The function getMinNorthing returns the minimum northing value of a MGRS\n\t * zone.\n\t *\n\t * Ported from Geotrans' c Lattitude_Band_Value structure table.\n\t *\n\t * @private\n\t * @param {char} zoneLetter The MGRS zone to get the min northing for.\n\t * @return {number}\n\t */\n\tfunction getMinNorthing(zoneLetter) {\n\t  var northing;\n\t  switch (zoneLetter) {\n\t  case 'C':\n\t    northing = 1100000.0;\n\t    break;\n\t  case 'D':\n\t    northing = 2000000.0;\n\t    break;\n\t  case 'E':\n\t    northing = 2800000.0;\n\t    break;\n\t  case 'F':\n\t    northing = 3700000.0;\n\t    break;\n\t  case 'G':\n\t    northing = 4600000.0;\n\t    break;\n\t  case 'H':\n\t    northing = 5500000.0;\n\t    break;\n\t  case 'J':\n\t    northing = 6400000.0;\n\t    break;\n\t  case 'K':\n\t    northing = 7300000.0;\n\t    break;\n\t  case 'L':\n\t    northing = 8200000.0;\n\t    break;\n\t  case 'M':\n\t    northing = 9100000.0;\n\t    break;\n\t  case 'N':\n\t    northing = 0.0;\n\t    break;\n\t  case 'P':\n\t    northing = 800000.0;\n\t    break;\n\t  case 'Q':\n\t    northing = 1700000.0;\n\t    break;\n\t  case 'R':\n\t    northing = 2600000.0;\n\t    break;\n\t  case 'S':\n\t    northing = 3500000.0;\n\t    break;\n\t  case 'T':\n\t    northing = 4400000.0;\n\t    break;\n\t  case 'U':\n\t    northing = 5300000.0;\n\t    break;\n\t  case 'V':\n\t    northing = 6200000.0;\n\t    break;\n\t  case 'W':\n\t    northing = 7000000.0;\n\t    break;\n\t  case 'X':\n\t    northing = 7900000.0;\n\t    break;\n\t  default:\n\t    northing = -1.0;\n\t  }\n\t  if (northing >= 0.0) {\n\t    return northing;\n\t  }\n\t  else {\n\t    throw (\"Invalid zone letter: \" + zoneLetter);\n\t  }\n\n\t}\n\n\tfunction Point(x, y, z) {\n\t  if (!(this instanceof Point)) {\n\t    return new Point(x, y, z);\n\t  }\n\t  if (Array.isArray(x)) {\n\t    this.x = x[0];\n\t    this.y = x[1];\n\t    this.z = x[2] || 0.0;\n\t  } else if(typeof x === 'object') {\n\t    this.x = x.x;\n\t    this.y = x.y;\n\t    this.z = x.z || 0.0;\n\t  } else if (typeof x === 'string' && typeof y === 'undefined') {\n\t    var coords = x.split(',');\n\t    this.x = parseFloat(coords[0], 10);\n\t    this.y = parseFloat(coords[1], 10);\n\t    this.z = parseFloat(coords[2], 10) || 0.0;\n\t  } else {\n\t    this.x = x;\n\t    this.y = y;\n\t    this.z = z || 0.0;\n\t  }\n\t  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n\t}\n\n\tPoint.fromMGRS = function(mgrsStr) {\n\t  return new Point(toPoint$1(mgrsStr));\n\t};\n\tPoint.prototype.toMGRS = function(accuracy) {\n\t  return forward$1([this.x, this.y], accuracy);\n\t};\n\n\tvar version = \"2.4.4\";\n\n\tvar C00 = 1;\n\tvar C02 = 0.25;\n\tvar C04 = 0.046875;\n\tvar C06 = 0.01953125;\n\tvar C08 = 0.01068115234375;\n\tvar C22 = 0.75;\n\tvar C44 = 0.46875;\n\tvar C46 = 0.01302083333333333333;\n\tvar C48 = 0.00712076822916666666;\n\tvar C66 = 0.36458333333333333333;\n\tvar C68 = 0.00569661458333333333;\n\tvar C88 = 0.3076171875;\n\n\tvar pj_enfn = function(es) {\n\t  var en = [];\n\t  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n\t  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n\t  var t = es * es;\n\t  en[2] = t * (C44 - es * (C46 + es * C48));\n\t  t *= es;\n\t  en[3] = t * (C66 - es * C68);\n\t  en[4] = t * es * C88;\n\t  return en;\n\t};\n\n\tvar pj_mlfn = function(phi, sphi, cphi, en) {\n\t  cphi *= sphi;\n\t  sphi *= sphi;\n\t  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n\t};\n\n\tvar MAX_ITER = 20;\n\n\tvar pj_inv_mlfn = function(arg, es, en) {\n\t  var k = 1 / (1 - es);\n\t  var phi = arg;\n\t  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n\t    var s = Math.sin(phi);\n\t    var t = 1 - es * s * s;\n\t    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n\t    //phi -= t * (t * Math.sqrt(t)) * k;\n\t    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n\t    phi -= t;\n\t    if (Math.abs(t) < EPSLN) {\n\t      return phi;\n\t    }\n\t  }\n\t  //..reportError(\"cass:pj_inv_mlfn: Convergence error\");\n\t  return phi;\n\t};\n\n\t// Heavily based on this tmerc projection implementation\n\t// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js\n\n\tfunction init$2() {\n\t  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n\t  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n\t  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n\t  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n\t  if (this.es) {\n\t    this.en = pj_enfn(this.es);\n\t    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);\n\t  }\n\t}\n\n\t/**\n\t    Transverse Mercator Forward  - long/lat to x/y\n\t    long/lat in radians\n\t  */\n\tfunction forward$2(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  var delta_lon = adjust_lon(lon - this.long0);\n\t  var con;\n\t  var x, y;\n\t  var sin_phi = Math.sin(lat);\n\t  var cos_phi = Math.cos(lat);\n\n\t  if (!this.es) {\n\t    var b = cos_phi * Math.sin(delta_lon);\n\n\t    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {\n\t      return (93);\n\t    }\n\t    else {\n\t      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;\n\t      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));\n\t      b = Math.abs(y);\n\n\t      if (b >= 1) {\n\t        if ((b - 1) > EPSLN) {\n\t          return (93);\n\t        }\n\t        else {\n\t          y = 0;\n\t        }\n\t      }\n\t      else {\n\t        y = Math.acos(y);\n\t      }\n\n\t      if (lat < 0) {\n\t        y = -y;\n\t      }\n\n\t      y = this.a * this.k0 * (y - this.lat0) + this.y0;\n\t    }\n\t  }\n\t  else {\n\t    var al = cos_phi * delta_lon;\n\t    var als = Math.pow(al, 2);\n\t    var c = this.ep2 * Math.pow(cos_phi, 2);\n\t    var cs = Math.pow(c, 2);\n\t    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;\n\t    var t = Math.pow(tq, 2);\n\t    var ts = Math.pow(t, 2);\n\t    con = 1 - this.es * Math.pow(sin_phi, 2);\n\t    al = al / Math.sqrt(con);\n\t    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);\n\n\t    x = this.a * (this.k0 * al * (1 +\n\t      als / 6 * (1 - t + c +\n\t      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +\n\t      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +\n\t      this.x0;\n\n\t    y = this.a * (this.k0 * (ml - this.ml0 +\n\t      sin_phi * delta_lon * al / 2 * (1 +\n\t      als / 12 * (5 - t + 9 * c + 4 * cs +\n\t      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +\n\t      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +\n\t      this.y0;\n\t  }\n\n\t  p.x = x;\n\t  p.y = y;\n\n\t  return p;\n\t}\n\n\t/**\n\t    Transverse Mercator Inverse  -  x/y to long/lat\n\t  */\n\tfunction inverse$2(p) {\n\t  var con, phi;\n\t  var lat, lon;\n\t  var x = (p.x - this.x0) * (1 / this.a);\n\t  var y = (p.y - this.y0) * (1 / this.a);\n\n\t  if (!this.es) {\n\t    var f = Math.exp(x / this.k0);\n\t    var g = 0.5 * (f - 1 / f);\n\t    var temp = this.lat0 + y / this.k0;\n\t    var h = Math.cos(temp);\n\t    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));\n\t    lat = Math.asin(con);\n\n\t    if (y < 0) {\n\t      lat = -lat;\n\t    }\n\n\t    if ((g === 0) && (h === 0)) {\n\t      lon = 0;\n\t    }\n\t    else {\n\t      lon = adjust_lon(Math.atan2(g, h) + this.long0);\n\t    }\n\t  }\n\t  else { // ellipsoidal form\n\t    con = this.ml0 + y / this.k0;\n\t    phi = pj_inv_mlfn(con, this.es, this.en);\n\n\t    if (Math.abs(phi) < HALF_PI) {\n\t      var sin_phi = Math.sin(phi);\n\t      var cos_phi = Math.cos(phi);\n\t      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;\n\t      var c = this.ep2 * Math.pow(cos_phi, 2);\n\t      var cs = Math.pow(c, 2);\n\t      var t = Math.pow(tan_phi, 2);\n\t      var ts = Math.pow(t, 2);\n\t      con = 1 - this.es * Math.pow(sin_phi, 2);\n\t      var d = x * Math.sqrt(con) / this.k0;\n\t      var ds = Math.pow(d, 2);\n\t      con = con * tan_phi;\n\n\t      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -\n\t        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -\n\t        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -\n\t        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));\n\n\t      lon = adjust_lon(this.long0 + (d * (1 -\n\t        ds / 6 * (1 + 2 * t + c -\n\t        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -\n\t        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));\n\t    }\n\t    else {\n\t      lat = HALF_PI * sign(y);\n\t      lon = 0;\n\t    }\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\n\t  return p;\n\t}\n\n\tvar names$3 = [\"Transverse_Mercator\", \"Transverse Mercator\", \"tmerc\"];\n\tvar tmerc = {\n\t  init: init$2,\n\t  forward: forward$2,\n\t  inverse: inverse$2,\n\t  names: names$3\n\t};\n\n\tvar sinh = function(x) {\n\t  var r = Math.exp(x);\n\t  r = (r - 1 / r) / 2;\n\t  return r;\n\t};\n\n\tvar hypot = function(x, y) {\n\t  x = Math.abs(x);\n\t  y = Math.abs(y);\n\t  var a = Math.max(x, y);\n\t  var b = Math.min(x, y) / (a ? a : 1);\n\n\t  return a * Math.sqrt(1 + Math.pow(b, 2));\n\t};\n\n\tvar log1py = function(x) {\n\t  var y = 1 + x;\n\t  var z = y - 1;\n\n\t  return z === 0 ? x : x * Math.log(y) / z;\n\t};\n\n\tvar asinhy = function(x) {\n\t  var y = Math.abs(x);\n\t  y = log1py(y * (1 + y / (hypot(1, y) + 1)));\n\n\t  return x < 0 ? -y : y;\n\t};\n\n\tvar gatg = function(pp, B) {\n\t  var cos_2B = 2 * Math.cos(2 * B);\n\t  var i = pp.length - 1;\n\t  var h1 = pp[i];\n\t  var h2 = 0;\n\t  var h;\n\n\t  while (--i >= 0) {\n\t    h = -h2 + cos_2B * h1 + pp[i];\n\t    h2 = h1;\n\t    h1 = h;\n\t  }\n\n\t  return (B + h * Math.sin(2 * B));\n\t};\n\n\tvar clens = function(pp, arg_r) {\n\t  var r = 2 * Math.cos(arg_r);\n\t  var i = pp.length - 1;\n\t  var hr1 = pp[i];\n\t  var hr2 = 0;\n\t  var hr;\n\n\t  while (--i >= 0) {\n\t    hr = -hr2 + r * hr1 + pp[i];\n\t    hr2 = hr1;\n\t    hr1 = hr;\n\t  }\n\n\t  return Math.sin(arg_r) * hr;\n\t};\n\n\tvar cosh = function(x) {\n\t  var r = Math.exp(x);\n\t  r = (r + 1 / r) / 2;\n\t  return r;\n\t};\n\n\tvar clens_cmplx = function(pp, arg_r, arg_i) {\n\t  var sin_arg_r = Math.sin(arg_r);\n\t  var cos_arg_r = Math.cos(arg_r);\n\t  var sinh_arg_i = sinh(arg_i);\n\t  var cosh_arg_i = cosh(arg_i);\n\t  var r = 2 * cos_arg_r * cosh_arg_i;\n\t  var i = -2 * sin_arg_r * sinh_arg_i;\n\t  var j = pp.length - 1;\n\t  var hr = pp[j];\n\t  var hi1 = 0;\n\t  var hr1 = 0;\n\t  var hi = 0;\n\t  var hr2;\n\t  var hi2;\n\n\t  while (--j >= 0) {\n\t    hr2 = hr1;\n\t    hi2 = hi1;\n\t    hr1 = hr;\n\t    hi1 = hi;\n\t    hr = -hr2 + r * hr1 - i * hi1 + pp[j];\n\t    hi = -hi2 + i * hr1 + r * hi1;\n\t  }\n\n\t  r = sin_arg_r * cosh_arg_i;\n\t  i = cos_arg_r * sinh_arg_i;\n\n\t  return [r * hr - i * hi, r * hi + i * hr];\n\t};\n\n\t// Heavily based on this etmerc projection implementation\n\t// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js\n\n\tfunction init$3() {\n\t  if (this.es === undefined || this.es <= 0) {\n\t    throw new Error('incorrect elliptical usage');\n\t  }\n\n\t  this.x0 = this.x0 !== undefined ? this.x0 : 0;\n\t  this.y0 = this.y0 !== undefined ? this.y0 : 0;\n\t  this.long0 = this.long0 !== undefined ? this.long0 : 0;\n\t  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;\n\n\t  this.cgb = [];\n\t  this.cbg = [];\n\t  this.utg = [];\n\t  this.gtu = [];\n\n\t  var f = this.es / (1 + Math.sqrt(1 - this.es));\n\t  var n = f / (2 - f);\n\t  var np = n;\n\n\t  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));\n\t  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));\n\n\t  np = np * n;\n\t  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));\n\t  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));\n\n\t  np = np * n;\n\t  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));\n\t  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));\n\n\t  np = np * n;\n\t  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));\n\t  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));\n\n\t  np = np * n;\n\t  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));\n\t  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));\n\n\t  np = np * n;\n\t  this.cgb[5] = np * (601676 / 22275);\n\t  this.cbg[5] = np * (444337 / 155925);\n\n\t  np = Math.pow(n, 2);\n\t  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));\n\n\t  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));\n\t  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));\n\n\t  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));\n\t  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));\n\n\t  np = np * n;\n\t  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));\n\t  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));\n\n\t  np = np * n;\n\t  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));\n\t  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));\n\n\t  np = np * n;\n\t  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));\n\t  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));\n\n\t  np = np * n;\n\t  this.utg[5] = np * (-20648693 / 638668800);\n\t  this.gtu[5] = np * (212378941 / 319334400);\n\n\t  var Z = gatg(this.cbg, this.lat0);\n\t  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));\n\t}\n\n\tfunction forward$3(p) {\n\t  var Ce = adjust_lon(p.x - this.long0);\n\t  var Cn = p.y;\n\n\t  Cn = gatg(this.cbg, Cn);\n\t  var sin_Cn = Math.sin(Cn);\n\t  var cos_Cn = Math.cos(Cn);\n\t  var sin_Ce = Math.sin(Ce);\n\t  var cos_Ce = Math.cos(Ce);\n\n\t  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);\n\t  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));\n\t  Ce = asinhy(Math.tan(Ce));\n\n\t  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);\n\n\t  Cn = Cn + tmp[0];\n\t  Ce = Ce + tmp[1];\n\n\t  var x;\n\t  var y;\n\n\t  if (Math.abs(Ce) <= 2.623395162778) {\n\t    x = this.a * (this.Qn * Ce) + this.x0;\n\t    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;\n\t  }\n\t  else {\n\t    x = Infinity;\n\t    y = Infinity;\n\t  }\n\n\t  p.x = x;\n\t  p.y = y;\n\n\t  return p;\n\t}\n\n\tfunction inverse$3(p) {\n\t  var Ce = (p.x - this.x0) * (1 / this.a);\n\t  var Cn = (p.y - this.y0) * (1 / this.a);\n\n\t  Cn = (Cn - this.Zb) / this.Qn;\n\t  Ce = Ce / this.Qn;\n\n\t  var lon;\n\t  var lat;\n\n\t  if (Math.abs(Ce) <= 2.623395162778) {\n\t    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);\n\n\t    Cn = Cn + tmp[0];\n\t    Ce = Ce + tmp[1];\n\t    Ce = Math.atan(sinh(Ce));\n\n\t    var sin_Cn = Math.sin(Cn);\n\t    var cos_Cn = Math.cos(Cn);\n\t    var sin_Ce = Math.sin(Ce);\n\t    var cos_Ce = Math.cos(Ce);\n\n\t    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));\n\t    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);\n\n\t    lon = adjust_lon(Ce + this.long0);\n\t    lat = gatg(this.cgb, Cn);\n\t  }\n\t  else {\n\t    lon = Infinity;\n\t    lat = Infinity;\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\n\t  return p;\n\t}\n\n\tvar names$4 = [\"Extended_Transverse_Mercator\", \"Extended Transverse Mercator\", \"etmerc\"];\n\tvar etmerc = {\n\t  init: init$3,\n\t  forward: forward$3,\n\t  inverse: inverse$3,\n\t  names: names$4\n\t};\n\n\tvar adjust_zone = function(zone, lon) {\n\t  if (zone === undefined) {\n\t    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;\n\n\t    if (zone < 0) {\n\t      return 0;\n\t    } else if (zone > 60) {\n\t      return 60;\n\t    }\n\t  }\n\t  return zone;\n\t};\n\n\tvar dependsOn = 'etmerc';\n\tfunction init$4() {\n\t  var zone = adjust_zone(this.zone, this.long0);\n\t  if (zone === undefined) {\n\t    throw new Error('unknown utm zone');\n\t  }\n\t  this.lat0 = 0;\n\t  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;\n\t  this.x0 = 500000;\n\t  this.y0 = this.utmSouth ? 10000000 : 0;\n\t  this.k0 = 0.9996;\n\n\t  etmerc.init.apply(this);\n\t  this.forward = etmerc.forward;\n\t  this.inverse = etmerc.inverse;\n\t}\n\n\tvar names$5 = [\"Universal Transverse Mercator System\", \"utm\"];\n\tvar utm = {\n\t  init: init$4,\n\t  names: names$5,\n\t  dependsOn: dependsOn\n\t};\n\n\tvar srat = function(esinp, exp) {\n\t  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n\t};\n\n\tvar MAX_ITER$1 = 20;\n\tfunction init$6() {\n\t  var sphi = Math.sin(this.lat0);\n\t  var cphi = Math.cos(this.lat0);\n\t  cphi *= cphi;\n\t  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n\t  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n\t  this.phic0 = Math.asin(sphi / this.C);\n\t  this.ratexp = 0.5 * this.C * this.e;\n\t  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n\t}\n\n\tfunction forward$5(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n\t  p.x = this.C * lon;\n\t  return p;\n\t}\n\n\tfunction inverse$5(p) {\n\t  var DEL_TOL = 1e-14;\n\t  var lon = p.x / this.C;\n\t  var lat = p.y;\n\t  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n\t  for (var i = MAX_ITER$1; i > 0; --i) {\n\t    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;\n\t    if (Math.abs(lat - p.y) < DEL_TOL) {\n\t      break;\n\t    }\n\t    p.y = lat;\n\t  }\n\t  /* convergence failed */\n\t  if (!i) {\n\t    return null;\n\t  }\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$7 = [\"gauss\"];\n\tvar gauss = {\n\t  init: init$6,\n\t  forward: forward$5,\n\t  inverse: inverse$5,\n\t  names: names$7\n\t};\n\n\tfunction init$5() {\n\t  gauss.init.apply(this);\n\t  if (!this.rc) {\n\t    return;\n\t  }\n\t  this.sinc0 = Math.sin(this.phic0);\n\t  this.cosc0 = Math.cos(this.phic0);\n\t  this.R2 = 2 * this.rc;\n\t  if (!this.title) {\n\t    this.title = \"Oblique Stereographic Alternative\";\n\t  }\n\t}\n\n\tfunction forward$4(p) {\n\t  var sinc, cosc, cosl, k;\n\t  p.x = adjust_lon(p.x - this.long0);\n\t  gauss.forward.apply(this, [p]);\n\t  sinc = Math.sin(p.y);\n\t  cosc = Math.cos(p.y);\n\t  cosl = Math.cos(p.x);\n\t  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n\t  p.x = k * cosc * Math.sin(p.x);\n\t  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n\t  p.x = this.a * p.x + this.x0;\n\t  p.y = this.a * p.y + this.y0;\n\t  return p;\n\t}\n\n\tfunction inverse$4(p) {\n\t  var sinc, cosc, lon, lat, rho;\n\t  p.x = (p.x - this.x0) / this.a;\n\t  p.y = (p.y - this.y0) / this.a;\n\n\t  p.x /= this.k0;\n\t  p.y /= this.k0;\n\t  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n\t    var c = 2 * Math.atan2(rho, this.R2);\n\t    sinc = Math.sin(c);\n\t    cosc = Math.cos(c);\n\t    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n\t    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n\t  }\n\t  else {\n\t    lat = this.phic0;\n\t    lon = 0;\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  gauss.inverse.apply(this, [p]);\n\t  p.x = adjust_lon(p.x + this.long0);\n\t  return p;\n\t}\n\n\tvar names$6 = [\"Stereographic_North_Pole\", \"Oblique_Stereographic\", \"Polar_Stereographic\", \"sterea\",\"Oblique Stereographic Alternative\"];\n\tvar sterea = {\n\t  init: init$5,\n\t  forward: forward$4,\n\t  inverse: inverse$4,\n\t  names: names$6\n\t};\n\n\tfunction ssfn_(phit, sinphi, eccen) {\n\t  sinphi *= eccen;\n\t  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n\t}\n\n\tfunction init$7() {\n\t  this.coslat0 = Math.cos(this.lat0);\n\t  this.sinlat0 = Math.sin(this.lat0);\n\t  if (this.sphere) {\n\t    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n\t      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n\t    }\n\t  }\n\t  else {\n\t    if (Math.abs(this.coslat0) <= EPSLN) {\n\t      if (this.lat0 > 0) {\n\t        //North pole\n\t        //trace('stere:north pole');\n\t        this.con = 1;\n\t      }\n\t      else {\n\t        //South pole\n\t        //trace('stere:south pole');\n\t        this.con = -1;\n\t      }\n\t    }\n\t    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n\t    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n\t      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n\t    }\n\t    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n\t    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n\t    this.cosX0 = Math.cos(this.X0);\n\t    this.sinX0 = Math.sin(this.X0);\n\t  }\n\t}\n\n\t// Stereographic forward equations--mapping lat,long to x,y\n\tfunction forward$6(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var sinlat = Math.sin(lat);\n\t  var coslat = Math.cos(lat);\n\t  var A, X, sinX, cosX, ts, rh;\n\t  var dlon = adjust_lon(lon - this.long0);\n\n\t  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n\t    //case of the origine point\n\t    //trace('stere:this is the origin point');\n\t    p.x = NaN;\n\t    p.y = NaN;\n\t    return p;\n\t  }\n\t  if (this.sphere) {\n\t    //trace('stere:sphere case');\n\t    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n\t    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n\t    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n\t    return p;\n\t  }\n\t  else {\n\t    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n\t    cosX = Math.cos(X);\n\t    sinX = Math.sin(X);\n\t    if (Math.abs(this.coslat0) <= EPSLN) {\n\t      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n\t      rh = 2 * this.a * this.k0 * ts / this.cons;\n\t      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n\t      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n\t      //trace(p.toString());\n\t      return p;\n\t    }\n\t    else if (Math.abs(this.sinlat0) < EPSLN) {\n\t      //Eq\n\t      //trace('stere:equateur');\n\t      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n\t      p.y = A * sinX;\n\t    }\n\t    else {\n\t      //other case\n\t      //trace('stere:normal case');\n\t      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n\t      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n\t    }\n\t    p.x = A * cosX * Math.sin(dlon) + this.x0;\n\t  }\n\t  //trace(p.toString());\n\t  return p;\n\t}\n\n\t//* Stereographic inverse equations--mapping x,y to lat/long\n\tfunction inverse$6(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  var lon, lat, ts, ce, Chi;\n\t  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t  if (this.sphere) {\n\t    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));\n\t    lon = this.long0;\n\t    lat = this.lat0;\n\t    if (rh <= EPSLN) {\n\t      p.x = lon;\n\t      p.y = lat;\n\t      return p;\n\t    }\n\t    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n\t    if (Math.abs(this.coslat0) < EPSLN) {\n\t      if (this.lat0 > 0) {\n\t        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n\t      }\n\t      else {\n\t        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n\t      }\n\t    }\n\t    else {\n\t      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n\t    }\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\t  else {\n\t    if (Math.abs(this.coslat0) <= EPSLN) {\n\t      if (rh <= EPSLN) {\n\t        lat = this.lat0;\n\t        lon = this.long0;\n\t        p.x = lon;\n\t        p.y = lat;\n\t        //trace(p.toString());\n\t        return p;\n\t      }\n\t      p.x *= this.con;\n\t      p.y *= this.con;\n\t      ts = rh * this.cons / (2 * this.a * this.k0);\n\t      lat = this.con * phi2z(this.e, ts);\n\t      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n\t    }\n\t    else {\n\t      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n\t      lon = this.long0;\n\t      if (rh <= EPSLN) {\n\t        Chi = this.X0;\n\t      }\n\t      else {\n\t        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n\t        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n\t      }\n\t      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n\t    }\n\t  }\n\t  p.x = lon;\n\t  p.y = lat;\n\n\t  //trace(p.toString());\n\t  return p;\n\n\t}\n\n\tvar names$8 = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\n\tvar stere = {\n\t  init: init$7,\n\t  forward: forward$6,\n\t  inverse: inverse$6,\n\t  names: names$8,\n\t  ssfn_: ssfn_\n\t};\n\n\t/*\n\t  references:\n\t    Formules et constantes pour le Calcul pour la\n\t    projection cylindrique conforme à axe oblique et pour la transformation entre\n\t    des systèmes de référence.\n\t    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n\t  */\n\n\tfunction init$8() {\n\t  var phy0 = this.lat0;\n\t  this.lambda0 = this.long0;\n\t  var sinPhy0 = Math.sin(phy0);\n\t  var semiMajorAxis = this.a;\n\t  var invF = this.rf;\n\t  var flattening = 1 / invF;\n\t  var e2 = 2 * flattening - Math.pow(flattening, 2);\n\t  var e = this.e = Math.sqrt(e2);\n\t  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n\t  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n\t  this.b0 = Math.asin(sinPhy0 / this.alpha);\n\t  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n\t  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n\t  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n\t  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n\t}\n\n\tfunction forward$7(p) {\n\t  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n\t  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n\t  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n\t  // spheric latitude\n\t  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n\t  // spheric longitude\n\t  var I = this.alpha * (p.x - this.lambda0);\n\n\t  // psoeudo equatorial rotation\n\t  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n\t  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n\t  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n\t  p.x = this.R * rotI + this.x0;\n\t  return p;\n\t}\n\n\tfunction inverse$7(p) {\n\t  var Y = p.x - this.x0;\n\t  var X = p.y - this.y0;\n\n\t  var rotI = Y / this.R;\n\t  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n\t  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n\t  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n\t  var lambda = this.lambda0 + I / this.alpha;\n\n\t  var S = 0;\n\t  var phy = b;\n\t  var prevPhy = -1000;\n\t  var iteration = 0;\n\t  while (Math.abs(phy - prevPhy) > 0.0000001) {\n\t    if (++iteration > 20) {\n\t      //...reportError(\"omercFwdInfinity\");\n\t      return;\n\t    }\n\t    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n\t    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n\t    prevPhy = phy;\n\t    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n\t  }\n\n\t  p.x = lambda;\n\t  p.y = phy;\n\t  return p;\n\t}\n\n\tvar names$9 = [\"somerc\"];\n\tvar somerc = {\n\t  init: init$8,\n\t  forward: forward$7,\n\t  inverse: inverse$7,\n\t  names: names$9\n\t};\n\n\t/* Initialize the Oblique Mercator  projection\n\t    ------------------------------------------*/\n\tfunction init$9() {\n\t  this.no_off = this.no_off || false;\n\t  this.no_rot = this.no_rot || false;\n\n\t  if (isNaN(this.k0)) {\n\t    this.k0 = 1;\n\t  }\n\t  var sinlat = Math.sin(this.lat0);\n\t  var coslat = Math.cos(this.lat0);\n\t  var con = this.e * sinlat;\n\n\t  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n\t  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n\t  var t0 = tsfnz(this.e, this.lat0, sinlat);\n\t  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n\t  if (dl * dl < 1) {\n\t    dl = 1;\n\t  }\n\t  var fl;\n\t  var gl;\n\t  if (!isNaN(this.longc)) {\n\t    //Central point and azimuth method\n\n\t    if (this.lat0 >= 0) {\n\t      fl = dl + Math.sqrt(dl * dl - 1);\n\t    }\n\t    else {\n\t      fl = dl - Math.sqrt(dl * dl - 1);\n\t    }\n\t    this.el = fl * Math.pow(t0, this.bl);\n\t    gl = 0.5 * (fl - 1 / fl);\n\t    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n\t    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n\n\t  }\n\t  else {\n\t    //2 points method\n\t    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));\n\t    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));\n\t    if (this.lat0 >= 0) {\n\t      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n\t    }\n\t    else {\n\t      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n\t    }\n\t    var hl = Math.pow(t1, this.bl);\n\t    var ll = Math.pow(t2, this.bl);\n\t    fl = this.el / hl;\n\t    gl = 0.5 * (fl - 1 / fl);\n\t    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n\t    var pl = (ll - hl) / (ll + hl);\n\t    var dlon12 = adjust_lon(this.long1 - this.long2);\n\t    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;\n\t    this.long0 = adjust_lon(this.long0);\n\t    var dlon10 = adjust_lon(this.long1 - this.long0);\n\t    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);\n\t    this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n\t  }\n\n\t  if (this.no_off) {\n\t    this.uc = 0;\n\t  }\n\t  else {\n\t    if (this.lat0 >= 0) {\n\t      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n\t    }\n\t    else {\n\t      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n\t    }\n\t  }\n\n\t}\n\n\t/* Oblique Mercator forward equations--mapping lat,long to x,y\n\t    ----------------------------------------------------------*/\n\tfunction forward$8(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  var us, vs;\n\t  var con;\n\t  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n\t    if (lat > 0) {\n\t      con = -1;\n\t    }\n\t    else {\n\t      con = 1;\n\t    }\n\t    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));\n\t    us = -1 * con * HALF_PI * this.al / this.bl;\n\t  }\n\t  else {\n\t    var t = tsfnz(this.e, lat, Math.sin(lat));\n\t    var ql = this.el / Math.pow(t, this.bl);\n\t    var sl = 0.5 * (ql - 1 / ql);\n\t    var tl = 0.5 * (ql + 1 / ql);\n\t    var vl = Math.sin(this.bl * (dlon));\n\t    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n\t    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {\n\t      vs = Number.POSITIVE_INFINITY;\n\t    }\n\t    else {\n\t      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n\t    }\n\t    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {\n\t      us = this.al * this.bl * (dlon);\n\t    }\n\t    else {\n\t      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n\t    }\n\t  }\n\n\t  if (this.no_rot) {\n\t    p.x = this.x0 + us;\n\t    p.y = this.y0 + vs;\n\t  }\n\t  else {\n\n\t    us -= this.uc;\n\t    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n\t    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n\t  }\n\t  return p;\n\t}\n\n\tfunction inverse$8(p) {\n\t  var us, vs;\n\t  if (this.no_rot) {\n\t    vs = p.y - this.y0;\n\t    us = p.x - this.x0;\n\t  }\n\t  else {\n\t    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n\t    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n\t    us += this.uc;\n\t  }\n\t  var qp = Math.exp(-1 * this.bl * vs / this.al);\n\t  var sp = 0.5 * (qp - 1 / qp);\n\t  var tp = 0.5 * (qp + 1 / qp);\n\t  var vp = Math.sin(this.bl * us / this.al);\n\t  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n\t  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n\t  if (Math.abs(up - 1) < EPSLN) {\n\t    p.x = this.long0;\n\t    p.y = HALF_PI;\n\t  }\n\t  else if (Math.abs(up + 1) < EPSLN) {\n\t    p.x = this.long0;\n\t    p.y = -1 * HALF_PI;\n\t  }\n\t  else {\n\t    p.y = phi2z(this.e, ts);\n\t    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n\t  }\n\t  return p;\n\t}\n\n\tvar names$10 = [\"Hotine_Oblique_Mercator\", \"Hotine Oblique Mercator\", \"Hotine_Oblique_Mercator_Azimuth_Natural_Origin\", \"Hotine_Oblique_Mercator_Azimuth_Center\", \"omerc\"];\n\tvar omerc = {\n\t  init: init$9,\n\t  forward: forward$8,\n\t  inverse: inverse$8,\n\t  names: names$10\n\t};\n\n\tfunction init$10() {\n\n\t  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n\t  //double c_lat;                   /* center latitude                      */\n\t  //double c_lon;                   /* center longitude                     */\n\t  //double lat1;                    /* first standard parallel              */\n\t  //double lat2;                    /* second standard parallel             */\n\t  //double r_maj;                   /* major axis                           */\n\t  //double r_min;                   /* minor axis                           */\n\t  //double false_east;              /* x offset in meters                   */\n\t  //double false_north;             /* y offset in meters                   */\n\n\t  if (!this.lat2) {\n\t    this.lat2 = this.lat1;\n\t  } //if lat2 is not defined\n\t  if (!this.k0) {\n\t    this.k0 = 1;\n\t  }\n\t  this.x0 = this.x0 || 0;\n\t  this.y0 = this.y0 || 0;\n\t  // Standard Parallels cannot be equal and on opposite sides of the equator\n\t  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n\t    return;\n\t  }\n\n\t  var temp = this.b / this.a;\n\t  this.e = Math.sqrt(1 - temp * temp);\n\n\t  var sin1 = Math.sin(this.lat1);\n\t  var cos1 = Math.cos(this.lat1);\n\t  var ms1 = msfnz(this.e, sin1, cos1);\n\t  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n\t  var sin2 = Math.sin(this.lat2);\n\t  var cos2 = Math.cos(this.lat2);\n\t  var ms2 = msfnz(this.e, sin2, cos2);\n\t  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n\t  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n\t  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n\t    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n\t  }\n\t  else {\n\t    this.ns = sin1;\n\t  }\n\t  if (isNaN(this.ns)) {\n\t    this.ns = sin1;\n\t  }\n\t  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n\t  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n\t  if (!this.title) {\n\t    this.title = \"Lambert Conformal Conic\";\n\t  }\n\t}\n\n\t// Lambert Conformal conic forward equations--mapping lat,long to x,y\n\t// -----------------------------------------------------------------\n\tfunction forward$9(p) {\n\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  // singular cases :\n\t  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n\t    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n\t  }\n\n\t  var con = Math.abs(Math.abs(lat) - HALF_PI);\n\t  var ts, rh1;\n\t  if (con > EPSLN) {\n\t    ts = tsfnz(this.e, lat, Math.sin(lat));\n\t    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n\t  }\n\t  else {\n\t    con = lat * this.ns;\n\t    if (con <= 0) {\n\t      return null;\n\t    }\n\t    rh1 = 0;\n\t  }\n\t  var theta = this.ns * adjust_lon(lon - this.long0);\n\t  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n\t  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n\t  return p;\n\t}\n\n\t// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n\t// -----------------------------------------------------------------\n\tfunction inverse$9(p) {\n\n\t  var rh1, con, ts;\n\t  var lat, lon;\n\t  var x = (p.x - this.x0) / this.k0;\n\t  var y = (this.rh - (p.y - this.y0) / this.k0);\n\t  if (this.ns > 0) {\n\t    rh1 = Math.sqrt(x * x + y * y);\n\t    con = 1;\n\t  }\n\t  else {\n\t    rh1 = -Math.sqrt(x * x + y * y);\n\t    con = -1;\n\t  }\n\t  var theta = 0;\n\t  if (rh1 !== 0) {\n\t    theta = Math.atan2((con * x), (con * y));\n\t  }\n\t  if ((rh1 !== 0) || (this.ns > 0)) {\n\t    con = 1 / this.ns;\n\t    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n\t    lat = phi2z(this.e, ts);\n\t    if (lat === -9999) {\n\t      return null;\n\t    }\n\t  }\n\t  else {\n\t    lat = -HALF_PI;\n\t  }\n\t  lon = adjust_lon(theta / this.ns + this.long0);\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$11 = [\"Lambert Tangential Conformal Conic Projection\", \"Lambert_Conformal_Conic\", \"Lambert_Conformal_Conic_2SP\", \"lcc\"];\n\tvar lcc = {\n\t  init: init$10,\n\t  forward: forward$9,\n\t  inverse: inverse$9,\n\t  names: names$11\n\t};\n\n\tfunction init$11() {\n\t  this.a = 6377397.155;\n\t  this.es = 0.006674372230614;\n\t  this.e = Math.sqrt(this.es);\n\t  if (!this.lat0) {\n\t    this.lat0 = 0.863937979737193;\n\t  }\n\t  if (!this.long0) {\n\t    this.long0 = 0.7417649320975901 - 0.308341501185665;\n\t  }\n\t  /* if scale not set default to 0.9999 */\n\t  if (!this.k0) {\n\t    this.k0 = 0.9999;\n\t  }\n\t  this.s45 = 0.785398163397448; /* 45 */\n\t  this.s90 = 2 * this.s45;\n\t  this.fi0 = this.lat0;\n\t  this.e2 = this.es;\n\t  this.e = Math.sqrt(this.e2);\n\t  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n\t  this.uq = 1.04216856380474;\n\t  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n\t  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n\t  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n\t  this.k1 = this.k0;\n\t  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n\t  this.s0 = 1.37008346281555;\n\t  this.n = Math.sin(this.s0);\n\t  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n\t  this.ad = this.s90 - this.uq;\n\t}\n\n\t/* ellipsoid */\n\t/* calculate xy from lat/lon */\n\t/* Constants, identical to inverse transform function */\n\tfunction forward$10(p) {\n\t  var gfi, u, deltav, s, d, eps, ro;\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var delta_lon = adjust_lon(lon - this.long0);\n\t  /* Transformation */\n\t  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n\t  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n\t  deltav = -delta_lon * this.alfa;\n\t  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n\t  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n\t  eps = this.n * d;\n\t  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n\t  p.y = ro * Math.cos(eps) / 1;\n\t  p.x = ro * Math.sin(eps) / 1;\n\n\t  if (!this.czech) {\n\t    p.y *= -1;\n\t    p.x *= -1;\n\t  }\n\t  return (p);\n\t}\n\n\t/* calculate lat/lon from xy */\n\tfunction inverse$10(p) {\n\t  var u, deltav, s, d, eps, ro, fi1;\n\t  var ok;\n\n\t  /* Transformation */\n\t  /* revert y, x*/\n\t  var tmp = p.x;\n\t  p.x = p.y;\n\t  p.y = tmp;\n\t  if (!this.czech) {\n\t    p.y *= -1;\n\t    p.x *= -1;\n\t  }\n\t  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n\t  eps = Math.atan2(p.y, p.x);\n\t  d = eps / Math.sin(this.s0);\n\t  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n\t  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n\t  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n\t  p.x = this.long0 - deltav / this.alfa;\n\t  fi1 = u;\n\t  ok = 0;\n\t  var iter = 0;\n\t  do {\n\t    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n\t    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n\t      ok = 1;\n\t    }\n\t    fi1 = p.y;\n\t    iter += 1;\n\t  } while (ok === 0 && iter < 15);\n\t  if (iter >= 15) {\n\t    return null;\n\t  }\n\n\t  return (p);\n\t}\n\n\tvar names$12 = [\"Krovak\", \"krovak\"];\n\tvar krovak = {\n\t  init: init$11,\n\t  forward: forward$10,\n\t  inverse: inverse$10,\n\t  names: names$12\n\t};\n\n\tvar mlfn = function(e0, e1, e2, e3, phi) {\n\t  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n\t};\n\n\tvar e0fn = function(x) {\n\t  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n\t};\n\n\tvar e1fn = function(x) {\n\t  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n\t};\n\n\tvar e2fn = function(x) {\n\t  return (0.05859375 * x * x * (1 + 0.75 * x));\n\t};\n\n\tvar e3fn = function(x) {\n\t  return (x * x * x * (35 / 3072));\n\t};\n\n\tvar gN = function(a, e, sinphi) {\n\t  var temp = e * sinphi;\n\t  return a / Math.sqrt(1 - temp * temp);\n\t};\n\n\tvar adjust_lat = function(x) {\n\t  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));\n\t};\n\n\tvar imlfn = function(ml, e0, e1, e2, e3) {\n\t  var phi;\n\t  var dphi;\n\n\t  phi = ml / e0;\n\t  for (var i = 0; i < 15; i++) {\n\t    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n\t    phi += dphi;\n\t    if (Math.abs(dphi) <= 0.0000000001) {\n\t      return phi;\n\t    }\n\t  }\n\n\t  //..reportError(\"IMLFN-CONV:Latitude failed to converge after 15 iterations\");\n\t  return NaN;\n\t};\n\n\tfunction init$12() {\n\t  if (!this.sphere) {\n\t    this.e0 = e0fn(this.es);\n\t    this.e1 = e1fn(this.es);\n\t    this.e2 = e2fn(this.es);\n\t    this.e3 = e3fn(this.es);\n\t    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n\t  }\n\t}\n\n\t/* Cassini forward equations--mapping lat,long to x,y\n\t  -----------------------------------------------------------------------*/\n\tfunction forward$11(p) {\n\n\t  /* Forward equations\n\t      -----------------*/\n\t  var x, y;\n\t  var lam = p.x;\n\t  var phi = p.y;\n\t  lam = adjust_lon(lam - this.long0);\n\n\t  if (this.sphere) {\n\t    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n\t    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n\t  }\n\t  else {\n\t    //ellipsoid\n\t    var sinphi = Math.sin(phi);\n\t    var cosphi = Math.cos(phi);\n\t    var nl = gN(this.a, this.e, sinphi);\n\t    var tl = Math.tan(phi) * Math.tan(phi);\n\t    var al = lam * Math.cos(phi);\n\t    var asq = al * al;\n\t    var cl = this.es * cosphi * cosphi / (1 - this.es);\n\t    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\n\t    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n\t    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n\t  }\n\n\t  p.x = x + this.x0;\n\t  p.y = y + this.y0;\n\t  return p;\n\t}\n\n\t/* Inverse equations\n\t  -----------------*/\n\tfunction inverse$11(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  var x = p.x / this.a;\n\t  var y = p.y / this.a;\n\t  var phi, lam;\n\n\t  if (this.sphere) {\n\t    var dd = y + this.lat0;\n\t    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n\t    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n\t  }\n\t  else {\n\t    /* ellipsoid */\n\t    var ml1 = this.ml0 / this.a + y;\n\t    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n\t    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n\t      p.x = this.long0;\n\t      p.y = HALF_PI;\n\t      if (y < 0) {\n\t        p.y *= -1;\n\t      }\n\t      return p;\n\t    }\n\t    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n\n\t    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n\t    var tl1 = Math.pow(Math.tan(phi1), 2);\n\t    var dl = x * this.a / nl1;\n\t    var dsq = dl * dl;\n\t    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n\t    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n\t  }\n\n\t  p.x = adjust_lon(lam + this.long0);\n\t  p.y = adjust_lat(phi);\n\t  return p;\n\n\t}\n\n\tvar names$13 = [\"Cassini\", \"Cassini_Soldner\", \"cass\"];\n\tvar cass = {\n\t  init: init$12,\n\t  forward: forward$11,\n\t  inverse: inverse$11,\n\t  names: names$13\n\t};\n\n\tvar qsfnz = function(eccent, sinphi) {\n\t  var con;\n\t  if (eccent > 1.0e-7) {\n\t    con = eccent * sinphi;\n\t    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n\t  }\n\t  else {\n\t    return (2 * sinphi);\n\t  }\n\t};\n\n\t/*\n\t  reference\n\t    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n\t    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n\t  */\n\n\tvar S_POLE = 1;\n\n\tvar N_POLE = 2;\n\tvar EQUIT = 3;\n\tvar OBLIQ = 4;\n\n\t/* Initialize the Lambert Azimuthal Equal Area projection\n\t  ------------------------------------------------------*/\n\tfunction init$13() {\n\t  var t = Math.abs(this.lat0);\n\t  if (Math.abs(t - HALF_PI) < EPSLN) {\n\t    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n\t  }\n\t  else if (Math.abs(t) < EPSLN) {\n\t    this.mode = this.EQUIT;\n\t  }\n\t  else {\n\t    this.mode = this.OBLIQ;\n\t  }\n\t  if (this.es > 0) {\n\t    var sinphi;\n\n\t    this.qp = qsfnz(this.e, 1);\n\t    this.mmf = 0.5 / (1 - this.es);\n\t    this.apa = authset(this.es);\n\t    switch (this.mode) {\n\t    case this.N_POLE:\n\t      this.dd = 1;\n\t      break;\n\t    case this.S_POLE:\n\t      this.dd = 1;\n\t      break;\n\t    case this.EQUIT:\n\t      this.rq = Math.sqrt(0.5 * this.qp);\n\t      this.dd = 1 / this.rq;\n\t      this.xmf = 1;\n\t      this.ymf = 0.5 * this.qp;\n\t      break;\n\t    case this.OBLIQ:\n\t      this.rq = Math.sqrt(0.5 * this.qp);\n\t      sinphi = Math.sin(this.lat0);\n\t      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n\t      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n\t      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n\t      this.ymf = (this.xmf = this.rq) / this.dd;\n\t      this.xmf *= this.dd;\n\t      break;\n\t    }\n\t  }\n\t  else {\n\t    if (this.mode === this.OBLIQ) {\n\t      this.sinph0 = Math.sin(this.lat0);\n\t      this.cosph0 = Math.cos(this.lat0);\n\t    }\n\t  }\n\t}\n\n\t/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n\t  -----------------------------------------------------------------------*/\n\tfunction forward$12(p) {\n\n\t  /* Forward equations\n\t      -----------------*/\n\t  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n\t  var lam = p.x;\n\t  var phi = p.y;\n\n\t  lam = adjust_lon(lam - this.long0);\n\t  if (this.sphere) {\n\t    sinphi = Math.sin(phi);\n\t    cosphi = Math.cos(phi);\n\t    coslam = Math.cos(lam);\n\t    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n\t      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n\t      if (y <= EPSLN) {\n\t        return null;\n\t      }\n\t      y = Math.sqrt(2 / y);\n\t      x = y * cosphi * Math.sin(lam);\n\t      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n\t    }\n\t    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n\t      if (this.mode === this.N_POLE) {\n\t        coslam = -coslam;\n\t      }\n\t      if (Math.abs(phi + this.phi0) < EPSLN) {\n\t        return null;\n\t      }\n\t      y = FORTPI - phi * 0.5;\n\t      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n\t      x = y * Math.sin(lam);\n\t      y *= coslam;\n\t    }\n\t  }\n\t  else {\n\t    sinb = 0;\n\t    cosb = 0;\n\t    b = 0;\n\t    coslam = Math.cos(lam);\n\t    sinlam = Math.sin(lam);\n\t    sinphi = Math.sin(phi);\n\t    q = qsfnz(this.e, sinphi);\n\t    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n\t      sinb = q / this.qp;\n\t      cosb = Math.sqrt(1 - sinb * sinb);\n\t    }\n\t    switch (this.mode) {\n\t    case this.OBLIQ:\n\t      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n\t      break;\n\t    case this.EQUIT:\n\t      b = 1 + cosb * coslam;\n\t      break;\n\t    case this.N_POLE:\n\t      b = HALF_PI + phi;\n\t      q = this.qp - q;\n\t      break;\n\t    case this.S_POLE:\n\t      b = phi - HALF_PI;\n\t      q = this.qp + q;\n\t      break;\n\t    }\n\t    if (Math.abs(b) < EPSLN) {\n\t      return null;\n\t    }\n\t    switch (this.mode) {\n\t    case this.OBLIQ:\n\t    case this.EQUIT:\n\t      b = Math.sqrt(2 / b);\n\t      if (this.mode === this.OBLIQ) {\n\t        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n\t      }\n\t      else {\n\t        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n\t      }\n\t      x = this.xmf * b * cosb * sinlam;\n\t      break;\n\t    case this.N_POLE:\n\t    case this.S_POLE:\n\t      if (q >= 0) {\n\t        x = (b = Math.sqrt(q)) * sinlam;\n\t        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n\t      }\n\t      else {\n\t        x = y = 0;\n\t      }\n\t      break;\n\t    }\n\t  }\n\n\t  p.x = this.a * x + this.x0;\n\t  p.y = this.a * y + this.y0;\n\t  return p;\n\t}\n\n\t/* Inverse equations\n\t  -----------------*/\n\tfunction inverse$12(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  var x = p.x / this.a;\n\t  var y = p.y / this.a;\n\t  var lam, phi, cCe, sCe, q, rho, ab;\n\t  if (this.sphere) {\n\t    var cosz = 0,\n\t      rh, sinz = 0;\n\n\t    rh = Math.sqrt(x * x + y * y);\n\t    phi = rh * 0.5;\n\t    if (phi > 1) {\n\t      return null;\n\t    }\n\t    phi = 2 * Math.asin(phi);\n\t    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n\t      sinz = Math.sin(phi);\n\t      cosz = Math.cos(phi);\n\t    }\n\t    switch (this.mode) {\n\t    case this.EQUIT:\n\t      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n\t      x *= sinz;\n\t      y = cosz * rh;\n\t      break;\n\t    case this.OBLIQ:\n\t      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n\t      x *= sinz * this.cosph0;\n\t      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n\t      break;\n\t    case this.N_POLE:\n\t      y = -y;\n\t      phi = HALF_PI - phi;\n\t      break;\n\t    case this.S_POLE:\n\t      phi -= HALF_PI;\n\t      break;\n\t    }\n\t    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n\t  }\n\t  else {\n\t    ab = 0;\n\t    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n\t      x /= this.dd;\n\t      y *= this.dd;\n\t      rho = Math.sqrt(x * x + y * y);\n\t      if (rho < EPSLN) {\n\t        p.x = 0;\n\t        p.y = this.phi0;\n\t        return p;\n\t      }\n\t      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n\t      cCe = Math.cos(sCe);\n\t      x *= (sCe = Math.sin(sCe));\n\t      if (this.mode === this.OBLIQ) {\n\t        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n\t        q = this.qp * ab;\n\t        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n\t      }\n\t      else {\n\t        ab = y * sCe / rho;\n\t        q = this.qp * ab;\n\t        y = rho * cCe;\n\t      }\n\t    }\n\t    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n\t      if (this.mode === this.N_POLE) {\n\t        y = -y;\n\t      }\n\t      q = (x * x + y * y);\n\t      if (!q) {\n\t        p.x = 0;\n\t        p.y = this.phi0;\n\t        return p;\n\t      }\n\t      ab = 1 - q / this.qp;\n\t      if (this.mode === this.S_POLE) {\n\t        ab = -ab;\n\t      }\n\t    }\n\t    lam = Math.atan2(x, y);\n\t    phi = authlat(Math.asin(ab), this.apa);\n\t  }\n\n\t  p.x = adjust_lon(this.long0 + lam);\n\t  p.y = phi;\n\t  return p;\n\t}\n\n\t/* determine latitude from authalic latitude */\n\tvar P00 = 0.33333333333333333333;\n\n\tvar P01 = 0.17222222222222222222;\n\tvar P02 = 0.10257936507936507936;\n\tvar P10 = 0.06388888888888888888;\n\tvar P11 = 0.06640211640211640211;\n\tvar P20 = 0.01641501294219154443;\n\n\tfunction authset(es) {\n\t  var t;\n\t  var APA = [];\n\t  APA[0] = es * P00;\n\t  t = es * es;\n\t  APA[0] += t * P01;\n\t  APA[1] = t * P10;\n\t  t *= es;\n\t  APA[0] += t * P02;\n\t  APA[1] += t * P11;\n\t  APA[2] = t * P20;\n\t  return APA;\n\t}\n\n\tfunction authlat(beta, APA) {\n\t  var t = beta + beta;\n\t  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n\t}\n\n\tvar names$14 = [\"Lambert Azimuthal Equal Area\", \"Lambert_Azimuthal_Equal_Area\", \"laea\"];\n\tvar laea = {\n\t  init: init$13,\n\t  forward: forward$12,\n\t  inverse: inverse$12,\n\t  names: names$14,\n\t  S_POLE: S_POLE,\n\t  N_POLE: N_POLE,\n\t  EQUIT: EQUIT,\n\t  OBLIQ: OBLIQ\n\t};\n\n\tvar asinz = function(x) {\n\t  if (Math.abs(x) > 1) {\n\t    x = (x > 1) ? 1 : -1;\n\t  }\n\t  return Math.asin(x);\n\t};\n\n\tfunction init$14() {\n\n\t  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n\t    return;\n\t  }\n\t  this.temp = this.b / this.a;\n\t  this.es = 1 - Math.pow(this.temp, 2);\n\t  this.e3 = Math.sqrt(this.es);\n\n\t  this.sin_po = Math.sin(this.lat1);\n\t  this.cos_po = Math.cos(this.lat1);\n\t  this.t1 = this.sin_po;\n\t  this.con = this.sin_po;\n\t  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n\t  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n\t  this.sin_po = Math.sin(this.lat2);\n\t  this.cos_po = Math.cos(this.lat2);\n\t  this.t2 = this.sin_po;\n\t  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n\t  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n\t  this.sin_po = Math.sin(this.lat0);\n\t  this.cos_po = Math.cos(this.lat0);\n\t  this.t3 = this.sin_po;\n\t  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n\t  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n\t    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n\t  }\n\t  else {\n\t    this.ns0 = this.con;\n\t  }\n\t  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n\t  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n\t}\n\n\t/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n\t  -------------------------------------------------------------------*/\n\tfunction forward$13(p) {\n\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  this.sin_phi = Math.sin(lat);\n\t  this.cos_phi = Math.cos(lat);\n\n\t  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n\t  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n\t  var theta = this.ns0 * adjust_lon(lon - this.long0);\n\t  var x = rh1 * Math.sin(theta) + this.x0;\n\t  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\tfunction inverse$13(p) {\n\t  var rh1, qs, con, theta, lon, lat;\n\n\t  p.x -= this.x0;\n\t  p.y = this.rh - p.y + this.y0;\n\t  if (this.ns0 >= 0) {\n\t    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n\t    con = 1;\n\t  }\n\t  else {\n\t    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n\t    con = -1;\n\t  }\n\t  theta = 0;\n\t  if (rh1 !== 0) {\n\t    theta = Math.atan2(con * p.x, con * p.y);\n\t  }\n\t  con = rh1 * this.ns0 / this.a;\n\t  if (this.sphere) {\n\t    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n\t  }\n\t  else {\n\t    qs = (this.c - con * con) / this.ns0;\n\t    lat = this.phi1z(this.e3, qs);\n\t  }\n\n\t  lon = adjust_lon(theta / this.ns0 + this.long0);\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\t/* Function to compute phi1, the latitude for the inverse of the\n\t   Albers Conical Equal-Area projection.\n\t-------------------------------------------*/\n\tfunction phi1z(eccent, qs) {\n\t  var sinphi, cosphi, con, com, dphi;\n\t  var phi = asinz(0.5 * qs);\n\t  if (eccent < EPSLN) {\n\t    return phi;\n\t  }\n\n\t  var eccnts = eccent * eccent;\n\t  for (var i = 1; i <= 25; i++) {\n\t    sinphi = Math.sin(phi);\n\t    cosphi = Math.cos(phi);\n\t    con = eccent * sinphi;\n\t    com = 1 - con * con;\n\t    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n\t    phi = phi + dphi;\n\t    if (Math.abs(dphi) <= 1e-7) {\n\t      return phi;\n\t    }\n\t  }\n\t  return null;\n\t}\n\n\tvar names$15 = [\"Albers_Conic_Equal_Area\", \"Albers\", \"aea\"];\n\tvar aea = {\n\t  init: init$14,\n\t  forward: forward$13,\n\t  inverse: inverse$13,\n\t  names: names$15,\n\t  phi1z: phi1z\n\t};\n\n\t/*\n\t  reference:\n\t    Wolfram Mathworld \"Gnomonic Projection\"\n\t    http://mathworld.wolfram.com/GnomonicProjection.html\n\t    Accessed: 12th November 2009\n\t  */\n\tfunction init$15() {\n\n\t  /* Place parameters in static storage for common use\n\t      -------------------------------------------------*/\n\t  this.sin_p14 = Math.sin(this.lat0);\n\t  this.cos_p14 = Math.cos(this.lat0);\n\t  // Approximation for projecting points to the horizon (infinity)\n\t  this.infinity_dist = 1000 * this.a;\n\t  this.rc = 1;\n\t}\n\n\t/* Gnomonic forward equations--mapping lat,long to x,y\n\t    ---------------------------------------------------*/\n\tfunction forward$14(p) {\n\t  var sinphi, cosphi; /* sin and cos value        */\n\t  var dlon; /* delta longitude value      */\n\t  var coslon; /* cos of longitude        */\n\t  var ksp; /* scale factor          */\n\t  var g;\n\t  var x, y;\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  /* Forward equations\n\t      -----------------*/\n\t  dlon = adjust_lon(lon - this.long0);\n\n\t  sinphi = Math.sin(lat);\n\t  cosphi = Math.cos(lat);\n\n\t  coslon = Math.cos(dlon);\n\t  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n\t  ksp = 1;\n\t  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n\t    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n\t    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n\t  }\n\t  else {\n\n\t    // Point is in the opposing hemisphere and is unprojectable\n\t    // We still need to return a reasonable point, so we project\n\t    // to infinity, on a bearing\n\t    // equivalent to the northern hemisphere equivalent\n\t    // This is a reasonable approximation for short shapes and lines that\n\t    // straddle the horizon.\n\n\t    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n\t    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n\t  }\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\tfunction inverse$14(p) {\n\t  var rh; /* Rho */\n\t  var sinc, cosc;\n\t  var c;\n\t  var lon, lat;\n\n\t  /* Inverse equations\n\t      -----------------*/\n\t  p.x = (p.x - this.x0) / this.a;\n\t  p.y = (p.y - this.y0) / this.a;\n\n\t  p.x /= this.k0;\n\t  p.y /= this.k0;\n\n\t  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n\t    c = Math.atan2(rh, this.rc);\n\t    sinc = Math.sin(c);\n\t    cosc = Math.cos(c);\n\n\t    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n\t    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n\t    lon = adjust_lon(this.long0 + lon);\n\t  }\n\t  else {\n\t    lat = this.phic0;\n\t    lon = 0;\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$16 = [\"gnom\"];\n\tvar gnom = {\n\t  init: init$15,\n\t  forward: forward$14,\n\t  inverse: inverse$14,\n\t  names: names$16\n\t};\n\n\tvar iqsfnz = function(eccent, q) {\n\t  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n\t  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n\t    if (q < 0) {\n\t      return (-1 * HALF_PI);\n\t    }\n\t    else {\n\t      return HALF_PI;\n\t    }\n\t  }\n\t  //var phi = 0.5* q/(1-eccent*eccent);\n\t  var phi = Math.asin(0.5 * q);\n\t  var dphi;\n\t  var sin_phi;\n\t  var cos_phi;\n\t  var con;\n\t  for (var i = 0; i < 30; i++) {\n\t    sin_phi = Math.sin(phi);\n\t    cos_phi = Math.cos(phi);\n\t    con = eccent * sin_phi;\n\t    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n\t    phi += dphi;\n\t    if (Math.abs(dphi) <= 0.0000000001) {\n\t      return phi;\n\t    }\n\t  }\n\n\t  //console.log(\"IQSFN-CONV:Latitude failed to converge after 30 iterations\");\n\t  return NaN;\n\t};\n\n\t/*\n\t  reference:\n\t    \"Cartographic Projection Procedures for the UNIX Environment-\n\t    A User's Manual\" by Gerald I. Evenden,\n\t    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n\t*/\n\tfunction init$16() {\n\t  //no-op\n\t  if (!this.sphere) {\n\t    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n\t  }\n\t}\n\n\t/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n\t    ------------------------------------------------------------*/\n\tfunction forward$15(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var x, y;\n\t  /* Forward equations\n\t      -----------------*/\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  if (this.sphere) {\n\t    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n\t    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n\t  }\n\t  else {\n\t    var qs = qsfnz(this.e, Math.sin(lat));\n\t    x = this.x0 + this.a * this.k0 * dlon;\n\t    y = this.y0 + this.a * qs * 0.5 / this.k0;\n\t  }\n\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\t/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n\t    ------------------------------------------------------------*/\n\tfunction inverse$15(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  var lon, lat;\n\n\t  if (this.sphere) {\n\t    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n\t    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n\t  }\n\t  else {\n\t    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n\t    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$17 = [\"cea\"];\n\tvar cea = {\n\t  init: init$16,\n\t  forward: forward$15,\n\t  inverse: inverse$15,\n\t  names: names$17\n\t};\n\n\tfunction init$17() {\n\n\t  this.x0 = this.x0 || 0;\n\t  this.y0 = this.y0 || 0;\n\t  this.lat0 = this.lat0 || 0;\n\t  this.long0 = this.long0 || 0;\n\t  this.lat_ts = this.lat_ts || 0;\n\t  this.title = this.title || \"Equidistant Cylindrical (Plate Carre)\";\n\n\t  this.rc = Math.cos(this.lat_ts);\n\t}\n\n\t// forward equations--mapping lat,long to x,y\n\t// -----------------------------------------------------------------\n\tfunction forward$16(p) {\n\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  var dlat = adjust_lat(lat - this.lat0);\n\t  p.x = this.x0 + (this.a * dlon * this.rc);\n\t  p.y = this.y0 + (this.a * dlat);\n\t  return p;\n\t}\n\n\t// inverse equations--mapping x,y to lat/long\n\t// -----------------------------------------------------------------\n\tfunction inverse$16(p) {\n\n\t  var x = p.x;\n\t  var y = p.y;\n\n\t  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n\t  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));\n\t  return p;\n\t}\n\n\tvar names$18 = [\"Equirectangular\", \"Equidistant_Cylindrical\", \"eqc\"];\n\tvar eqc = {\n\t  init: init$17,\n\t  forward: forward$16,\n\t  inverse: inverse$16,\n\t  names: names$18\n\t};\n\n\tvar MAX_ITER$2 = 20;\n\n\tfunction init$18() {\n\t  /* Place parameters in static storage for common use\n\t      -------------------------------------------------*/\n\t  this.temp = this.b / this.a;\n\t  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n\t  this.e = Math.sqrt(this.es);\n\t  this.e0 = e0fn(this.es);\n\t  this.e1 = e1fn(this.es);\n\t  this.e2 = e2fn(this.es);\n\t  this.e3 = e3fn(this.es);\n\t  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n\t}\n\n\t/* Polyconic forward equations--mapping lat,long to x,y\n\t    ---------------------------------------------------*/\n\tfunction forward$17(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var x, y, el;\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  el = dlon * Math.sin(lat);\n\t  if (this.sphere) {\n\t    if (Math.abs(lat) <= EPSLN) {\n\t      x = this.a * dlon;\n\t      y = -1 * this.a * this.lat0;\n\t    }\n\t    else {\n\t      x = this.a * Math.sin(el) / Math.tan(lat);\n\t      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n\t    }\n\t  }\n\t  else {\n\t    if (Math.abs(lat) <= EPSLN) {\n\t      x = this.a * dlon;\n\t      y = -1 * this.ml0;\n\t    }\n\t    else {\n\t      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n\t      x = nl * Math.sin(el);\n\t      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n\t    }\n\n\t  }\n\t  p.x = x + this.x0;\n\t  p.y = y + this.y0;\n\t  return p;\n\t}\n\n\t/* Inverse equations\n\t  -----------------*/\n\tfunction inverse$17(p) {\n\t  var lon, lat, x, y, i;\n\t  var al, bl;\n\t  var phi, dphi;\n\t  x = p.x - this.x0;\n\t  y = p.y - this.y0;\n\n\t  if (this.sphere) {\n\t    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n\t      lon = adjust_lon(x / this.a + this.long0);\n\t      lat = 0;\n\t    }\n\t    else {\n\t      al = this.lat0 + y / this.a;\n\t      bl = x * x / this.a / this.a + al * al;\n\t      phi = al;\n\t      var tanphi;\n\t      for (i = MAX_ITER$2; i; --i) {\n\t        tanphi = Math.tan(phi);\n\t        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n\t        phi += dphi;\n\t        if (Math.abs(dphi) <= EPSLN) {\n\t          lat = phi;\n\t          break;\n\t        }\n\t      }\n\t      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n\t    }\n\t  }\n\t  else {\n\t    if (Math.abs(y + this.ml0) <= EPSLN) {\n\t      lat = 0;\n\t      lon = adjust_lon(this.long0 + x / this.a);\n\t    }\n\t    else {\n\n\t      al = (this.ml0 + y) / this.a;\n\t      bl = x * x / this.a / this.a + al * al;\n\t      phi = al;\n\t      var cl, mln, mlnp, ma;\n\t      var con;\n\t      for (i = MAX_ITER$2; i; --i) {\n\t        con = this.e * Math.sin(phi);\n\t        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n\t        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\t        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n\t        ma = mln / this.a;\n\t        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n\t        phi -= dphi;\n\t        if (Math.abs(dphi) <= EPSLN) {\n\t          lat = phi;\n\t          break;\n\t        }\n\t      }\n\n\t      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n\t      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n\t      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n\t    }\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$19 = [\"Polyconic\", \"poly\"];\n\tvar poly = {\n\t  init: init$18,\n\t  forward: forward$17,\n\t  inverse: inverse$17,\n\t  names: names$19\n\t};\n\n\t/*\n\t  reference\n\t    Department of Land and Survey Technical Circular 1973/32\n\t      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n\t    OSG Technical Report 4.1\n\t      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n\t  */\n\n\t/**\n\t * iterations: Number of iterations to refine inverse transform.\n\t *     0 -> km accuracy\n\t *     1 -> m accuracy -- suitable for most mapping applications\n\t *     2 -> mm accuracy\n\t */\n\n\n\tfunction init$19() {\n\t  this.A = [];\n\t  this.A[1] = 0.6399175073;\n\t  this.A[2] = -0.1358797613;\n\t  this.A[3] = 0.063294409;\n\t  this.A[4] = -0.02526853;\n\t  this.A[5] = 0.0117879;\n\t  this.A[6] = -0.0055161;\n\t  this.A[7] = 0.0026906;\n\t  this.A[8] = -0.001333;\n\t  this.A[9] = 0.00067;\n\t  this.A[10] = -0.00034;\n\n\t  this.B_re = [];\n\t  this.B_im = [];\n\t  this.B_re[1] = 0.7557853228;\n\t  this.B_im[1] = 0;\n\t  this.B_re[2] = 0.249204646;\n\t  this.B_im[2] = 0.003371507;\n\t  this.B_re[3] = -0.001541739;\n\t  this.B_im[3] = 0.041058560;\n\t  this.B_re[4] = -0.10162907;\n\t  this.B_im[4] = 0.01727609;\n\t  this.B_re[5] = -0.26623489;\n\t  this.B_im[5] = -0.36249218;\n\t  this.B_re[6] = -0.6870983;\n\t  this.B_im[6] = -1.1651967;\n\n\t  this.C_re = [];\n\t  this.C_im = [];\n\t  this.C_re[1] = 1.3231270439;\n\t  this.C_im[1] = 0;\n\t  this.C_re[2] = -0.577245789;\n\t  this.C_im[2] = -0.007809598;\n\t  this.C_re[3] = 0.508307513;\n\t  this.C_im[3] = -0.112208952;\n\t  this.C_re[4] = -0.15094762;\n\t  this.C_im[4] = 0.18200602;\n\t  this.C_re[5] = 1.01418179;\n\t  this.C_im[5] = 1.64497696;\n\t  this.C_re[6] = 1.9660549;\n\t  this.C_im[6] = 2.5127645;\n\n\t  this.D = [];\n\t  this.D[1] = 1.5627014243;\n\t  this.D[2] = 0.5185406398;\n\t  this.D[3] = -0.03333098;\n\t  this.D[4] = -0.1052906;\n\t  this.D[5] = -0.0368594;\n\t  this.D[6] = 0.007317;\n\t  this.D[7] = 0.01220;\n\t  this.D[8] = 0.00394;\n\t  this.D[9] = -0.0013;\n\t}\n\n\t/**\n\t    New Zealand Map Grid Forward  - long/lat to x/y\n\t    long/lat in radians\n\t  */\n\tfunction forward$18(p) {\n\t  var n;\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  var delta_lat = lat - this.lat0;\n\t  var delta_lon = lon - this.long0;\n\n\t  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n\t  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n\t  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n\t  var d_lambda = delta_lon;\n\t  var d_phi_n = 1; // d_phi^0\n\n\t  var d_psi = 0;\n\t  for (n = 1; n <= 10; n++) {\n\t    d_phi_n = d_phi_n * d_phi;\n\t    d_psi = d_psi + this.A[n] * d_phi_n;\n\t  }\n\n\t  // 2. Calculate theta\n\t  var th_re = d_psi;\n\t  var th_im = d_lambda;\n\n\t  // 3. Calculate z\n\t  var th_n_re = 1;\n\t  var th_n_im = 0; // theta^0\n\t  var th_n_re1;\n\t  var th_n_im1;\n\n\t  var z_re = 0;\n\t  var z_im = 0;\n\t  for (n = 1; n <= 6; n++) {\n\t    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n\t    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n\t    th_n_re = th_n_re1;\n\t    th_n_im = th_n_im1;\n\t    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n\t    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n\t  }\n\n\t  // 4. Calculate easting and northing\n\t  p.x = (z_im * this.a) + this.x0;\n\t  p.y = (z_re * this.a) + this.y0;\n\n\t  return p;\n\t}\n\n\t/**\n\t    New Zealand Map Grid Inverse  -  x/y to long/lat\n\t  */\n\tfunction inverse$18(p) {\n\t  var n;\n\t  var x = p.x;\n\t  var y = p.y;\n\n\t  var delta_x = x - this.x0;\n\t  var delta_y = y - this.y0;\n\n\t  // 1. Calculate z\n\t  var z_re = delta_y / this.a;\n\t  var z_im = delta_x / this.a;\n\n\t  // 2a. Calculate theta - first approximation gives km accuracy\n\t  var z_n_re = 1;\n\t  var z_n_im = 0; // z^0\n\t  var z_n_re1;\n\t  var z_n_im1;\n\n\t  var th_re = 0;\n\t  var th_im = 0;\n\t  for (n = 1; n <= 6; n++) {\n\t    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n\t    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n\t    z_n_re = z_n_re1;\n\t    z_n_im = z_n_im1;\n\t    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n\t    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n\t  }\n\n\t  // 2b. Iterate to refine the accuracy of the calculation\n\t  //        0 iterations gives km accuracy\n\t  //        1 iteration gives m accuracy -- good enough for most mapping applications\n\t  //        2 iterations bives mm accuracy\n\t  for (var i = 0; i < this.iterations; i++) {\n\t    var th_n_re = th_re;\n\t    var th_n_im = th_im;\n\t    var th_n_re1;\n\t    var th_n_im1;\n\n\t    var num_re = z_re;\n\t    var num_im = z_im;\n\t    for (n = 2; n <= 6; n++) {\n\t      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n\t      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n\t      th_n_re = th_n_re1;\n\t      th_n_im = th_n_im1;\n\t      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n\t      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n\t    }\n\n\t    th_n_re = 1;\n\t    th_n_im = 0;\n\t    var den_re = this.B_re[1];\n\t    var den_im = this.B_im[1];\n\t    for (n = 2; n <= 6; n++) {\n\t      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n\t      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n\t      th_n_re = th_n_re1;\n\t      th_n_im = th_n_im1;\n\t      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n\t      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n\t    }\n\n\t    // Complex division\n\t    var den2 = den_re * den_re + den_im * den_im;\n\t    th_re = (num_re * den_re + num_im * den_im) / den2;\n\t    th_im = (num_im * den_re - num_re * den_im) / den2;\n\t  }\n\n\t  // 3. Calculate d_phi              ...                                    // and d_lambda\n\t  var d_psi = th_re;\n\t  var d_lambda = th_im;\n\t  var d_psi_n = 1; // d_psi^0\n\n\t  var d_phi = 0;\n\t  for (n = 1; n <= 9; n++) {\n\t    d_psi_n = d_psi_n * d_psi;\n\t    d_phi = d_phi + this.D[n] * d_psi_n;\n\t  }\n\n\t  // 4. Calculate latitude and longitude\n\t  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n\t  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n\t  var lon = this.long0 + d_lambda;\n\n\t  p.x = lon;\n\t  p.y = lat;\n\n\t  return p;\n\t}\n\n\tvar names$20 = [\"New_Zealand_Map_Grid\", \"nzmg\"];\n\tvar nzmg = {\n\t  init: init$19,\n\t  forward: forward$18,\n\t  inverse: inverse$18,\n\t  names: names$20\n\t};\n\n\t/*\n\t  reference\n\t    \"New Equal-Area Map Projections for Noncircular Regions\", John P. Snyder,\n\t    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n\t  */\n\n\n\t/* Initialize the Miller Cylindrical projection\n\t  -------------------------------------------*/\n\tfunction init$20() {\n\t  //no-op\n\t}\n\n\t/* Miller Cylindrical forward equations--mapping lat,long to x,y\n\t    ------------------------------------------------------------*/\n\tfunction forward$19(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  /* Forward equations\n\t      -----------------*/\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  var x = this.x0 + this.a * dlon;\n\t  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\t/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n\t    ------------------------------------------------------------*/\n\tfunction inverse$19(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\n\t  var lon = adjust_lon(this.long0 + p.x / this.a);\n\t  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$21 = [\"Miller_Cylindrical\", \"mill\"];\n\tvar mill = {\n\t  init: init$20,\n\t  forward: forward$19,\n\t  inverse: inverse$19,\n\t  names: names$21\n\t};\n\n\tvar MAX_ITER$3 = 20;\n\tfunction init$21() {\n\t  /* Place parameters in static storage for common use\n\t    -------------------------------------------------*/\n\n\n\t  if (!this.sphere) {\n\t    this.en = pj_enfn(this.es);\n\t  }\n\t  else {\n\t    this.n = 1;\n\t    this.m = 0;\n\t    this.es = 0;\n\t    this.C_y = Math.sqrt((this.m + 1) / this.n);\n\t    this.C_x = this.C_y / (this.m + 1);\n\t  }\n\n\t}\n\n\t/* Sinusoidal forward equations--mapping lat,long to x,y\n\t  -----------------------------------------------------*/\n\tfunction forward$20(p) {\n\t  var x, y;\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  /* Forward equations\n\t    -----------------*/\n\t  lon = adjust_lon(lon - this.long0);\n\n\t  if (this.sphere) {\n\t    if (!this.m) {\n\t      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n\t    }\n\t    else {\n\t      var k = this.n * Math.sin(lat);\n\t      for (var i = MAX_ITER$3; i; --i) {\n\t        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n\t        lat -= V;\n\t        if (Math.abs(V) < EPSLN) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n\t    y = this.a * this.C_y * lat;\n\n\t  }\n\t  else {\n\n\t    var s = Math.sin(lat);\n\t    var c = Math.cos(lat);\n\t    y = this.a * pj_mlfn(lat, s, c, this.en);\n\t    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n\t  }\n\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\tfunction inverse$20(p) {\n\t  var lat, temp, lon, s;\n\n\t  p.x -= this.x0;\n\t  lon = p.x / this.a;\n\t  p.y -= this.y0;\n\t  lat = p.y / this.a;\n\n\t  if (this.sphere) {\n\t    lat /= this.C_y;\n\t    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n\t    if (this.m) {\n\t      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n\t    }\n\t    else if (this.n !== 1) {\n\t      lat = asinz(Math.sin(lat) / this.n);\n\t    }\n\t    lon = adjust_lon(lon + this.long0);\n\t    lat = adjust_lat(lat);\n\t  }\n\t  else {\n\t    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n\t    s = Math.abs(lat);\n\t    if (s < HALF_PI) {\n\t      s = Math.sin(lat);\n\t      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n\t      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n\t      lon = adjust_lon(temp);\n\t    }\n\t    else if ((s - EPSLN) < HALF_PI) {\n\t      lon = this.long0;\n\t    }\n\t  }\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$22 = [\"Sinusoidal\", \"sinu\"];\n\tvar sinu = {\n\t  init: init$21,\n\t  forward: forward$20,\n\t  inverse: inverse$20,\n\t  names: names$22\n\t};\n\n\tfunction init$22() {}\n\t/* Mollweide forward equations--mapping lat,long to x,y\n\t    ----------------------------------------------------*/\n\tfunction forward$21(p) {\n\n\t  /* Forward equations\n\t      -----------------*/\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  var delta_lon = adjust_lon(lon - this.long0);\n\t  var theta = lat;\n\t  var con = Math.PI * Math.sin(lat);\n\n\t  /* Iterate using the Newton-Raphson method to find theta\n\t      -----------------------------------------------------*/\n\t  while (true) {\n\t    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n\t    theta += delta_theta;\n\t    if (Math.abs(delta_theta) < EPSLN) {\n\t      break;\n\t    }\n\t  }\n\t  theta /= 2;\n\n\t  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n\t       this is done here because of precision problems with \"cos(theta)\"\n\t       --------------------------------------------------------------------------*/\n\t  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n\t    delta_lon = 0;\n\t  }\n\t  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n\t  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\tfunction inverse$21(p) {\n\t  var theta;\n\t  var arg;\n\n\t  /* Inverse equations\n\t      -----------------*/\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  arg = p.y / (1.4142135623731 * this.a);\n\n\t  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n\t       a number very close to one is used instead.\n\t       -------------------------------------------------------------------*/\n\t  if (Math.abs(arg) > 0.999999999999) {\n\t    arg = 0.999999999999;\n\t  }\n\t  theta = Math.asin(arg);\n\t  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n\t  if (lon < (-Math.PI)) {\n\t    lon = -Math.PI;\n\t  }\n\t  if (lon > Math.PI) {\n\t    lon = Math.PI;\n\t  }\n\t  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n\t  if (Math.abs(arg) > 1) {\n\t    arg = 1;\n\t  }\n\t  var lat = Math.asin(arg);\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$23 = [\"Mollweide\", \"moll\"];\n\tvar moll = {\n\t  init: init$22,\n\t  forward: forward$21,\n\t  inverse: inverse$21,\n\t  names: names$23\n\t};\n\n\tfunction init$23() {\n\n\t  /* Place parameters in static storage for common use\n\t      -------------------------------------------------*/\n\t  // Standard Parallels cannot be equal and on opposite sides of the equator\n\t  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n\t    return;\n\t  }\n\t  this.lat2 = this.lat2 || this.lat1;\n\t  this.temp = this.b / this.a;\n\t  this.es = 1 - Math.pow(this.temp, 2);\n\t  this.e = Math.sqrt(this.es);\n\t  this.e0 = e0fn(this.es);\n\t  this.e1 = e1fn(this.es);\n\t  this.e2 = e2fn(this.es);\n\t  this.e3 = e3fn(this.es);\n\n\t  this.sinphi = Math.sin(this.lat1);\n\t  this.cosphi = Math.cos(this.lat1);\n\n\t  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n\t  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n\t  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n\t    this.ns = this.sinphi;\n\t  }\n\t  else {\n\t    this.sinphi = Math.sin(this.lat2);\n\t    this.cosphi = Math.cos(this.lat2);\n\t    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n\t    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n\t    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n\t  }\n\t  this.g = this.ml1 + this.ms1 / this.ns;\n\t  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n\t  this.rh = this.a * (this.g - this.ml0);\n\t}\n\n\t/* Equidistant Conic forward equations--mapping lat,long to x,y\n\t  -----------------------------------------------------------*/\n\tfunction forward$22(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var rh1;\n\n\t  /* Forward equations\n\t      -----------------*/\n\t  if (this.sphere) {\n\t    rh1 = this.a * (this.g - lat);\n\t  }\n\t  else {\n\t    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n\t    rh1 = this.a * (this.g - ml);\n\t  }\n\t  var theta = this.ns * adjust_lon(lon - this.long0);\n\t  var x = this.x0 + rh1 * Math.sin(theta);\n\t  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\t/* Inverse equations\n\t  -----------------*/\n\tfunction inverse$22(p) {\n\t  p.x -= this.x0;\n\t  p.y = this.rh - p.y + this.y0;\n\t  var con, rh1, lat, lon;\n\t  if (this.ns >= 0) {\n\t    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n\t    con = 1;\n\t  }\n\t  else {\n\t    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n\t    con = -1;\n\t  }\n\t  var theta = 0;\n\t  if (rh1 !== 0) {\n\t    theta = Math.atan2(con * p.x, con * p.y);\n\t  }\n\n\t  if (this.sphere) {\n\t    lon = adjust_lon(this.long0 + theta / this.ns);\n\t    lat = adjust_lat(this.g - rh1 / this.a);\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\t  else {\n\t    var ml = this.g - rh1 / this.a;\n\t    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n\t    lon = adjust_lon(this.long0 + theta / this.ns);\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\n\t}\n\n\tvar names$24 = [\"Equidistant_Conic\", \"eqdc\"];\n\tvar eqdc = {\n\t  init: init$23,\n\t  forward: forward$22,\n\t  inverse: inverse$22,\n\t  names: names$24\n\t};\n\n\t/* Initialize the Van Der Grinten projection\n\t  ----------------------------------------*/\n\tfunction init$24() {\n\t  //this.R = 6370997; //Radius of earth\n\t  this.R = this.a;\n\t}\n\n\tfunction forward$23(p) {\n\n\t  var lon = p.x;\n\t  var lat = p.y;\n\n\t  /* Forward equations\n\t    -----------------*/\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  var x, y;\n\n\t  if (Math.abs(lat) <= EPSLN) {\n\t    x = this.x0 + this.R * dlon;\n\t    y = this.y0;\n\t  }\n\t  var theta = asinz(2 * Math.abs(lat / Math.PI));\n\t  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {\n\t    x = this.x0;\n\t    if (lat >= 0) {\n\t      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n\t    }\n\t    else {\n\t      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n\t    }\n\t    //  return(OK);\n\t  }\n\t  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n\t  var asq = al * al;\n\t  var sinth = Math.sin(theta);\n\t  var costh = Math.cos(theta);\n\n\t  var g = costh / (sinth + costh - 1);\n\t  var gsq = g * g;\n\t  var m = g * (2 / sinth - 1);\n\t  var msq = m * m;\n\t  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n\t  if (dlon < 0) {\n\t    con = -con;\n\t  }\n\t  x = this.x0 + con;\n\t  //con = Math.abs(con / (Math.PI * this.R));\n\t  var q = asq + g;\n\t  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n\t  if (lat >= 0) {\n\t    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n\t    y = this.y0 + con;\n\t  }\n\t  else {\n\t    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n\t    y = this.y0 - con;\n\t  }\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\t/* Van Der Grinten inverse equations--mapping x,y to lat/long\n\t  ---------------------------------------------------------*/\n\tfunction inverse$23(p) {\n\t  var lon, lat;\n\t  var xx, yy, xys, c1, c2, c3;\n\t  var a1;\n\t  var m1;\n\t  var con;\n\t  var th1;\n\t  var d;\n\n\t  /* inverse equations\n\t    -----------------*/\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  con = Math.PI * this.R;\n\t  xx = p.x / con;\n\t  yy = p.y / con;\n\t  xys = xx * xx + yy * yy;\n\t  c1 = -Math.abs(yy) * (1 + xys);\n\t  c2 = c1 - 2 * yy * yy + xx * xx;\n\t  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n\t  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n\t  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n\t  m1 = 2 * Math.sqrt(-a1 / 3);\n\t  con = ((3 * d) / a1) / m1;\n\t  if (Math.abs(con) > 1) {\n\t    if (con >= 0) {\n\t      con = 1;\n\t    }\n\t    else {\n\t      con = -1;\n\t    }\n\t  }\n\t  th1 = Math.acos(con) / 3;\n\t  if (p.y >= 0) {\n\t    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n\t  }\n\t  else {\n\t    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n\t  }\n\n\t  if (Math.abs(xx) < EPSLN) {\n\t    lon = this.long0;\n\t  }\n\t  else {\n\t    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n\t  }\n\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$25 = [\"Van_der_Grinten_I\", \"VanDerGrinten\", \"vandg\"];\n\tvar vandg = {\n\t  init: init$24,\n\t  forward: forward$23,\n\t  inverse: inverse$23,\n\t  names: names$25\n\t};\n\n\tfunction init$25() {\n\t  this.sin_p12 = Math.sin(this.lat0);\n\t  this.cos_p12 = Math.cos(this.lat0);\n\t}\n\n\tfunction forward$24(p) {\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  var sinphi = Math.sin(p.y);\n\t  var cosphi = Math.cos(p.y);\n\t  var dlon = adjust_lon(lon - this.long0);\n\t  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n\t  if (this.sphere) {\n\t    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n\t      //North Pole case\n\t      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n\t      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n\t      return p;\n\t    }\n\t    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n\t      //South Pole case\n\t      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n\t      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n\t      return p;\n\t    }\n\t    else {\n\t      //default case\n\t      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n\t      c = Math.acos(cos_c);\n\t      kp = c / Math.sin(c);\n\t      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n\t      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n\t      return p;\n\t    }\n\t  }\n\t  else {\n\t    e0 = e0fn(this.es);\n\t    e1 = e1fn(this.es);\n\t    e2 = e2fn(this.es);\n\t    e3 = e3fn(this.es);\n\t    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n\t      //North Pole case\n\t      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n\t      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n\t      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n\t      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n\t      return p;\n\t    }\n\t    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n\t      //South Pole case\n\t      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n\t      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n\t      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n\t      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n\t      return p;\n\t    }\n\t    else {\n\t      //Default case\n\t      tanphi = sinphi / cosphi;\n\t      Nl1 = gN(this.a, this.e, this.sin_p12);\n\t      Nl = gN(this.a, this.e, sinphi);\n\t      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n\t      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n\t      if (Az === 0) {\n\t        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n\t      }\n\t      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n\t        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n\t      }\n\t      else {\n\t        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n\t      }\n\t      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n\t      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n\t      GH = G * H;\n\t      Hs = H * H;\n\t      s2 = s * s;\n\t      s3 = s2 * s;\n\t      s4 = s3 * s;\n\t      s5 = s4 * s;\n\t      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n\t      p.x = this.x0 + c * Math.sin(Az);\n\t      p.y = this.y0 + c * Math.cos(Az);\n\t      return p;\n\t    }\n\t  }\n\n\n\t}\n\n\tfunction inverse$24(p) {\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n\t  if (this.sphere) {\n\t    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t    if (rh > (2 * HALF_PI * this.a)) {\n\t      return;\n\t    }\n\t    z = rh / this.a;\n\n\t    sinz = Math.sin(z);\n\t    cosz = Math.cos(z);\n\n\t    lon = this.long0;\n\t    if (Math.abs(rh) <= EPSLN) {\n\t      lat = this.lat0;\n\t    }\n\t    else {\n\t      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n\t      con = Math.abs(this.lat0) - HALF_PI;\n\t      if (Math.abs(con) <= EPSLN) {\n\t        if (this.lat0 >= 0) {\n\t          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n\t        }\n\t        else {\n\t          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n\t        }\n\t      }\n\t      else {\n\t        /*con = cosz - this.sin_p12 * Math.sin(lat);\n\t        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n\t          //no-op, just keep the lon value as is\n\t        } else {\n\t          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n\t          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n\t        }*/\n\t        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n\t      }\n\t    }\n\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\t  else {\n\t    e0 = e0fn(this.es);\n\t    e1 = e1fn(this.es);\n\t    e2 = e2fn(this.es);\n\t    e3 = e3fn(this.es);\n\t    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n\t      //North pole case\n\t      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n\t      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t      M = Mlp - rh;\n\t      lat = imlfn(M / this.a, e0, e1, e2, e3);\n\t      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n\t      p.x = lon;\n\t      p.y = lat;\n\t      return p;\n\t    }\n\t    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n\t      //South pole case\n\t      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n\t      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t      M = rh - Mlp;\n\n\t      lat = imlfn(M / this.a, e0, e1, e2, e3);\n\t      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n\t      p.x = lon;\n\t      p.y = lat;\n\t      return p;\n\t    }\n\t    else {\n\t      //default case\n\t      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t      Az = Math.atan2(p.x, p.y);\n\t      N1 = gN(this.a, this.e, this.sin_p12);\n\t      cosAz = Math.cos(Az);\n\t      tmp = this.e * this.cos_p12 * cosAz;\n\t      A = -tmp * tmp / (1 - this.es);\n\t      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n\t      D = rh / N1;\n\t      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n\t      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n\t      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n\t      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n\t      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n\t      p.x = lon;\n\t      p.y = lat;\n\t      return p;\n\t    }\n\t  }\n\n\t}\n\n\tvar names$26 = [\"Azimuthal_Equidistant\", \"aeqd\"];\n\tvar aeqd = {\n\t  init: init$25,\n\t  forward: forward$24,\n\t  inverse: inverse$24,\n\t  names: names$26\n\t};\n\n\tfunction init$26() {\n\t  //double temp;      /* temporary variable    */\n\n\t  /* Place parameters in static storage for common use\n\t      -------------------------------------------------*/\n\t  this.sin_p14 = Math.sin(this.lat0);\n\t  this.cos_p14 = Math.cos(this.lat0);\n\t}\n\n\t/* Orthographic forward equations--mapping lat,long to x,y\n\t    ---------------------------------------------------*/\n\tfunction forward$25(p) {\n\t  var sinphi, cosphi; /* sin and cos value        */\n\t  var dlon; /* delta longitude value      */\n\t  var coslon; /* cos of longitude        */\n\t  var ksp; /* scale factor          */\n\t  var g, x, y;\n\t  var lon = p.x;\n\t  var lat = p.y;\n\t  /* Forward equations\n\t      -----------------*/\n\t  dlon = adjust_lon(lon - this.long0);\n\n\t  sinphi = Math.sin(lat);\n\t  cosphi = Math.cos(lat);\n\n\t  coslon = Math.cos(dlon);\n\t  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n\t  ksp = 1;\n\t  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n\t    x = this.a * ksp * cosphi * Math.sin(dlon);\n\t    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\t  }\n\t  p.x = x;\n\t  p.y = y;\n\t  return p;\n\t}\n\n\tfunction inverse$25(p) {\n\t  var rh; /* height above ellipsoid      */\n\t  var z; /* angle          */\n\t  var sinz, cosz; /* sin of z and cos of z      */\n\t  var con;\n\t  var lon, lat;\n\t  /* Inverse equations\n\t      -----------------*/\n\t  p.x -= this.x0;\n\t  p.y -= this.y0;\n\t  rh = Math.sqrt(p.x * p.x + p.y * p.y);\n\t  z = asinz(rh / this.a);\n\n\t  sinz = Math.sin(z);\n\t  cosz = Math.cos(z);\n\n\t  lon = this.long0;\n\t  if (Math.abs(rh) <= EPSLN) {\n\t    lat = this.lat0;\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\t  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);\n\t  con = Math.abs(this.lat0) - HALF_PI;\n\t  if (Math.abs(con) <= EPSLN) {\n\t    if (this.lat0 >= 0) {\n\t      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n\t    }\n\t    else {\n\t      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n\t    }\n\t    p.x = lon;\n\t    p.y = lat;\n\t    return p;\n\t  }\n\t  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));\n\t  p.x = lon;\n\t  p.y = lat;\n\t  return p;\n\t}\n\n\tvar names$27 = [\"ortho\"];\n\tvar ortho = {\n\t  init: init$26,\n\t  forward: forward$25,\n\t  inverse: inverse$25,\n\t  names: names$27\n\t};\n\n\t// QSC projection rewritten from the original PROJ4\n\t// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\n\t/* constants */\n\tvar FACE_ENUM = {\n\t    FRONT: 1,\n\t    RIGHT: 2,\n\t    BACK: 3,\n\t    LEFT: 4,\n\t    TOP: 5,\n\t    BOTTOM: 6\n\t};\n\n\tvar AREA_ENUM = {\n\t    AREA_0: 1,\n\t    AREA_1: 2,\n\t    AREA_2: 3,\n\t    AREA_3: 4\n\t};\n\n\tfunction init$27() {\n\n\t  this.x0 = this.x0 || 0;\n\t  this.y0 = this.y0 || 0;\n\t  this.lat0 = this.lat0 || 0;\n\t  this.long0 = this.long0 || 0;\n\t  this.lat_ts = this.lat_ts || 0;\n\t  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n\t  /* Determine the cube face from the center of projection. */\n\t  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n\t    this.face = FACE_ENUM.TOP;\n\t  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n\t    this.face = FACE_ENUM.BOTTOM;\n\t  } else if (Math.abs(this.long0) <= FORTPI) {\n\t    this.face = FACE_ENUM.FRONT;\n\t  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n\t    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n\t  } else {\n\t    this.face = FACE_ENUM.BACK;\n\t  }\n\n\t  /* Fill in useful values for the ellipsoid <-> sphere shift\n\t   * described in [LK12]. */\n\t  if (this.es !== 0) {\n\t    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n\t    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n\t  }\n\t}\n\n\t// QSC forward equations--mapping lat,long to x,y\n\t// -----------------------------------------------------------------\n\tfunction forward$26(p) {\n\t  var xy = {x: 0, y: 0};\n\t  var lat, lon;\n\t  var theta, phi;\n\t  var t, mu;\n\t  /* nu; */\n\t  var area = {value: 0};\n\n\t  // move lon according to projection's lon\n\t  p.x -= this.long0;\n\n\t  /* Convert the geodetic latitude to a geocentric latitude.\n\t   * This corresponds to the shift from the ellipsoid to the sphere\n\t   * described in [LK12]. */\n\t  if (this.es !== 0) {//if (P->es != 0) {\n\t    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n\t  } else {\n\t    lat = p.y;\n\t  }\n\n\t  /* Convert the input lat, lon into theta, phi as used by QSC.\n\t   * This depends on the cube face and the area on it.\n\t   * For the top and bottom face, we can compute theta and phi\n\t   * directly from phi, lam. For the other faces, we must use\n\t   * unit sphere cartesian coordinates as an intermediate step. */\n\t  lon = p.x; //lon = lp.lam;\n\t  if (this.face === FACE_ENUM.TOP) {\n\t    phi = HALF_PI - lat;\n\t    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n\t      area.value = AREA_ENUM.AREA_0;\n\t      theta = lon - HALF_PI;\n\t    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n\t      area.value = AREA_ENUM.AREA_1;\n\t      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n\t    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n\t      area.value = AREA_ENUM.AREA_2;\n\t      theta = lon + HALF_PI;\n\t    } else {\n\t      area.value = AREA_ENUM.AREA_3;\n\t      theta = lon;\n\t    }\n\t  } else if (this.face === FACE_ENUM.BOTTOM) {\n\t    phi = HALF_PI + lat;\n\t    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n\t      area.value = AREA_ENUM.AREA_0;\n\t      theta = -lon + HALF_PI;\n\t    } else if (lon < FORTPI && lon >= -FORTPI) {\n\t      area.value = AREA_ENUM.AREA_1;\n\t      theta = -lon;\n\t    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n\t      area.value = AREA_ENUM.AREA_2;\n\t      theta = -lon - HALF_PI;\n\t    } else {\n\t      area.value = AREA_ENUM.AREA_3;\n\t      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n\t    }\n\t  } else {\n\t    var q, r, s;\n\t    var sinlat, coslat;\n\t    var sinlon, coslon;\n\n\t    if (this.face === FACE_ENUM.RIGHT) {\n\t      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n\t    } else if (this.face === FACE_ENUM.BACK) {\n\t      lon = qsc_shift_lon_origin(lon, +SPI);\n\t    } else if (this.face === FACE_ENUM.LEFT) {\n\t      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n\t    }\n\t    sinlat = Math.sin(lat);\n\t    coslat = Math.cos(lat);\n\t    sinlon = Math.sin(lon);\n\t    coslon = Math.cos(lon);\n\t    q = coslat * coslon;\n\t    r = coslat * sinlon;\n\t    s = sinlat;\n\n\t    if (this.face === FACE_ENUM.FRONT) {\n\t      phi = Math.acos(q);\n\t      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n\t    } else if (this.face === FACE_ENUM.RIGHT) {\n\t      phi = Math.acos(r);\n\t      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n\t    } else if (this.face === FACE_ENUM.BACK) {\n\t      phi = Math.acos(-q);\n\t      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n\t    } else if (this.face === FACE_ENUM.LEFT) {\n\t      phi = Math.acos(-r);\n\t      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n\t    } else {\n\t      /* Impossible */\n\t      phi = theta = 0;\n\t      area.value = AREA_ENUM.AREA_0;\n\t    }\n\t  }\n\n\t  /* Compute mu and nu for the area of definition.\n\t   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n\t   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n\t  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n\t  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n\t  /* Apply the result to the real area. */\n\t  if (area.value === AREA_ENUM.AREA_1) {\n\t    mu += HALF_PI;\n\t  } else if (area.value === AREA_ENUM.AREA_2) {\n\t    mu += SPI;\n\t  } else if (area.value === AREA_ENUM.AREA_3) {\n\t    mu += 1.5 * SPI;\n\t  }\n\n\t  /* Now compute x, y from mu and nu */\n\t  xy.x = t * Math.cos(mu);\n\t  xy.y = t * Math.sin(mu);\n\t  xy.x = xy.x * this.a + this.x0;\n\t  xy.y = xy.y * this.a + this.y0;\n\n\t  p.x = xy.x;\n\t  p.y = xy.y;\n\t  return p;\n\t}\n\n\t// QSC inverse equations--mapping x,y to lat/long\n\t// -----------------------------------------------------------------\n\tfunction inverse$26(p) {\n\t  var lp = {lam: 0, phi: 0};\n\t  var mu, nu, cosmu, tannu;\n\t  var tantheta, theta, cosphi, phi;\n\t  var t;\n\t  var area = {value: 0};\n\n\t  /* de-offset */\n\t  p.x = (p.x - this.x0) / this.a;\n\t  p.y = (p.y - this.y0) / this.a;\n\n\t  /* Convert the input x, y to the mu and nu angles as used by QSC.\n\t   * This depends on the area of the cube face. */\n\t  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n\t  mu = Math.atan2(p.y, p.x);\n\t  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n\t    area.value = AREA_ENUM.AREA_0;\n\t  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n\t    area.value = AREA_ENUM.AREA_1;\n\t    mu -= HALF_PI;\n\t  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n\t    area.value = AREA_ENUM.AREA_2;\n\t    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n\t  } else {\n\t    area.value = AREA_ENUM.AREA_3;\n\t    mu += HALF_PI;\n\t  }\n\n\t  /* Compute phi and theta for the area of definition.\n\t   * The inverse projection is not described in the original paper, but some\n\t   * good hints can be found here (as of 2011-12-14):\n\t   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n\t   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n\t  t = (SPI / 12) * Math.tan(mu);\n\t  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n\t  theta = Math.atan(tantheta);\n\t  cosmu = Math.cos(mu);\n\t  tannu = Math.tan(nu);\n\t  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n\t  if (cosphi < -1) {\n\t    cosphi = -1;\n\t  } else if (cosphi > +1) {\n\t    cosphi = +1;\n\t  }\n\n\t  /* Apply the result to the real area on the cube face.\n\t   * For the top and bottom face, we can compute phi and lam directly.\n\t   * For the other faces, we must use unit sphere cartesian coordinates\n\t   * as an intermediate step. */\n\t  if (this.face === FACE_ENUM.TOP) {\n\t    phi = Math.acos(cosphi);\n\t    lp.phi = HALF_PI - phi;\n\t    if (area.value === AREA_ENUM.AREA_0) {\n\t      lp.lam = theta + HALF_PI;\n\t    } else if (area.value === AREA_ENUM.AREA_1) {\n\t      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n\t    } else if (area.value === AREA_ENUM.AREA_2) {\n\t      lp.lam = theta - HALF_PI;\n\t    } else /* area.value == AREA_ENUM.AREA_3 */ {\n\t      lp.lam = theta;\n\t    }\n\t  } else if (this.face === FACE_ENUM.BOTTOM) {\n\t    phi = Math.acos(cosphi);\n\t    lp.phi = phi - HALF_PI;\n\t    if (area.value === AREA_ENUM.AREA_0) {\n\t      lp.lam = -theta + HALF_PI;\n\t    } else if (area.value === AREA_ENUM.AREA_1) {\n\t      lp.lam = -theta;\n\t    } else if (area.value === AREA_ENUM.AREA_2) {\n\t      lp.lam = -theta - HALF_PI;\n\t    } else /* area.value == AREA_ENUM.AREA_3 */ {\n\t      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n\t    }\n\t  } else {\n\t    /* Compute phi and lam via cartesian unit sphere coordinates. */\n\t    var q, r, s;\n\t    q = cosphi;\n\t    t = q * q;\n\t    if (t >= 1) {\n\t      s = 0;\n\t    } else {\n\t      s = Math.sqrt(1 - t) * Math.sin(theta);\n\t    }\n\t    t += s * s;\n\t    if (t >= 1) {\n\t      r = 0;\n\t    } else {\n\t      r = Math.sqrt(1 - t);\n\t    }\n\t    /* Rotate q,r,s into the correct area. */\n\t    if (area.value === AREA_ENUM.AREA_1) {\n\t      t = r;\n\t      r = -s;\n\t      s = t;\n\t    } else if (area.value === AREA_ENUM.AREA_2) {\n\t      r = -r;\n\t      s = -s;\n\t    } else if (area.value === AREA_ENUM.AREA_3) {\n\t      t = r;\n\t      r = s;\n\t      s = -t;\n\t    }\n\t    /* Rotate q,r,s into the correct cube face. */\n\t    if (this.face === FACE_ENUM.RIGHT) {\n\t      t = q;\n\t      q = -r;\n\t      r = t;\n\t    } else if (this.face === FACE_ENUM.BACK) {\n\t      q = -q;\n\t      r = -r;\n\t    } else if (this.face === FACE_ENUM.LEFT) {\n\t      t = q;\n\t      q = r;\n\t      r = -t;\n\t    }\n\t    /* Now compute phi and lam from the unit sphere coordinates. */\n\t    lp.phi = Math.acos(-s) - HALF_PI;\n\t    lp.lam = Math.atan2(r, q);\n\t    if (this.face === FACE_ENUM.RIGHT) {\n\t      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n\t    } else if (this.face === FACE_ENUM.BACK) {\n\t      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n\t    } else if (this.face === FACE_ENUM.LEFT) {\n\t      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n\t    }\n\t  }\n\n\t  /* Apply the shift from the sphere to the ellipsoid as described\n\t   * in [LK12]. */\n\t  if (this.es !== 0) {\n\t    var invert_sign;\n\t    var tanphi, xa;\n\t    invert_sign = (lp.phi < 0 ? 1 : 0);\n\t    tanphi = Math.tan(lp.phi);\n\t    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n\t    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n\t    if (invert_sign) {\n\t      lp.phi = -lp.phi;\n\t    }\n\t  }\n\n\t  lp.lam += this.long0;\n\t  p.x = lp.lam;\n\t  p.y = lp.phi;\n\t  return p;\n\t}\n\n\t/* Helper function for forward projection: compute the theta angle\n\t * and determine the area number. */\n\tfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n\t  var theta;\n\t  if (phi < EPSLN) {\n\t    area.value = AREA_ENUM.AREA_0;\n\t    theta = 0.0;\n\t  } else {\n\t    theta = Math.atan2(y, x);\n\t    if (Math.abs(theta) <= FORTPI) {\n\t      area.value = AREA_ENUM.AREA_0;\n\t    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n\t      area.value = AREA_ENUM.AREA_1;\n\t      theta -= HALF_PI;\n\t    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n\t      area.value = AREA_ENUM.AREA_2;\n\t      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n\t    } else {\n\t      area.value = AREA_ENUM.AREA_3;\n\t      theta += HALF_PI;\n\t    }\n\t  }\n\t  return theta;\n\t}\n\n\t/* Helper function: shift the longitude. */\n\tfunction qsc_shift_lon_origin(lon, offset) {\n\t  var slon = lon + offset;\n\t  if (slon < -SPI) {\n\t    slon += TWO_PI;\n\t  } else if (slon > +SPI) {\n\t    slon -= TWO_PI;\n\t  }\n\t  return slon;\n\t}\n\n\tvar names$28 = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\n\tvar qsc = {\n\t  init: init$27,\n\t  forward: forward$26,\n\t  inverse: inverse$26,\n\t  names: names$28\n\t};\n\n\tvar includedProjections = function(proj4){\n\t  proj4.Proj.projections.add(tmerc);\n\t  proj4.Proj.projections.add(etmerc);\n\t  proj4.Proj.projections.add(utm);\n\t  proj4.Proj.projections.add(sterea);\n\t  proj4.Proj.projections.add(stere);\n\t  proj4.Proj.projections.add(somerc);\n\t  proj4.Proj.projections.add(omerc);\n\t  proj4.Proj.projections.add(lcc);\n\t  proj4.Proj.projections.add(krovak);\n\t  proj4.Proj.projections.add(cass);\n\t  proj4.Proj.projections.add(laea);\n\t  proj4.Proj.projections.add(aea);\n\t  proj4.Proj.projections.add(gnom);\n\t  proj4.Proj.projections.add(cea);\n\t  proj4.Proj.projections.add(eqc);\n\t  proj4.Proj.projections.add(poly);\n\t  proj4.Proj.projections.add(nzmg);\n\t  proj4.Proj.projections.add(mill);\n\t  proj4.Proj.projections.add(sinu);\n\t  proj4.Proj.projections.add(moll);\n\t  proj4.Proj.projections.add(eqdc);\n\t  proj4.Proj.projections.add(vandg);\n\t  proj4.Proj.projections.add(aeqd);\n\t  proj4.Proj.projections.add(ortho);\n\t  proj4.Proj.projections.add(qsc);\n\t};\n\n\tproj4$1.defaultDatum = 'WGS84'; //default datum\n\tproj4$1.Proj = Projection$1;\n\tproj4$1.WGS84 = new proj4$1.Proj('WGS84');\n\tproj4$1.Point = Point;\n\tproj4$1.toPoint = toPoint;\n\tproj4$1.defs = defs;\n\tproj4$1.transform = transform;\n\tproj4$1.mgrs = mgrs;\n\tproj4$1.version = version;\n\tincludedProjections(proj4$1);\n\n\treturn proj4$1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvajQvZGlzdC9wcm9qNC1zcmMuanM/M2UyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CLGtDQUFrQzs7QUFFbEM7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osaUJBQWlCO0FBQ2pCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsVUFBVTtBQUNWLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1QsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osYUFBYTtBQUNiLFlBQVk7O0FBRVo7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksT0FBTztBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEdBQUcsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixjQUFjO0FBQ2QsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsWUFBWTtBQUNaLGNBQWM7QUFDZCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixTQUFTO0FBQ1Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5wcm9qNCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZ2xvYmFscyA9IGZ1bmN0aW9uKGRlZnMpIHtcblx0ICBkZWZzKCdFUFNHOjQzMjYnLCBcIit0aXRsZT1XR1MgODQgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICtlbGxwcz1XR1M4NCArZGF0dW09V0dTODQgK3VuaXRzPWRlZ3JlZXNcIik7XG5cdCAgZGVmcygnRVBTRzo0MjY5JywgXCIrdGl0bGU9TkFEODMgKGxvbmcvbGF0KSArcHJvaj1sb25nbGF0ICthPTYzNzgxMzcuMCArYj02MzU2NzUyLjMxNDE0MDM2ICtlbGxwcz1HUlM4MCArZGF0dW09TkFEODMgK3VuaXRzPWRlZ3JlZXNcIik7XG5cdCAgZGVmcygnRVBTRzozODU3JywgXCIrdGl0bGU9V0dTIDg0IC8gUHNldWRvLU1lcmNhdG9yICtwcm9qPW1lcmMgK2E9NjM3ODEzNyArYj02Mzc4MTM3ICtsYXRfdHM9MC4wICtsb25fMD0wLjAgK3hfMD0wLjAgK3lfMD0wICtrPTEuMCArdW5pdHM9bSArbmFkZ3JpZHM9QG51bGwgK25vX2RlZnNcIik7XG5cblx0ICBkZWZzLldHUzg0ID0gZGVmc1snRVBTRzo0MzI2J107XG5cdCAgZGVmc1snRVBTRzozNzg1J10gPSBkZWZzWydFUFNHOjM4NTcnXTsgLy8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0LCBvZmZpY2lhbCBjb2RlIGlzIDM4NTdcblx0ICBkZWZzLkdPT0dMRSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuXHQgIGRlZnNbJ0VQU0c6OTAwOTEzJ10gPSBkZWZzWydFUFNHOjM4NTcnXTtcblx0ICBkZWZzWydFUFNHOjEwMjExMyddID0gZGVmc1snRVBTRzozODU3J107XG5cdH07XG5cblx0dmFyIFBKRF8zUEFSQU0gPSAxO1xuXHR2YXIgUEpEXzdQQVJBTSA9IDI7XG5cdHZhciBQSkRfV0dTODQgPSA0OyAvLyBXR1M4NCBvciBlcXVpdmFsZW50XG5cdHZhciBQSkRfTk9EQVRVTSA9IDU7IC8vIFdHUzg0IG9yIGVxdWl2YWxlbnRcblx0dmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xuXHR2YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblx0Ly8gZWxsaXBvaWQgcGpfc2V0X2VsbC5jXG5cdHZhciBTSVhUSCA9IDAuMTY2NjY2NjY2NjY2NjY2NjY2Nztcblx0LyogMS82ICovXG5cdHZhciBSQTQgPSAwLjA0NzIyMjIyMjIyMjIyMjIyMjIyO1xuXHQvKiAxNy8zNjAgKi9cblx0dmFyIFJBNiA9IDAuMDIyMTU2MDg0NjU2MDg0NjU2MDg7XG5cdHZhciBFUFNMTiA9IDEuMGUtMTA7XG5cdC8vIHlvdSdkIHRoaW5rIHlvdSBjb3VsZCB1c2UgTnVtYmVyLkVQU0lMT04gYWJvdmUgYnV0IHRoYXQgbWFrZXNcblx0Ly8gTW9sbHdlaWRlIGdldCBpbnRvIGFuIGluZmluYXRlIGxvb3AuXG5cblx0dmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG5cdHZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcblx0dmFyIEZPUlRQSSA9IE1hdGguUEkvNDtcblx0dmFyIFRXT19QSSA9IE1hdGguUEkgKiAyO1xuXHQvLyBTUEkgaXMgc2xpZ2h0bHkgZ3JlYXRlciB0aGFuIE1hdGguUEksIHNvIHZhbHVlcyB0aGF0IGV4Y2VlZCB0aGUgLTE4MC4uMTgwXG5cdC8vIGRlZ3JlZSByYW5nZSBieSBhIHRpbnkgYW1vdW50IGRvbid0IGdldCB3cmFwcGVkLiBUaGlzIHByZXZlbnRzIHBvaW50cyB0aGF0XG5cdC8vIGhhdmUgZHJpZnRlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFsb25nIHRoZSAxODB0aCBtZXJpZGlhbiAoZHVlIHRvXG5cdC8vIGZsb2F0aW5nIHBvaW50IGVycm9yKSBmcm9tIGNoYW5naW5nIHRoZWlyIHNpZ24uXG5cdHZhciBTUEkgPSAzLjE0MTU5MjY1MzU5O1xuXG5cdHZhciBleHBvcnRzJDEgPSB7fTtcblx0ZXhwb3J0cyQxLmdyZWVud2ljaCA9IDAuMDsgLy9cIjBkRVwiLFxuXHRleHBvcnRzJDEubGlzYm9uID0gLTkuMTMxOTA2MTExMTExOyAvL1wiOWQwNyc1NC44NjJcXFwiV1wiLFxuXHRleHBvcnRzJDEucGFyaXMgPSAyLjMzNzIyOTE2NjY2NzsgLy9cIjJkMjAnMTQuMDI1XFxcIkVcIixcblx0ZXhwb3J0cyQxLmJvZ290YSA9IC03NC4wODA5MTY2NjY2Njc7IC8vXCI3NGQwNCc1MS4zXFxcIldcIixcblx0ZXhwb3J0cyQxLm1hZHJpZCA9IC0zLjY4NzkzODg4ODg4OTsgLy9cIjNkNDEnMTYuNThcXFwiV1wiLFxuXHRleHBvcnRzJDEucm9tZSA9IDEyLjQ1MjMzMzMzMzMzMzsgLy9cIjEyZDI3JzguNFxcXCJFXCIsXG5cdGV4cG9ydHMkMS5iZXJuID0gNy40Mzk1ODMzMzMzMzM7IC8vXCI3ZDI2JzIyLjVcXFwiRVwiLFxuXHRleHBvcnRzJDEuamFrYXJ0YSA9IDEwNi44MDc3MTk0NDQ0NDQ7IC8vXCIxMDZkNDgnMjcuNzlcXFwiRVwiLFxuXHRleHBvcnRzJDEuZmVycm8gPSAtMTcuNjY2NjY2NjY2NjY3OyAvL1wiMTdkNDAnV1wiLFxuXHRleHBvcnRzJDEuYnJ1c3NlbHMgPSA0LjM2Nzk3NTsgLy9cIjRkMjInNC43MVxcXCJFXCIsXG5cdGV4cG9ydHMkMS5zdG9ja2hvbG0gPSAxOC4wNTgyNzc3Nzc3Nzg7IC8vXCIxOGQzJzI5LjhcXFwiRVwiLFxuXHRleHBvcnRzJDEuYXRoZW5zID0gMjMuNzE2MzM3NTsgLy9cIjIzZDQyJzU4LjgxNVxcXCJFXCIsXG5cdGV4cG9ydHMkMS5vc2xvID0gMTAuNzIyOTE2NjY2NjY3OyAvL1wiMTBkNDMnMjIuNVxcXCJFXCJcblxuXHR2YXIgdW5pdHMgPSB7XG5cdCAgZnQ6IHt0b19tZXRlcjogMC4zMDQ4fSxcblx0ICAndXMtZnQnOiB7dG9fbWV0ZXI6IDEyMDAgLyAzOTM3fVxuXHR9O1xuXG5cdHZhciBpZ25vcmVkQ2hhciA9IC9bXFxzX1xcLVxcL1xcKFxcKV0vZztcblx0ZnVuY3Rpb24gbWF0Y2gob2JqLCBrZXkpIHtcblx0ICBpZiAob2JqW2tleV0pIHtcblx0ICAgIHJldHVybiBvYmpba2V5XTtcblx0ICB9XG5cdCAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHQgIHZhciBsa2V5ID0ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZShpZ25vcmVkQ2hhciwgJycpO1xuXHQgIHZhciBpID0gLTE7XG5cdCAgdmFyIHRlc3RrZXksIHByb2Nlc3NlZEtleTtcblx0ICB3aGlsZSAoKytpIDwga2V5cy5sZW5ndGgpIHtcblx0ICAgIHRlc3RrZXkgPSBrZXlzW2ldO1xuXHQgICAgcHJvY2Vzc2VkS2V5ID0gdGVzdGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoaWdub3JlZENoYXIsICcnKTtcblx0ICAgIGlmIChwcm9jZXNzZWRLZXkgPT09IGxrZXkpIHtcblx0ICAgICAgcmV0dXJuIG9ialt0ZXN0a2V5XTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHR2YXIgcGFyc2VQcm9qID0gZnVuY3Rpb24oZGVmRGF0YSkge1xuXHQgIHZhciBzZWxmID0ge307XG5cdCAgdmFyIHBhcmFtT2JqID0gZGVmRGF0YS5zcGxpdCgnKycpLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gdi50cmltKCk7XG5cdCAgfSkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0ICAgIHJldHVybiBhO1xuXHQgIH0pLnJlZHVjZShmdW5jdGlvbihwLCBhKSB7XG5cdCAgICB2YXIgc3BsaXQgPSBhLnNwbGl0KCc9Jyk7XG5cdCAgICBzcGxpdC5wdXNoKHRydWUpO1xuXHQgICAgcFtzcGxpdFswXS50b0xvd2VyQ2FzZSgpXSA9IHNwbGl0WzFdO1xuXHQgICAgcmV0dXJuIHA7XG5cdCAgfSwge30pO1xuXHQgIHZhciBwYXJhbU5hbWUsIHBhcmFtVmFsLCBwYXJhbU91dG5hbWU7XG5cdCAgdmFyIHBhcmFtcyA9IHtcblx0ICAgIHByb2o6ICdwcm9qTmFtZScsXG5cdCAgICBkYXR1bTogJ2RhdHVtQ29kZScsXG5cdCAgICByZjogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLnJmID0gcGFyc2VGbG9hdCh2KTtcblx0ICAgIH0sXG5cdCAgICBsYXRfMDogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLmxhdDAgPSB2ICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGxhdF8xOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYubGF0MSA9IHYgKiBEMlI7XG5cdCAgICB9LFxuXHQgICAgbGF0XzI6IGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgc2VsZi5sYXQyID0gdiAqIEQyUjtcblx0ICAgIH0sXG5cdCAgICBsYXRfdHM6IGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgc2VsZi5sYXRfdHMgPSB2ICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGxvbl8wOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYubG9uZzAgPSB2ICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGxvbl8xOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYubG9uZzEgPSB2ICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGxvbl8yOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYubG9uZzIgPSB2ICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGFscGhhOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYuYWxwaGEgPSBwYXJzZUZsb2F0KHYpICogRDJSO1xuXHQgICAgfSxcblx0ICAgIGxvbmM6IGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgc2VsZi5sb25nYyA9IHYgKiBEMlI7XG5cdCAgICB9LFxuXHQgICAgeF8wOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYueDAgPSBwYXJzZUZsb2F0KHYpO1xuXHQgICAgfSxcblx0ICAgIHlfMDogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLnkwID0gcGFyc2VGbG9hdCh2KTtcblx0ICAgIH0sXG5cdCAgICBrXzA6IGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgc2VsZi5rMCA9IHBhcnNlRmxvYXQodik7XG5cdCAgICB9LFxuXHQgICAgazogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcblx0ICAgIH0sXG5cdCAgICBhOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYuYSA9IHBhcnNlRmxvYXQodik7XG5cdCAgICB9LFxuXHQgICAgYjogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLmIgPSBwYXJzZUZsb2F0KHYpO1xuXHQgICAgfSxcblx0ICAgIHJfYTogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGYuUl9BID0gdHJ1ZTtcblx0ICAgIH0sXG5cdCAgICB6b25lOiBmdW5jdGlvbih2KSB7XG5cdCAgICAgIHNlbGYuem9uZSA9IHBhcnNlSW50KHYsIDEwKTtcblx0ICAgIH0sXG5cdCAgICBzb3V0aDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHNlbGYudXRtU291dGggPSB0cnVlO1xuXHQgICAgfSxcblx0ICAgIHRvd2dzODQ6IGZ1bmN0aW9uKHYpIHtcblx0ICAgICAgc2VsZi5kYXR1bV9wYXJhbXMgPSB2LnNwbGl0KFwiLFwiKS5tYXAoZnVuY3Rpb24oYSkge1xuXHQgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEpO1xuXHQgICAgICB9KTtcblx0ICAgIH0sXG5cdCAgICB0b19tZXRlcjogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLnRvX21ldGVyID0gcGFyc2VGbG9hdCh2KTtcblx0ICAgIH0sXG5cdCAgICB1bml0czogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLnVuaXRzID0gdjtcblx0ICAgICAgdmFyIHVuaXQgPSBtYXRjaCh1bml0cywgdik7XG5cdCAgICAgIGlmICh1bml0KSB7XG5cdCAgICAgICAgc2VsZi50b19tZXRlciA9IHVuaXQudG9fbWV0ZXI7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBmcm9tX2dyZWVud2ljaDogZnVuY3Rpb24odikge1xuXHQgICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gdiAqIEQyUjtcblx0ICAgIH0sXG5cdCAgICBwbTogZnVuY3Rpb24odikge1xuXHQgICAgICB2YXIgcG0gPSBtYXRjaChleHBvcnRzJDEsIHYpO1xuXHQgICAgICBzZWxmLmZyb21fZ3JlZW53aWNoID0gKHBtID8gcG0gOiBwYXJzZUZsb2F0KHYpKSAqIEQyUjtcblx0ICAgIH0sXG5cdCAgICBuYWRncmlkczogZnVuY3Rpb24odikge1xuXHQgICAgICBpZiAodiA9PT0gJ0BudWxsJykge1xuXHQgICAgICAgIHNlbGYuZGF0dW1Db2RlID0gJ25vbmUnO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIHNlbGYubmFkZ3JpZHMgPSB2O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgYXhpczogZnVuY3Rpb24odikge1xuXHQgICAgICB2YXIgbGVnYWxBeGlzID0gXCJld25zdWRcIjtcblx0ICAgICAgaWYgKHYubGVuZ3RoID09PSAzICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDAsIDEpKSAhPT0gLTEgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMSwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigyLCAxKSkgIT09IC0xKSB7XG5cdCAgICAgICAgc2VsZi5heGlzID0gdjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1PYmopIHtcblx0ICAgIHBhcmFtVmFsID0gcGFyYW1PYmpbcGFyYW1OYW1lXTtcblx0ICAgIGlmIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG5cdCAgICAgIHBhcmFtT3V0bmFtZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXHQgICAgICBpZiAodHlwZW9mIHBhcmFtT3V0bmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHBhcmFtT3V0bmFtZShwYXJhbVZhbCk7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSB7XG5cdCAgICAgICAgc2VsZltwYXJhbU91dG5hbWVdID0gcGFyYW1WYWw7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICBzZWxmW3BhcmFtTmFtZV0gPSBwYXJhbVZhbDtcblx0ICAgIH1cblx0ICB9XG5cdCAgaWYodHlwZW9mIHNlbGYuZGF0dW1Db2RlID09PSAnc3RyaW5nJyAmJiBzZWxmLmRhdHVtQ29kZSAhPT0gXCJXR1M4NFwiKXtcblx0ICAgIHNlbGYuZGF0dW1Db2RlID0gc2VsZi5kYXR1bUNvZGUudG9Mb3dlckNhc2UoKTtcblx0ICB9XG5cdCAgcmV0dXJuIHNlbGY7XG5cdH07XG5cblx0dmFyIE5FVVRSQUwgPSAxO1xuXHR2YXIgS0VZV09SRCA9IDI7XG5cdHZhciBOVU1CRVIgPSAzO1xuXHR2YXIgUVVPVEVEID0gNDtcblx0dmFyIEFGVEVSUVVPVEUgPSA1O1xuXHR2YXIgRU5ERUQgPSAtMTtcblx0dmFyIHdoaXRlc3BhY2UgPSAvXFxzLztcblx0dmFyIGxhdGluID0gL1tBLVphLXpdLztcblx0dmFyIGtleXdvcmQgPSAvW0EtWmEtejg0XS87XG5cdHZhciBlbmRUaGluZ3MgPSAvWyxcXF1dLztcblx0dmFyIGRpZ2V0cyA9IC9bXFxkXFwuRVxcLVxcK10vO1xuXHQvLyBjb25zdCBpZ25vcmVkQ2hhciA9IC9bXFxzX1xcLVxcL1xcKFxcKV0vZztcblx0ZnVuY3Rpb24gUGFyc2VyKHRleHQpIHtcblx0ICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHN0cmluZycpO1xuXHQgIH1cblx0ICB0aGlzLnRleHQgPSB0ZXh0LnRyaW0oKTtcblx0ICB0aGlzLmxldmVsID0gMDtcblx0ICB0aGlzLnBsYWNlID0gMDtcblx0ICB0aGlzLnJvb3QgPSBudWxsO1xuXHQgIHRoaXMuc3RhY2sgPSBbXTtcblx0ICB0aGlzLmN1cnJlbnRPYmplY3QgPSBudWxsO1xuXHQgIHRoaXMuc3RhdGUgPSBORVVUUkFMO1xuXHR9XG5cdFBhcnNlci5wcm90b3R5cGUucmVhZENoYXJpY3RlciA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBjaGFyID0gdGhpcy50ZXh0W3RoaXMucGxhY2UrK107XG5cdCAgaWYgKHRoaXMuc3RhdGUgIT09IFFVT1RFRCkge1xuXHQgICAgd2hpbGUgKHdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuXHQgICAgICBpZiAodGhpcy5wbGFjZSA+PSB0aGlzLnRleHQubGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIGNoYXIgPSB0aGlzLnRleHRbdGhpcy5wbGFjZSsrXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG5cdCAgICBjYXNlIE5FVVRSQUw6XG5cdCAgICAgIHJldHVybiB0aGlzLm5ldXRyYWwoY2hhcik7XG5cdCAgICBjYXNlIEtFWVdPUkQ6XG5cdCAgICAgIHJldHVybiB0aGlzLmtleXdvcmQoY2hhcilcblx0ICAgIGNhc2UgUVVPVEVEOlxuXHQgICAgICByZXR1cm4gdGhpcy5xdW90ZWQoY2hhcik7XG5cdCAgICBjYXNlIEFGVEVSUVVPVEU6XG5cdCAgICAgIHJldHVybiB0aGlzLmFmdGVycXVvdGUoY2hhcik7XG5cdCAgICBjYXNlIE5VTUJFUjpcblx0ICAgICAgcmV0dXJuIHRoaXMubnVtYmVyKGNoYXIpO1xuXHQgICAgY2FzZSBFTkRFRDpcblx0ICAgICAgcmV0dXJuO1xuXHQgIH1cblx0fTtcblx0UGFyc2VyLnByb3RvdHlwZS5hZnRlcnF1b3RlID0gZnVuY3Rpb24oY2hhcikge1xuXHQgIGlmIChjaGFyID09PSAnXCInKSB7XG5cdCAgICB0aGlzLndvcmQgKz0gJ1wiJztcblx0ICAgIHRoaXMuc3RhdGUgPSBRVU9URUQ7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChlbmRUaGluZ3MudGVzdChjaGFyKSkge1xuXHQgICAgdGhpcy53b3JkID0gdGhpcy53b3JkLnRyaW0oKTtcblx0ICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIGFmdGVycXVvdGUgeWV0LCBpbmRleCAnICsgdGhpcy5wbGFjZSk7XG5cdH07XG5cdFBhcnNlci5wcm90b3R5cGUuYWZ0ZXJJdGVtID0gZnVuY3Rpb24oY2hhcikge1xuXHQgIGlmIChjaGFyID09PSAnLCcpIHtcblx0ICAgIGlmICh0aGlzLndvcmQgIT09IG51bGwpIHtcblx0ICAgICAgdGhpcy5jdXJyZW50T2JqZWN0LnB1c2godGhpcy53b3JkKTtcblx0ICAgIH1cblx0ICAgIHRoaXMud29yZCA9IG51bGw7XG5cdCAgICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGNoYXIgPT09ICddJykge1xuXHQgICAgdGhpcy5sZXZlbC0tO1xuXHQgICAgaWYgKHRoaXMud29yZCAhPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLmN1cnJlbnRPYmplY3QucHVzaCh0aGlzLndvcmQpO1xuXHQgICAgICB0aGlzLndvcmQgPSBudWxsO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdGF0ZSA9IE5FVVRSQUw7XG5cdCAgICB0aGlzLmN1cnJlbnRPYmplY3QgPSB0aGlzLnN0YWNrLnBvcCgpO1xuXHQgICAgaWYgKCF0aGlzLmN1cnJlbnRPYmplY3QpIHtcblx0ICAgICAgdGhpcy5zdGF0ZSA9IEVOREVEO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHR9O1xuXHRQYXJzZXIucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKGNoYXIpIHtcblx0ICBpZiAoZGlnZXRzLnRlc3QoY2hhcikpIHtcblx0ICAgIHRoaXMud29yZCArPSBjaGFyO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICBpZiAoZW5kVGhpbmdzLnRlc3QoY2hhcikpIHtcblx0ICAgIHRoaXMud29yZCA9IHBhcnNlRmxvYXQodGhpcy53b3JkKTtcblx0ICAgIHRoaXMuYWZ0ZXJJdGVtKGNoYXIpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoJ2hhdm5cXCd0IGhhbmRsZWQgXCInICtjaGFyICsgJ1wiIGluIG51bWJlciB5ZXQsIGluZGV4ICcgKyB0aGlzLnBsYWNlKTtcblx0fTtcblx0UGFyc2VyLnByb3RvdHlwZS5xdW90ZWQgPSBmdW5jdGlvbihjaGFyKSB7XG5cdCAgaWYgKGNoYXIgPT09ICdcIicpIHtcblx0ICAgIHRoaXMuc3RhdGUgPSBBRlRFUlFVT1RFO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB0aGlzLndvcmQgKz0gY2hhcjtcblx0ICByZXR1cm47XG5cdH07XG5cdFBhcnNlci5wcm90b3R5cGUua2V5d29yZCA9IGZ1bmN0aW9uKGNoYXIpIHtcblx0ICBpZiAoa2V5d29yZC50ZXN0KGNoYXIpKSB7XG5cdCAgICB0aGlzLndvcmQgKz0gY2hhcjtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGNoYXIgPT09ICdbJykge1xuXHQgICAgdmFyIG5ld09iamVjdHMgPSBbXTtcblx0ICAgIG5ld09iamVjdHMucHVzaCh0aGlzLndvcmQpO1xuXHQgICAgdGhpcy5sZXZlbCsrO1xuXHQgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xuXHQgICAgICB0aGlzLnJvb3QgPSBuZXdPYmplY3RzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5jdXJyZW50T2JqZWN0LnB1c2gobmV3T2JqZWN0cyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50T2JqZWN0KTtcblx0ICAgIHRoaXMuY3VycmVudE9iamVjdCA9IG5ld09iamVjdHM7XG5cdCAgICB0aGlzLnN0YXRlID0gTkVVVFJBTDtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGVuZFRoaW5ncy50ZXN0KGNoYXIpKSB7XG5cdCAgICB0aGlzLmFmdGVySXRlbShjaGFyKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdoYXZuXFwndCBoYW5kbGVkIFwiJyArY2hhciArICdcIiBpbiBrZXl3b3JkIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xuXHR9O1xuXHRQYXJzZXIucHJvdG90eXBlLm5ldXRyYWwgPSBmdW5jdGlvbihjaGFyKSB7XG5cdCAgaWYgKGxhdGluLnRlc3QoY2hhcikpIHtcblx0ICAgIHRoaXMud29yZCA9IGNoYXI7XG5cdCAgICB0aGlzLnN0YXRlID0gS0VZV09SRDtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGNoYXIgPT09ICdcIicpIHtcblx0ICAgIHRoaXMud29yZCA9ICcnO1xuXHQgICAgdGhpcy5zdGF0ZSA9IFFVT1RFRDtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGRpZ2V0cy50ZXN0KGNoYXIpKSB7XG5cdCAgICB0aGlzLndvcmQgPSBjaGFyO1xuXHQgICAgdGhpcy5zdGF0ZSA9IE5VTUJFUjtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGVuZFRoaW5ncy50ZXN0KGNoYXIpKSB7XG5cdCAgICB0aGlzLmFmdGVySXRlbShjaGFyKTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdoYXZuXFwndCBoYW5kbGVkIFwiJyArY2hhciArICdcIiBpbiBuZXV0cmFsIHlldCwgaW5kZXggJyArIHRoaXMucGxhY2UpO1xuXHR9O1xuXHRQYXJzZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uKCkge1xuXHQgIHdoaWxlICh0aGlzLnBsYWNlIDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuXHQgICAgdGhpcy5yZWFkQ2hhcmljdGVyKCk7XG5cdCAgfVxuXHQgIGlmICh0aGlzLnN0YXRlID09PSBFTkRFRCkge1xuXHQgICAgcmV0dXJuIHRoaXMucm9vdDtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gcGFyc2Ugc3RyaW5nIFwiJyArdGhpcy50ZXh0ICsgJ1wiLiBTdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gcGFyc2VTdHJpbmcodHh0KSB7XG5cdCAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIodHh0KTtcblx0ICByZXR1cm4gcGFyc2VyLm91dHB1dCgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFwaXQob2JqLCBrZXksIHZhbHVlKSB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuXHQgICAgdmFsdWUudW5zaGlmdChrZXkpO1xuXHQgICAga2V5ID0gbnVsbDtcblx0ICB9XG5cdCAgdmFyIHRoaW5nID0ga2V5ID8ge30gOiBvYmo7XG5cblx0ICB2YXIgb3V0ID0gdmFsdWUucmVkdWNlKGZ1bmN0aW9uKG5ld09iaiwgaXRlbSkge1xuXHQgICAgc0V4cHIoaXRlbSwgbmV3T2JqKTtcblx0ICAgIHJldHVybiBuZXdPYmpcblx0ICB9LCB0aGluZyk7XG5cdCAgaWYgKGtleSkge1xuXHQgICAgb2JqW2tleV0gPSBvdXQ7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gc0V4cHIodiwgb2JqKSB7XG5cdCAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG5cdCAgICBvYmpbdl0gPSB0cnVlO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIga2V5ID0gdi5zaGlmdCgpO1xuXHQgIGlmIChrZXkgPT09ICdQQVJBTUVURVInKSB7XG5cdCAgICBrZXkgPSB2LnNoaWZ0KCk7XG5cdCAgfVxuXHQgIGlmICh2Lmxlbmd0aCA9PT0gMSkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkodlswXSkpIHtcblx0ICAgICAgb2JqW2tleV0gPSB7fTtcblx0ICAgICAgc0V4cHIodlswXSwgb2JqW2tleV0pO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBvYmpba2V5XSA9IHZbMF07XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmICghdi5sZW5ndGgpIHtcblx0ICAgIG9ialtrZXldID0gdHJ1ZTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgaWYgKGtleSA9PT0gJ1RPV0dTODQnKSB7XG5cdCAgICBvYmpba2V5XSA9IHY7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmICghQXJyYXkuaXNBcnJheShrZXkpKSB7XG5cdCAgICBvYmpba2V5XSA9IHt9O1xuXHQgIH1cblxuXHQgIHZhciBpO1xuXHQgIHN3aXRjaCAoa2V5KSB7XG5cdCAgICBjYXNlICdVTklUJzpcblx0ICAgIGNhc2UgJ1BSSU1FTSc6XG5cdCAgICBjYXNlICdWRVJUX0RBVFVNJzpcblx0ICAgICAgb2JqW2tleV0gPSB7XG5cdCAgICAgICAgbmFtZTogdlswXS50b0xvd2VyQ2FzZSgpLFxuXHQgICAgICAgIGNvbnZlcnQ6IHZbMV1cblx0ICAgICAgfTtcblx0ICAgICAgaWYgKHYubGVuZ3RoID09PSAzKSB7XG5cdCAgICAgICAgc0V4cHIodlsyXSwgb2JqW2tleV0pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybjtcblx0ICAgIGNhc2UgJ1NQSEVST0lEJzpcblx0ICAgIGNhc2UgJ0VMTElQU09JRCc6XG5cdCAgICAgIG9ialtrZXldID0ge1xuXHQgICAgICAgIG5hbWU6IHZbMF0sXG5cdCAgICAgICAgYTogdlsxXSxcblx0ICAgICAgICByZjogdlsyXVxuXHQgICAgICB9O1xuXHQgICAgICBpZiAodi5sZW5ndGggPT09IDQpIHtcblx0ICAgICAgICBzRXhwcih2WzNdLCBvYmpba2V5XSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuO1xuXHQgICAgY2FzZSAnUFJPSkVDVEVEQ1JTJzpcblx0ICAgIGNhc2UgJ1BST0pDUlMnOlxuXHQgICAgY2FzZSAnR0VPR0NTJzpcblx0ICAgIGNhc2UgJ0dFT0NDUyc6XG5cdCAgICBjYXNlICdQUk9KQ1MnOlxuXHQgICAgY2FzZSAnTE9DQUxfQ1MnOlxuXHQgICAgY2FzZSAnR0VPRENSUyc6XG5cdCAgICBjYXNlICdHRU9ERVRJQ0NSUyc6XG5cdCAgICBjYXNlICdHRU9ERVRJQ0RBVFVNJzpcblx0ICAgIGNhc2UgJ0VEQVRVTSc6XG5cdCAgICBjYXNlICdFTkdJTkVFUklOR0RBVFVNJzpcblx0ICAgIGNhc2UgJ1ZFUlRfQ1MnOlxuXHQgICAgY2FzZSAnVkVSVENSUyc6XG5cdCAgICBjYXNlICdWRVJUSUNBTENSUyc6XG5cdCAgICBjYXNlICdDT01QRF9DUyc6XG5cdCAgICBjYXNlICdDT01QT1VORENSUyc6XG5cdCAgICBjYXNlICdFTkdJTkVFUklOR0NSUyc6XG5cdCAgICBjYXNlICdFTkdDUlMnOlxuXHQgICAgY2FzZSAnRklUVEVEX0NTJzpcblx0ICAgIGNhc2UgJ0xPQ0FMX0RBVFVNJzpcblx0ICAgIGNhc2UgJ0RBVFVNJzpcblx0ICAgICAgdlswXSA9IFsnbmFtZScsIHZbMF1dO1xuXHQgICAgICBtYXBpdChvYmosIGtleSwgdik7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIGkgPSAtMTtcblx0ICAgICAgd2hpbGUgKCsraSA8IHYubGVuZ3RoKSB7XG5cdCAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZbaV0pKSB7XG5cdCAgICAgICAgICByZXR1cm4gc0V4cHIodiwgb2JqW2tleV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gbWFwaXQob2JqLCBrZXksIHYpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBEMlIkMSA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG5cdGZ1bmN0aW9uIHJlbmFtZShvYmosIHBhcmFtcykge1xuXHQgIHZhciBvdXROYW1lID0gcGFyYW1zWzBdO1xuXHQgIHZhciBpbk5hbWUgPSBwYXJhbXNbMV07XG5cdCAgaWYgKCEob3V0TmFtZSBpbiBvYmopICYmIChpbk5hbWUgaW4gb2JqKSkge1xuXHQgICAgb2JqW291dE5hbWVdID0gb2JqW2luTmFtZV07XG5cdCAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMykge1xuXHQgICAgICBvYmpbb3V0TmFtZV0gPSBwYXJhbXNbMl0ob2JqW291dE5hbWVdKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBkMnIoaW5wdXQpIHtcblx0ICByZXR1cm4gaW5wdXQgKiBEMlIkMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFuV0tUKHdrdCkge1xuXHQgIGlmICh3a3QudHlwZSA9PT0gJ0dFT0dDUycpIHtcblx0ICAgIHdrdC5wcm9qTmFtZSA9ICdsb25nbGF0Jztcblx0ICB9IGVsc2UgaWYgKHdrdC50eXBlID09PSAnTE9DQUxfQ1MnKSB7XG5cdCAgICB3a3QucHJvak5hbWUgPSAnaWRlbnRpdHknO1xuXHQgICAgd2t0LmxvY2FsID0gdHJ1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHR5cGVvZiB3a3QuUFJPSkVDVElPTiA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgd2t0LnByb2pOYW1lID0gT2JqZWN0LmtleXMod2t0LlBST0pFQ1RJT04pWzBdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgd2t0LnByb2pOYW1lID0gd2t0LlBST0pFQ1RJT047XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICh3a3QuVU5JVCkge1xuXHQgICAgd2t0LnVuaXRzID0gd2t0LlVOSVQubmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgaWYgKHdrdC51bml0cyA9PT0gJ21ldHJlJykge1xuXHQgICAgICB3a3QudW5pdHMgPSAnbWV0ZXInO1xuXHQgICAgfVxuXHQgICAgaWYgKHdrdC5VTklULmNvbnZlcnQpIHtcblx0ICAgICAgaWYgKHdrdC50eXBlID09PSAnR0VPR0NTJykge1xuXHQgICAgICAgIGlmICh3a3QuREFUVU0gJiYgd2t0LkRBVFVNLlNQSEVST0lEKSB7XG5cdCAgICAgICAgICB3a3QudG9fbWV0ZXIgPSB3a3QuVU5JVC5jb252ZXJ0KndrdC5EQVRVTS5TUEhFUk9JRC5hO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB3a3QudG9fbWV0ZXIgPSB3a3QuVU5JVC5jb252ZXJ0LCAxMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICB2YXIgZ2VvZ2NzID0gd2t0LkdFT0dDUztcblx0ICBpZiAod2t0LnR5cGUgPT09ICdHRU9HQ1MnKSB7XG5cdCAgICBnZW9nY3MgPSB3a3Q7XG5cdCAgfVxuXHQgIGlmIChnZW9nY3MpIHtcblx0ICAgIC8vaWYod2t0LkdFT0dDUy5QUklNRU0mJndrdC5HRU9HQ1MuUFJJTUVNLmNvbnZlcnQpe1xuXHQgICAgLy8gIHdrdC5mcm9tX2dyZWVud2ljaD13a3QuR0VPR0NTLlBSSU1FTS5jb252ZXJ0KkQyUjtcblx0ICAgIC8vfVxuXHQgICAgaWYgKGdlb2djcy5EQVRVTSkge1xuXHQgICAgICB3a3QuZGF0dW1Db2RlID0gZ2VvZ2NzLkRBVFVNLm5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHdrdC5kYXR1bUNvZGUgPSBnZW9nY3MubmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgMikgPT09ICdkXycpIHtcblx0ICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5kYXR1bUNvZGUuc2xpY2UoMik7XG5cdCAgICB9XG5cdCAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kX2dlb2RldGljX2RhdHVtXzE5NDknIHx8IHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF8xOTQ5Jykge1xuXHQgICAgICB3a3QuZGF0dW1Db2RlID0gJ256Z2Q0OSc7XG5cdCAgICB9XG5cdCAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ3dnc18xOTg0Jykge1xuXHQgICAgICBpZiAod2t0LlBST0pFQ1RJT04gPT09ICdNZXJjYXRvcl9BdXhpbGlhcnlfU3BoZXJlJykge1xuXHQgICAgICAgIHdrdC5zcGhlcmUgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIHdrdC5kYXR1bUNvZGUgPSAnd2dzODQnO1xuXHQgICAgfVxuXHQgICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTYpID09PSAnX2ZlcnJvJykge1xuXHQgICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDYpO1xuXHQgICAgfVxuXHQgICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoLTgpID09PSAnX2pha2FydGEnKSB7XG5cdCAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gOCk7XG5cdCAgICB9XG5cdCAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignYmVsZ2UnKSkge1xuXHQgICAgICB3a3QuZGF0dW1Db2RlID0gJ3JuYjcyJztcblx0ICAgIH1cblx0ICAgIGlmIChnZW9nY3MuREFUVU0gJiYgZ2VvZ2NzLkRBVFVNLlNQSEVST0lEKSB7XG5cdCAgICAgIHdrdC5lbGxwcyA9IGdlb2djcy5EQVRVTS5TUEhFUk9JRC5uYW1lLnJlcGxhY2UoJ18xOScsICcnKS5yZXBsYWNlKC9bQ2NdbGFya2VcXF8xOC8sICdjbHJrJyk7XG5cdCAgICAgIGlmICh3a3QuZWxscHMudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAxMykgPT09ICdpbnRlcm5hdGlvbmFsJykge1xuXHQgICAgICAgIHdrdC5lbGxwcyA9ICdpbnRsJztcblx0ICAgICAgfVxuXG5cdCAgICAgIHdrdC5hID0gZ2VvZ2NzLkRBVFVNLlNQSEVST0lELmE7XG5cdCAgICAgIHdrdC5yZiA9IHBhcnNlRmxvYXQoZ2VvZ2NzLkRBVFVNLlNQSEVST0lELnJmLCAxMCk7XG5cdCAgICB9XG5cdCAgICBpZiAofndrdC5kYXR1bUNvZGUuaW5kZXhPZignb3NnYl8xOTM2JykpIHtcblx0ICAgICAgd2t0LmRhdHVtQ29kZSA9ICdvc2diMzYnO1xuXHQgICAgfVxuXHQgICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ29zbmlfMTk1MicpKSB7XG5cdCAgICAgIHdrdC5kYXR1bUNvZGUgPSAnb3NuaTUyJztcblx0ICAgIH1cblx0ICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCd0bTY1Jylcblx0ICAgICAgfHwgfndrdC5kYXR1bUNvZGUuaW5kZXhPZignZ2VvZGV0aWNfZGF0dW1fb2ZfMTk2NScpKSB7XG5cdCAgICAgIHdrdC5kYXR1bUNvZGUgPSAnaXJlNjUnO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAod2t0LmIgJiYgIWlzRmluaXRlKHdrdC5iKSkge1xuXHQgICAgd2t0LmIgPSB3a3QuYTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiB0b01ldGVyKGlucHV0KSB7XG5cdCAgICB2YXIgcmF0aW8gPSB3a3QudG9fbWV0ZXIgfHwgMTtcblx0ICAgIHJldHVybiBpbnB1dCAqIHJhdGlvO1xuXHQgIH1cblx0ICB2YXIgcmVuYW1lciA9IGZ1bmN0aW9uKGEpIHtcblx0ICAgIHJldHVybiByZW5hbWUod2t0LCBhKTtcblx0ICB9O1xuXHQgIHZhciBsaXN0ID0gW1xuXHQgICAgWydzdGFuZGFyZF9wYXJhbGxlbF8xJywgJ1N0YW5kYXJkX1BhcmFsbGVsXzEnXSxcblx0ICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMicsICdTdGFuZGFyZF9QYXJhbGxlbF8yJ10sXG5cdCAgICBbJ2ZhbHNlX2Vhc3RpbmcnLCAnRmFsc2VfRWFzdGluZyddLFxuXHQgICAgWydmYWxzZV9ub3J0aGluZycsICdGYWxzZV9Ob3J0aGluZyddLFxuXHQgICAgWydjZW50cmFsX21lcmlkaWFuJywgJ0NlbnRyYWxfTWVyaWRpYW4nXSxcblx0ICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0xhdGl0dWRlX09mX09yaWdpbiddLFxuXHQgICAgWydsYXRpdHVkZV9vZl9vcmlnaW4nLCAnQ2VudHJhbF9QYXJhbGxlbCddLFxuXHQgICAgWydzY2FsZV9mYWN0b3InLCAnU2NhbGVfRmFjdG9yJ10sXG5cdCAgICBbJ2swJywgJ3NjYWxlX2ZhY3RvciddLFxuXHQgICAgWydsYXRpdHVkZV9vZl9jZW50ZXInLCAnTGF0aXR1ZGVfb2ZfY2VudGVyJ10sXG5cdCAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcblx0ICAgIFsnbG9uZ2l0dWRlX29mX2NlbnRlcicsICdMb25naXR1ZGVfT2ZfQ2VudGVyJ10sXG5cdCAgICBbJ2xvbmdjJywgJ2xvbmdpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuXHQgICAgWyd4MCcsICdmYWxzZV9lYXN0aW5nJywgdG9NZXRlcl0sXG5cdCAgICBbJ3kwJywgJ2ZhbHNlX25vcnRoaW5nJywgdG9NZXRlcl0sXG5cdCAgICBbJ2xvbmcwJywgJ2NlbnRyYWxfbWVyaWRpYW4nLCBkMnJdLFxuXHQgICAgWydsYXQwJywgJ2xhdGl0dWRlX29mX29yaWdpbicsIGQycl0sXG5cdCAgICBbJ2xhdDAnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG5cdCAgICBbJ2xhdDEnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG5cdCAgICBbJ2xhdDInLCAnc3RhbmRhcmRfcGFyYWxsZWxfMicsIGQycl0sXG5cdCAgICBbJ2FscGhhJywgJ2F6aW11dGgnLCBkMnJdLFxuXHQgICAgWydzcnNDb2RlJywgJ25hbWUnXVxuXHQgIF07XG5cdCAgbGlzdC5mb3JFYWNoKHJlbmFtZXIpO1xuXHQgIGlmICghd2t0LmxvbmcwICYmIHdrdC5sb25nYyAmJiAod2t0LnByb2pOYW1lID09PSAnQWxiZXJzX0NvbmljX0VxdWFsX0FyZWEnIHx8IHdrdC5wcm9qTmFtZSA9PT0gJ0xhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWEnKSkge1xuXHQgICAgd2t0LmxvbmcwID0gd2t0LmxvbmdjO1xuXHQgIH1cblx0ICBpZiAoIXdrdC5sYXRfdHMgJiYgd2t0LmxhdDEgJiYgKHdrdC5wcm9qTmFtZSA9PT0gJ1N0ZXJlb2dyYXBoaWNfU291dGhfUG9sZScgfHwgd2t0LnByb2pOYW1lID09PSAnUG9sYXIgU3RlcmVvZ3JhcGhpYyAodmFyaWFudCBCKScpKSB7XG5cdCAgICB3a3QubGF0MCA9IGQycih3a3QubGF0MSA+IDAgPyA5MCA6IC05MCk7XG5cdCAgICB3a3QubGF0X3RzID0gd2t0LmxhdDE7XG5cdCAgfVxuXHR9XG5cdHZhciB3a3QgPSBmdW5jdGlvbih3a3QpIHtcblx0ICB2YXIgbGlzcCA9IHBhcnNlU3RyaW5nKHdrdCk7XG5cdCAgdmFyIHR5cGUgPSBsaXNwLnNoaWZ0KCk7XG5cdCAgdmFyIG5hbWUgPSBsaXNwLnNoaWZ0KCk7XG5cdCAgbGlzcC51bnNoaWZ0KFsnbmFtZScsIG5hbWVdKTtcblx0ICBsaXNwLnVuc2hpZnQoWyd0eXBlJywgdHlwZV0pO1xuXHQgIHZhciBvYmogPSB7fTtcblx0ICBzRXhwcihsaXNwLCBvYmopO1xuXHQgIGNsZWFuV0tUKG9iaik7XG5cdCAgcmV0dXJuIG9iajtcblx0fTtcblxuXHRmdW5jdGlvbiBkZWZzKG5hbWUpIHtcblx0ICAvKmdsb2JhbCBjb25zb2xlKi9cblx0ICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcblx0ICAgIHZhciBkZWYgPSBhcmd1bWVudHNbMV07XG5cdCAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKGRlZi5jaGFyQXQoMCkgPT09ICcrJykge1xuXHQgICAgICAgIGRlZnNbbmFtZV0gPSBwYXJzZVByb2ooYXJndW1lbnRzWzFdKTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICBkZWZzW25hbWVdID0gd2t0KGFyZ3VtZW50c1sxXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlZnNbbmFtZV0gPSBkZWY7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG5cdCAgICAgIHJldHVybiBuYW1lLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcblx0ICAgICAgICAgIGRlZnMuYXBwbHkodGhhdCwgdik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgZGVmcyh2KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmIChuYW1lIGluIGRlZnMpIHtcblx0ICAgICAgICByZXR1cm4gZGVmc1tuYW1lXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoJ0VQU0cnIGluIG5hbWUpIHtcblx0ICAgICAgZGVmc1snRVBTRzonICsgbmFtZS5FUFNHXSA9IG5hbWU7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICgnRVNSSScgaW4gbmFtZSkge1xuXHQgICAgICBkZWZzWydFU1JJOicgKyBuYW1lLkVTUkldID0gbmFtZTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKCdJQVUyMDAwJyBpbiBuYW1lKSB7XG5cdCAgICAgIGRlZnNbJ0lBVTIwMDA6JyArIG5hbWUuSUFVMjAwMF0gPSBuYW1lO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuO1xuXHQgIH1cblxuXG5cdH1cblx0Z2xvYmFscyhkZWZzKTtcblxuXHRmdW5jdGlvbiB0ZXN0T2JqKGNvZGUpe1xuXHQgIHJldHVybiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZyc7XG5cdH1cblx0ZnVuY3Rpb24gdGVzdERlZihjb2RlKXtcblx0ICByZXR1cm4gY29kZSBpbiBkZWZzO1xuXHR9XG5cdCB2YXIgY29kZVdvcmRzID0gWydQUk9KRUNURURDUlMnLCAnUFJPSkNSUycsICdHRU9HQ1MnLCdHRU9DQ1MnLCdQUk9KQ1MnLCdMT0NBTF9DUycsICdHRU9EQ1JTJywgJ0dFT0RFVElDQ1JTJywgJ0dFT0RFVElDREFUVU0nLCAnRU5HQ1JTJywgJ0VOR0lORUVSSU5HQ1JTJ107IFxuXHRmdW5jdGlvbiB0ZXN0V0tUKGNvZGUpe1xuXHQgIHJldHVybiBjb2RlV29yZHMuc29tZShmdW5jdGlvbiAod29yZCkge1xuXHQgICAgcmV0dXJuIGNvZGUuaW5kZXhPZih3b3JkKSA+IC0xO1xuXHQgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIHRlc3RQcm9qKGNvZGUpe1xuXHQgIHJldHVybiBjb2RlWzBdID09PSAnKyc7XG5cdH1cblx0ZnVuY3Rpb24gcGFyc2UoY29kZSl7XG5cdCAgaWYgKHRlc3RPYmooY29kZSkpIHtcblx0ICAgIC8vY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBXS1Qgc3RyaW5nXG5cdCAgICBpZiAodGVzdERlZihjb2RlKSkge1xuXHQgICAgICByZXR1cm4gZGVmc1tjb2RlXTtcblx0ICAgIH1cblx0ICAgIGlmICh0ZXN0V0tUKGNvZGUpKSB7XG5cdCAgICAgIHJldHVybiB3a3QoY29kZSk7XG5cdCAgICB9XG5cdCAgICBpZiAodGVzdFByb2ooY29kZSkpIHtcblx0ICAgICAgcmV0dXJuIHBhcnNlUHJvaihjb2RlKTtcblx0ICAgIH1cblx0ICB9ZWxzZXtcblx0ICAgIHJldHVybiBjb2RlO1xuXHQgIH1cblx0fVxuXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG5cdCAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcblx0ICB2YXIgdmFsdWUsIHByb3BlcnR5O1xuXHQgIGlmICghc291cmNlKSB7XG5cdCAgICByZXR1cm4gZGVzdGluYXRpb247XG5cdCAgfVxuXHQgIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG5cdCAgICB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG5cdCAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuXHR9O1xuXG5cdHZhciBtc2ZueiA9IGZ1bmN0aW9uKGVjY2VudCwgc2lucGhpLCBjb3NwaGkpIHtcblx0ICB2YXIgY29uID0gZWNjZW50ICogc2lucGhpO1xuXHQgIHJldHVybiBjb3NwaGkgLyAoTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pKTtcblx0fTtcblxuXHR2YXIgc2lnbiA9IGZ1bmN0aW9uKHgpIHtcblx0ICByZXR1cm4geDwwID8gLTEgOiAxO1xuXHR9O1xuXG5cdHZhciBhZGp1c3RfbG9uID0gZnVuY3Rpb24oeCkge1xuXHQgIHJldHVybiAoTWF0aC5hYnMoeCkgPD0gU1BJKSA/IHggOiAoeCAtIChzaWduKHgpICogVFdPX1BJKSk7XG5cdH07XG5cblx0dmFyIHRzZm56ID0gZnVuY3Rpb24oZWNjZW50LCBwaGksIHNpbnBoaSkge1xuXHQgIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG5cdCAgdmFyIGNvbSA9IDAuNSAqIGVjY2VudDtcblx0ICBjb24gPSBNYXRoLnBvdygoKDEgLSBjb24pIC8gKDEgKyBjb24pKSwgY29tKTtcblx0ICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJIC0gcGhpKSkgLyBjb24pO1xuXHR9O1xuXG5cdHZhciBwaGkyeiA9IGZ1bmN0aW9uKGVjY2VudCwgdHMpIHtcblx0ICB2YXIgZWNjbnRoID0gMC41ICogZWNjZW50O1xuXHQgIHZhciBjb24sIGRwaGk7XG5cdCAgdmFyIHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8PSAxNTsgaSsrKSB7XG5cdCAgICBjb24gPSBlY2NlbnQgKiBNYXRoLnNpbihwaGkpO1xuXHQgICAgZHBoaSA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKHRzICogKE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBlY2NudGgpKSkgLSBwaGk7XG5cdCAgICBwaGkgKz0gZHBoaTtcblx0ICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcblx0ICAgICAgcmV0dXJuIHBoaTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy9jb25zb2xlLmxvZyhcInBoaTJ6IGhhcyBOb0NvbnZlcmdlbmNlXCIpO1xuXHQgIHJldHVybiAtOTk5OTtcblx0fTtcblxuXHRmdW5jdGlvbiBpbml0KCkge1xuXHQgIHZhciBjb24gPSB0aGlzLmIgLyB0aGlzLmE7XG5cdCAgdGhpcy5lcyA9IDEgLSBjb24gKiBjb247XG5cdCAgaWYoISgneDAnIGluIHRoaXMpKXtcblx0ICAgIHRoaXMueDAgPSAwO1xuXHQgIH1cblx0ICBpZighKCd5MCcgaW4gdGhpcykpe1xuXHQgICAgdGhpcy55MCA9IDA7XG5cdCAgfVxuXHQgIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcblx0ICBpZiAodGhpcy5sYXRfdHMpIHtcblx0ICAgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgICB0aGlzLmswID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHRoaXMuazAgPSBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBpZiAoIXRoaXMuazApIHtcblx0ICAgICAgaWYgKHRoaXMuaykge1xuXHQgICAgICAgIHRoaXMuazAgPSB0aGlzLms7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSB7XG5cdCAgICAgICAgdGhpcy5rMCA9IDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHQvKiBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gZm9yd2FyZChwKSB7XG5cdCAgdmFyIGxvbiA9IHAueDtcblx0ICB2YXIgbGF0ID0gcC55O1xuXHQgIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuXHQgIGlmIChsYXQgKiBSMkQgPiA5MCAmJiBsYXQgKiBSMkQgPCAtOTAgJiYgbG9uICogUjJEID4gMTgwICYmIGxvbiAqIFIyRCA8IC0xODApIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblxuXHQgIHZhciB4LCB5O1xuXHQgIGlmIChNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSkgPD0gRVBTTE4pIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgICAgICB5ID0gdGhpcy55MCArIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZyhNYXRoLnRhbihGT1JUUEkgKyAwLjUgKiBsYXQpKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICB2YXIgc2lucGhpID0gTWF0aC5zaW4obGF0KTtcblx0ICAgICAgdmFyIHRzID0gdHNmbnoodGhpcy5lLCBsYXQsIHNpbnBoaSk7XG5cdCAgICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cdCAgICAgIHkgPSB0aGlzLnkwIC0gdGhpcy5hICogdGhpcy5rMCAqIE1hdGgubG9nKHRzKTtcblx0ICAgIH1cblx0ICAgIHAueCA9IHg7XG5cdCAgICBwLnkgPSB5O1xuXHQgICAgcmV0dXJuIHA7XG5cdCAgfVxuXHR9XG5cblx0LyogTWVyY2F0b3IgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG5cdCAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBpbnZlcnNlKHApIHtcblxuXHQgIHZhciB4ID0gcC54IC0gdGhpcy54MDtcblx0ICB2YXIgeSA9IHAueSAtIHRoaXMueTA7XG5cdCAgdmFyIGxvbiwgbGF0O1xuXG5cdCAgaWYgKHRoaXMuc3BoZXJlKSB7XG5cdCAgICBsYXQgPSBIQUxGX1BJIC0gMiAqIE1hdGguYXRhbihNYXRoLmV4cCgteSAvICh0aGlzLmEgKiB0aGlzLmswKSkpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciB0cyA9IE1hdGguZXhwKC15IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblx0ICAgIGxhdCA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuXHQgICAgaWYgKGxhdCA9PT0gLTk5OTkpIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHggLyAodGhpcy5hICogdGhpcy5rMCkpO1xuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdHZhciBuYW1lcyQxID0gW1wiTWVyY2F0b3JcIiwgXCJQb3B1bGFyIFZpc3VhbGlzYXRpb24gUHNldWRvIE1lcmNhdG9yXCIsIFwiTWVyY2F0b3JfMVNQXCIsIFwiTWVyY2F0b3JfQXV4aWxpYXJ5X1NwaGVyZVwiLCBcIm1lcmNcIl07XG5cdHZhciBtZXJjID0ge1xuXHQgIGluaXQ6IGluaXQsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCxcblx0ICBpbnZlcnNlOiBpbnZlcnNlLFxuXHQgIG5hbWVzOiBuYW1lcyQxXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQxKCkge1xuXHQgIC8vbm8tb3AgZm9yIGxvbmdsYXRcblx0fVxuXG5cdGZ1bmN0aW9uIGlkZW50aXR5KHB0KSB7XG5cdCAgcmV0dXJuIHB0O1xuXHR9XG5cdHZhciBuYW1lcyQyID0gW1wibG9uZ2xhdFwiLCBcImlkZW50aXR5XCJdO1xuXHR2YXIgbG9uZ2xhdCA9IHtcblx0ICBpbml0OiBpbml0JDEsXG5cdCAgZm9yd2FyZDogaWRlbnRpdHksXG5cdCAgaW52ZXJzZTogaWRlbnRpdHksXG5cdCAgbmFtZXM6IG5hbWVzJDJcblx0fTtcblxuXHR2YXIgcHJvanMgPSBbbWVyYywgbG9uZ2xhdF07XG5cdHZhciBuYW1lcyQkMSA9IHt9O1xuXHR2YXIgcHJvalN0b3JlID0gW107XG5cblx0ZnVuY3Rpb24gYWRkKHByb2osIGkpIHtcblx0ICB2YXIgbGVuID0gcHJvalN0b3JlLmxlbmd0aDtcblx0ICBpZiAoIXByb2oubmFtZXMpIHtcblx0ICAgIGNvbnNvbGUubG9nKGkpO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHQgIHByb2pTdG9yZVtsZW5dID0gcHJvajtcblx0ICBwcm9qLm5hbWVzLmZvckVhY2goZnVuY3Rpb24obikge1xuXHQgICAgbmFtZXMkJDFbbi50b0xvd2VyQ2FzZSgpXSA9IGxlbjtcblx0ICB9KTtcblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldChuYW1lKSB7XG5cdCAgaWYgKCFuYW1lKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBuID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHQgIGlmICh0eXBlb2YgbmFtZXMkJDFbbl0gIT09ICd1bmRlZmluZWQnICYmIHByb2pTdG9yZVtuYW1lcyQkMVtuXV0pIHtcblx0ICAgIHJldHVybiBwcm9qU3RvcmVbbmFtZXMkJDFbbl1dO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHN0YXJ0KCkge1xuXHQgIHByb2pzLmZvckVhY2goYWRkKTtcblx0fVxuXHR2YXIgcHJvamVjdGlvbnMgPSB7XG5cdCAgc3RhcnQ6IHN0YXJ0LFxuXHQgIGFkZDogYWRkLFxuXHQgIGdldDogZ2V0XG5cdH07XG5cblx0dmFyIGV4cG9ydHMkMiA9IHt9O1xuXHRleHBvcnRzJDIuTUVSSVQgPSB7XG5cdCAgYTogNjM3ODEzNy4wLFxuXHQgIHJmOiAyOTguMjU3LFxuXHQgIGVsbGlwc2VOYW1lOiBcIk1FUklUIDE5ODNcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5TR1M4NSA9IHtcblx0ICBhOiA2Mzc4MTM2LjAsXG5cdCAgcmY6IDI5OC4yNTcsXG5cdCAgZWxsaXBzZU5hbWU6IFwiU292aWV0IEdlb2RldGljIFN5c3RlbSA4NVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLkdSUzgwID0ge1xuXHQgIGE6IDYzNzgxMzcuMCxcblx0ICByZjogMjk4LjI1NzIyMjEwMSxcblx0ICBlbGxpcHNlTmFtZTogXCJHUlMgMTk4MChJVUdHLCAxOTgwKVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLklBVTc2ID0ge1xuXHQgIGE6IDYzNzgxNDAuMCxcblx0ICByZjogMjk4LjI1Nyxcblx0ICBlbGxpcHNlTmFtZTogXCJJQVUgMTk3NlwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmFpcnkgPSB7XG5cdCAgYTogNjM3NzU2My4zOTYsXG5cdCAgYjogNjM1NjI1Ni45MTAsXG5cdCAgZWxsaXBzZU5hbWU6IFwiQWlyeSAxODMwXCJcblx0fTtcblxuXHRleHBvcnRzJDIuQVBMNCA9IHtcblx0ICBhOiA2Mzc4MTM3LFxuXHQgIHJmOiAyOTguMjUsXG5cdCAgZWxsaXBzZU5hbWU6IFwiQXBwbC4gUGh5c2ljcy4gMTk2NVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLk5XTDlEID0ge1xuXHQgIGE6IDYzNzgxNDUuMCxcblx0ICByZjogMjk4LjI1LFxuXHQgIGVsbGlwc2VOYW1lOiBcIk5hdmFsIFdlYXBvbnMgTGFiLiwgMTk2NVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLm1vZF9haXJ5ID0ge1xuXHQgIGE6IDYzNzczNDAuMTg5LFxuXHQgIGI6IDYzNTYwMzQuNDQ2LFxuXHQgIGVsbGlwc2VOYW1lOiBcIk1vZGlmaWVkIEFpcnlcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5hbmRyYWUgPSB7XG5cdCAgYTogNjM3NzEwNC40Myxcblx0ICByZjogMzAwLjAsXG5cdCAgZWxsaXBzZU5hbWU6IFwiQW5kcmFlIDE4NzYgKERlbi4sIEljbG5kLilcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5hdXN0X1NBID0ge1xuXHQgIGE6IDYzNzgxNjAuMCxcblx0ICByZjogMjk4LjI1LFxuXHQgIGVsbGlwc2VOYW1lOiBcIkF1c3RyYWxpYW4gTmF0bCAmIFMuIEFtZXIuIDE5NjlcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5HUlM2NyA9IHtcblx0ICBhOiA2Mzc4MTYwLjAsXG5cdCAgcmY6IDI5OC4yNDcxNjc0MjcwLFxuXHQgIGVsbGlwc2VOYW1lOiBcIkdSUyA2NyhJVUdHIDE5NjcpXCJcblx0fTtcblxuXHRleHBvcnRzJDIuYmVzc2VsID0ge1xuXHQgIGE6IDYzNzczOTcuMTU1LFxuXHQgIHJmOiAyOTkuMTUyODEyOCxcblx0ICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmJlc3NfbmFtID0ge1xuXHQgIGE6IDYzNzc0ODMuODY1LFxuXHQgIHJmOiAyOTkuMTUyODEyOCxcblx0ICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MSAoTmFtaWJpYSlcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5jbHJrNjYgPSB7XG5cdCAgYTogNjM3ODIwNi40LFxuXHQgIGI6IDYzNTY1ODMuOCxcblx0ICBlbGxpcHNlTmFtZTogXCJDbGFya2UgMTg2NlwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmNscms4MCA9IHtcblx0ICBhOiA2Mzc4MjQ5LjE0NSxcblx0ICByZjogMjkzLjQ2NjMsXG5cdCAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4ODAgbW9kLlwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmNscms1OCA9IHtcblx0ICBhOiA2Mzc4MjkzLjY0NTIwODc1OSxcblx0ICByZjogMjk0LjI2MDY3NjM2OTI2NTQsXG5cdCAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4NThcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5DUE0gPSB7XG5cdCAgYTogNjM3NTczOC43LFxuXHQgIHJmOiAzMzQuMjksXG5cdCAgZWxsaXBzZU5hbWU6IFwiQ29tbS4gZGVzIFBvaWRzIGV0IE1lc3VyZXMgMTc5OVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmRlbG1iciA9IHtcblx0ICBhOiA2Mzc2NDI4LjAsXG5cdCAgcmY6IDMxMS41LFxuXHQgIGVsbGlwc2VOYW1lOiBcIkRlbGFtYnJlIDE4MTAgKEJlbGdpdW0pXCJcblx0fTtcblxuXHRleHBvcnRzJDIuZW5nZWxpcyA9IHtcblx0ICBhOiA2Mzc4MTM2LjA1LFxuXHQgIHJmOiAyOTguMjU2Nixcblx0ICBlbGxpcHNlTmFtZTogXCJFbmdlbGlzIDE5ODVcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5ldnJzdDMwID0ge1xuXHQgIGE6IDYzNzcyNzYuMzQ1LFxuXHQgIHJmOiAzMDAuODAxNyxcblx0ICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE4MzBcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5ldnJzdDQ4ID0ge1xuXHQgIGE6IDYzNzczMDQuMDYzLFxuXHQgIHJmOiAzMDAuODAxNyxcblx0ICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NDhcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5ldnJzdDU2ID0ge1xuXHQgIGE6IDYzNzczMDEuMjQzLFxuXHQgIHJmOiAzMDAuODAxNyxcblx0ICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NTZcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5ldnJzdDY5ID0ge1xuXHQgIGE6IDYzNzcyOTUuNjY0LFxuXHQgIHJmOiAzMDAuODAxNyxcblx0ICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NjlcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5ldnJzdFNTID0ge1xuXHQgIGE6IDYzNzcyOTguNTU2LFxuXHQgIHJmOiAzMDAuODAxNyxcblx0ICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IChTYWJhaCAmIFNhcmF3YWspXCJcblx0fTtcblxuXHRleHBvcnRzJDIuZnNjaHI2MCA9IHtcblx0ICBhOiA2Mzc4MTY2LjAsXG5cdCAgcmY6IDI5OC4zLFxuXHQgIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgKE1lcmN1cnkgRGF0dW0pIDE5NjBcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5mc2NocjYwbSA9IHtcblx0ICBhOiA2Mzc4MTU1LjAsXG5cdCAgcmY6IDI5OC4zLFxuXHQgIGVsbGlwc2VOYW1lOiBcIkZpc2NoZXIgMTk2MFwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmZzY2hyNjggPSB7XG5cdCAgYTogNjM3ODE1MC4wLFxuXHQgIHJmOiAyOTguMyxcblx0ICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjhcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5oZWxtZXJ0ID0ge1xuXHQgIGE6IDYzNzgyMDAuMCxcblx0ICByZjogMjk4LjMsXG5cdCAgZWxsaXBzZU5hbWU6IFwiSGVsbWVydCAxOTA2XCJcblx0fTtcblxuXHRleHBvcnRzJDIuaG91Z2ggPSB7XG5cdCAgYTogNjM3ODI3MC4wLFxuXHQgIHJmOiAyOTcuMCxcblx0ICBlbGxpcHNlTmFtZTogXCJIb3VnaFwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmludGwgPSB7XG5cdCAgYTogNjM3ODM4OC4wLFxuXHQgIHJmOiAyOTcuMCxcblx0ICBlbGxpcHNlTmFtZTogXCJJbnRlcm5hdGlvbmFsIDE5MDkgKEhheWZvcmQpXCJcblx0fTtcblxuXHRleHBvcnRzJDIua2F1bGEgPSB7XG5cdCAgYTogNjM3ODE2My4wLFxuXHQgIHJmOiAyOTguMjQsXG5cdCAgZWxsaXBzZU5hbWU6IFwiS2F1bGEgMTk2MVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmxlcmNoID0ge1xuXHQgIGE6IDYzNzgxMzkuMCxcblx0ICByZjogMjk4LjI1Nyxcblx0ICBlbGxpcHNlTmFtZTogXCJMZXJjaCAxOTc5XCJcblx0fTtcblxuXHRleHBvcnRzJDIubXBydHMgPSB7XG5cdCAgYTogNjM5NzMwMC4wLFxuXHQgIHJmOiAxOTEuMCxcblx0ICBlbGxpcHNlTmFtZTogXCJNYXVwZXJ0aXVzIDE3MzhcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5uZXdfaW50bCA9IHtcblx0ICBhOiA2Mzc4MTU3LjUsXG5cdCAgYjogNjM1Njc3Mi4yLFxuXHQgIGVsbGlwc2VOYW1lOiBcIk5ldyBJbnRlcm5hdGlvbmFsIDE5NjdcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5wbGVzc2lzID0ge1xuXHQgIGE6IDYzNzY1MjMuMCxcblx0ICByZjogNjM1NTg2My4wLFxuXHQgIGVsbGlwc2VOYW1lOiBcIlBsZXNzaXMgMTgxNyAoRnJhbmNlKVwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLmtyYXNzID0ge1xuXHQgIGE6IDYzNzgyNDUuMCxcblx0ICByZjogMjk4LjMsXG5cdCAgZWxsaXBzZU5hbWU6IFwiS3Jhc3NvdnNreSwgMTk0MlwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLlNFYXNpYSA9IHtcblx0ICBhOiA2Mzc4MTU1LjAsXG5cdCAgYjogNjM1Njc3My4zMjA1LFxuXHQgIGVsbGlwc2VOYW1lOiBcIlNvdXRoZWFzdCBBc2lhXCJcblx0fTtcblxuXHRleHBvcnRzJDIud2FsYmVjayA9IHtcblx0ICBhOiA2Mzc2ODk2LjAsXG5cdCAgYjogNjM1NTgzNC44NDY3LFxuXHQgIGVsbGlwc2VOYW1lOiBcIldhbGJlY2tcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMi5XR1M2MCA9IHtcblx0ICBhOiA2Mzc4MTY1LjAsXG5cdCAgcmY6IDI5OC4zLFxuXHQgIGVsbGlwc2VOYW1lOiBcIldHUyA2MFwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLldHUzY2ID0ge1xuXHQgIGE6IDYzNzgxNDUuMCxcblx0ICByZjogMjk4LjI1LFxuXHQgIGVsbGlwc2VOYW1lOiBcIldHUyA2NlwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLldHUzcgPSB7XG5cdCAgYTogNjM3ODEzNS4wLFxuXHQgIHJmOiAyOTguMjYsXG5cdCAgZWxsaXBzZU5hbWU6IFwiV0dTIDcyXCJcblx0fTtcblxuXHR2YXIgV0dTODQgPSBleHBvcnRzJDIuV0dTODQgPSB7XG5cdCAgYTogNjM3ODEzNy4wLFxuXHQgIHJmOiAyOTguMjU3MjIzNTYzLFxuXHQgIGVsbGlwc2VOYW1lOiBcIldHUyA4NFwiXG5cdH07XG5cblx0ZXhwb3J0cyQyLnNwaGVyZSA9IHtcblx0ICBhOiA2MzcwOTk3LjAsXG5cdCAgYjogNjM3MDk5Ny4wLFxuXHQgIGVsbGlwc2VOYW1lOiBcIk5vcm1hbCBTcGhlcmUgKHI9NjM3MDk5NylcIlxuXHR9O1xuXG5cdGZ1bmN0aW9uIGVjY2VudHJpY2l0eShhLCBiLCByZiwgUl9BKSB7XG5cdCAgdmFyIGEyID0gYSAqIGE7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuXHQgIHZhciBiMiA9IGIgKiBiOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcblx0ICB2YXIgZXMgPSAoYTIgLSBiMikgLyBhMjsgLy8gZSBeIDJcblx0ICB2YXIgZSA9IDA7XG5cdCAgaWYgKFJfQSkge1xuXHQgICAgYSAqPSAxIC0gZXMgKiAoU0lYVEggKyBlcyAqIChSQTQgKyBlcyAqIFJBNikpO1xuXHQgICAgYTIgPSBhICogYTtcblx0ICAgIGVzID0gMDtcblx0ICB9IGVsc2Uge1xuXHQgICAgZSA9IE1hdGguc3FydChlcyk7IC8vIGVjY2VudHJpY2l0eVxuXHQgIH1cblx0ICB2YXIgZXAyID0gKGEyIC0gYjIpIC8gYjI7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuXHQgIHJldHVybiB7XG5cdCAgICBlczogZXMsXG5cdCAgICBlOiBlLFxuXHQgICAgZXAyOiBlcDJcblx0ICB9O1xuXHR9XG5cdGZ1bmN0aW9uIHNwaGVyZShhLCBiLCByZiwgZWxscHMsIHNwaGVyZSkge1xuXHQgIGlmICghYSkgeyAvLyBkbyB3ZSBoYXZlIGFuIGVsbGlwc29pZD9cblx0ICAgIHZhciBlbGxpcHNlID0gbWF0Y2goZXhwb3J0cyQyLCBlbGxwcyk7XG5cdCAgICBpZiAoIWVsbGlwc2UpIHtcblx0ICAgICAgZWxsaXBzZSA9IFdHUzg0O1xuXHQgICAgfVxuXHQgICAgYSA9IGVsbGlwc2UuYTtcblx0ICAgIGIgPSBlbGxpcHNlLmI7XG5cdCAgICByZiA9IGVsbGlwc2UucmY7XG5cdCAgfVxuXG5cdCAgaWYgKHJmICYmICFiKSB7XG5cdCAgICBiID0gKDEuMCAtIDEuMCAvIHJmKSAqIGE7XG5cdCAgfVxuXHQgIGlmIChyZiA9PT0gMCB8fCBNYXRoLmFicyhhIC0gYikgPCBFUFNMTikge1xuXHQgICAgc3BoZXJlID0gdHJ1ZTtcblx0ICAgIGIgPSBhO1xuXHQgIH1cblx0ICByZXR1cm4ge1xuXHQgICAgYTogYSxcblx0ICAgIGI6IGIsXG5cdCAgICByZjogcmYsXG5cdCAgICBzcGhlcmU6IHNwaGVyZVxuXHQgIH07XG5cdH1cblxuXHR2YXIgZXhwb3J0cyQzID0ge307XG5cdGV4cG9ydHMkMy53Z3M4NCA9IHtcblx0ICB0b3dnczg0OiBcIjAsMCwwXCIsXG5cdCAgZWxsaXBzZTogXCJXR1M4NFwiLFxuXHQgIGRhdHVtTmFtZTogXCJXR1M4NFwiXG5cdH07XG5cblx0ZXhwb3J0cyQzLmNoMTkwMyA9IHtcblx0ICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcblx0ICBlbGxpcHNlOiBcImJlc3NlbFwiLFxuXHQgIGRhdHVtTmFtZTogXCJzd2lzc1wiXG5cdH07XG5cblx0ZXhwb3J0cyQzLmdncnM4NyA9IHtcblx0ICB0b3dnczg0OiBcIi0xOTkuODcsNzQuNzksMjQ2LjYyXCIsXG5cdCAgZWxsaXBzZTogXCJHUlM4MFwiLFxuXHQgIGRhdHVtTmFtZTogXCJHcmVla19HZW9kZXRpY19SZWZlcmVuY2VfU3lzdGVtXzE5ODdcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMy5uYWQ4MyA9IHtcblx0ICB0b3dnczg0OiBcIjAsMCwwXCIsXG5cdCAgZWxsaXBzZTogXCJHUlM4MFwiLFxuXHQgIGRhdHVtTmFtZTogXCJOb3J0aF9BbWVyaWNhbl9EYXR1bV8xOTgzXCJcblx0fTtcblxuXHRleHBvcnRzJDMubmFkMjcgPSB7XG5cdCAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuXHQgIGVsbGlwc2U6IFwiY2xyazY2XCIsXG5cdCAgZGF0dW1OYW1lOiBcIk5vcnRoX0FtZXJpY2FuX0RhdHVtXzE5MjdcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMy5wb3RzZGFtID0ge1xuXHQgIHRvd2dzODQ6IFwiNjA2LjAsMjMuMCw0MTMuMFwiLFxuXHQgIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG5cdCAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG5cdH07XG5cblx0ZXhwb3J0cyQzLmNhcnRoYWdlID0ge1xuXHQgIHRvd2dzODQ6IFwiLTI2My4wLDYuMCw0MzEuMFwiLFxuXHQgIGVsbGlwc2U6IFwiY2xhcms4MFwiLFxuXHQgIGRhdHVtTmFtZTogXCJDYXJ0aGFnZSAxOTM0IFR1bmlzaWFcIlxuXHR9O1xuXG5cdGV4cG9ydHMkMy5oZXJtYW5uc2tvZ2VsID0ge1xuXHQgIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG5cdCAgZWxsaXBzZTogXCJiZXNzZWxcIixcblx0ICBkYXR1bU5hbWU6IFwiSGVybWFubnNrb2dlbFwiXG5cdH07XG5cblx0ZXhwb3J0cyQzLm9zbmk1MiA9IHtcblx0ICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG5cdCAgZWxsaXBzZTogXCJhaXJ5XCIsXG5cdCAgZGF0dW1OYW1lOiBcIklyaXNoIE5hdGlvbmFsXCJcblx0fTtcblxuXHRleHBvcnRzJDMuaXJlNjUgPSB7XG5cdCAgdG93Z3M4NDogXCI0ODIuNTMwLC0xMzAuNTk2LDU2NC41NTcsLTEuMDQyLC0wLjIxNCwtMC42MzEsOC4xNVwiLFxuXHQgIGVsbGlwc2U6IFwibW9kX2FpcnlcIixcblx0ICBkYXR1bU5hbWU6IFwiSXJlbGFuZCAxOTY1XCJcblx0fTtcblxuXHRleHBvcnRzJDMucmFzc2FkaXJhbiA9IHtcblx0ICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcblx0ICBlbGxpcHNlOiBcImludGxcIixcblx0ICBkYXR1bU5hbWU6IFwiUmFzc2FkaXJhblwiXG5cdH07XG5cblx0ZXhwb3J0cyQzLm56Z2Q0OSA9IHtcblx0ICB0b3dnczg0OiBcIjU5LjQ3LC01LjA0LDE4Ny40NCwwLjQ3LC0wLjEsMS4wMjQsLTQuNTk5M1wiLFxuXHQgIGVsbGlwc2U6IFwiaW50bFwiLFxuXHQgIGRhdHVtTmFtZTogXCJOZXcgWmVhbGFuZCBHZW9kZXRpYyBEYXR1bSAxOTQ5XCJcblx0fTtcblxuXHRleHBvcnRzJDMub3NnYjM2ID0ge1xuXHQgIHRvd2dzODQ6IFwiNDQ2LjQ0OCwtMTI1LjE1Nyw1NDIuMDYwLDAuMTUwMiwwLjI0NzAsMC44NDIxLC0yMC40ODk0XCIsXG5cdCAgZWxsaXBzZTogXCJhaXJ5XCIsXG5cdCAgZGF0dW1OYW1lOiBcIkFpcnkgMTgzMFwiXG5cdH07XG5cblx0ZXhwb3J0cyQzLnNfanRzayA9IHtcblx0ICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcblx0ICBlbGxpcHNlOiAnYmVzc2VsJyxcblx0ICBkYXR1bU5hbWU6ICdTLUpUU0sgKEZlcnJvKSdcblx0fTtcblxuXHRleHBvcnRzJDMuYmVkdWFyYW0gPSB7XG5cdCAgdG93Z3M4NDogJy0xMDYsLTg3LDE4OCcsXG5cdCAgZWxsaXBzZTogJ2Nscms4MCcsXG5cdCAgZGF0dW1OYW1lOiAnQmVkdWFyYW0nXG5cdH07XG5cblx0ZXhwb3J0cyQzLmd1bnVuZ19zZWdhcmEgPSB7XG5cdCAgdG93Z3M4NDogJy00MDMsNjg0LDQxJyxcblx0ICBlbGxpcHNlOiAnYmVzc2VsJyxcblx0ICBkYXR1bU5hbWU6ICdHdW51bmcgU2VnYXJhIEpha2FydGEnXG5cdH07XG5cblx0ZXhwb3J0cyQzLnJuYjcyID0ge1xuXHQgIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcblx0ICBlbGxpcHNlOiBcImludGxcIixcblx0ICBkYXR1bU5hbWU6IFwiUmVzZWF1IE5hdGlvbmFsIEJlbGdlIDE5NzJcIlxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRhdHVtKGRhdHVtQ29kZSwgZGF0dW1fcGFyYW1zLCBhLCBiLCBlcywgZXAyKSB7XG5cdCAgdmFyIG91dCA9IHt9O1xuXG5cdCAgaWYgKGRhdHVtQ29kZSA9PT0gdW5kZWZpbmVkIHx8IGRhdHVtQ29kZSA9PT0gJ25vbmUnKSB7XG5cdCAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF9OT0RBVFVNO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF9XR1M4NDtcblx0ICB9XG5cblx0ICBpZiAoZGF0dW1fcGFyYW1zKSB7XG5cdCAgICBvdXQuZGF0dW1fcGFyYW1zID0gZGF0dW1fcGFyYW1zLm1hcChwYXJzZUZsb2F0KTtcblx0ICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zWzBdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbMV0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1syXSAhPT0gMCkge1xuXHQgICAgICBvdXQuZGF0dW1fdHlwZSA9IFBKRF8zUEFSQU07XG5cdCAgICB9XG5cdCAgICBpZiAob3V0LmRhdHVtX3BhcmFtcy5sZW5ndGggPiAzKSB7XG5cdCAgICAgIGlmIChvdXQuZGF0dW1fcGFyYW1zWzNdICE9PSAwIHx8IG91dC5kYXR1bV9wYXJhbXNbNF0gIT09IDAgfHwgb3V0LmRhdHVtX3BhcmFtc1s1XSAhPT0gMCB8fCBvdXQuZGF0dW1fcGFyYW1zWzZdICE9PSAwKSB7XG5cdCAgICAgICAgb3V0LmRhdHVtX3R5cGUgPSBQSkRfN1BBUkFNO1xuXHQgICAgICAgIG91dC5kYXR1bV9wYXJhbXNbM10gKj0gU0VDX1RPX1JBRDtcblx0ICAgICAgICBvdXQuZGF0dW1fcGFyYW1zWzRdICo9IFNFQ19UT19SQUQ7XG5cdCAgICAgICAgb3V0LmRhdHVtX3BhcmFtc1s1XSAqPSBTRUNfVE9fUkFEO1xuXHQgICAgICAgIG91dC5kYXR1bV9wYXJhbXNbNl0gPSAob3V0LmRhdHVtX3BhcmFtc1s2XSAvIDEwMDAwMDAuMCkgKyAxLjA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBvdXQuYSA9IGE7IC8vZGF0dW0gb2JqZWN0IGFsc28gdXNlcyB0aGVzZSB2YWx1ZXNcblx0ICBvdXQuYiA9IGI7XG5cdCAgb3V0LmVzID0gZXM7XG5cdCAgb3V0LmVwMiA9IGVwMjtcblx0ICByZXR1cm4gb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gUHJvamVjdGlvbiQxKHNyc0NvZGUsY2FsbGJhY2spIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvamVjdGlvbiQxKSkge1xuXHQgICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uJDEoc3JzQ29kZSk7XG5cdCAgfVxuXHQgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyb3Ipe1xuXHQgICAgaWYoZXJyb3Ipe1xuXHQgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICB9O1xuXHQgIHZhciBqc29uID0gcGFyc2Uoc3JzQ29kZSk7XG5cdCAgaWYodHlwZW9mIGpzb24gIT09ICdvYmplY3QnKXtcblx0ICAgIGNhbGxiYWNrKHNyc0NvZGUpO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgb3VyUHJvaiA9IFByb2plY3Rpb24kMS5wcm9qZWN0aW9ucy5nZXQoanNvbi5wcm9qTmFtZSk7XG5cdCAgaWYoIW91clByb2ope1xuXHQgICAgY2FsbGJhY2soc3JzQ29kZSk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIGlmIChqc29uLmRhdHVtQ29kZSAmJiBqc29uLmRhdHVtQ29kZSAhPT0gJ25vbmUnKSB7XG5cdCAgICB2YXIgZGF0dW1EZWYgPSBtYXRjaChleHBvcnRzJDMsIGpzb24uZGF0dW1Db2RlKTtcblx0ICAgIGlmIChkYXR1bURlZikge1xuXHQgICAgICBqc29uLmRhdHVtX3BhcmFtcyA9IGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsO1xuXHQgICAgICBqc29uLmVsbHBzID0gZGF0dW1EZWYuZWxsaXBzZTtcblx0ICAgICAganNvbi5kYXR1bU5hbWUgPSBkYXR1bURlZi5kYXR1bU5hbWUgPyBkYXR1bURlZi5kYXR1bU5hbWUgOiBqc29uLmRhdHVtQ29kZTtcblx0ICAgIH1cblx0ICB9XG5cdCAganNvbi5rMCA9IGpzb24uazAgfHwgMS4wO1xuXHQgIGpzb24uYXhpcyA9IGpzb24uYXhpcyB8fCAnZW51Jztcblx0ICBqc29uLmVsbHBzID0ganNvbi5lbGxwcyB8fCAnd2dzODQnO1xuXHQgIHZhciBzcGhlcmVfID0gc3BoZXJlKGpzb24uYSwganNvbi5iLCBqc29uLnJmLCBqc29uLmVsbHBzLCBqc29uLnNwaGVyZSk7XG5cdCAgdmFyIGVjYyA9IGVjY2VudHJpY2l0eShzcGhlcmVfLmEsIHNwaGVyZV8uYiwgc3BoZXJlXy5yZiwganNvbi5SX0EpO1xuXHQgIHZhciBkYXR1bU9iaiA9IGpzb24uZGF0dW0gfHwgZGF0dW0oanNvbi5kYXR1bUNvZGUsIGpzb24uZGF0dW1fcGFyYW1zLCBzcGhlcmVfLmEsIHNwaGVyZV8uYiwgZWNjLmVzLCBlY2MuZXAyKTtcblxuXHQgIGV4dGVuZCh0aGlzLCBqc29uKTsgLy8gdHJhbnNmZXIgZXZlcnl0aGluZyBvdmVyIGZyb20gdGhlIHByb2plY3Rpb24gYmVjYXVzZSB3ZSBkb24ndCBrbm93IHdoYXQgd2UnbGwgbmVlZFxuXHQgIGV4dGVuZCh0aGlzLCBvdXJQcm9qKTsgLy8gdHJhbnNmZXIgYWxsIHRoZSBtZXRob2RzIGZyb20gdGhlIHByb2plY3Rpb25cblxuXHQgIC8vIGNvcHkgdGhlIDQgdGhpbmdzIG92ZXIgd2UgY2FsdWxhdGVkIGluIGRlcml2ZUNvbnN0YW50cy5zcGhlcmVcblx0ICB0aGlzLmEgPSBzcGhlcmVfLmE7XG5cdCAgdGhpcy5iID0gc3BoZXJlXy5iO1xuXHQgIHRoaXMucmYgPSBzcGhlcmVfLnJmO1xuXHQgIHRoaXMuc3BoZXJlID0gc3BoZXJlXy5zcGhlcmU7XG5cblx0ICAvLyBjb3B5IHRoZSAzIHRoaW5ncyB3ZSBjYWxjdWxhdGVkIGluIGRlcml2ZUNvbnN0YW50cy5lY2NlbnRyaWNpdHlcblx0ICB0aGlzLmVzID0gZWNjLmVzO1xuXHQgIHRoaXMuZSA9IGVjYy5lO1xuXHQgIHRoaXMuZXAyID0gZWNjLmVwMjtcblxuXHQgIC8vIGFkZCBpbiB0aGUgZGF0dW0gb2JqZWN0XG5cdCAgdGhpcy5kYXR1bSA9IGRhdHVtT2JqO1xuXG5cdCAgLy8gaW5pdCB0aGUgcHJvamVjdGlvblxuXHQgIHRoaXMuaW5pdCgpO1xuXG5cdCAgLy8gbGVnZWN5IGNhbGxiYWNrIGZyb20gYmFjayBpbiB0aGUgZGF5IHdoZW4gaXQgd2VudCB0byBzcGF0aWFscmVmZXJlbmNlLm9yZ1xuXHQgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuXG5cdH1cblx0UHJvamVjdGlvbiQxLnByb2plY3Rpb25zID0gcHJvamVjdGlvbnM7XG5cdFByb2plY3Rpb24kMS5wcm9qZWN0aW9ucy5zdGFydCgpO1xuXG5cdGZ1bmN0aW9uIGNvbXBhcmVEYXR1bXMoc291cmNlLCBkZXN0KSB7XG5cdCAgaWYgKHNvdXJjZS5kYXR1bV90eXBlICE9PSBkZXN0LmRhdHVtX3R5cGUpIHtcblx0ICAgIHJldHVybiBmYWxzZTsgLy8gZmFsc2UsIGRhdHVtcyBhcmUgbm90IGVxdWFsXG5cdCAgfSBlbHNlIGlmIChzb3VyY2UuYSAhPT0gZGVzdC5hIHx8IE1hdGguYWJzKHNvdXJjZS5lcyAtIGRlc3QuZXMpID4gMC4wMDAwMDAwMDAwNTApIHtcblx0ICAgIC8vIHRoZSB0b2xlcmFuY2UgZm9yIGVzIGlzIHRvIGVuc3VyZSB0aGF0IEdSUzgwIGFuZCBXR1M4NFxuXHQgICAgLy8gYXJlIGNvbnNpZGVyZWQgaWRlbnRpY2FsXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfSBlbHNlIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuXHQgICAgcmV0dXJuIChzb3VyY2UuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSk7XG5cdCAgfSBlbHNlIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuXHQgICAgcmV0dXJuIChzb3VyY2UuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzFdID09PSBkZXN0LmRhdHVtX3BhcmFtc1sxXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzJdID09PSBkZXN0LmRhdHVtX3BhcmFtc1syXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzNdID09PSBkZXN0LmRhdHVtX3BhcmFtc1szXSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzRdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s0XSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzVdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s1XSAmJiBzb3VyY2UuZGF0dW1fcGFyYW1zWzZdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s2XSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHJldHVybiB0cnVlOyAvLyBkYXR1bXMgYXJlIGVxdWFsXG5cdCAgfVxuXHR9IC8vIGNzX2NvbXBhcmVfZGF0dW1zKClcblxuXHQvKlxuXHQgKiBUaGUgZnVuY3Rpb24gQ29udmVydF9HZW9kZXRpY19Ub19HZW9jZW50cmljIGNvbnZlcnRzIGdlb2RldGljIGNvb3JkaW5hdGVzXG5cdCAqIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhbmQgaGVpZ2h0KSB0byBnZW9jZW50cmljIGNvb3JkaW5hdGVzIChYLCBZLCBaKSxcblx0ICogYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGVsbGlwc29pZCBwYXJhbWV0ZXJzLlxuXHQgKlxuXHQgKiAgICBMYXRpdHVkZSAgOiBHZW9kZXRpYyBsYXRpdHVkZSBpbiByYWRpYW5zICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuXHQgKiAgICBMb25naXR1ZGUgOiBHZW9kZXRpYyBsb25naXR1ZGUgaW4gcmFkaWFucyAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuXHQgKiAgICBIZWlnaHQgICAgOiBHZW9kZXRpYyBoZWlnaHQsIGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuXHQgKiAgICBYICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWCBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcblx0ICogICAgWSAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFkgY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG5cdCAqICAgIFogICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBaIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuXHQgKlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2VvZGV0aWNUb0dlb2NlbnRyaWMocCwgZXMsIGEpIHtcblx0ICB2YXIgTG9uZ2l0dWRlID0gcC54O1xuXHQgIHZhciBMYXRpdHVkZSA9IHAueTtcblx0ICB2YXIgSGVpZ2h0ID0gcC56ID8gcC56IDogMDsgLy9aIHZhbHVlIG5vdCBhbHdheXMgc3VwcGxpZWRcblxuXHQgIHZhciBSbjsgLyogIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAgKi9cblx0ICB2YXIgU2luX0xhdDsgLyogIE1hdGguc2luKExhdGl0dWRlKSAgKi9cblx0ICB2YXIgU2luMl9MYXQ7IC8qICBTcXVhcmUgb2YgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuXHQgIHZhciBDb3NfTGF0OyAvKiAgTWF0aC5jb3MoTGF0aXR1ZGUpICAqL1xuXG5cdCAgLypcblx0ICAgKiogRG9uJ3QgYmxvdyB1cCBpZiBMYXRpdHVkZSBpcyBqdXN0IGEgbGl0dGxlIG91dCBvZiB0aGUgdmFsdWVcblx0ICAgKiogcmFuZ2UgYXMgaXQgbWF5IGp1c3QgYmUgYSByb3VuZGluZyBpc3N1ZS4gIEFsc28gcmVtb3ZlZCBsb25naXR1ZGVcblx0ICAgKiogdGVzdCwgaXQgc2hvdWxkIGJlIHdyYXBwZWQgYnkgTWF0aC5jb3MoKSBhbmQgTWF0aC5zaW4oKS4gIE5GVyBmb3IgUFJPSi40LCBTZXAvMjAwMS5cblx0ICAgKi9cblx0ICBpZiAoTGF0aXR1ZGUgPCAtSEFMRl9QSSAmJiBMYXRpdHVkZSA+IC0xLjAwMSAqIEhBTEZfUEkpIHtcblx0ICAgIExhdGl0dWRlID0gLUhBTEZfUEk7XG5cdCAgfSBlbHNlIGlmIChMYXRpdHVkZSA+IEhBTEZfUEkgJiYgTGF0aXR1ZGUgPCAxLjAwMSAqIEhBTEZfUEkpIHtcblx0ICAgIExhdGl0dWRlID0gSEFMRl9QSTtcblx0ICB9IGVsc2UgaWYgKChMYXRpdHVkZSA8IC1IQUxGX1BJKSB8fCAoTGF0aXR1ZGUgPiBIQUxGX1BJKSkge1xuXHQgICAgLyogTGF0aXR1ZGUgb3V0IG9mIHJhbmdlICovXG5cdCAgICAvLy4ucmVwb3J0RXJyb3IoJ2dlb2NlbnQ6bGF0IG91dCBvZiByYW5nZTonICsgTGF0aXR1ZGUpO1xuXHQgICAgcmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKExvbmdpdHVkZSA+IE1hdGguUEkpIHtcblx0ICAgIExvbmdpdHVkZSAtPSAoMiAqIE1hdGguUEkpO1xuXHQgIH1cblx0ICBTaW5fTGF0ID0gTWF0aC5zaW4oTGF0aXR1ZGUpO1xuXHQgIENvc19MYXQgPSBNYXRoLmNvcyhMYXRpdHVkZSk7XG5cdCAgU2luMl9MYXQgPSBTaW5fTGF0ICogU2luX0xhdDtcblx0ICBSbiA9IGEgLyAoTWF0aC5zcXJ0KDEuMGUwIC0gZXMgKiBTaW4yX0xhdCkpO1xuXHQgIHJldHVybiB7XG5cdCAgICB4OiAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguY29zKExvbmdpdHVkZSksXG5cdCAgICB5OiAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguc2luKExvbmdpdHVkZSksXG5cdCAgICB6OiAoKFJuICogKDEgLSBlcykpICsgSGVpZ2h0KSAqIFNpbl9MYXRcblx0ICB9O1xuXHR9IC8vIGNzX2dlb2RldGljX3RvX2dlb2NlbnRyaWMoKVxuXG5cdGZ1bmN0aW9uIGdlb2NlbnRyaWNUb0dlb2RldGljKHAsIGVzLCBhLCBiKSB7XG5cdCAgLyogbG9jYWwgZGVmaW50aW9ucyBhbmQgdmFyaWFibGVzICovXG5cdCAgLyogZW5kLWNyaXRlcml1bSBvZiBsb29wLCBhY2N1cmFjeSBvZiBzaW4oTGF0aXR1ZGUpICovXG5cdCAgdmFyIGdlbmF1ID0gMWUtMTI7XG5cdCAgdmFyIGdlbmF1MiA9IChnZW5hdSAqIGdlbmF1KTtcblx0ICB2YXIgbWF4aXRlciA9IDMwO1xuXG5cdCAgdmFyIFA7IC8qIGRpc3RhbmNlIGJldHdlZW4gc2VtaS1taW5vciBheGlzIGFuZCBsb2NhdGlvbiAqL1xuXHQgIHZhciBSUjsgLyogZGlzdGFuY2UgYmV0d2VlbiBjZW50ZXIgYW5kIGxvY2F0aW9uICovXG5cdCAgdmFyIENUOyAvKiBzaW4gb2YgZ2VvY2VudHJpYyBsYXRpdHVkZSAqL1xuXHQgIHZhciBTVDsgLyogY29zIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cblx0ICB2YXIgUlg7XG5cdCAgdmFyIFJLO1xuXHQgIHZhciBSTjsgLyogRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICovXG5cdCAgdmFyIENQSEkwOyAvKiBjb3Mgb2Ygc3RhcnQgb3Igb2xkIGdlb2RldGljIGxhdGl0dWRlIGluIGl0ZXJhdGlvbnMgKi9cblx0ICB2YXIgU1BISTA7IC8qIHNpbiBvZiBzdGFydCBvciBvbGQgZ2VvZGV0aWMgbGF0aXR1ZGUgaW4gaXRlcmF0aW9ucyAqL1xuXHQgIHZhciBDUEhJOyAvKiBjb3Mgb2Ygc2VhcmNoZWQgZ2VvZGV0aWMgbGF0aXR1ZGUgKi9cblx0ICB2YXIgU1BISTsgLyogc2luIG9mIHNlYXJjaGVkIGdlb2RldGljIGxhdGl0dWRlICovXG5cdCAgdmFyIFNEUEhJOyAvKiBlbmQtY3JpdGVyaXVtOiBhZGRpdGlvbi10aGVvcmVtIG9mIHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKSAqL1xuXHQgIHZhciBpdGVyOyAvKiAjIG9mIGNvbnRpbm91cyBpdGVyYXRpb24sIG1heC4gMzAgaXMgYWx3YXlzIGVub3VnaCAocy5hLikgKi9cblxuXHQgIHZhciBYID0gcC54O1xuXHQgIHZhciBZID0gcC55O1xuXHQgIHZhciBaID0gcC56ID8gcC56IDogMC4wOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuXHQgIHZhciBMb25naXR1ZGU7XG5cdCAgdmFyIExhdGl0dWRlO1xuXHQgIHZhciBIZWlnaHQ7XG5cblx0ICBQID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkpO1xuXHQgIFJSID0gTWF0aC5zcXJ0KFggKiBYICsgWSAqIFkgKyBaICogWik7XG5cblx0ICAvKiAgICAgIHNwZWNpYWwgY2FzZXMgZm9yIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgKi9cblx0ICBpZiAoUCAvIGEgPCBnZW5hdSkge1xuXG5cdCAgICAvKiAgc3BlY2lhbCBjYXNlLCBpZiBQPTAuIChYPTAuLCBZPTAuKSAqL1xuXHQgICAgTG9uZ2l0dWRlID0gMC4wO1xuXG5cdCAgICAvKiAgaWYgKFgsWSxaKT0oMC4sMC4sMC4pIHRoZW4gSGVpZ2h0IGJlY29tZXMgc2VtaS1taW5vciBheGlzXG5cdCAgICAgKiAgb2YgZWxsaXBzb2lkICg9Y2VudGVyIG9mIG1hc3MpLCBMYXRpdHVkZSBiZWNvbWVzIFBJLzIgKi9cblx0ICAgIGlmIChSUiAvIGEgPCBnZW5hdSkge1xuXHQgICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG5cdCAgICAgIEhlaWdodCA9IC1iO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHg6IHAueCxcblx0ICAgICAgICB5OiBwLnksXG5cdCAgICAgICAgejogcC56XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8qICBlbGxpcHNvaWRhbCAoZ2VvZGV0aWMpIGxvbmdpdHVkZVxuXHQgICAgICogIGludGVydmFsOiAtUEkgPCBMb25naXR1ZGUgPD0gK1BJICovXG5cdCAgICBMb25naXR1ZGUgPSBNYXRoLmF0YW4yKFksIFgpO1xuXHQgIH1cblxuXHQgIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAgICogRm9sbG93aW5nIGl0ZXJhdGl2ZSBhbGdvcml0aG0gd2FzIGRldmVsb3BwZWQgYnlcblx0ICAgKiBcIkluc3RpdHV0IGZvciBFcmRtZXNzdW5nXCIsIFVuaXZlcnNpdHkgb2YgSGFubm92ZXIsIEp1bHkgMTk4OC5cblx0ICAgKiBJbnRlcm5ldDogd3d3LmlmZS51bmktaGFubm92ZXIuZGVcblx0ICAgKiBJdGVyYXRpdmUgY29tcHV0YXRpb24gb2YgQ1BISSxTUEhJIGFuZCBIZWlnaHQuXG5cdCAgICogSXRlcmF0aW9uIG9mIENQSEkgYW5kIFNQSEkgdG8gMTAqKi0xMiByYWRpYW4gcmVzcC5cblx0ICAgKiAyKjEwKiotNyBhcmNzZWMuXG5cdCAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICAgKi9cblx0ICBDVCA9IFogLyBSUjtcblx0ICBTVCA9IFAgLyBSUjtcblx0ICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSBlcyAqICgyLjAgLSBlcykgKiBTVCAqIFNUKTtcblx0ICBDUEhJMCA9IFNUICogKDEuMCAtIGVzKSAqIFJYO1xuXHQgIFNQSEkwID0gQ1QgKiBSWDtcblx0ICBpdGVyID0gMDtcblxuXHQgIC8qIGxvb3AgdG8gZmluZCBzaW4oTGF0aXR1ZGUpIHJlc3AuIExhdGl0dWRlXG5cdCAgICogdW50aWwgfHNpbihMYXRpdHVkZShpdGVyKS1MYXRpdHVkZShpdGVyLTEpKXwgPCBnZW5hdSAqL1xuXHQgIGRvIHtcblx0ICAgIGl0ZXIrKztcblx0ICAgIFJOID0gYSAvIE1hdGguc3FydCgxLjAgLSBlcyAqIFNQSEkwICogU1BISTApO1xuXG5cdCAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBoZWlnaHQgKi9cblx0ICAgIEhlaWdodCA9IFAgKiBDUEhJMCArIFogKiBTUEhJMCAtIFJOICogKDEuMCAtIGVzICogU1BISTAgKiBTUEhJMCk7XG5cblx0ICAgIFJLID0gZXMgKiBSTiAvIChSTiArIEhlaWdodCk7XG5cdCAgICBSWCA9IDEuMCAvIE1hdGguc3FydCgxLjAgLSBSSyAqICgyLjAgLSBSSykgKiBTVCAqIFNUKTtcblx0ICAgIENQSEkgPSBTVCAqICgxLjAgLSBSSykgKiBSWDtcblx0ICAgIFNQSEkgPSBDVCAqIFJYO1xuXHQgICAgU0RQSEkgPSBTUEhJICogQ1BISTAgLSBDUEhJICogU1BISTA7XG5cdCAgICBDUEhJMCA9IENQSEk7XG5cdCAgICBTUEhJMCA9IFNQSEk7XG5cdCAgfVxuXHQgIHdoaWxlIChTRFBISSAqIFNEUEhJID4gZ2VuYXUyICYmIGl0ZXIgPCBtYXhpdGVyKTtcblxuXHQgIC8qICAgICAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBsYXRpdHVkZSAqL1xuXHQgIExhdGl0dWRlID0gTWF0aC5hdGFuKFNQSEkgLyBNYXRoLmFicyhDUEhJKSk7XG5cdCAgcmV0dXJuIHtcblx0ICAgIHg6IExvbmdpdHVkZSxcblx0ICAgIHk6IExhdGl0dWRlLFxuXHQgICAgejogSGVpZ2h0XG5cdCAgfTtcblx0fSAvLyBjc19nZW9jZW50cmljX3RvX2dlb2RldGljKClcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0Ly8gcGpfZ2VvY2VudGljX3RvX3dnczg0KCBwIClcblx0Ly8gIHAgPSBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG5cblxuXHQvKiogcG9pbnQgb2JqZWN0LCBub3RoaW5nIGZhbmN5LCBqdXN0IGFsbG93cyB2YWx1ZXMgdG8gYmVcblx0ICAgIHBhc3NlZCBiYWNrIGFuZCBmb3J0aCBieSByZWZlcmVuY2UgcmF0aGVyIHRoYW4gYnkgdmFsdWUuXG5cdCAgICBPdGhlciBwb2ludCBjbGFzc2VzIG1heSBiZSB1c2VkIGFzIGxvbmcgYXMgdGhleSBoYXZlXG5cdCAgICB4IGFuZCB5IHByb3BlcnRpZXMsIHdoaWNoIHdpbGwgZ2V0IG1vZGlmaWVkIGluIHRoZSB0cmFuc2Zvcm0gbWV0aG9kLlxuXHQqL1xuXHRmdW5jdGlvbiBnZW9jZW50cmljVG9XZ3M4NChwLCBkYXR1bV90eXBlLCBkYXR1bV9wYXJhbXMpIHtcblxuXHQgIGlmIChkYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG5cdCAgICAvLyBpZiggeFtpb10gPT09IEhVR0VfVkFMIClcblx0ICAgIC8vICAgIGNvbnRpbnVlO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgeDogcC54ICsgZGF0dW1fcGFyYW1zWzBdLFxuXHQgICAgICB5OiBwLnkgKyBkYXR1bV9wYXJhbXNbMV0sXG5cdCAgICAgIHo6IHAueiArIGRhdHVtX3BhcmFtc1syXSxcblx0ICAgIH07XG5cdCAgfSBlbHNlIGlmIChkYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG5cdCAgICB2YXIgRHhfQkYgPSBkYXR1bV9wYXJhbXNbMF07XG5cdCAgICB2YXIgRHlfQkYgPSBkYXR1bV9wYXJhbXNbMV07XG5cdCAgICB2YXIgRHpfQkYgPSBkYXR1bV9wYXJhbXNbMl07XG5cdCAgICB2YXIgUnhfQkYgPSBkYXR1bV9wYXJhbXNbM107XG5cdCAgICB2YXIgUnlfQkYgPSBkYXR1bV9wYXJhbXNbNF07XG5cdCAgICB2YXIgUnpfQkYgPSBkYXR1bV9wYXJhbXNbNV07XG5cdCAgICB2YXIgTV9CRiA9IGRhdHVtX3BhcmFtc1s2XTtcblx0ICAgIC8vIGlmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuXHQgICAgLy8gICAgY29udGludWU7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB4OiBNX0JGICogKHAueCAtIFJ6X0JGICogcC55ICsgUnlfQkYgKiBwLnopICsgRHhfQkYsXG5cdCAgICAgIHk6IE1fQkYgKiAoUnpfQkYgKiBwLnggKyBwLnkgLSBSeF9CRiAqIHAueikgKyBEeV9CRixcblx0ICAgICAgejogTV9CRiAqICgtUnlfQkYgKiBwLnggKyBSeF9CRiAqIHAueSArIHAueikgKyBEel9CRlxuXHQgICAgfTtcblx0ICB9XG5cdH0gLy8gY3NfZ2VvY2VudHJpY190b193Z3M4NFxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvLyBwal9nZW9jZW50aWNfZnJvbV93Z3M4NCgpXG5cdC8vICBjb29yZGluYXRlIHN5c3RlbSBkZWZpbml0aW9uLFxuXHQvLyAgcG9pbnQgdG8gdHJhbnNmb3JtIGluIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMgKHgseSx6KVxuXHRmdW5jdGlvbiBnZW9jZW50cmljRnJvbVdnczg0KHAsIGRhdHVtX3R5cGUsIGRhdHVtX3BhcmFtcykge1xuXG5cdCAgaWYgKGRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcblx0ICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG5cdCAgICAvLyAgICBjb250aW51ZTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHg6IHAueCAtIGRhdHVtX3BhcmFtc1swXSxcblx0ICAgICAgeTogcC55IC0gZGF0dW1fcGFyYW1zWzFdLFxuXHQgICAgICB6OiBwLnogLSBkYXR1bV9wYXJhbXNbMl0sXG5cdCAgICB9O1xuXG5cdCAgfSBlbHNlIGlmIChkYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG5cdCAgICB2YXIgRHhfQkYgPSBkYXR1bV9wYXJhbXNbMF07XG5cdCAgICB2YXIgRHlfQkYgPSBkYXR1bV9wYXJhbXNbMV07XG5cdCAgICB2YXIgRHpfQkYgPSBkYXR1bV9wYXJhbXNbMl07XG5cdCAgICB2YXIgUnhfQkYgPSBkYXR1bV9wYXJhbXNbM107XG5cdCAgICB2YXIgUnlfQkYgPSBkYXR1bV9wYXJhbXNbNF07XG5cdCAgICB2YXIgUnpfQkYgPSBkYXR1bV9wYXJhbXNbNV07XG5cdCAgICB2YXIgTV9CRiA9IGRhdHVtX3BhcmFtc1s2XTtcblx0ICAgIHZhciB4X3RtcCA9IChwLnggLSBEeF9CRikgLyBNX0JGO1xuXHQgICAgdmFyIHlfdG1wID0gKHAueSAtIER5X0JGKSAvIE1fQkY7XG5cdCAgICB2YXIgel90bXAgPSAocC56IC0gRHpfQkYpIC8gTV9CRjtcblx0ICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG5cdCAgICAvLyAgICBjb250aW51ZTtcblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgeDogeF90bXAgKyBSel9CRiAqIHlfdG1wIC0gUnlfQkYgKiB6X3RtcCxcblx0ICAgICAgeTogLVJ6X0JGICogeF90bXAgKyB5X3RtcCArIFJ4X0JGICogel90bXAsXG5cdCAgICAgIHo6IFJ5X0JGICogeF90bXAgLSBSeF9CRiAqIHlfdG1wICsgel90bXBcblx0ICAgIH07XG5cdCAgfSAvL2NzX2dlb2NlbnRyaWNfZnJvbV93Z3M4NCgpXG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1BhcmFtcyh0eXBlKSB7XG5cdCAgcmV0dXJuICh0eXBlID09PSBQSkRfM1BBUkFNIHx8IHR5cGUgPT09IFBKRF83UEFSQU0pO1xuXHR9XG5cblx0dmFyIGRhdHVtX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcblx0ICAvLyBTaG9ydCBjdXQgaWYgdGhlIGRhdHVtcyBhcmUgaWRlbnRpY2FsLlxuXHQgIGlmIChjb21wYXJlRGF0dW1zKHNvdXJjZSwgZGVzdCkpIHtcblx0ICAgIHJldHVybiBwb2ludDsgLy8gaW4gdGhpcyBjYXNlLCB6ZXJvIGlzIHN1Y2Vzcyxcblx0ICAgIC8vIHdoZXJlYXMgY3NfY29tcGFyZV9kYXR1bXMgcmV0dXJucyAxIHRvIGluZGljYXRlIFRSVUVcblx0ICAgIC8vIGNvbmZ1c2luZywgc2hvdWxkIGZpeCB0aGlzXG5cdCAgfVxuXG5cdCAgLy8gRXhwbGljaXRseSBza2lwIGRhdHVtIHRyYW5zZm9ybSBieSBzZXR0aW5nICdkYXR1bT1ub25lJyBhcyBwYXJhbWV0ZXIgZm9yIGVpdGhlciBzb3VyY2Ugb3IgZGVzdFxuXHQgIGlmIChzb3VyY2UuZGF0dW1fdHlwZSA9PT0gUEpEX05PREFUVU0gfHwgZGVzdC5kYXR1bV90eXBlID09PSBQSkRfTk9EQVRVTSkge1xuXHQgICAgcmV0dXJuIHBvaW50O1xuXHQgIH1cblxuXHQgIC8vIElmIHRoaXMgZGF0dW0gcmVxdWlyZXMgZ3JpZCBzaGlmdHMsIHRoZW4gYXBwbHkgaXQgdG8gZ2VvZGV0aWMgY29vcmRpbmF0ZXMuXG5cblx0ICAvLyBEbyB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggZ2VvY2VudHJpYyBjb29yZGluYXRlcz9cblx0ICBpZiAoc291cmNlLmVzID09PSBkZXN0LmVzICYmIHNvdXJjZS5hID09PSBkZXN0LmEgJiYgIWNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSAmJiAgIWNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcblx0ICAgIHJldHVybiBwb2ludDtcblx0ICB9XG5cblx0ICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG5cdCAgcG9pbnQgPSBnZW9kZXRpY1RvR2VvY2VudHJpYyhwb2ludCwgc291cmNlLmVzLCBzb3VyY2UuYSk7XG5cdCAgLy8gQ29udmVydCBiZXR3ZWVuIGRhdHVtc1xuXHQgIGlmIChjaGVja1BhcmFtcyhzb3VyY2UuZGF0dW1fdHlwZSkpIHtcblx0ICAgIHBvaW50ID0gZ2VvY2VudHJpY1RvV2dzODQocG9pbnQsIHNvdXJjZS5kYXR1bV90eXBlLCBzb3VyY2UuZGF0dW1fcGFyYW1zKTtcblx0ICB9XG5cdCAgaWYgKGNoZWNrUGFyYW1zKGRlc3QuZGF0dW1fdHlwZSkpIHtcblx0ICAgIHBvaW50ID0gZ2VvY2VudHJpY0Zyb21XZ3M4NChwb2ludCwgZGVzdC5kYXR1bV90eXBlLCBkZXN0LmRhdHVtX3BhcmFtcyk7XG5cdCAgfVxuXHQgIHJldHVybiBnZW9jZW50cmljVG9HZW9kZXRpYyhwb2ludCwgZGVzdC5lcywgZGVzdC5hLCBkZXN0LmIpO1xuXG5cdH07XG5cblx0dmFyIGFkanVzdF9heGlzID0gZnVuY3Rpb24oY3JzLCBkZW5vcm0sIHBvaW50KSB7XG5cdCAgdmFyIHhpbiA9IHBvaW50LngsXG5cdCAgICB5aW4gPSBwb2ludC55LFxuXHQgICAgemluID0gcG9pbnQueiB8fCAwLjA7XG5cdCAgdmFyIHYsIHQsIGk7XG5cdCAgdmFyIG91dCA9IHt9O1xuXHQgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0ICAgIGlmIChkZW5vcm0gJiYgaSA9PT0gMiAmJiBwb2ludC56ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cdCAgICBpZiAoaSA9PT0gMCkge1xuXHQgICAgICB2ID0geGluO1xuXHQgICAgICB0ID0gJ3gnO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuXHQgICAgICB2ID0geWluO1xuXHQgICAgICB0ID0gJ3knO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHYgPSB6aW47XG5cdCAgICAgIHQgPSAneic7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKGNycy5heGlzW2ldKSB7XG5cdCAgICBjYXNlICdlJzpcblx0ICAgICAgb3V0W3RdID0gdjtcblx0ICAgICAgYnJlYWs7XG5cdCAgICBjYXNlICd3Jzpcblx0ICAgICAgb3V0W3RdID0gLXY7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSAnbic6XG5cdCAgICAgIG91dFt0XSA9IHY7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSAncyc6XG5cdCAgICAgIG91dFt0XSA9IC12O1xuXHQgICAgICBicmVhaztcblx0ICAgIGNhc2UgJ3UnOlxuXHQgICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG91dC56ID0gdjtcblx0ICAgICAgfVxuXHQgICAgICBicmVhaztcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG91dC56ID0gLXY7XG5cdCAgICAgIH1cblx0ICAgICAgYnJlYWs7XG5cdCAgICBkZWZhdWx0OlxuXHQgICAgICAvL2NvbnNvbGUubG9nKFwiRVJST1I6IHVua25vdyBheGlzIChcIitjcnMuYXhpc1tpXStcIikgLSBjaGVjayBkZWZpbml0aW9uIG9mIFwiK2Nycy5wcm9qTmFtZSk7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gb3V0O1xuXHR9O1xuXG5cdHZhciB0b1BvaW50ID0gZnVuY3Rpb24gKGFycmF5KXtcblx0ICB2YXIgb3V0ID0ge1xuXHQgICAgeDogYXJyYXlbMF0sXG5cdCAgICB5OiBhcnJheVsxXVxuXHQgIH07XG5cdCAgaWYgKGFycmF5Lmxlbmd0aD4yKSB7XG5cdCAgICBvdXQueiA9IGFycmF5WzJdO1xuXHQgIH1cblx0ICBpZiAoYXJyYXkubGVuZ3RoPjMpIHtcblx0ICAgIG91dC5tID0gYXJyYXlbM107XG5cdCAgfVxuXHQgIHJldHVybiBvdXQ7XG5cdH07XG5cblx0dmFyIGNoZWNrU2FuaXR5ID0gZnVuY3Rpb24gKHBvaW50KSB7XG5cdCAgY2hlY2tDb29yZChwb2ludC54KTtcblx0ICBjaGVja0Nvb3JkKHBvaW50LnkpO1xuXHR9O1xuXHRmdW5jdGlvbiBjaGVja0Nvb3JkKG51bSkge1xuXHQgIGlmICh0eXBlb2YgTnVtYmVyLmlzRmluaXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG51bSkpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29vcmRpbmF0ZXMgbXVzdCBiZSBmaW5pdGUgbnVtYmVycycpO1xuXHQgIH1cblx0ICBpZiAodHlwZW9mIG51bSAhPT0gJ251bWJlcicgfHwgbnVtICE9PSBudW0gfHwgIWlzRmluaXRlKG51bSkpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nvb3JkaW5hdGVzIG11c3QgYmUgZmluaXRlIG51bWJlcnMnKTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpIHtcblx0ICByZXR1cm4gKChzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSB8fCBzb3VyY2UuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkgJiYgZGVzdC5kYXR1bUNvZGUgIT09ICdXR1M4NCcpIHx8ICgoZGVzdC5kYXR1bS5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNIHx8IGRlc3QuZGF0dW0uZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkgJiYgc291cmNlLmRhdHVtQ29kZSAhPT0gJ1dHUzg0Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm0oc291cmNlLCBkZXN0LCBwb2ludCkge1xuXHQgIHZhciB3Z3M4NDtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShwb2ludCkpIHtcblx0ICAgIHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG5cdCAgfVxuXHQgIGNoZWNrU2FuaXR5KHBvaW50KTtcblx0ICAvLyBXb3JrYXJvdW5kIGZvciBkYXR1bSBzaGlmdHMgdG93Z3M4NCwgaWYgZWl0aGVyIHNvdXJjZSBvciBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uIGlzIG5vdCB3Z3M4NFxuXHQgIGlmIChzb3VyY2UuZGF0dW0gJiYgZGVzdC5kYXR1bSAmJiBjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpKSB7XG5cdCAgICB3Z3M4NCA9IG5ldyBQcm9qZWN0aW9uJDEoJ1dHUzg0Jyk7XG5cdCAgICBwb2ludCA9IHRyYW5zZm9ybShzb3VyY2UsIHdnczg0LCBwb2ludCk7XG5cdCAgICBzb3VyY2UgPSB3Z3M4NDtcblx0ICB9XG5cdCAgLy8gREdSLCAyMDEwLzExLzEyXG5cdCAgaWYgKHNvdXJjZS5heGlzICE9PSAnZW51Jykge1xuXHQgICAgcG9pbnQgPSBhZGp1c3RfYXhpcyhzb3VyY2UsIGZhbHNlLCBwb2ludCk7XG5cdCAgfVxuXHQgIC8vIFRyYW5zZm9ybSBzb3VyY2UgcG9pbnRzIHRvIGxvbmcvbGF0LCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5LlxuXHQgIGlmIChzb3VyY2UucHJvak5hbWUgPT09ICdsb25nbGF0Jykge1xuXHQgICAgcG9pbnQgPSB7XG5cdCAgICAgIHg6IHBvaW50LnggKiBEMlIsXG5cdCAgICAgIHk6IHBvaW50LnkgKiBEMlJcblx0ICAgIH07XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgaWYgKHNvdXJjZS50b19tZXRlcikge1xuXHQgICAgICBwb2ludCA9IHtcblx0ICAgICAgICB4OiBwb2ludC54ICogc291cmNlLnRvX21ldGVyLFxuXHQgICAgICAgIHk6IHBvaW50LnkgKiBzb3VyY2UudG9fbWV0ZXJcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHBvaW50ID0gc291cmNlLmludmVyc2UocG9pbnQpOyAvLyBDb252ZXJ0IENhcnRlc2lhbiB0byBsb25nbGF0XG5cdCAgfVxuXHQgIC8vIEFkanVzdCBmb3IgdGhlIHByaW1lIG1lcmlkaWFuIGlmIG5lY2Vzc2FyeVxuXHQgIGlmIChzb3VyY2UuZnJvbV9ncmVlbndpY2gpIHtcblx0ICAgIHBvaW50LnggKz0gc291cmNlLmZyb21fZ3JlZW53aWNoO1xuXHQgIH1cblxuXHQgIC8vIENvbnZlcnQgZGF0dW1zIGlmIG5lZWRlZCwgYW5kIGlmIHBvc3NpYmxlLlxuXHQgIHBvaW50ID0gZGF0dW1fdHJhbnNmb3JtKHNvdXJjZS5kYXR1bSwgZGVzdC5kYXR1bSwgcG9pbnQpO1xuXG5cdCAgLy8gQWRqdXN0IGZvciB0aGUgcHJpbWUgbWVyaWRpYW4gaWYgbmVjZXNzYXJ5XG5cdCAgaWYgKGRlc3QuZnJvbV9ncmVlbndpY2gpIHtcblx0ICAgIHBvaW50ID0ge1xuXHQgICAgICB4OiBwb2ludC54IC0gZGVzdC5mcm9tX2dyZWVud2ljaCxcblx0ICAgICAgeTogcG9pbnQueVxuXHQgICAgfTtcblx0ICB9XG5cblx0ICBpZiAoZGVzdC5wcm9qTmFtZSA9PT0gJ2xvbmdsYXQnKSB7XG5cdCAgICAvLyBjb252ZXJ0IHJhZGlhbnMgdG8gZGVjaW1hbCBkZWdyZWVzXG5cdCAgICBwb2ludCA9IHtcblx0ICAgICAgeDogcG9pbnQueCAqIFIyRCxcblx0ICAgICAgeTogcG9pbnQueSAqIFIyRFxuXHQgICAgfTtcblx0ICB9IGVsc2UgeyAvLyBlbHNlIHByb2plY3Rcblx0ICAgIHBvaW50ID0gZGVzdC5mb3J3YXJkKHBvaW50KTtcblx0ICAgIGlmIChkZXN0LnRvX21ldGVyKSB7XG5cdCAgICAgIHBvaW50ID0ge1xuXHQgICAgICAgIHg6IHBvaW50LnggLyBkZXN0LnRvX21ldGVyLFxuXHQgICAgICAgIHk6IHBvaW50LnkgLyBkZXN0LnRvX21ldGVyXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gREdSLCAyMDEwLzExLzEyXG5cdCAgaWYgKGRlc3QuYXhpcyAhPT0gJ2VudScpIHtcblx0ICAgIHJldHVybiBhZGp1c3RfYXhpcyhkZXN0LCB0cnVlLCBwb2ludCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHBvaW50O1xuXHR9XG5cblx0dmFyIHdnczg0ID0gUHJvamVjdGlvbiQxKCdXR1M4NCcpO1xuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybWVyKGZyb20sIHRvLCBjb29yZHMpIHtcblx0ICB2YXIgdHJhbnNmb3JtZWRBcnJheSwgb3V0LCBrZXlzO1xuXHQgIGlmIChBcnJheS5pc0FycmF5KGNvb3JkcykpIHtcblx0ICAgIHRyYW5zZm9ybWVkQXJyYXkgPSB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3Jkcyk7XG5cdCAgICBpZiAoY29vcmRzLmxlbmd0aCA9PT0gMykge1xuXHQgICAgICByZXR1cm4gW3RyYW5zZm9ybWVkQXJyYXkueCwgdHJhbnNmb3JtZWRBcnJheS55LCB0cmFuc2Zvcm1lZEFycmF5LnpdO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHJldHVybiBbdHJhbnNmb3JtZWRBcnJheS54LCB0cmFuc2Zvcm1lZEFycmF5LnldO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIG91dCA9IHRyYW5zZm9ybShmcm9tLCB0bywgY29vcmRzKTtcblx0ICAgIGtleXMgPSBPYmplY3Qua2V5cyhjb29yZHMpO1xuXHQgICAgaWYgKGtleXMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgIHJldHVybiBvdXQ7XG5cdCAgICB9XG5cdCAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICBpZiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgb3V0W2tleV0gPSBjb29yZHNba2V5XTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIG91dDtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1Byb2ooaXRlbSkge1xuXHQgIGlmIChpdGVtIGluc3RhbmNlb2YgUHJvamVjdGlvbiQxKSB7XG5cdCAgICByZXR1cm4gaXRlbTtcblx0ICB9XG5cdCAgaWYgKGl0ZW0ub1Byb2opIHtcblx0ICAgIHJldHVybiBpdGVtLm9Qcm9qO1xuXHQgIH1cblx0ICByZXR1cm4gUHJvamVjdGlvbiQxKGl0ZW0pO1xuXHR9XG5cdGZ1bmN0aW9uIHByb2o0JDEoZnJvbVByb2osIHRvUHJvaiwgY29vcmQpIHtcblx0ICBmcm9tUHJvaiA9IGNoZWNrUHJvaihmcm9tUHJvaik7XG5cdCAgdmFyIHNpbmdsZSA9IGZhbHNlO1xuXHQgIHZhciBvYmo7XG5cdCAgaWYgKHR5cGVvZiB0b1Byb2ogPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICB0b1Byb2ogPSBmcm9tUHJvajtcblx0ICAgIGZyb21Qcm9qID0gd2dzODQ7XG5cdCAgICBzaW5nbGUgPSB0cnVlO1xuXHQgIH1cblx0ICBlbHNlIGlmICh0eXBlb2YgdG9Qcm9qLnggIT09ICd1bmRlZmluZWQnIHx8IEFycmF5LmlzQXJyYXkodG9Qcm9qKSkge1xuXHQgICAgY29vcmQgPSB0b1Byb2o7XG5cdCAgICB0b1Byb2ogPSBmcm9tUHJvajtcblx0ICAgIGZyb21Qcm9qID0gd2dzODQ7XG5cdCAgICBzaW5nbGUgPSB0cnVlO1xuXHQgIH1cblx0ICB0b1Byb2ogPSBjaGVja1Byb2oodG9Qcm9qKTtcblx0ICBpZiAoY29vcmQpIHtcblx0ICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZCk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgb2JqID0ge1xuXHQgICAgICBmb3J3YXJkOiBmdW5jdGlvbihjb29yZHMpIHtcblx0ICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoZnJvbVByb2osIHRvUHJvaiwgY29vcmRzKTtcblx0ICAgICAgfSxcblx0ICAgICAgaW52ZXJzZTogZnVuY3Rpb24oY29vcmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKHRvUHJvaiwgZnJvbVByb2osIGNvb3Jkcyk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBpZiAoc2luZ2xlKSB7XG5cdCAgICAgIG9iai5vUHJvaiA9IHRvUHJvajtcblx0ICAgIH1cblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFVUTSB6b25lcyBhcmUgZ3JvdXBlZCwgYW5kIGFzc2lnbmVkIHRvIG9uZSBvZiBhIGdyb3VwIG9mIDZcblx0ICogc2V0cy5cblx0ICpcblx0ICoge2ludH0gQHByaXZhdGVcblx0ICovXG5cdHZhciBOVU1fMTAwS19TRVRTID0gNjtcblxuXHQvKipcblx0ICogVGhlIGNvbHVtbiBsZXR0ZXJzIChmb3IgZWFzdGluZykgb2YgdGhlIGxvd2VyIGxlZnQgdmFsdWUsIHBlclxuXHQgKiBzZXQuXG5cdCAqXG5cdCAqIHtzdHJpbmd9IEBwcml2YXRlXG5cdCAqL1xuXHR2YXIgU0VUX09SSUdJTl9DT0xVTU5fTEVUVEVSUyA9ICdBSlNBSlMnO1xuXG5cdC8qKlxuXHQgKiBUaGUgcm93IGxldHRlcnMgKGZvciBub3J0aGluZykgb2YgdGhlIGxvd2VyIGxlZnQgdmFsdWUsIHBlclxuXHQgKiBzZXQuXG5cdCAqXG5cdCAqIHtzdHJpbmd9IEBwcml2YXRlXG5cdCAqL1xuXHR2YXIgU0VUX09SSUdJTl9ST1dfTEVUVEVSUyA9ICdBRkFGQUYnO1xuXG5cdHZhciBBID0gNjU7IC8vIEFcblx0dmFyIEkgPSA3MzsgLy8gSVxuXHR2YXIgTyA9IDc5OyAvLyBPXG5cdHZhciBWID0gODY7IC8vIFZcblx0dmFyIFogPSA5MDsgLy8gWlxuXHR2YXIgbWdycyA9IHtcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDEsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxLFxuXHQgIHRvUG9pbnQ6IHRvUG9pbnQkMVxuXHR9O1xuXHQvKipcblx0ICogQ29udmVyc2lvbiBvZiBsYXQvbG9uIHRvIE1HUlMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXMgb24gYVxuXHQgKiAgICAgV0dTODQgZWxsaXBzb2lkLlxuXHQgKiBAcGFyYW0ge2ludH0gYWNjdXJhY3kgQWNjdXJhY3kgaW4gZGlnaXRzICg1IGZvciAxIG0sIDQgZm9yIDEwIG0sIDMgZm9yXG5cdCAqICAgICAgMTAwIG0sIDIgZm9yIDEwMDAgbSBvciAxIGZvciAxMDAwMCBtKS4gT3B0aW9uYWwsIGRlZmF1bHQgaXMgNS5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgTUdSUyBzdHJpbmcgZm9yIHRoZSBnaXZlbiBsb2NhdGlvbiBhbmQgYWNjdXJhY3kuXG5cdCAqL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDEobGwsIGFjY3VyYWN5KSB7XG5cdCAgYWNjdXJhY3kgPSBhY2N1cmFjeSB8fCA1OyAvLyBkZWZhdWx0IGFjY3VyYWN5IDFtXG5cdCAgcmV0dXJuIGVuY29kZShMTHRvVVRNKHtcblx0ICAgIGxhdDogbGxbMV0sXG5cdCAgICBsb246IGxsWzBdXG5cdCAgfSksIGFjY3VyYWN5KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJzaW9uIG9mIE1HUlMgdG8gbGF0L2xvbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ncnMgTUdSUyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSB3aXRoIGxlZnQgKGxvbmdpdHVkZSksIGJvdHRvbSAobGF0aXR1ZGUpLCByaWdodFxuXHQgKiAgICAgKGxvbmdpdHVkZSkgYW5kIHRvcCAobGF0aXR1ZGUpIHZhbHVlcyBpbiBXR1M4NCwgcmVwcmVzZW50aW5nIHRoZVxuXHQgKiAgICAgYm91bmRpbmcgYm94IGZvciB0aGUgcHJvdmlkZWQgTUdSUyByZWZlcmVuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnZlcnNlJDEobWdycykge1xuXHQgIHZhciBiYm94ID0gVVRNdG9MTChkZWNvZGUobWdycy50b1VwcGVyQ2FzZSgpKSk7XG5cdCAgaWYgKGJib3gubGF0ICYmIGJib3gubG9uKSB7XG5cdCAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdCwgYmJveC5sb24sIGJib3gubGF0XTtcblx0ICB9XG5cdCAgcmV0dXJuIFtiYm94LmxlZnQsIGJib3guYm90dG9tLCBiYm94LnJpZ2h0LCBiYm94LnRvcF07XG5cdH1cblxuXHRmdW5jdGlvbiB0b1BvaW50JDEobWdycykge1xuXHQgIHZhciBiYm94ID0gVVRNdG9MTChkZWNvZGUobWdycy50b1VwcGVyQ2FzZSgpKSk7XG5cdCAgaWYgKGJib3gubGF0ICYmIGJib3gubG9uKSB7XG5cdCAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdF07XG5cdCAgfVxuXHQgIHJldHVybiBbKGJib3gubGVmdCArIGJib3gucmlnaHQpIC8gMiwgKGJib3gudG9wICsgYmJveC5ib3R0b20pIC8gMl07XG5cdH1cblx0LyoqXG5cdCAqIENvbnZlcnNpb24gZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgdGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gdGhlIGFuZ2xlIGluIHJhZGlhbnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWdUb1JhZChkZWcpIHtcblx0ICByZXR1cm4gKGRlZyAqIChNYXRoLlBJIC8gMTgwLjApKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJzaW9uIGZyb20gcmFkaWFucyB0byBkZWdyZWVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmFkVG9EZWcocmFkKSB7XG5cdCAgcmV0dXJuICgxODAuMCAqIChyYWQgLyBNYXRoLlBJKSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzZXQgb2YgTG9uZ2l0dWRlIGFuZCBMYXRpdHVkZSBjby1vcmRpbmF0ZXMgdG8gVVRNXG5cdCAqIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsbCBPYmplY3QgbGl0ZXJhbCB3aXRoIGxhdCBhbmQgbG9uIHByb3BlcnRpZXNcblx0ICogICAgIHJlcHJlc2VudGluZyB0aGUgV0dTODQgY29vcmRpbmF0ZSB0byBiZSBjb252ZXJ0ZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyB0aGUgVVRNIHZhbHVlIHdpdGggZWFzdGluZyxcblx0ICogICAgIG5vcnRoaW5nLCB6b25lTnVtYmVyIGFuZCB6b25lTGV0dGVyIHByb3BlcnRpZXMsIGFuZCBhbiBvcHRpb25hbFxuXHQgKiAgICAgYWNjdXJhY3kgcHJvcGVydHkgaW4gZGlnaXRzLiBSZXR1cm5zIG51bGwgaWYgdGhlIGNvbnZlcnNpb24gZmFpbGVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gTEx0b1VUTShsbCkge1xuXHQgIHZhciBMYXQgPSBsbC5sYXQ7XG5cdCAgdmFyIExvbmcgPSBsbC5sb247XG5cdCAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuXHQgIHZhciBlY2NTcXVhcmVkID0gMC4wMDY2OTQzODsgLy9lbGxpcC5lY2NzcTtcblx0ICB2YXIgazAgPSAwLjk5OTY7XG5cdCAgdmFyIExvbmdPcmlnaW47XG5cdCAgdmFyIGVjY1ByaW1lU3F1YXJlZDtcblx0ICB2YXIgTiwgVCwgQywgQSwgTTtcblx0ICB2YXIgTGF0UmFkID0gZGVnVG9SYWQoTGF0KTtcblx0ICB2YXIgTG9uZ1JhZCA9IGRlZ1RvUmFkKExvbmcpO1xuXHQgIHZhciBMb25nT3JpZ2luUmFkO1xuXHQgIHZhciBab25lTnVtYmVyO1xuXHQgIC8vIChpbnQpXG5cdCAgWm9uZU51bWJlciA9IE1hdGguZmxvb3IoKExvbmcgKyAxODApIC8gNikgKyAxO1xuXG5cdCAgLy9NYWtlIHN1cmUgdGhlIGxvbmdpdHVkZSAxODAuMDAgaXMgaW4gWm9uZSA2MFxuXHQgIGlmIChMb25nID09PSAxODApIHtcblx0ICAgIFpvbmVOdW1iZXIgPSA2MDtcblx0ICB9XG5cblx0ICAvLyBTcGVjaWFsIHpvbmUgZm9yIE5vcndheVxuXHQgIGlmIChMYXQgPj0gNTYuMCAmJiBMYXQgPCA2NC4wICYmIExvbmcgPj0gMy4wICYmIExvbmcgPCAxMi4wKSB7XG5cdCAgICBab25lTnVtYmVyID0gMzI7XG5cdCAgfVxuXG5cdCAgLy8gU3BlY2lhbCB6b25lcyBmb3IgU3ZhbGJhcmRcblx0ICBpZiAoTGF0ID49IDcyLjAgJiYgTGF0IDwgODQuMCkge1xuXHQgICAgaWYgKExvbmcgPj0gMC4wICYmIExvbmcgPCA5LjApIHtcblx0ICAgICAgWm9uZU51bWJlciA9IDMxO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoTG9uZyA+PSA5LjAgJiYgTG9uZyA8IDIxLjApIHtcblx0ICAgICAgWm9uZU51bWJlciA9IDMzO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoTG9uZyA+PSAyMS4wICYmIExvbmcgPCAzMy4wKSB7XG5cdCAgICAgIFpvbmVOdW1iZXIgPSAzNTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKExvbmcgPj0gMzMuMCAmJiBMb25nIDwgNDIuMCkge1xuXHQgICAgICBab25lTnVtYmVyID0gMzc7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgTG9uZ09yaWdpbiA9IChab25lTnVtYmVyIC0gMSkgKiA2IC0gMTgwICsgMzsgLy8rMyBwdXRzIG9yaWdpblxuXHQgIC8vIGluIG1pZGRsZSBvZlxuXHQgIC8vIHpvbmVcblx0ICBMb25nT3JpZ2luUmFkID0gZGVnVG9SYWQoTG9uZ09yaWdpbik7XG5cblx0ICBlY2NQcmltZVNxdWFyZWQgPSAoZWNjU3F1YXJlZCkgLyAoMSAtIGVjY1NxdWFyZWQpO1xuXG5cdCAgTiA9IGEgLyBNYXRoLnNxcnQoMSAtIGVjY1NxdWFyZWQgKiBNYXRoLnNpbihMYXRSYWQpICogTWF0aC5zaW4oTGF0UmFkKSk7XG5cdCAgVCA9IE1hdGgudGFuKExhdFJhZCkgKiBNYXRoLnRhbihMYXRSYWQpO1xuXHQgIEMgPSBlY2NQcmltZVNxdWFyZWQgKiBNYXRoLmNvcyhMYXRSYWQpICogTWF0aC5jb3MoTGF0UmFkKTtcblx0ICBBID0gTWF0aC5jb3MoTGF0UmFkKSAqIChMb25nUmFkIC0gTG9uZ09yaWdpblJhZCk7XG5cblx0ICBNID0gYSAqICgoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSAqIExhdFJhZCAtICgzICogZWNjU3F1YXJlZCAvIDggKyAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMiArIDQ1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMTAyNCkgKiBNYXRoLnNpbigyICogTGF0UmFkKSArICgxNSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2ICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDQgKiBMYXRSYWQpIC0gKDM1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMzA3MikgKiBNYXRoLnNpbig2ICogTGF0UmFkKSk7XG5cblx0ICB2YXIgVVRNRWFzdGluZyA9IChrMCAqIE4gKiAoQSArICgxIC0gVCArIEMpICogQSAqIEEgKiBBIC8gNi4wICsgKDUgLSAxOCAqIFQgKyBUICogVCArIDcyICogQyAtIDU4ICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBIC8gMTIwLjApICsgNTAwMDAwLjApO1xuXG5cdCAgdmFyIFVUTU5vcnRoaW5nID0gKGswICogKE0gKyBOICogTWF0aC50YW4oTGF0UmFkKSAqIChBICogQSAvIDIgKyAoNSAtIFQgKyA5ICogQyArIDQgKiBDICogQykgKiBBICogQSAqIEEgKiBBIC8gMjQuMCArICg2MSAtIDU4ICogVCArIFQgKiBUICsgNjAwICogQyAtIDMzMCAqIGVjY1ByaW1lU3F1YXJlZCkgKiBBICogQSAqIEEgKiBBICogQSAqIEEgLyA3MjAuMCkpKTtcblx0ICBpZiAoTGF0IDwgMC4wKSB7XG5cdCAgICBVVE1Ob3J0aGluZyArPSAxMDAwMDAwMC4wOyAvLzEwMDAwMDAwIG1ldGVyIG9mZnNldCBmb3Jcblx0ICAgIC8vIHNvdXRoZXJuIGhlbWlzcGhlcmVcblx0ICB9XG5cblx0ICByZXR1cm4ge1xuXHQgICAgbm9ydGhpbmc6IE1hdGgucm91bmQoVVRNTm9ydGhpbmcpLFxuXHQgICAgZWFzdGluZzogTWF0aC5yb3VuZChVVE1FYXN0aW5nKSxcblx0ICAgIHpvbmVOdW1iZXI6IFpvbmVOdW1iZXIsXG5cdCAgICB6b25lTGV0dGVyOiBnZXRMZXR0ZXJEZXNpZ25hdG9yKExhdClcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIFVUTSBjb29yZHMgdG8gbGF0L2xvbmcsIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuXHQgKiBjbGFzcyB3aGVyZSB0aGUgWm9uZSBjYW4gYmUgc3BlY2lmaWVkIGFzIGEgc2luZ2xlIHN0cmluZyBlZy5cIjYwTlwiIHdoaWNoXG5cdCAqIGlzIHRoZW4gYnJva2VuIGRvd24gaW50byB0aGUgWm9uZU51bWJlciBhbmQgWm9uZUxldHRlci5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHV0bSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIG5vcnRoaW5nLCBlYXN0aW5nLCB6b25lTnVtYmVyXG5cdCAqICAgICBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLiBJZiBhbiBvcHRpb25hbCBhY2N1cmFjeSBwcm9wZXJ0eSBpc1xuXHQgKiAgICAgcHJvdmlkZWQgKGluIG1ldGVycyksIGEgYm91bmRpbmcgYm94IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZlxuXHQgKiAgICAgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cblx0ICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGVpdGhlciBsYXQgYW5kIGxvbiB2YWx1ZXNcblx0ICogICAgIChpZiBubyBhY2N1cmFjeSB3YXMgcHJvdmlkZWQpLCBvciB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnQgdmFsdWVzXG5cdCAqICAgICBmb3IgdGhlIGJvdW5kaW5nIGJveCBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgYWNjdXJhY3kuXG5cdCAqICAgICBSZXR1cm5zIG51bGwgaWYgdGhlIGNvbnZlcnNpb24gZmFpbGVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gVVRNdG9MTCh1dG0pIHtcblxuXHQgIHZhciBVVE1Ob3J0aGluZyA9IHV0bS5ub3J0aGluZztcblx0ICB2YXIgVVRNRWFzdGluZyA9IHV0bS5lYXN0aW5nO1xuXHQgIHZhciB6b25lTGV0dGVyID0gdXRtLnpvbmVMZXR0ZXI7XG5cdCAgdmFyIHpvbmVOdW1iZXIgPSB1dG0uem9uZU51bWJlcjtcblx0ICAvLyBjaGVjayB0aGUgWm9uZU51bW1iZXIgaXMgdmFsaWRcblx0ICBpZiAoem9uZU51bWJlciA8IDAgfHwgem9uZU51bWJlciA+IDYwKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgazAgPSAwLjk5OTY7XG5cdCAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuXHQgIHZhciBlY2NTcXVhcmVkID0gMC4wMDY2OTQzODsgLy9lbGxpcC5lY2NzcTtcblx0ICB2YXIgZWNjUHJpbWVTcXVhcmVkO1xuXHQgIHZhciBlMSA9ICgxIC0gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSkgLyAoMSArIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCkpO1xuXHQgIHZhciBOMSwgVDEsIEMxLCBSMSwgRCwgTTtcblx0ICB2YXIgTG9uZ09yaWdpbjtcblx0ICB2YXIgbXUsIHBoaTFSYWQ7XG5cblx0ICAvLyByZW1vdmUgNTAwLDAwMCBtZXRlciBvZmZzZXQgZm9yIGxvbmdpdHVkZVxuXHQgIHZhciB4ID0gVVRNRWFzdGluZyAtIDUwMDAwMC4wO1xuXHQgIHZhciB5ID0gVVRNTm9ydGhpbmc7XG5cblx0ICAvLyBXZSBtdXN0IGtub3cgc29tZWhvdyBpZiB3ZSBhcmUgaW4gdGhlIE5vcnRoZXJuIG9yIFNvdXRoZXJuXG5cdCAgLy8gaGVtaXNwaGVyZSwgdGhpcyBpcyB0aGUgb25seSB0aW1lIHdlIHVzZSB0aGUgbGV0dGVyIFNvIGV2ZW5cblx0ICAvLyBpZiB0aGUgWm9uZSBsZXR0ZXIgaXNuJ3QgZXhhY3RseSBjb3JyZWN0IGl0IHNob3VsZCBpbmRpY2F0ZVxuXHQgIC8vIHRoZSBoZW1pc3BoZXJlIGNvcnJlY3RseVxuXHQgIGlmICh6b25lTGV0dGVyIDwgJ04nKSB7XG5cdCAgICB5IC09IDEwMDAwMDAwLjA7IC8vIHJlbW92ZSAxMCwwMDAsMDAwIG1ldGVyIG9mZnNldCB1c2VkXG5cdCAgICAvLyBmb3Igc291dGhlcm4gaGVtaXNwaGVyZVxuXHQgIH1cblxuXHQgIC8vIFRoZXJlIGFyZSA2MCB6b25lcyB3aXRoIHpvbmUgMSBiZWluZyBhdCBXZXN0IC0xODAgdG8gLTE3NFxuXHQgIExvbmdPcmlnaW4gPSAoem9uZU51bWJlciAtIDEpICogNiAtIDE4MCArIDM7IC8vICszIHB1dHMgb3JpZ2luXG5cdCAgLy8gaW4gbWlkZGxlIG9mXG5cdCAgLy8gem9uZVxuXG5cdCAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuXHQgIE0gPSB5IC8gazA7XG5cdCAgbXUgPSBNIC8gKGEgKiAoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSk7XG5cblx0ICBwaGkxUmFkID0gbXUgKyAoMyAqIGUxIC8gMiAtIDI3ICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oMiAqIG11KSArICgyMSAqIGUxICogZTEgLyAxNiAtIDU1ICogZTEgKiBlMSAqIGUxICogZTEgLyAzMikgKiBNYXRoLnNpbig0ICogbXUpICsgKDE1MSAqIGUxICogZTEgKiBlMSAvIDk2KSAqIE1hdGguc2luKDYgKiBtdSk7XG5cdCAgLy8gZG91YmxlIHBoaTEgPSBQcm9qTWF0aC5yYWRUb0RlZyhwaGkxUmFkKTtcblxuXHQgIE4xID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKHBoaTFSYWQpICogTWF0aC5zaW4ocGhpMVJhZCkpO1xuXHQgIFQxID0gTWF0aC50YW4ocGhpMVJhZCkgKiBNYXRoLnRhbihwaGkxUmFkKTtcblx0ICBDMSA9IGVjY1ByaW1lU3F1YXJlZCAqIE1hdGguY29zKHBoaTFSYWQpICogTWF0aC5jb3MocGhpMVJhZCk7XG5cdCAgUjEgPSBhICogKDEgLSBlY2NTcXVhcmVkKSAvIE1hdGgucG93KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSwgMS41KTtcblx0ICBEID0geCAvIChOMSAqIGswKTtcblxuXHQgIHZhciBsYXQgPSBwaGkxUmFkIC0gKE4xICogTWF0aC50YW4ocGhpMVJhZCkgLyBSMSkgKiAoRCAqIEQgLyAyIC0gKDUgKyAzICogVDEgKyAxMCAqIEMxIC0gNCAqIEMxICogQzEgLSA5ICogZWNjUHJpbWVTcXVhcmVkKSAqIEQgKiBEICogRCAqIEQgLyAyNCArICg2MSArIDkwICogVDEgKyAyOTggKiBDMSArIDQ1ICogVDEgKiBUMSAtIDI1MiAqIGVjY1ByaW1lU3F1YXJlZCAtIDMgKiBDMSAqIEMxKSAqIEQgKiBEICogRCAqIEQgKiBEICogRCAvIDcyMCk7XG5cdCAgbGF0ID0gcmFkVG9EZWcobGF0KTtcblxuXHQgIHZhciBsb24gPSAoRCAtICgxICsgMiAqIFQxICsgQzEpICogRCAqIEQgKiBEIC8gNiArICg1IC0gMiAqIEMxICsgMjggKiBUMSAtIDMgKiBDMSAqIEMxICsgOCAqIGVjY1ByaW1lU3F1YXJlZCArIDI0ICogVDEgKiBUMSkgKiBEICogRCAqIEQgKiBEICogRCAvIDEyMCkgLyBNYXRoLmNvcyhwaGkxUmFkKTtcblx0ICBsb24gPSBMb25nT3JpZ2luICsgcmFkVG9EZWcobG9uKTtcblxuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYgKHV0bS5hY2N1cmFjeSkge1xuXHQgICAgdmFyIHRvcFJpZ2h0ID0gVVRNdG9MTCh7XG5cdCAgICAgIG5vcnRoaW5nOiB1dG0ubm9ydGhpbmcgKyB1dG0uYWNjdXJhY3ksXG5cdCAgICAgIGVhc3Rpbmc6IHV0bS5lYXN0aW5nICsgdXRtLmFjY3VyYWN5LFxuXHQgICAgICB6b25lTGV0dGVyOiB1dG0uem9uZUxldHRlcixcblx0ICAgICAgem9uZU51bWJlcjogdXRtLnpvbmVOdW1iZXJcblx0ICAgIH0pO1xuXHQgICAgcmVzdWx0ID0ge1xuXHQgICAgICB0b3A6IHRvcFJpZ2h0LmxhdCxcblx0ICAgICAgcmlnaHQ6IHRvcFJpZ2h0Lmxvbixcblx0ICAgICAgYm90dG9tOiBsYXQsXG5cdCAgICAgIGxlZnQ6IGxvblxuXHQgICAgfTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICByZXN1bHQgPSB7XG5cdCAgICAgIGxhdDogbGF0LFxuXHQgICAgICBsb246IGxvblxuXHQgICAgfTtcblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIHRoZSBNR1JTIGxldHRlciBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gbGF0aXR1ZGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGluIFdHUzg0IHRvIGdldCB0aGUgbGV0dGVyIGRlc2lnbmF0b3Jcblx0ICogICAgIGZvci5cblx0ICogQHJldHVybiB7Y2hhcn0gVGhlIGxldHRlciBkZXNpZ25hdG9yLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TGV0dGVyRGVzaWduYXRvcihsYXQpIHtcblx0ICAvL1RoaXMgaXMgaGVyZSBhcyBhbiBlcnJvciBmbGFnIHRvIHNob3cgdGhhdCB0aGUgTGF0aXR1ZGUgaXNcblx0ICAvL291dHNpZGUgTUdSUyBsaW1pdHNcblx0ICB2YXIgTGV0dGVyRGVzaWduYXRvciA9ICdaJztcblxuXHQgIGlmICgoODQgPj0gbGF0KSAmJiAobGF0ID49IDcyKSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdYJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDcyID4gbGF0KSAmJiAobGF0ID49IDY0KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdXJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDY0ID4gbGF0KSAmJiAobGF0ID49IDU2KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdWJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDU2ID4gbGF0KSAmJiAobGF0ID49IDQ4KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdVJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDQ4ID4gbGF0KSAmJiAobGF0ID49IDQwKSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdUJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDQwID4gbGF0KSAmJiAobGF0ID49IDMyKSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdTJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDMyID4gbGF0KSAmJiAobGF0ID49IDI0KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdSJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDI0ID4gbGF0KSAmJiAobGF0ID49IDE2KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdRJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDE2ID4gbGF0KSAmJiAobGF0ID49IDgpKSB7XG5cdCAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1AnO1xuXHQgIH1cblx0ICBlbHNlIGlmICgoOCA+IGxhdCkgJiYgKGxhdCA+PSAwKSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdOJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKDAgPiBsYXQpICYmIChsYXQgPj0gLTgpKSB7XG5cdCAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ00nO1xuXHQgIH1cblx0ICBlbHNlIGlmICgoLTggPiBsYXQpICYmIChsYXQgPj0gLTE2KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdMJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKC0xNiA+IGxhdCkgJiYgKGxhdCA+PSAtMjQpKSB7XG5cdCAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0snO1xuXHQgIH1cblx0ICBlbHNlIGlmICgoLTI0ID4gbGF0KSAmJiAobGF0ID49IC0zMikpIHtcblx0ICAgIExldHRlckRlc2lnbmF0b3IgPSAnSic7XG5cdCAgfVxuXHQgIGVsc2UgaWYgKCgtMzIgPiBsYXQpICYmIChsYXQgPj0gLTQwKSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdIJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKC00MCA+IGxhdCkgJiYgKGxhdCA+PSAtNDgpKSB7XG5cdCAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0cnO1xuXHQgIH1cblx0ICBlbHNlIGlmICgoLTQ4ID4gbGF0KSAmJiAobGF0ID49IC01NikpIHtcblx0ICAgIExldHRlckRlc2lnbmF0b3IgPSAnRic7XG5cdCAgfVxuXHQgIGVsc2UgaWYgKCgtNTYgPiBsYXQpICYmIChsYXQgPj0gLTY0KSkge1xuXHQgICAgTGV0dGVyRGVzaWduYXRvciA9ICdFJztcblx0ICB9XG5cdCAgZWxzZSBpZiAoKC02NCA+IGxhdCkgJiYgKGxhdCA+PSAtNzIpKSB7XG5cdCAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0QnO1xuXHQgIH1cblx0ICBlbHNlIGlmICgoLTcyID4gbGF0KSAmJiAobGF0ID49IC04MCkpIHtcblx0ICAgIExldHRlckRlc2lnbmF0b3IgPSAnQyc7XG5cdCAgfVxuXHQgIHJldHVybiBMZXR0ZXJEZXNpZ25hdG9yO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgYSBVVE0gbG9jYXRpb24gYXMgTUdSUyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB1dG0gQW4gb2JqZWN0IGxpdGVyYWwgd2l0aCBlYXN0aW5nLCBub3J0aGluZyxcblx0ICogICAgIHpvbmVMZXR0ZXIsIHpvbmVOdW1iZXJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGFjY3VyYWN5IEFjY3VyYWN5IGluIGRpZ2l0cyAoMS01KS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBNR1JTIHN0cmluZyBmb3IgdGhlIGdpdmVuIFVUTSBsb2NhdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZSh1dG0sIGFjY3VyYWN5KSB7XG5cdCAgLy8gcHJlcGVuZCB3aXRoIGxlYWRpbmcgemVyb2VzXG5cdCAgdmFyIHNlYXN0aW5nID0gXCIwMDAwMFwiICsgdXRtLmVhc3RpbmcsXG5cdCAgICBzbm9ydGhpbmcgPSBcIjAwMDAwXCIgKyB1dG0ubm9ydGhpbmc7XG5cblx0ICByZXR1cm4gdXRtLnpvbmVOdW1iZXIgKyB1dG0uem9uZUxldHRlciArIGdldDEwMGtJRCh1dG0uZWFzdGluZywgdXRtLm5vcnRoaW5nLCB1dG0uem9uZU51bWJlcikgKyBzZWFzdGluZy5zdWJzdHIoc2Vhc3RpbmcubGVuZ3RoIC0gNSwgYWNjdXJhY3kpICsgc25vcnRoaW5nLnN1YnN0cihzbm9ydGhpbmcubGVuZ3RoIC0gNSwgYWNjdXJhY3kpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgdHdvIGxldHRlciAxMDBrIGRlc2lnbmF0b3IgZm9yIGEgZ2l2ZW4gVVRNIGVhc3RpbmcsXG5cdCAqIG5vcnRoaW5nIGFuZCB6b25lIG51bWJlciB2YWx1ZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGVhc3Rpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5vcnRoaW5nXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB6b25lTnVtYmVyXG5cdCAqIEByZXR1cm4gdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0MTAwa0lEKGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTnVtYmVyKSB7XG5cdCAgdmFyIHNldFBhcm0gPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcblx0ICB2YXIgc2V0Q29sdW1uID0gTWF0aC5mbG9vcihlYXN0aW5nIC8gMTAwMDAwKTtcblx0ICB2YXIgc2V0Um93ID0gTWF0aC5mbG9vcihub3J0aGluZyAvIDEwMDAwMCkgJSAyMDtcblx0ICByZXR1cm4gZ2V0TGV0dGVyMTAwa0lEKHNldENvbHVtbiwgc2V0Um93LCBzZXRQYXJtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHaXZlbiBhIFVUTSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgTUdSUyAxMDBLIHNldCBpdCBpcyBpbi5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgQW4gVVRNIHpvbmUgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSAxMDBrIHNldCB0aGUgVVRNIHpvbmUgaXMgaW4uXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXQxMDBrU2V0Rm9yWm9uZShpKSB7XG5cdCAgdmFyIHNldFBhcm0gPSBpICUgTlVNXzEwMEtfU0VUUztcblx0ICBpZiAoc2V0UGFybSA9PT0gMCkge1xuXHQgICAgc2V0UGFybSA9IE5VTV8xMDBLX1NFVFM7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNldFBhcm07XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB0d28tbGV0dGVyIE1HUlMgMTAwayBkZXNpZ25hdG9yIGdpdmVuIGluZm9ybWF0aW9uXG5cdCAqIHRyYW5zbGF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nLCBlYXN0aW5nIGFuZCB6b25lIG51bWJlci5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiB0aGUgY29sdW1uIGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlNcblx0ICogICAgICAgIDEwMGsgc2V0IHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSBlYXN0aW5nLlxuXHQgKiAgICAgICAgVmFsdWVzIGFyZSAxLTguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByb3cgdGhlIHJvdyBpbmRleCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG5cdCAqICAgICAgICBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gbm9ydGhpbmcgdmFsdWUuIFZhbHVlc1xuXHQgKiAgICAgICAgYXJlIGZyb20gMC0xOS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcm0gdGhlIHNldCBibG9jaywgYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSUyAxMDBrIHNldFxuXHQgKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIHpvbmUuIFZhbHVlcyBhcmUgZnJvbVxuXHQgKiAgICAgICAgMS02MC5cblx0ICogQHJldHVybiB0d28gbGV0dGVyIE1HUlMgMTAwayBjb2RlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TGV0dGVyMTAwa0lEKGNvbHVtbiwgcm93LCBwYXJtKSB7XG5cdCAgLy8gY29sT3JpZ2luIGFuZCByb3dPcmlnaW4gYXJlIHRoZSBsZXR0ZXJzIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldFxuXHQgIHZhciBpbmRleCA9IHBhcm0gLSAxO1xuXHQgIHZhciBjb2xPcmlnaW4gPSBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHQgIHZhciByb3dPcmlnaW4gPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG5cdCAgLy8gY29sSW50IGFuZCByb3dJbnQgYXJlIHRoZSBsZXR0ZXJzIHRvIGJ1aWxkIHRvIHJldHVyblxuXHQgIHZhciBjb2xJbnQgPSBjb2xPcmlnaW4gKyBjb2x1bW4gLSAxO1xuXHQgIHZhciByb3dJbnQgPSByb3dPcmlnaW4gKyByb3c7XG5cdCAgdmFyIHJvbGxvdmVyID0gZmFsc2U7XG5cblx0ICBpZiAoY29sSW50ID4gWikge1xuXHQgICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuXHQgICAgcm9sbG92ZXIgPSB0cnVlO1xuXHQgIH1cblxuXHQgIGlmIChjb2xJbnQgPT09IEkgfHwgKGNvbE9yaWdpbiA8IEkgJiYgY29sSW50ID4gSSkgfHwgKChjb2xJbnQgPiBJIHx8IGNvbE9yaWdpbiA8IEkpICYmIHJvbGxvdmVyKSkge1xuXHQgICAgY29sSW50Kys7XG5cdCAgfVxuXG5cdCAgaWYgKGNvbEludCA9PT0gTyB8fCAoY29sT3JpZ2luIDwgTyAmJiBjb2xJbnQgPiBPKSB8fCAoKGNvbEludCA+IE8gfHwgY29sT3JpZ2luIDwgTykgJiYgcm9sbG92ZXIpKSB7XG5cdCAgICBjb2xJbnQrKztcblxuXHQgICAgaWYgKGNvbEludCA9PT0gSSkge1xuXHQgICAgICBjb2xJbnQrKztcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAoY29sSW50ID4gWikge1xuXHQgICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuXHQgIH1cblxuXHQgIGlmIChyb3dJbnQgPiBWKSB7XG5cdCAgICByb3dJbnQgPSByb3dJbnQgLSBWICsgQSAtIDE7XG5cdCAgICByb2xsb3ZlciA9IHRydWU7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgcm9sbG92ZXIgPSBmYWxzZTtcblx0ICB9XG5cblx0ICBpZiAoKChyb3dJbnQgPT09IEkpIHx8ICgocm93T3JpZ2luIDwgSSkgJiYgKHJvd0ludCA+IEkpKSkgfHwgKCgocm93SW50ID4gSSkgfHwgKHJvd09yaWdpbiA8IEkpKSAmJiByb2xsb3ZlcikpIHtcblx0ICAgIHJvd0ludCsrO1xuXHQgIH1cblxuXHQgIGlmICgoKHJvd0ludCA9PT0gTykgfHwgKChyb3dPcmlnaW4gPCBPKSAmJiAocm93SW50ID4gTykpKSB8fCAoKChyb3dJbnQgPiBPKSB8fCAocm93T3JpZ2luIDwgTykpICYmIHJvbGxvdmVyKSkge1xuXHQgICAgcm93SW50Kys7XG5cblx0ICAgIGlmIChyb3dJbnQgPT09IEkpIHtcblx0ICAgICAgcm93SW50Kys7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHJvd0ludCA+IFYpIHtcblx0ICAgIHJvd0ludCA9IHJvd0ludCAtIFYgKyBBIC0gMTtcblx0ICB9XG5cblx0ICB2YXIgdHdvTGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2xJbnQpICsgU3RyaW5nLmZyb21DaGFyQ29kZShyb3dJbnQpO1xuXHQgIHJldHVybiB0d29MZXR0ZXI7XG5cdH1cblxuXHQvKipcblx0ICogRGVjb2RlIHRoZSBVVE0gcGFyYW1ldGVycyBmcm9tIGEgTUdSUyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZ3JzU3RyaW5nIGFuIFVQUEVSQ0FTRSBjb29yZGluYXRlIHN0cmluZyBpcyBleHBlY3RlZC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTGV0dGVyLFxuXHQgKiAgICAgem9uZU51bWJlciBhbmQgYWNjdXJhY3kgKGluIG1ldGVycykgcHJvcGVydGllcy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShtZ3JzU3RyaW5nKSB7XG5cblx0ICBpZiAobWdyc1N0cmluZyAmJiBtZ3JzU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgdGhyb3cgKFwiTUdSU1BvaW50IGNvdmVydGluZyBmcm9tIG5vdGhpbmdcIik7XG5cdCAgfVxuXG5cdCAgdmFyIGxlbmd0aCA9IG1ncnNTdHJpbmcubGVuZ3RoO1xuXG5cdCAgdmFyIGh1bksgPSBudWxsO1xuXHQgIHZhciBzYiA9IFwiXCI7XG5cdCAgdmFyIHRlc3RDaGFyO1xuXHQgIHZhciBpID0gMDtcblxuXHQgIC8vIGdldCBab25lIG51bWJlclxuXHQgIHdoaWxlICghKC9bQS1aXS8pLnRlc3QodGVzdENoYXIgPSBtZ3JzU3RyaW5nLmNoYXJBdChpKSkpIHtcblx0ICAgIGlmIChpID49IDIpIHtcblx0ICAgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG5cdCAgICB9XG5cdCAgICBzYiArPSB0ZXN0Q2hhcjtcblx0ICAgIGkrKztcblx0ICB9XG5cblx0ICB2YXIgem9uZU51bWJlciA9IHBhcnNlSW50KHNiLCAxMCk7XG5cblx0ICBpZiAoaSA9PT0gMCB8fCBpICsgMyA+IGxlbmd0aCkge1xuXHQgICAgLy8gQSBnb29kIE1HUlMgc3RyaW5nIGhhcyB0byBiZSA0LTUgZGlnaXRzIGxvbmcsXG5cdCAgICAvLyAjI0FBQS8jQUFBIGF0IGxlYXN0LlxuXHQgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG5cdCAgfVxuXG5cdCAgdmFyIHpvbmVMZXR0ZXIgPSBtZ3JzU3RyaW5nLmNoYXJBdChpKyspO1xuXG5cdCAgLy8gU2hvdWxkIHdlIGNoZWNrIHRoZSB6b25lIGxldHRlciBoZXJlPyBXaHkgbm90LlxuXHQgIGlmICh6b25lTGV0dGVyIDw9ICdBJyB8fCB6b25lTGV0dGVyID09PSAnQicgfHwgem9uZUxldHRlciA9PT0gJ1knIHx8IHpvbmVMZXR0ZXIgPj0gJ1onIHx8IHpvbmVMZXR0ZXIgPT09ICdJJyB8fCB6b25lTGV0dGVyID09PSAnTycpIHtcblx0ICAgIHRocm93IChcIk1HUlNQb2ludCB6b25lIGxldHRlciBcIiArIHpvbmVMZXR0ZXIgKyBcIiBub3QgaGFuZGxlZDogXCIgKyBtZ3JzU3RyaW5nKTtcblx0ICB9XG5cblx0ICBodW5LID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArPSAyKTtcblxuXHQgIHZhciBzZXQgPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcblxuXHQgIHZhciBlYXN0MTAwayA9IGdldEVhc3RpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgwKSwgc2V0KTtcblx0ICB2YXIgbm9ydGgxMDBrID0gZ2V0Tm9ydGhpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgxKSwgc2V0KTtcblxuXHQgIC8vIFdlIGhhdmUgYSBidWcgd2hlcmUgdGhlIG5vcnRoaW5nIG1heSBiZSAyMDAwMDAwIHRvbyBsb3cuXG5cdCAgLy8gSG93XG5cdCAgLy8gZG8gd2Uga25vdyB3aGVuIHRvIHJvbGwgb3Zlcj9cblxuXHQgIHdoaWxlIChub3J0aDEwMGsgPCBnZXRNaW5Ob3J0aGluZyh6b25lTGV0dGVyKSkge1xuXHQgICAgbm9ydGgxMDBrICs9IDIwMDAwMDA7XG5cdCAgfVxuXG5cdCAgLy8gY2FsY3VsYXRlIHRoZSBjaGFyIGluZGV4IGZvciBlYXN0aW5nL25vcnRoaW5nIHNlcGFyYXRvclxuXHQgIHZhciByZW1haW5kZXIgPSBsZW5ndGggLSBpO1xuXG5cdCAgaWYgKHJlbWFpbmRlciAlIDIgIT09IDApIHtcblx0ICAgIHRocm93IChcIk1HUlNQb2ludCBoYXMgdG8gaGF2ZSBhbiBldmVuIG51bWJlciBcXG5vZiBkaWdpdHMgYWZ0ZXIgdGhlIHpvbmUgbGV0dGVyIGFuZCB0d28gMTAwa20gbGV0dGVycyAtIGZyb250IFxcbmhhbGYgZm9yIGVhc3RpbmcgbWV0ZXJzLCBzZWNvbmQgaGFsZiBmb3IgXFxubm9ydGhpbmcgbWV0ZXJzXCIgKyBtZ3JzU3RyaW5nKTtcblx0ICB9XG5cblx0ICB2YXIgc2VwID0gcmVtYWluZGVyIC8gMjtcblxuXHQgIHZhciBzZXBFYXN0aW5nID0gMC4wO1xuXHQgIHZhciBzZXBOb3J0aGluZyA9IDAuMDtcblx0ICB2YXIgYWNjdXJhY3lCb251cywgc2VwRWFzdGluZ1N0cmluZywgc2VwTm9ydGhpbmdTdHJpbmcsIGVhc3RpbmcsIG5vcnRoaW5nO1xuXHQgIGlmIChzZXAgPiAwKSB7XG5cdCAgICBhY2N1cmFjeUJvbnVzID0gMTAwMDAwLjAgLyBNYXRoLnBvdygxMCwgc2VwKTtcblx0ICAgIHNlcEVhc3RpbmdTdHJpbmcgPSBtZ3JzU3RyaW5nLnN1YnN0cmluZyhpLCBpICsgc2VwKTtcblx0ICAgIHNlcEVhc3RpbmcgPSBwYXJzZUZsb2F0KHNlcEVhc3RpbmdTdHJpbmcpICogYWNjdXJhY3lCb251cztcblx0ICAgIHNlcE5vcnRoaW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSArIHNlcCk7XG5cdCAgICBzZXBOb3J0aGluZyA9IHBhcnNlRmxvYXQoc2VwTm9ydGhpbmdTdHJpbmcpICogYWNjdXJhY3lCb251cztcblx0ICB9XG5cblx0ICBlYXN0aW5nID0gc2VwRWFzdGluZyArIGVhc3QxMDBrO1xuXHQgIG5vcnRoaW5nID0gc2VwTm9ydGhpbmcgKyBub3J0aDEwMGs7XG5cblx0ICByZXR1cm4ge1xuXHQgICAgZWFzdGluZzogZWFzdGluZyxcblx0ICAgIG5vcnRoaW5nOiBub3J0aGluZyxcblx0ICAgIHpvbmVMZXR0ZXI6IHpvbmVMZXR0ZXIsXG5cdCAgICB6b25lTnVtYmVyOiB6b25lTnVtYmVyLFxuXHQgICAgYWNjdXJhY3k6IGFjY3VyYWN5Qm9udXNcblx0ICB9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdpdmVuIHRoZSBmaXJzdCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDBrIHpvbmUsIGFuZCBnaXZlbiB0aGVcblx0ICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgZWFzdGluZyB2YWx1ZSB0aGF0XG5cdCAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgb3RoZXIsIHNlY29uZGFyeSBlYXN0aW5nIHZhbHVlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge2NoYXJ9IGUgVGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMMK0ayB6b25lLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlYXN0aW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRFYXN0aW5nRnJvbUNoYXIoZSwgc2V0KSB7XG5cdCAgLy8gY29sT3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcblx0ICAvLyBjb2x1bW5cblx0ICB2YXIgY3VyQ29sID0gU0VUX09SSUdJTl9DT0xVTU5fTEVUVEVSUy5jaGFyQ29kZUF0KHNldCAtIDEpO1xuXHQgIHZhciBlYXN0aW5nVmFsdWUgPSAxMDAwMDAuMDtcblx0ICB2YXIgcmV3aW5kTWFya2VyID0gZmFsc2U7XG5cblx0ICB3aGlsZSAoY3VyQ29sICE9PSBlLmNoYXJDb2RlQXQoMCkpIHtcblx0ICAgIGN1ckNvbCsrO1xuXHQgICAgaWYgKGN1ckNvbCA9PT0gSSkge1xuXHQgICAgICBjdXJDb2wrKztcblx0ICAgIH1cblx0ICAgIGlmIChjdXJDb2wgPT09IE8pIHtcblx0ICAgICAgY3VyQ29sKys7XG5cdCAgICB9XG5cdCAgICBpZiAoY3VyQ29sID4gWikge1xuXHQgICAgICBpZiAocmV3aW5kTWFya2VyKSB7XG5cdCAgICAgICAgdGhyb3cgKFwiQmFkIGNoYXJhY3RlcjogXCIgKyBlKTtcblx0ICAgICAgfVxuXHQgICAgICBjdXJDb2wgPSBBO1xuXHQgICAgICByZXdpbmRNYXJrZXIgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgZWFzdGluZ1ZhbHVlICs9IDEwMDAwMC4wO1xuXHQgIH1cblxuXHQgIHJldHVybiBlYXN0aW5nVmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogR2l2ZW4gdGhlIHNlY29uZCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDBrIHpvbmUsIGFuZCBnaXZlbiB0aGVcblx0ICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgbm9ydGhpbmcgdmFsdWUgdGhhdFxuXHQgKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgbm9ydGhpbmcgdmFsdWUuIFlvdSBoYXZlIHRvXG5cdCAqIHJlbWVtYmVyIHRoYXQgTm9ydGhpbmdzIGFyZSBkZXRlcm1pbmVkIGZyb20gdGhlIGVxdWF0b3IsIGFuZCB0aGUgdmVydGljYWxcblx0ICogY3ljbGUgb2YgbGV0dGVycyBtZWFuIGEgMjAwMDAwMCBhZGRpdGlvbmFsIG5vcnRoaW5nIG1ldGVycy4gVGhpcyBoYXBwZW5zXG5cdCAqIGFwcHJveC4gZXZlcnkgMTggZGVncmVlcyBvZiBsYXRpdHVkZS4gVGhpcyBtZXRob2QgZG9lcyAqTk9UKiBjb3VudCBhbnlcblx0ICogYWRkaXRpb25hbCBub3J0aGluZ3MuIFlvdSBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93IG1hbnkgMjAwMDAwMCBtZXRlcnMgbmVlZFxuXHQgKiB0byBiZSBhZGRlZCBmb3IgdGhlIHpvbmUgbGV0dGVyIG9mIHRoZSBNR1JTIGNvb3JkaW5hdGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Y2hhcn0gbiBTZWNvbmQgbGV0dGVyIG9mIHRoZSBNR1JTIDEwMGsgem9uZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBudW1iZXIsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGVcblx0ICogICAgIFVUTSB6b25lIG51bWJlci5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgbm9ydGhpbmcgdmFsdWUgZm9yIHRoZSBnaXZlbiBsZXR0ZXIgYW5kIHNldC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5vcnRoaW5nRnJvbUNoYXIobiwgc2V0KSB7XG5cblx0ICBpZiAobiA+ICdWJykge1xuXHQgICAgdGhyb3cgKFwiTUdSU1BvaW50IGdpdmVuIGludmFsaWQgTm9ydGhpbmcgXCIgKyBuKTtcblx0ICB9XG5cblx0ICAvLyByb3dPcmlnaW4gaXMgdGhlIGxldHRlciBhdCB0aGUgb3JpZ2luIG9mIHRoZSBzZXQgZm9yIHRoZVxuXHQgIC8vIGNvbHVtblxuXHQgIHZhciBjdXJSb3cgPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG5cdCAgdmFyIG5vcnRoaW5nVmFsdWUgPSAwLjA7XG5cdCAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG5cdCAgd2hpbGUgKGN1clJvdyAhPT0gbi5jaGFyQ29kZUF0KDApKSB7XG5cdCAgICBjdXJSb3crKztcblx0ICAgIGlmIChjdXJSb3cgPT09IEkpIHtcblx0ICAgICAgY3VyUm93Kys7XG5cdCAgICB9XG5cdCAgICBpZiAoY3VyUm93ID09PSBPKSB7XG5cdCAgICAgIGN1clJvdysrO1xuXHQgICAgfVxuXHQgICAgLy8gZml4aW5nIGEgYnVnIG1ha2luZyB3aG9sZSBhcHBsaWNhdGlvbiBoYW5nIGluIHRoaXMgbG9vcFxuXHQgICAgLy8gd2hlbiAnbicgaXMgYSB3cm9uZyBjaGFyYWN0ZXJcblx0ICAgIGlmIChjdXJSb3cgPiBWKSB7XG5cdCAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHsgLy8gbWFraW5nIHN1cmUgdGhhdCB0aGlzIGxvb3AgZW5kc1xuXHQgICAgICAgIHRocm93IChcIkJhZCBjaGFyYWN0ZXI6IFwiICsgbik7XG5cdCAgICAgIH1cblx0ICAgICAgY3VyUm93ID0gQTtcblx0ICAgICAgcmV3aW5kTWFya2VyID0gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIG5vcnRoaW5nVmFsdWUgKz0gMTAwMDAwLjA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG5vcnRoaW5nVmFsdWU7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGZ1bmN0aW9uIGdldE1pbk5vcnRoaW5nIHJldHVybnMgdGhlIG1pbmltdW0gbm9ydGhpbmcgdmFsdWUgb2YgYSBNR1JTXG5cdCAqIHpvbmUuXG5cdCAqXG5cdCAqIFBvcnRlZCBmcm9tIEdlb3RyYW5zJyBjIExhdHRpdHVkZV9CYW5kX1ZhbHVlIHN0cnVjdHVyZSB0YWJsZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtjaGFyfSB6b25lTGV0dGVyIFRoZSBNR1JTIHpvbmUgdG8gZ2V0IHRoZSBtaW4gbm9ydGhpbmcgZm9yLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNaW5Ob3J0aGluZyh6b25lTGV0dGVyKSB7XG5cdCAgdmFyIG5vcnRoaW5nO1xuXHQgIHN3aXRjaCAoem9uZUxldHRlcikge1xuXHQgIGNhc2UgJ0MnOlxuXHQgICAgbm9ydGhpbmcgPSAxMTAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdEJzpcblx0ICAgIG5vcnRoaW5nID0gMjAwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnRSc6XG5cdCAgICBub3J0aGluZyA9IDI4MDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ0YnOlxuXHQgICAgbm9ydGhpbmcgPSAzNzAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdHJzpcblx0ICAgIG5vcnRoaW5nID0gNDYwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnSCc6XG5cdCAgICBub3J0aGluZyA9IDU1MDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ0onOlxuXHQgICAgbm9ydGhpbmcgPSA2NDAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdLJzpcblx0ICAgIG5vcnRoaW5nID0gNzMwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnTCc6XG5cdCAgICBub3J0aGluZyA9IDgyMDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ00nOlxuXHQgICAgbm9ydGhpbmcgPSA5MTAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdOJzpcblx0ICAgIG5vcnRoaW5nID0gMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnUCc6XG5cdCAgICBub3J0aGluZyA9IDgwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnUSc6XG5cdCAgICBub3J0aGluZyA9IDE3MDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ1InOlxuXHQgICAgbm9ydGhpbmcgPSAyNjAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdTJzpcblx0ICAgIG5vcnRoaW5nID0gMzUwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnVCc6XG5cdCAgICBub3J0aGluZyA9IDQ0MDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ1UnOlxuXHQgICAgbm9ydGhpbmcgPSA1MzAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBjYXNlICdWJzpcblx0ICAgIG5vcnRoaW5nID0gNjIwMDAwMC4wO1xuXHQgICAgYnJlYWs7XG5cdCAgY2FzZSAnVyc6XG5cdCAgICBub3J0aGluZyA9IDcwMDAwMDAuMDtcblx0ICAgIGJyZWFrO1xuXHQgIGNhc2UgJ1gnOlxuXHQgICAgbm9ydGhpbmcgPSA3OTAwMDAwLjA7XG5cdCAgICBicmVhaztcblx0ICBkZWZhdWx0OlxuXHQgICAgbm9ydGhpbmcgPSAtMS4wO1xuXHQgIH1cblx0ICBpZiAobm9ydGhpbmcgPj0gMC4wKSB7XG5cdCAgICByZXR1cm4gbm9ydGhpbmc7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdGhyb3cgKFwiSW52YWxpZCB6b25lIGxldHRlcjogXCIgKyB6b25lTGV0dGVyKTtcblx0ICB9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFBvaW50KHgsIHksIHopIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG5cdCAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIHopO1xuXHQgIH1cblx0ICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuXHQgICAgdGhpcy54ID0geFswXTtcblx0ICAgIHRoaXMueSA9IHhbMV07XG5cdCAgICB0aGlzLnogPSB4WzJdIHx8IDAuMDtcblx0ICB9IGVsc2UgaWYodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG5cdCAgICB0aGlzLnggPSB4Lng7XG5cdCAgICB0aGlzLnkgPSB4Lnk7XG5cdCAgICB0aGlzLnogPSB4LnogfHwgMC4wO1xuXHQgIH0gZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnICYmIHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgdmFyIGNvb3JkcyA9IHguc3BsaXQoJywnKTtcblx0ICAgIHRoaXMueCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdLCAxMCk7XG5cdCAgICB0aGlzLnkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSwgMTApO1xuXHQgICAgdGhpcy56ID0gcGFyc2VGbG9hdChjb29yZHNbMl0sIDEwKSB8fCAwLjA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMueCA9IHg7XG5cdCAgICB0aGlzLnkgPSB5O1xuXHQgICAgdGhpcy56ID0geiB8fCAwLjA7XG5cdCAgfVxuXHQgIGNvbnNvbGUud2FybigncHJvajQuUG9pbnQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMywgdXNlIHByb2o0LnRvUG9pbnQnKTtcblx0fVxuXG5cdFBvaW50LmZyb21NR1JTID0gZnVuY3Rpb24obWdyc1N0cikge1xuXHQgIHJldHVybiBuZXcgUG9pbnQodG9Qb2ludCQxKG1ncnNTdHIpKTtcblx0fTtcblx0UG9pbnQucHJvdG90eXBlLnRvTUdSUyA9IGZ1bmN0aW9uKGFjY3VyYWN5KSB7XG5cdCAgcmV0dXJuIGZvcndhcmQkMShbdGhpcy54LCB0aGlzLnldLCBhY2N1cmFjeSk7XG5cdH07XG5cblx0dmFyIHZlcnNpb24gPSBcIjIuNC40XCI7XG5cblx0dmFyIEMwMCA9IDE7XG5cdHZhciBDMDIgPSAwLjI1O1xuXHR2YXIgQzA0ID0gMC4wNDY4NzU7XG5cdHZhciBDMDYgPSAwLjAxOTUzMTI1O1xuXHR2YXIgQzA4ID0gMC4wMTA2ODExNTIzNDM3NTtcblx0dmFyIEMyMiA9IDAuNzU7XG5cdHZhciBDNDQgPSAwLjQ2ODc1O1xuXHR2YXIgQzQ2ID0gMC4wMTMwMjA4MzMzMzMzMzMzMzMzMztcblx0dmFyIEM0OCA9IDAuMDA3MTIwNzY4MjI5MTY2NjY2NjY7XG5cdHZhciBDNjYgPSAwLjM2NDU4MzMzMzMzMzMzMzMzMzMzO1xuXHR2YXIgQzY4ID0gMC4wMDU2OTY2MTQ1ODMzMzMzMzMzMztcblx0dmFyIEM4OCA9IDAuMzA3NjE3MTg3NTtcblxuXHR2YXIgcGpfZW5mbiA9IGZ1bmN0aW9uKGVzKSB7XG5cdCAgdmFyIGVuID0gW107XG5cdCAgZW5bMF0gPSBDMDAgLSBlcyAqIChDMDIgKyBlcyAqIChDMDQgKyBlcyAqIChDMDYgKyBlcyAqIEMwOCkpKTtcblx0ICBlblsxXSA9IGVzICogKEMyMiAtIGVzICogKEMwNCArIGVzICogKEMwNiArIGVzICogQzA4KSkpO1xuXHQgIHZhciB0ID0gZXMgKiBlcztcblx0ICBlblsyXSA9IHQgKiAoQzQ0IC0gZXMgKiAoQzQ2ICsgZXMgKiBDNDgpKTtcblx0ICB0ICo9IGVzO1xuXHQgIGVuWzNdID0gdCAqIChDNjYgLSBlcyAqIEM2OCk7XG5cdCAgZW5bNF0gPSB0ICogZXMgKiBDODg7XG5cdCAgcmV0dXJuIGVuO1xuXHR9O1xuXG5cdHZhciBwal9tbGZuID0gZnVuY3Rpb24ocGhpLCBzcGhpLCBjcGhpLCBlbikge1xuXHQgIGNwaGkgKj0gc3BoaTtcblx0ICBzcGhpICo9IHNwaGk7XG5cdCAgcmV0dXJuIChlblswXSAqIHBoaSAtIGNwaGkgKiAoZW5bMV0gKyBzcGhpICogKGVuWzJdICsgc3BoaSAqIChlblszXSArIHNwaGkgKiBlbls0XSkpKSk7XG5cdH07XG5cblx0dmFyIE1BWF9JVEVSID0gMjA7XG5cblx0dmFyIHBqX2ludl9tbGZuID0gZnVuY3Rpb24oYXJnLCBlcywgZW4pIHtcblx0ICB2YXIgayA9IDEgLyAoMSAtIGVzKTtcblx0ICB2YXIgcGhpID0gYXJnO1xuXHQgIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7IC8qIHJhcmVseSBnb2VzIG92ZXIgMiBpdGVyYXRpb25zICovXG5cdCAgICB2YXIgcyA9IE1hdGguc2luKHBoaSk7XG5cdCAgICB2YXIgdCA9IDEgLSBlcyAqIHMgKiBzO1xuXHQgICAgLy90ID0gdGhpcy5wal9tbGZuKHBoaSwgcywgTWF0aC5jb3MocGhpKSwgZW4pIC0gYXJnO1xuXHQgICAgLy9waGkgLT0gdCAqICh0ICogTWF0aC5zcXJ0KHQpKSAqIGs7XG5cdCAgICB0ID0gKHBqX21sZm4ocGhpLCBzLCBNYXRoLmNvcyhwaGkpLCBlbikgLSBhcmcpICogKHQgKiBNYXRoLnNxcnQodCkpICogaztcblx0ICAgIHBoaSAtPSB0O1xuXHQgICAgaWYgKE1hdGguYWJzKHQpIDwgRVBTTE4pIHtcblx0ICAgICAgcmV0dXJuIHBoaTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8uLnJlcG9ydEVycm9yKFwiY2Fzczpwal9pbnZfbWxmbjogQ29udmVyZ2VuY2UgZXJyb3JcIik7XG5cdCAgcmV0dXJuIHBoaTtcblx0fTtcblxuXHQvLyBIZWF2aWx5IGJhc2VkIG9uIHRoaXMgdG1lcmMgcHJvamVjdGlvbiBpbXBsZW1lbnRhdGlvblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbWJsb2NoL21hcHNoYXBlci1wcm9qL2Jsb2IvbWFzdGVyL3NyYy9wcm9qZWN0aW9ucy90bWVyYy5qc1xuXG5cdGZ1bmN0aW9uIGluaXQkMigpIHtcblx0ICB0aGlzLngwID0gdGhpcy54MCAhPT0gdW5kZWZpbmVkID8gdGhpcy54MCA6IDA7XG5cdCAgdGhpcy55MCA9IHRoaXMueTAgIT09IHVuZGVmaW5lZCA/IHRoaXMueTAgOiAwO1xuXHQgIHRoaXMubG9uZzAgPSB0aGlzLmxvbmcwICE9PSB1bmRlZmluZWQgPyB0aGlzLmxvbmcwIDogMDtcblx0ICB0aGlzLmxhdDAgPSB0aGlzLmxhdDAgIT09IHVuZGVmaW5lZCA/IHRoaXMubGF0MCA6IDA7XG5cblx0ICBpZiAodGhpcy5lcykge1xuXHQgICAgdGhpcy5lbiA9IHBqX2VuZm4odGhpcy5lcyk7XG5cdCAgICB0aGlzLm1sMCA9IHBqX21sZm4odGhpcy5sYXQwLCBNYXRoLnNpbih0aGlzLmxhdDApLCBNYXRoLmNvcyh0aGlzLmxhdDApLCB0aGlzLmVuKTtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICAgIFRyYW5zdmVyc2UgTWVyY2F0b3IgRm9yd2FyZCAgLSBsb25nL2xhdCB0byB4L3lcblx0ICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcblx0ICAqL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDIocCkge1xuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblxuXHQgIHZhciBkZWx0YV9sb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciBjb247XG5cdCAgdmFyIHgsIHk7XG5cdCAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihsYXQpO1xuXHQgIHZhciBjb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuXHQgIGlmICghdGhpcy5lcykge1xuXHQgICAgdmFyIGIgPSBjb3NfcGhpICogTWF0aC5zaW4oZGVsdGFfbG9uKTtcblxuXHQgICAgaWYgKChNYXRoLmFicyhNYXRoLmFicyhiKSAtIDEpKSA8IEVQU0xOKSB7XG5cdCAgICAgIHJldHVybiAoOTMpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHggPSAwLjUgKiB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2coKDEgKyBiKSAvICgxIC0gYikpICsgdGhpcy54MDtcblx0ICAgICAgeSA9IGNvc19waGkgKiBNYXRoLmNvcyhkZWx0YV9sb24pIC8gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyhiLCAyKSk7XG5cdCAgICAgIGIgPSBNYXRoLmFicyh5KTtcblxuXHQgICAgICBpZiAoYiA+PSAxKSB7XG5cdCAgICAgICAgaWYgKChiIC0gMSkgPiBFUFNMTikge1xuXHQgICAgICAgICAgcmV0dXJuICg5Myk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgeSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIHkgPSBNYXRoLmFjb3MoeSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAobGF0IDwgMCkge1xuXHQgICAgICAgIHkgPSAteTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHkgPSB0aGlzLmEgKiB0aGlzLmswICogKHkgLSB0aGlzLmxhdDApICsgdGhpcy55MDtcblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB2YXIgYWwgPSBjb3NfcGhpICogZGVsdGFfbG9uO1xuXHQgICAgdmFyIGFscyA9IE1hdGgucG93KGFsLCAyKTtcblx0ICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcblx0ICAgIHZhciBjcyA9IE1hdGgucG93KGMsIDIpO1xuXHQgICAgdmFyIHRxID0gTWF0aC5hYnMoY29zX3BoaSkgPiBFUFNMTiA/IE1hdGgudGFuKGxhdCkgOiAwO1xuXHQgICAgdmFyIHQgPSBNYXRoLnBvdyh0cSwgMik7XG5cdCAgICB2YXIgdHMgPSBNYXRoLnBvdyh0LCAyKTtcblx0ICAgIGNvbiA9IDEgLSB0aGlzLmVzICogTWF0aC5wb3coc2luX3BoaSwgMik7XG5cdCAgICBhbCA9IGFsIC8gTWF0aC5zcXJ0KGNvbik7XG5cdCAgICB2YXIgbWwgPSBwal9tbGZuKGxhdCwgc2luX3BoaSwgY29zX3BoaSwgdGhpcy5lbik7XG5cblx0ICAgIHggPSB0aGlzLmEgKiAodGhpcy5rMCAqIGFsICogKDEgK1xuXHQgICAgICBhbHMgLyA2ICogKDEgLSB0ICsgYyArXG5cdCAgICAgIGFscyAvIDIwICogKDUgLSAxOCAqIHQgKyB0cyArIDE0ICogYyAtIDU4ICogdCAqIGMgK1xuXHQgICAgICBhbHMgLyA0MiAqICg2MSArIDE3OSAqIHRzIC0gdHMgKiB0IC0gNDc5ICogdCkpKSkpICtcblx0ICAgICAgdGhpcy54MDtcblxuXHQgICAgeSA9IHRoaXMuYSAqICh0aGlzLmswICogKG1sIC0gdGhpcy5tbDAgK1xuXHQgICAgICBzaW5fcGhpICogZGVsdGFfbG9uICogYWwgLyAyICogKDEgK1xuXHQgICAgICBhbHMgLyAxMiAqICg1IC0gdCArIDkgKiBjICsgNCAqIGNzICtcblx0ICAgICAgYWxzIC8gMzAgKiAoNjEgKyB0cyAtIDU4ICogdCArIDI3MCAqIGMgLSAzMzAgKiB0ICogYyArXG5cdCAgICAgIGFscyAvIDU2ICogKDEzODUgKyA1NDMgKiB0cyAtIHRzICogdCAtIDMxMTEgKiB0KSkpKSkpICtcblx0ICAgICAgdGhpcy55MDtcblx0ICB9XG5cblx0ICBwLnggPSB4O1xuXHQgIHAueSA9IHk7XG5cblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qKlxuXHQgICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcblx0ICAqL1xuXHRmdW5jdGlvbiBpbnZlcnNlJDIocCkge1xuXHQgIHZhciBjb24sIHBoaTtcblx0ICB2YXIgbGF0LCBsb247XG5cdCAgdmFyIHggPSAocC54IC0gdGhpcy54MCkgKiAoMSAvIHRoaXMuYSk7XG5cdCAgdmFyIHkgPSAocC55IC0gdGhpcy55MCkgKiAoMSAvIHRoaXMuYSk7XG5cblx0ICBpZiAoIXRoaXMuZXMpIHtcblx0ICAgIHZhciBmID0gTWF0aC5leHAoeCAvIHRoaXMuazApO1xuXHQgICAgdmFyIGcgPSAwLjUgKiAoZiAtIDEgLyBmKTtcblx0ICAgIHZhciB0ZW1wID0gdGhpcy5sYXQwICsgeSAvIHRoaXMuazA7XG5cdCAgICB2YXIgaCA9IE1hdGguY29zKHRlbXApO1xuXHQgICAgY29uID0gTWF0aC5zcXJ0KCgxIC0gTWF0aC5wb3coaCwgMikpIC8gKDEgKyBNYXRoLnBvdyhnLCAyKSkpO1xuXHQgICAgbGF0ID0gTWF0aC5hc2luKGNvbik7XG5cblx0ICAgIGlmICh5IDwgMCkge1xuXHQgICAgICBsYXQgPSAtbGF0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoKGcgPT09IDApICYmIChoID09PSAwKSkge1xuXHQgICAgICBsb24gPSAwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGxvbiA9IGFkanVzdF9sb24oTWF0aC5hdGFuMihnLCBoKSArIHRoaXMubG9uZzApO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHsgLy8gZWxsaXBzb2lkYWwgZm9ybVxuXHQgICAgY29uID0gdGhpcy5tbDAgKyB5IC8gdGhpcy5rMDtcblx0ICAgIHBoaSA9IHBqX2ludl9tbGZuKGNvbiwgdGhpcy5lcywgdGhpcy5lbik7XG5cblx0ICAgIGlmIChNYXRoLmFicyhwaGkpIDwgSEFMRl9QSSkge1xuXHQgICAgICB2YXIgc2luX3BoaSA9IE1hdGguc2luKHBoaSk7XG5cdCAgICAgIHZhciBjb3NfcGhpID0gTWF0aC5jb3MocGhpKTtcblx0ICAgICAgdmFyIHRhbl9waGkgPSBNYXRoLmFicyhjb3NfcGhpKSA+IEVQU0xOID8gTWF0aC50YW4ocGhpKSA6IDA7XG5cdCAgICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcblx0ICAgICAgdmFyIGNzID0gTWF0aC5wb3coYywgMik7XG5cdCAgICAgIHZhciB0ID0gTWF0aC5wb3codGFuX3BoaSwgMik7XG5cdCAgICAgIHZhciB0cyA9IE1hdGgucG93KHQsIDIpO1xuXHQgICAgICBjb24gPSAxIC0gdGhpcy5lcyAqIE1hdGgucG93KHNpbl9waGksIDIpO1xuXHQgICAgICB2YXIgZCA9IHggKiBNYXRoLnNxcnQoY29uKSAvIHRoaXMuazA7XG5cdCAgICAgIHZhciBkcyA9IE1hdGgucG93KGQsIDIpO1xuXHQgICAgICBjb24gPSBjb24gKiB0YW5fcGhpO1xuXG5cdCAgICAgIGxhdCA9IHBoaSAtIChjb24gKiBkcyAvICgxIC0gdGhpcy5lcykpICogMC41ICogKDEgLVxuXHQgICAgICAgIGRzIC8gMTIgKiAoNSArIDMgKiB0IC0gOSAqIGMgKiB0ICsgYyAtIDQgKiBjcyAtXG5cdCAgICAgICAgZHMgLyAzMCAqICg2MSArIDkwICogdCAtIDI1MiAqIGMgKiB0ICsgNDUgKiB0cyArIDQ2ICogYyAtXG5cdCAgICAgICAgZHMgLyA1NiAqICgxMzg1ICsgMzYzMyAqIHQgKyA0MDk1ICogdHMgKyAxNTc0ICogdHMgKiB0KSkpKTtcblxuXHQgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoZCAqICgxIC1cblx0ICAgICAgICBkcyAvIDYgKiAoMSArIDIgKiB0ICsgYyAtXG5cdCAgICAgICAgZHMgLyAyMCAqICg1ICsgMjggKiB0ICsgMjQgKiB0cyArIDggKiBjICogdCArIDYgKiBjIC1cblx0ICAgICAgICBkcyAvIDQyICogKDYxICsgNjYyICogdCArIDEzMjAgKiB0cyArIDcyMCAqIHRzICogdCkpKSkgLyBjb3NfcGhpKSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgbGF0ID0gSEFMRl9QSSAqIHNpZ24oeSk7XG5cdCAgICAgIGxvbiA9IDA7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblxuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDMgPSBbXCJUcmFuc3ZlcnNlX01lcmNhdG9yXCIsIFwiVHJhbnN2ZXJzZSBNZXJjYXRvclwiLCBcInRtZXJjXCJdO1xuXHR2YXIgdG1lcmMgPSB7XG5cdCAgaW5pdDogaW5pdCQyLFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMixcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDIsXG5cdCAgbmFtZXM6IG5hbWVzJDNcblx0fTtcblxuXHR2YXIgc2luaCA9IGZ1bmN0aW9uKHgpIHtcblx0ICB2YXIgciA9IE1hdGguZXhwKHgpO1xuXHQgIHIgPSAociAtIDEgLyByKSAvIDI7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0dmFyIGh5cG90ID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgIHggPSBNYXRoLmFicyh4KTtcblx0ICB5ID0gTWF0aC5hYnMoeSk7XG5cdCAgdmFyIGEgPSBNYXRoLm1heCh4LCB5KTtcblx0ICB2YXIgYiA9IE1hdGgubWluKHgsIHkpIC8gKGEgPyBhIDogMSk7XG5cblx0ICByZXR1cm4gYSAqIE1hdGguc3FydCgxICsgTWF0aC5wb3coYiwgMikpO1xuXHR9O1xuXG5cdHZhciBsb2cxcHkgPSBmdW5jdGlvbih4KSB7XG5cdCAgdmFyIHkgPSAxICsgeDtcblx0ICB2YXIgeiA9IHkgLSAxO1xuXG5cdCAgcmV0dXJuIHogPT09IDAgPyB4IDogeCAqIE1hdGgubG9nKHkpIC8gejtcblx0fTtcblxuXHR2YXIgYXNpbmh5ID0gZnVuY3Rpb24oeCkge1xuXHQgIHZhciB5ID0gTWF0aC5hYnMoeCk7XG5cdCAgeSA9IGxvZzFweSh5ICogKDEgKyB5IC8gKGh5cG90KDEsIHkpICsgMSkpKTtcblxuXHQgIHJldHVybiB4IDwgMCA/IC15IDogeTtcblx0fTtcblxuXHR2YXIgZ2F0ZyA9IGZ1bmN0aW9uKHBwLCBCKSB7XG5cdCAgdmFyIGNvc18yQiA9IDIgKiBNYXRoLmNvcygyICogQik7XG5cdCAgdmFyIGkgPSBwcC5sZW5ndGggLSAxO1xuXHQgIHZhciBoMSA9IHBwW2ldO1xuXHQgIHZhciBoMiA9IDA7XG5cdCAgdmFyIGg7XG5cblx0ICB3aGlsZSAoLS1pID49IDApIHtcblx0ICAgIGggPSAtaDIgKyBjb3NfMkIgKiBoMSArIHBwW2ldO1xuXHQgICAgaDIgPSBoMTtcblx0ICAgIGgxID0gaDtcblx0ICB9XG5cblx0ICByZXR1cm4gKEIgKyBoICogTWF0aC5zaW4oMiAqIEIpKTtcblx0fTtcblxuXHR2YXIgY2xlbnMgPSBmdW5jdGlvbihwcCwgYXJnX3IpIHtcblx0ICB2YXIgciA9IDIgKiBNYXRoLmNvcyhhcmdfcik7XG5cdCAgdmFyIGkgPSBwcC5sZW5ndGggLSAxO1xuXHQgIHZhciBocjEgPSBwcFtpXTtcblx0ICB2YXIgaHIyID0gMDtcblx0ICB2YXIgaHI7XG5cblx0ICB3aGlsZSAoLS1pID49IDApIHtcblx0ICAgIGhyID0gLWhyMiArIHIgKiBocjEgKyBwcFtpXTtcblx0ICAgIGhyMiA9IGhyMTtcblx0ICAgIGhyMSA9IGhyO1xuXHQgIH1cblxuXHQgIHJldHVybiBNYXRoLnNpbihhcmdfcikgKiBocjtcblx0fTtcblxuXHR2YXIgY29zaCA9IGZ1bmN0aW9uKHgpIHtcblx0ICB2YXIgciA9IE1hdGguZXhwKHgpO1xuXHQgIHIgPSAociArIDEgLyByKSAvIDI7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0dmFyIGNsZW5zX2NtcGx4ID0gZnVuY3Rpb24ocHAsIGFyZ19yLCBhcmdfaSkge1xuXHQgIHZhciBzaW5fYXJnX3IgPSBNYXRoLnNpbihhcmdfcik7XG5cdCAgdmFyIGNvc19hcmdfciA9IE1hdGguY29zKGFyZ19yKTtcblx0ICB2YXIgc2luaF9hcmdfaSA9IHNpbmgoYXJnX2kpO1xuXHQgIHZhciBjb3NoX2FyZ19pID0gY29zaChhcmdfaSk7XG5cdCAgdmFyIHIgPSAyICogY29zX2FyZ19yICogY29zaF9hcmdfaTtcblx0ICB2YXIgaSA9IC0yICogc2luX2FyZ19yICogc2luaF9hcmdfaTtcblx0ICB2YXIgaiA9IHBwLmxlbmd0aCAtIDE7XG5cdCAgdmFyIGhyID0gcHBbal07XG5cdCAgdmFyIGhpMSA9IDA7XG5cdCAgdmFyIGhyMSA9IDA7XG5cdCAgdmFyIGhpID0gMDtcblx0ICB2YXIgaHIyO1xuXHQgIHZhciBoaTI7XG5cblx0ICB3aGlsZSAoLS1qID49IDApIHtcblx0ICAgIGhyMiA9IGhyMTtcblx0ICAgIGhpMiA9IGhpMTtcblx0ICAgIGhyMSA9IGhyO1xuXHQgICAgaGkxID0gaGk7XG5cdCAgICBociA9IC1ocjIgKyByICogaHIxIC0gaSAqIGhpMSArIHBwW2pdO1xuXHQgICAgaGkgPSAtaGkyICsgaSAqIGhyMSArIHIgKiBoaTE7XG5cdCAgfVxuXG5cdCAgciA9IHNpbl9hcmdfciAqIGNvc2hfYXJnX2k7XG5cdCAgaSA9IGNvc19hcmdfciAqIHNpbmhfYXJnX2k7XG5cblx0ICByZXR1cm4gW3IgKiBociAtIGkgKiBoaSwgciAqIGhpICsgaSAqIGhyXTtcblx0fTtcblxuXHQvLyBIZWF2aWx5IGJhc2VkIG9uIHRoaXMgZXRtZXJjIHByb2plY3Rpb24gaW1wbGVtZW50YXRpb25cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21ibG9jaC9tYXBzaGFwZXItcHJvai9ibG9iL21hc3Rlci9zcmMvcHJvamVjdGlvbnMvZXRtZXJjLmpzXG5cblx0ZnVuY3Rpb24gaW5pdCQzKCkge1xuXHQgIGlmICh0aGlzLmVzID09PSB1bmRlZmluZWQgfHwgdGhpcy5lcyA8PSAwKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBlbGxpcHRpY2FsIHVzYWdlJyk7XG5cdCAgfVxuXG5cdCAgdGhpcy54MCA9IHRoaXMueDAgIT09IHVuZGVmaW5lZCA/IHRoaXMueDAgOiAwO1xuXHQgIHRoaXMueTAgPSB0aGlzLnkwICE9PSB1bmRlZmluZWQgPyB0aGlzLnkwIDogMDtcblx0ICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCAhPT0gdW5kZWZpbmVkID8gdGhpcy5sb25nMCA6IDA7XG5cdCAgdGhpcy5sYXQwID0gdGhpcy5sYXQwICE9PSB1bmRlZmluZWQgPyB0aGlzLmxhdDAgOiAwO1xuXG5cdCAgdGhpcy5jZ2IgPSBbXTtcblx0ICB0aGlzLmNiZyA9IFtdO1xuXHQgIHRoaXMudXRnID0gW107XG5cdCAgdGhpcy5ndHUgPSBbXTtcblxuXHQgIHZhciBmID0gdGhpcy5lcyAvICgxICsgTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSk7XG5cdCAgdmFyIG4gPSBmIC8gKDIgLSBmKTtcblx0ICB2YXIgbnAgPSBuO1xuXG5cdCAgdGhpcy5jZ2JbMF0gPSBuICogKDIgKyBuICogKC0yIC8gMyArIG4gKiAoLTIgKyBuICogKDExNiAvIDQ1ICsgbiAqICgyNiAvIDQ1ICsgbiAqICgtMjg1NCAvIDY3NSApKSkpKSk7XG5cdCAgdGhpcy5jYmdbMF0gPSBuICogKC0yICsgbiAqICggMiAvIDMgKyBuICogKCA0IC8gMyArIG4gKiAoLTgyIC8gNDUgKyBuICogKDMyIC8gNDUgKyBuICogKDQ2NDIgLyA0NzI1KSkpKSkpO1xuXG5cdCAgbnAgPSBucCAqIG47XG5cdCAgdGhpcy5jZ2JbMV0gPSBucCAqICg3IC8gMyArIG4gKiAoLTggLyA1ICsgbiAqICgtMjI3IC8gNDUgKyBuICogKDI3MDQgLyAzMTUgKyBuICogKDIzMjMgLyA5NDUpKSkpKTtcblx0ICB0aGlzLmNiZ1sxXSA9IG5wICogKDUgLyAzICsgbiAqICgtMTYgLyAxNSArIG4gKiAoIC0xMyAvIDkgKyBuICogKDkwNCAvIDMxNSArIG4gKiAoLTE1MjIgLyA5NDUpKSkpKTtcblxuXHQgIG5wID0gbnAgKiBuO1xuXHQgIHRoaXMuY2diWzJdID0gbnAgKiAoNTYgLyAxNSArIG4gKiAoLTEzNiAvIDM1ICsgbiAqICgtMTI2MiAvIDEwNSArIG4gKiAoNzM4MTQgLyAyODM1KSkpKTtcblx0ICB0aGlzLmNiZ1syXSA9IG5wICogKC0yNiAvIDE1ICsgbiAqICgzNCAvIDIxICsgbiAqICg4IC8gNSArIG4gKiAoLTEyNjg2IC8gMjgzNSkpKSk7XG5cblx0ICBucCA9IG5wICogbjtcblx0ICB0aGlzLmNnYlszXSA9IG5wICogKDQyNzkgLyA2MzAgKyBuICogKC0zMzIgLyAzNSArIG4gKiAoLTM5OTU3MiAvIDE0MTc1KSkpO1xuXHQgIHRoaXMuY2JnWzNdID0gbnAgKiAoMTIzNyAvIDYzMCArIG4gKiAoLTEyIC8gNSArIG4gKiAoIC0yNDgzMiAvIDE0MTc1KSkpO1xuXG5cdCAgbnAgPSBucCAqIG47XG5cdCAgdGhpcy5jZ2JbNF0gPSBucCAqICg0MTc0IC8gMzE1ICsgbiAqICgtMTQ0ODM4IC8gNjIzNykpO1xuXHQgIHRoaXMuY2JnWzRdID0gbnAgKiAoLTczNCAvIDMxNSArIG4gKiAoMTA5NTk4IC8gMzExODUpKTtcblxuXHQgIG5wID0gbnAgKiBuO1xuXHQgIHRoaXMuY2diWzVdID0gbnAgKiAoNjAxNjc2IC8gMjIyNzUpO1xuXHQgIHRoaXMuY2JnWzVdID0gbnAgKiAoNDQ0MzM3IC8gMTU1OTI1KTtcblxuXHQgIG5wID0gTWF0aC5wb3cobiwgMik7XG5cdCAgdGhpcy5RbiA9IHRoaXMuazAgLyAoMSArIG4pICogKDEgKyBucCAqICgxIC8gNCArIG5wICogKDEgLyA2NCArIG5wIC8gMjU2KSkpO1xuXG5cdCAgdGhpcy51dGdbMF0gPSBuICogKC0wLjUgKyBuICogKCAyIC8gMyArIG4gKiAoLTM3IC8gOTYgKyBuICogKCAxIC8gMzYwICsgbiAqICg4MSAvIDUxMiArIG4gKiAoLTk2MTk5IC8gNjA0ODAwKSkpKSkpO1xuXHQgIHRoaXMuZ3R1WzBdID0gbiAqICgwLjUgKyBuICogKC0yIC8gMyArIG4gKiAoNSAvIDE2ICsgbiAqICg0MSAvIDE4MCArIG4gKiAoLTEyNyAvIDI4OCArIG4gKiAoNzg5MSAvIDM3ODAwKSkpKSkpO1xuXG5cdCAgdGhpcy51dGdbMV0gPSBucCAqICgtMSAvIDQ4ICsgbiAqICgtMSAvIDE1ICsgbiAqICg0MzcgLyAxNDQwICsgbiAqICgtNDYgLyAxMDUgKyBuICogKDExMTg3MTEgLyAzODcwNzIwKSkpKSk7XG5cdCAgdGhpcy5ndHVbMV0gPSBucCAqICgxMyAvIDQ4ICsgbiAqICgtMyAvIDUgKyBuICogKDU1NyAvIDE0NDAgKyBuICogKDI4MSAvIDYzMCArIG4gKiAoLTE5ODM0MzMgLyAxOTM1MzYwKSkpKSk7XG5cblx0ICBucCA9IG5wICogbjtcblx0ICB0aGlzLnV0Z1syXSA9IG5wICogKC0xNyAvIDQ4MCArIG4gKiAoMzcgLyA4NDAgKyBuICogKDIwOSAvIDQ0ODAgKyBuICogKC01NTY5IC8gOTA3MjAgKSkpKTtcblx0ICB0aGlzLmd0dVsyXSA9IG5wICogKDYxIC8gMjQwICsgbiAqICgtMTAzIC8gMTQwICsgbiAqICgxNTA2MSAvIDI2ODgwICsgbiAqICgxNjc2MDMgLyAxODE0NDApKSkpO1xuXG5cdCAgbnAgPSBucCAqIG47XG5cdCAgdGhpcy51dGdbM10gPSBucCAqICgtNDM5NyAvIDE2MTI4MCArIG4gKiAoMTEgLyA1MDQgKyBuICogKDgzMDI1MSAvIDcyNTc2MDApKSk7XG5cdCAgdGhpcy5ndHVbM10gPSBucCAqICg0OTU2MSAvIDE2MTI4MCArIG4gKiAoLTE3OSAvIDE2OCArIG4gKiAoNjYwMTY2MSAvIDcyNTc2MDApKSk7XG5cblx0ICBucCA9IG5wICogbjtcblx0ICB0aGlzLnV0Z1s0XSA9IG5wICogKC00NTgzIC8gMTYxMjgwICsgbiAqICgxMDg4NDcgLyAzOTkxNjgwKSk7XG5cdCAgdGhpcy5ndHVbNF0gPSBucCAqICgzNDcyOSAvIDgwNjQwICsgbiAqICgtMzQxODg4OSAvIDE5OTU4NDApKTtcblxuXHQgIG5wID0gbnAgKiBuO1xuXHQgIHRoaXMudXRnWzVdID0gbnAgKiAoLTIwNjQ4NjkzIC8gNjM4NjY4ODAwKTtcblx0ICB0aGlzLmd0dVs1XSA9IG5wICogKDIxMjM3ODk0MSAvIDMxOTMzNDQwMCk7XG5cblx0ICB2YXIgWiA9IGdhdGcodGhpcy5jYmcsIHRoaXMubGF0MCk7XG5cdCAgdGhpcy5aYiA9IC10aGlzLlFuICogKFogKyBjbGVucyh0aGlzLmd0dSwgMiAqIFopKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcndhcmQkMyhwKSB7XG5cdCAgdmFyIENlID0gYWRqdXN0X2xvbihwLnggLSB0aGlzLmxvbmcwKTtcblx0ICB2YXIgQ24gPSBwLnk7XG5cblx0ICBDbiA9IGdhdGcodGhpcy5jYmcsIENuKTtcblx0ICB2YXIgc2luX0NuID0gTWF0aC5zaW4oQ24pO1xuXHQgIHZhciBjb3NfQ24gPSBNYXRoLmNvcyhDbik7XG5cdCAgdmFyIHNpbl9DZSA9IE1hdGguc2luKENlKTtcblx0ICB2YXIgY29zX0NlID0gTWF0aC5jb3MoQ2UpO1xuXG5cdCAgQ24gPSBNYXRoLmF0YW4yKHNpbl9DbiwgY29zX0NlICogY29zX0NuKTtcblx0ICBDZSA9IE1hdGguYXRhbjIoc2luX0NlICogY29zX0NuLCBoeXBvdChzaW5fQ24sIGNvc19DbiAqIGNvc19DZSkpO1xuXHQgIENlID0gYXNpbmh5KE1hdGgudGFuKENlKSk7XG5cblx0ICB2YXIgdG1wID0gY2xlbnNfY21wbHgodGhpcy5ndHUsIDIgKiBDbiwgMiAqIENlKTtcblxuXHQgIENuID0gQ24gKyB0bXBbMF07XG5cdCAgQ2UgPSBDZSArIHRtcFsxXTtcblxuXHQgIHZhciB4O1xuXHQgIHZhciB5O1xuXG5cdCAgaWYgKE1hdGguYWJzKENlKSA8PSAyLjYyMzM5NTE2Mjc3OCkge1xuXHQgICAgeCA9IHRoaXMuYSAqICh0aGlzLlFuICogQ2UpICsgdGhpcy54MDtcblx0ICAgIHkgPSB0aGlzLmEgKiAodGhpcy5RbiAqIENuICsgdGhpcy5aYikgKyB0aGlzLnkwO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHggPSBJbmZpbml0eTtcblx0ICAgIHkgPSBJbmZpbml0eTtcblx0ICB9XG5cblx0ICBwLnggPSB4O1xuXHQgIHAueSA9IHk7XG5cblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmVyc2UkMyhwKSB7XG5cdCAgdmFyIENlID0gKHAueCAtIHRoaXMueDApICogKDEgLyB0aGlzLmEpO1xuXHQgIHZhciBDbiA9IChwLnkgLSB0aGlzLnkwKSAqICgxIC8gdGhpcy5hKTtcblxuXHQgIENuID0gKENuIC0gdGhpcy5aYikgLyB0aGlzLlFuO1xuXHQgIENlID0gQ2UgLyB0aGlzLlFuO1xuXG5cdCAgdmFyIGxvbjtcblx0ICB2YXIgbGF0O1xuXG5cdCAgaWYgKE1hdGguYWJzKENlKSA8PSAyLjYyMzM5NTE2Mjc3OCkge1xuXHQgICAgdmFyIHRtcCA9IGNsZW5zX2NtcGx4KHRoaXMudXRnLCAyICogQ24sIDIgKiBDZSk7XG5cblx0ICAgIENuID0gQ24gKyB0bXBbMF07XG5cdCAgICBDZSA9IENlICsgdG1wWzFdO1xuXHQgICAgQ2UgPSBNYXRoLmF0YW4oc2luaChDZSkpO1xuXG5cdCAgICB2YXIgc2luX0NuID0gTWF0aC5zaW4oQ24pO1xuXHQgICAgdmFyIGNvc19DbiA9IE1hdGguY29zKENuKTtcblx0ICAgIHZhciBzaW5fQ2UgPSBNYXRoLnNpbihDZSk7XG5cdCAgICB2YXIgY29zX0NlID0gTWF0aC5jb3MoQ2UpO1xuXG5cdCAgICBDbiA9IE1hdGguYXRhbjIoc2luX0NuICogY29zX0NlLCBoeXBvdChzaW5fQ2UsIGNvc19DZSAqIGNvc19DbikpO1xuXHQgICAgQ2UgPSBNYXRoLmF0YW4yKHNpbl9DZSwgY29zX0NlICogY29zX0NuKTtcblxuXHQgICAgbG9uID0gYWRqdXN0X2xvbihDZSArIHRoaXMubG9uZzApO1xuXHQgICAgbGF0ID0gZ2F0Zyh0aGlzLmNnYiwgQ24pO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGxvbiA9IEluZmluaXR5O1xuXHQgICAgbGF0ID0gSW5maW5pdHk7XG5cdCAgfVxuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblxuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDQgPSBbXCJFeHRlbmRlZF9UcmFuc3ZlcnNlX01lcmNhdG9yXCIsIFwiRXh0ZW5kZWQgVHJhbnN2ZXJzZSBNZXJjYXRvclwiLCBcImV0bWVyY1wiXTtcblx0dmFyIGV0bWVyYyA9IHtcblx0ICBpbml0OiBpbml0JDMsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCQzLFxuXHQgIGludmVyc2U6IGludmVyc2UkMyxcblx0ICBuYW1lczogbmFtZXMkNFxuXHR9O1xuXG5cdHZhciBhZGp1c3Rfem9uZSA9IGZ1bmN0aW9uKHpvbmUsIGxvbikge1xuXHQgIGlmICh6b25lID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHpvbmUgPSBNYXRoLmZsb29yKChhZGp1c3RfbG9uKGxvbikgKyBNYXRoLlBJKSAqIDMwIC8gTWF0aC5QSSkgKyAxO1xuXG5cdCAgICBpZiAoem9uZSA8IDApIHtcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9IGVsc2UgaWYgKHpvbmUgPiA2MCkge1xuXHQgICAgICByZXR1cm4gNjA7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB6b25lO1xuXHR9O1xuXG5cdHZhciBkZXBlbmRzT24gPSAnZXRtZXJjJztcblx0ZnVuY3Rpb24gaW5pdCQ0KCkge1xuXHQgIHZhciB6b25lID0gYWRqdXN0X3pvbmUodGhpcy56b25lLCB0aGlzLmxvbmcwKTtcblx0ICBpZiAoem9uZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdXRtIHpvbmUnKTtcblx0ICB9XG5cdCAgdGhpcy5sYXQwID0gMDtcblx0ICB0aGlzLmxvbmcwID0gICgoNiAqIE1hdGguYWJzKHpvbmUpKSAtIDE4MykgKiBEMlI7XG5cdCAgdGhpcy54MCA9IDUwMDAwMDtcblx0ICB0aGlzLnkwID0gdGhpcy51dG1Tb3V0aCA/IDEwMDAwMDAwIDogMDtcblx0ICB0aGlzLmswID0gMC45OTk2O1xuXG5cdCAgZXRtZXJjLmluaXQuYXBwbHkodGhpcyk7XG5cdCAgdGhpcy5mb3J3YXJkID0gZXRtZXJjLmZvcndhcmQ7XG5cdCAgdGhpcy5pbnZlcnNlID0gZXRtZXJjLmludmVyc2U7XG5cdH1cblxuXHR2YXIgbmFtZXMkNSA9IFtcIlVuaXZlcnNhbCBUcmFuc3ZlcnNlIE1lcmNhdG9yIFN5c3RlbVwiLCBcInV0bVwiXTtcblx0dmFyIHV0bSA9IHtcblx0ICBpbml0OiBpbml0JDQsXG5cdCAgbmFtZXM6IG5hbWVzJDUsXG5cdCAgZGVwZW5kc09uOiBkZXBlbmRzT25cblx0fTtcblxuXHR2YXIgc3JhdCA9IGZ1bmN0aW9uKGVzaW5wLCBleHApIHtcblx0ICByZXR1cm4gKE1hdGgucG93KCgxIC0gZXNpbnApIC8gKDEgKyBlc2lucCksIGV4cCkpO1xuXHR9O1xuXG5cdHZhciBNQVhfSVRFUiQxID0gMjA7XG5cdGZ1bmN0aW9uIGluaXQkNigpIHtcblx0ICB2YXIgc3BoaSA9IE1hdGguc2luKHRoaXMubGF0MCk7XG5cdCAgdmFyIGNwaGkgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuXHQgIGNwaGkgKj0gY3BoaTtcblx0ICB0aGlzLnJjID0gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKSAvICgxIC0gdGhpcy5lcyAqIHNwaGkgKiBzcGhpKTtcblx0ICB0aGlzLkMgPSBNYXRoLnNxcnQoMSArIHRoaXMuZXMgKiBjcGhpICogY3BoaSAvICgxIC0gdGhpcy5lcykpO1xuXHQgIHRoaXMucGhpYzAgPSBNYXRoLmFzaW4oc3BoaSAvIHRoaXMuQyk7XG5cdCAgdGhpcy5yYXRleHAgPSAwLjUgKiB0aGlzLkMgKiB0aGlzLmU7XG5cdCAgdGhpcy5LID0gTWF0aC50YW4oMC41ICogdGhpcy5waGljMCArIEZPUlRQSSkgLyAoTWF0aC5wb3coTWF0aC50YW4oMC41ICogdGhpcy5sYXQwICsgRk9SVFBJKSwgdGhpcy5DKSAqIHNyYXQodGhpcy5lICogc3BoaSwgdGhpcy5yYXRleHApKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcndhcmQkNShwKSB7XG5cdCAgdmFyIGxvbiA9IHAueDtcblx0ICB2YXIgbGF0ID0gcC55O1xuXG5cdCAgcC55ID0gMiAqIE1hdGguYXRhbih0aGlzLksgKiBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBNYXRoLnNpbihsYXQpLCB0aGlzLnJhdGV4cCkpIC0gSEFMRl9QSTtcblx0ICBwLnggPSB0aGlzLkMgKiBsb247XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZlcnNlJDUocCkge1xuXHQgIHZhciBERUxfVE9MID0gMWUtMTQ7XG5cdCAgdmFyIGxvbiA9IHAueCAvIHRoaXMuQztcblx0ICB2YXIgbGF0ID0gcC55O1xuXHQgIHZhciBudW0gPSBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpIC8gdGhpcy5LLCAxIC8gdGhpcy5DKTtcblx0ICBmb3IgKHZhciBpID0gTUFYX0lURVIkMTsgaSA+IDA7IC0taSkge1xuXHQgICAgbGF0ID0gMiAqIE1hdGguYXRhbihudW0gKiBzcmF0KHRoaXMuZSAqIE1hdGguc2luKHAueSksIC0gMC41ICogdGhpcy5lKSkgLSBIQUxGX1BJO1xuXHQgICAgaWYgKE1hdGguYWJzKGxhdCAtIHAueSkgPCBERUxfVE9MKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcC55ID0gbGF0O1xuXHQgIH1cblx0ICAvKiBjb252ZXJnZW5jZSBmYWlsZWQgKi9cblx0ICBpZiAoIWkpIHtcblx0ICAgIHJldHVybiBudWxsO1xuXHQgIH1cblx0ICBwLnggPSBsb247XG5cdCAgcC55ID0gbGF0O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDcgPSBbXCJnYXVzc1wiXTtcblx0dmFyIGdhdXNzID0ge1xuXHQgIGluaXQ6IGluaXQkNixcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDUsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQ1LFxuXHQgIG5hbWVzOiBuYW1lcyQ3XG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQ1KCkge1xuXHQgIGdhdXNzLmluaXQuYXBwbHkodGhpcyk7XG5cdCAgaWYgKCF0aGlzLnJjKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHRoaXMuc2luYzAgPSBNYXRoLnNpbih0aGlzLnBoaWMwKTtcblx0ICB0aGlzLmNvc2MwID0gTWF0aC5jb3ModGhpcy5waGljMCk7XG5cdCAgdGhpcy5SMiA9IDIgKiB0aGlzLnJjO1xuXHQgIGlmICghdGhpcy50aXRsZSkge1xuXHQgICAgdGhpcy50aXRsZSA9IFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCI7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZm9yd2FyZCQ0KHApIHtcblx0ICB2YXIgc2luYywgY29zYywgY29zbCwgaztcblx0ICBwLnggPSBhZGp1c3RfbG9uKHAueCAtIHRoaXMubG9uZzApO1xuXHQgIGdhdXNzLmZvcndhcmQuYXBwbHkodGhpcywgW3BdKTtcblx0ICBzaW5jID0gTWF0aC5zaW4ocC55KTtcblx0ICBjb3NjID0gTWF0aC5jb3MocC55KTtcblx0ICBjb3NsID0gTWF0aC5jb3MocC54KTtcblx0ICBrID0gdGhpcy5rMCAqIHRoaXMuUjIgLyAoMSArIHRoaXMuc2luYzAgKiBzaW5jICsgdGhpcy5jb3NjMCAqIGNvc2MgKiBjb3NsKTtcblx0ICBwLnggPSBrICogY29zYyAqIE1hdGguc2luKHAueCk7XG5cdCAgcC55ID0gayAqICh0aGlzLmNvc2MwICogc2luYyAtIHRoaXMuc2luYzAgKiBjb3NjICogY29zbCk7XG5cdCAgcC54ID0gdGhpcy5hICogcC54ICsgdGhpcy54MDtcblx0ICBwLnkgPSB0aGlzLmEgKiBwLnkgKyB0aGlzLnkwO1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW52ZXJzZSQ0KHApIHtcblx0ICB2YXIgc2luYywgY29zYywgbG9uLCBsYXQsIHJobztcblx0ICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG5cdCAgcC55ID0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5hO1xuXG5cdCAgcC54IC89IHRoaXMuazA7XG5cdCAgcC55IC89IHRoaXMuazA7XG5cdCAgaWYgKChyaG8gPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSkpIHtcblx0ICAgIHZhciBjID0gMiAqIE1hdGguYXRhbjIocmhvLCB0aGlzLlIyKTtcblx0ICAgIHNpbmMgPSBNYXRoLnNpbihjKTtcblx0ICAgIGNvc2MgPSBNYXRoLmNvcyhjKTtcblx0ICAgIGxhdCA9IE1hdGguYXNpbihjb3NjICogdGhpcy5zaW5jMCArIHAueSAqIHNpbmMgKiB0aGlzLmNvc2MwIC8gcmhvKTtcblx0ICAgIGxvbiA9IE1hdGguYXRhbjIocC54ICogc2luYywgcmhvICogdGhpcy5jb3NjMCAqIGNvc2MgLSBwLnkgKiB0aGlzLnNpbmMwICogc2luYyk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgbGF0ID0gdGhpcy5waGljMDtcblx0ICAgIGxvbiA9IDA7XG5cdCAgfVxuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblx0ICBnYXVzcy5pbnZlcnNlLmFwcGx5KHRoaXMsIFtwXSk7XG5cdCAgcC54ID0gYWRqdXN0X2xvbihwLnggKyB0aGlzLmxvbmcwKTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdHZhciBuYW1lcyQ2ID0gW1wiU3RlcmVvZ3JhcGhpY19Ob3J0aF9Qb2xlXCIsIFwiT2JsaXF1ZV9TdGVyZW9ncmFwaGljXCIsIFwiUG9sYXJfU3RlcmVvZ3JhcGhpY1wiLCBcInN0ZXJlYVwiLFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCJdO1xuXHR2YXIgc3RlcmVhID0ge1xuXHQgIGluaXQ6IGluaXQkNSxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDQsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQ0LFxuXHQgIG5hbWVzOiBuYW1lcyQ2XG5cdH07XG5cblx0ZnVuY3Rpb24gc3Nmbl8ocGhpdCwgc2lucGhpLCBlY2Nlbikge1xuXHQgIHNpbnBoaSAqPSBlY2Nlbjtcblx0ICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgcGhpdCkpICogTWF0aC5wb3coKDEgLSBzaW5waGkpIC8gKDEgKyBzaW5waGkpLCAwLjUgKiBlY2NlbikpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdCQ3KCkge1xuXHQgIHRoaXMuY29zbGF0MCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG5cdCAgdGhpcy5zaW5sYXQwID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIGlmICh0aGlzLmswID09PSAxICYmICFpc05hTih0aGlzLmxhdF90cykgJiYgTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuXHQgICAgICB0aGlzLmswID0gMC41ICogKDEgKyBzaWduKHRoaXMubGF0MCkgKiBNYXRoLnNpbih0aGlzLmxhdF90cykpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG5cdCAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG5cdCAgICAgICAgLy9Ob3J0aCBwb2xlXG5cdCAgICAgICAgLy90cmFjZSgnc3RlcmU6bm9ydGggcG9sZScpO1xuXHQgICAgICAgIHRoaXMuY29uID0gMTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICAvL1NvdXRoIHBvbGVcblx0ICAgICAgICAvL3RyYWNlKCdzdGVyZTpzb3V0aCBwb2xlJyk7XG5cdCAgICAgICAgdGhpcy5jb24gPSAtMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5jb25zID0gTWF0aC5zcXJ0KE1hdGgucG93KDEgKyB0aGlzLmUsIDEgKyB0aGlzLmUpICogTWF0aC5wb3coMSAtIHRoaXMuZSwgMSAtIHRoaXMuZSkpO1xuXHQgICAgaWYgKHRoaXMuazAgPT09IDEgJiYgIWlzTmFOKHRoaXMubGF0X3RzKSAmJiBNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG5cdCAgICAgIHRoaXMuazAgPSAwLjUgKiB0aGlzLmNvbnMgKiBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKSAvIHRzZm56KHRoaXMuZSwgdGhpcy5jb24gKiB0aGlzLmxhdF90cywgdGhpcy5jb24gKiBNYXRoLnNpbih0aGlzLmxhdF90cykpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lubGF0MCwgdGhpcy5jb3NsYXQwKTtcblx0ICAgIHRoaXMuWDAgPSAyICogTWF0aC5hdGFuKHRoaXMuc3Nmbl8odGhpcy5sYXQwLCB0aGlzLnNpbmxhdDAsIHRoaXMuZSkpIC0gSEFMRl9QSTtcblx0ICAgIHRoaXMuY29zWDAgPSBNYXRoLmNvcyh0aGlzLlgwKTtcblx0ICAgIHRoaXMuc2luWDAgPSBNYXRoLnNpbih0aGlzLlgwKTtcblx0ICB9XG5cdH1cblxuXHQvLyBTdGVyZW9ncmFwaGljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuXHRmdW5jdGlvbiBmb3J3YXJkJDYocCkge1xuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblx0ICB2YXIgc2lubGF0ID0gTWF0aC5zaW4obGF0KTtcblx0ICB2YXIgY29zbGF0ID0gTWF0aC5jb3MobGF0KTtcblx0ICB2YXIgQSwgWCwgc2luWCwgY29zWCwgdHMsIHJoO1xuXHQgIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuXHQgIGlmIChNYXRoLmFicyhNYXRoLmFicyhsb24gLSB0aGlzLmxvbmcwKSAtIE1hdGguUEkpIDw9IEVQU0xOICYmIE1hdGguYWJzKGxhdCArIHRoaXMubGF0MCkgPD0gRVBTTE4pIHtcblx0ICAgIC8vY2FzZSBvZiB0aGUgb3JpZ2luZSBwb2ludFxuXHQgICAgLy90cmFjZSgnc3RlcmU6dGhpcyBpcyB0aGUgb3JpZ2luIHBvaW50Jyk7XG5cdCAgICBwLnggPSBOYU47XG5cdCAgICBwLnkgPSBOYU47XG5cdCAgICByZXR1cm4gcDtcblx0ICB9XG5cdCAgaWYgKHRoaXMuc3BoZXJlKSB7XG5cdCAgICAvL3RyYWNlKCdzdGVyZTpzcGhlcmUgY2FzZScpO1xuXHQgICAgQSA9IDIgKiB0aGlzLmswIC8gKDEgKyB0aGlzLnNpbmxhdDAgKiBzaW5sYXQgKyB0aGlzLmNvc2xhdDAgKiBjb3NsYXQgKiBNYXRoLmNvcyhkbG9uKSk7XG5cdCAgICBwLnggPSB0aGlzLmEgKiBBICogY29zbGF0ICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuXHQgICAgcC55ID0gdGhpcy5hICogQSAqICh0aGlzLmNvc2xhdDAgKiBzaW5sYXQgLSB0aGlzLnNpbmxhdDAgKiBjb3NsYXQgKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuXHQgICAgcmV0dXJuIHA7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgWCA9IDIgKiBNYXRoLmF0YW4odGhpcy5zc2ZuXyhsYXQsIHNpbmxhdCwgdGhpcy5lKSkgLSBIQUxGX1BJO1xuXHQgICAgY29zWCA9IE1hdGguY29zKFgpO1xuXHQgICAgc2luWCA9IE1hdGguc2luKFgpO1xuXHQgICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcblx0ICAgICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCAqIHRoaXMuY29uLCB0aGlzLmNvbiAqIHNpbmxhdCk7XG5cdCAgICAgIHJoID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0cyAvIHRoaXMuY29ucztcblx0ICAgICAgcC54ID0gdGhpcy54MCArIHJoICogTWF0aC5zaW4obG9uIC0gdGhpcy5sb25nMCk7XG5cdCAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmNvbiAqIHJoICogTWF0aC5jb3MobG9uIC0gdGhpcy5sb25nMCk7XG5cdCAgICAgIC8vdHJhY2UocC50b1N0cmluZygpKTtcblx0ICAgICAgcmV0dXJuIHA7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbmxhdDApIDwgRVBTTE4pIHtcblx0ICAgICAgLy9FcVxuXHQgICAgICAvL3RyYWNlKCdzdGVyZTplcXVhdGV1cicpO1xuXHQgICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgLyAoMSArIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSk7XG5cdCAgICAgIHAueSA9IEEgKiBzaW5YO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIC8vb3RoZXIgY2FzZVxuXHQgICAgICAvL3RyYWNlKCdzdGVyZTpub3JtYWwgY2FzZScpO1xuXHQgICAgICBBID0gMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0aGlzLm1zMSAvICh0aGlzLmNvc1gwICogKDEgKyB0aGlzLnNpblgwICogc2luWCArIHRoaXMuY29zWDAgKiBjb3NYICogTWF0aC5jb3MoZGxvbikpKTtcblx0ICAgICAgcC55ID0gQSAqICh0aGlzLmNvc1gwICogc2luWCAtIHRoaXMuc2luWDAgKiBjb3NYICogTWF0aC5jb3MoZGxvbikpICsgdGhpcy55MDtcblx0ICAgIH1cblx0ICAgIHAueCA9IEEgKiBjb3NYICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuXHQgIH1cblx0ICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvLyogU3RlcmVvZ3JhcGhpYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcblx0ZnVuY3Rpb24gaW52ZXJzZSQ2KHApIHtcblx0ICBwLnggLT0gdGhpcy54MDtcblx0ICBwLnkgLT0gdGhpcy55MDtcblx0ICB2YXIgbG9uLCBsYXQsIHRzLCBjZSwgQ2hpO1xuXHQgIHZhciByaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuXHQgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgdmFyIGMgPSAyICogTWF0aC5hdGFuKHJoIC8gKDAuNSAqIHRoaXMuYSAqIHRoaXMuazApKTtcblx0ICAgIGxvbiA9IHRoaXMubG9uZzA7XG5cdCAgICBsYXQgPSB0aGlzLmxhdDA7XG5cdCAgICBpZiAocmggPD0gRVBTTE4pIHtcblx0ICAgICAgcC54ID0gbG9uO1xuXHQgICAgICBwLnkgPSBsYXQ7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgbGF0ID0gTWF0aC5hc2luKE1hdGguY29zKGMpICogdGhpcy5zaW5sYXQwICsgcC55ICogTWF0aC5zaW4oYykgKiB0aGlzLmNvc2xhdDAgLyByaCk7XG5cdCAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8IEVQU0xOKSB7XG5cdCAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG5cdCAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCBwLnkpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogTWF0aC5zaW4oYyksIHJoICogdGhpcy5jb3NsYXQwICogTWF0aC5jb3MoYykgLSBwLnkgKiB0aGlzLnNpbmxhdDAgKiBNYXRoLnNpbihjKSkpO1xuXHQgICAgfVxuXHQgICAgcC54ID0gbG9uO1xuXHQgICAgcC55ID0gbGF0O1xuXHQgICAgcmV0dXJuIHA7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcblx0ICAgICAgaWYgKHJoIDw9IEVQU0xOKSB7XG5cdCAgICAgICAgbGF0ID0gdGhpcy5sYXQwO1xuXHQgICAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG5cdCAgICAgICAgcC54ID0gbG9uO1xuXHQgICAgICAgIHAueSA9IGxhdDtcblx0ICAgICAgICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgIH1cblx0ICAgICAgcC54ICo9IHRoaXMuY29uO1xuXHQgICAgICBwLnkgKj0gdGhpcy5jb247XG5cdCAgICAgIHRzID0gcmggKiB0aGlzLmNvbnMgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazApO1xuXHQgICAgICBsYXQgPSB0aGlzLmNvbiAqIHBoaTJ6KHRoaXMuZSwgdHMpO1xuXHQgICAgICBsb24gPSB0aGlzLmNvbiAqIGFkanVzdF9sb24odGhpcy5jb24gKiB0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gMSAqIHAueSkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGNlID0gMiAqIE1hdGguYXRhbihyaCAqIHRoaXMuY29zWDAgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazAgKiB0aGlzLm1zMSkpO1xuXHQgICAgICBsb24gPSB0aGlzLmxvbmcwO1xuXHQgICAgICBpZiAocmggPD0gRVBTTE4pIHtcblx0ICAgICAgICBDaGkgPSB0aGlzLlgwO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIENoaSA9IE1hdGguYXNpbihNYXRoLmNvcyhjZSkgKiB0aGlzLnNpblgwICsgcC55ICogTWF0aC5zaW4oY2UpICogdGhpcy5jb3NYMCAvIHJoKTtcblx0ICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCAqIE1hdGguc2luKGNlKSwgcmggKiB0aGlzLmNvc1gwICogTWF0aC5jb3MoY2UpIC0gcC55ICogdGhpcy5zaW5YMCAqIE1hdGguc2luKGNlKSkpO1xuXHQgICAgICB9XG5cdCAgICAgIGxhdCA9IC0xICogcGhpMnoodGhpcy5lLCBNYXRoLnRhbigwLjUgKiAoSEFMRl9QSSArIENoaSkpKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblxuXHQgIC8vdHJhY2UocC50b1N0cmluZygpKTtcblx0ICByZXR1cm4gcDtcblxuXHR9XG5cblx0dmFyIG5hbWVzJDggPSBbXCJzdGVyZVwiLCBcIlN0ZXJlb2dyYXBoaWNfU291dGhfUG9sZVwiLCBcIlBvbGFyIFN0ZXJlb2dyYXBoaWMgKHZhcmlhbnQgQilcIl07XG5cdHZhciBzdGVyZSA9IHtcblx0ICBpbml0OiBpbml0JDcsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCQ2LFxuXHQgIGludmVyc2U6IGludmVyc2UkNixcblx0ICBuYW1lczogbmFtZXMkOCxcblx0ICBzc2ZuXzogc3Nmbl9cblx0fTtcblxuXHQvKlxuXHQgIHJlZmVyZW5jZXM6XG5cdCAgICBGb3JtdWxlcyBldCBjb25zdGFudGVzIHBvdXIgbGUgQ2FsY3VsIHBvdXIgbGFcblx0ICAgIHByb2plY3Rpb24gY3lsaW5kcmlxdWUgY29uZm9ybWUgw6AgYXhlIG9ibGlxdWUgZXQgcG91ciBsYSB0cmFuc2Zvcm1hdGlvbiBlbnRyZVxuXHQgICAgZGVzIHN5c3TDqG1lcyBkZSByw6lmw6lyZW5jZS5cblx0ICAgIGh0dHA6Ly93d3cuc3dpc3N0b3BvLmFkbWluLmNoL2ludGVybmV0L3N3aXNzdG9wby9mci9ob21lL3RvcGljcy9zdXJ2ZXkvc3lzL3JlZnN5cy9zd2l0emVybGFuZC5wYXJzeXNyZWxhdGVkMS4zMTIxNi5kb3dubG9hZExpc3QuNzcwMDQuRG93bmxvYWRGaWxlLnRtcC9zd2lzc3Byb2plY3Rpb25mci5wZGZcblx0ICAqL1xuXG5cdGZ1bmN0aW9uIGluaXQkOCgpIHtcblx0ICB2YXIgcGh5MCA9IHRoaXMubGF0MDtcblx0ICB0aGlzLmxhbWJkYTAgPSB0aGlzLmxvbmcwO1xuXHQgIHZhciBzaW5QaHkwID0gTWF0aC5zaW4ocGh5MCk7XG5cdCAgdmFyIHNlbWlNYWpvckF4aXMgPSB0aGlzLmE7XG5cdCAgdmFyIGludkYgPSB0aGlzLnJmO1xuXHQgIHZhciBmbGF0dGVuaW5nID0gMSAvIGludkY7XG5cdCAgdmFyIGUyID0gMiAqIGZsYXR0ZW5pbmcgLSBNYXRoLnBvdyhmbGF0dGVuaW5nLCAyKTtcblx0ICB2YXIgZSA9IHRoaXMuZSA9IE1hdGguc3FydChlMik7XG5cdCAgdGhpcy5SID0gdGhpcy5rMCAqIHNlbWlNYWpvckF4aXMgKiBNYXRoLnNxcnQoMSAtIGUyKSAvICgxIC0gZTIgKiBNYXRoLnBvdyhzaW5QaHkwLCAyKSk7XG5cdCAgdGhpcy5hbHBoYSA9IE1hdGguc3FydCgxICsgZTIgLyAoMSAtIGUyKSAqIE1hdGgucG93KE1hdGguY29zKHBoeTApLCA0KSk7XG5cdCAgdGhpcy5iMCA9IE1hdGguYXNpbihzaW5QaHkwIC8gdGhpcy5hbHBoYSk7XG5cdCAgdmFyIGsxID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyB0aGlzLmIwIC8gMikpO1xuXHQgIHZhciBrMiA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5MCAvIDIpKTtcblx0ICB2YXIgazMgPSBNYXRoLmxvZygoMSArIGUgKiBzaW5QaHkwKSAvICgxIC0gZSAqIHNpblBoeTApKTtcblx0ICB0aGlzLksgPSBrMSAtIHRoaXMuYWxwaGEgKiBrMiArIHRoaXMuYWxwaGEgKiBlIC8gMiAqIGszO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9yd2FyZCQ3KHApIHtcblx0ICB2YXIgU2ExID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgLSBwLnkgLyAyKSk7XG5cdCAgdmFyIFNhMiA9IHRoaXMuZSAvIDIgKiBNYXRoLmxvZygoMSArIHRoaXMuZSAqIE1hdGguc2luKHAueSkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihwLnkpKSk7XG5cdCAgdmFyIFMgPSAtdGhpcy5hbHBoYSAqIChTYTEgKyBTYTIpICsgdGhpcy5LO1xuXG5cdCAgLy8gc3BoZXJpYyBsYXRpdHVkZVxuXHQgIHZhciBiID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUykpIC0gTWF0aC5QSSAvIDQpO1xuXG5cdCAgLy8gc3BoZXJpYyBsb25naXR1ZGVcblx0ICB2YXIgSSA9IHRoaXMuYWxwaGEgKiAocC54IC0gdGhpcy5sYW1iZGEwKTtcblxuXHQgIC8vIHBzb2V1ZG8gZXF1YXRvcmlhbCByb3RhdGlvblxuXHQgIHZhciByb3RJID0gTWF0aC5hdGFuKE1hdGguc2luKEkpIC8gKE1hdGguc2luKHRoaXMuYjApICogTWF0aC50YW4oYikgKyBNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguY29zKEkpKSk7XG5cblx0ICB2YXIgcm90QiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKGIpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhiKSAqIE1hdGguY29zKEkpKTtcblxuXHQgIHAueSA9IHRoaXMuUiAvIDIgKiBNYXRoLmxvZygoMSArIE1hdGguc2luKHJvdEIpKSAvICgxIC0gTWF0aC5zaW4ocm90QikpKSArIHRoaXMueTA7XG5cdCAgcC54ID0gdGhpcy5SICogcm90SSArIHRoaXMueDA7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZlcnNlJDcocCkge1xuXHQgIHZhciBZID0gcC54IC0gdGhpcy54MDtcblx0ICB2YXIgWCA9IHAueSAtIHRoaXMueTA7XG5cblx0ICB2YXIgcm90SSA9IFkgLyB0aGlzLlI7XG5cdCAgdmFyIHJvdEIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChYIC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gNCk7XG5cblx0ICB2YXIgYiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKHJvdEIpICsgTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhyb3RCKSAqIE1hdGguY29zKHJvdEkpKTtcblx0ICB2YXIgSSA9IE1hdGguYXRhbihNYXRoLnNpbihyb3RJKSAvIChNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguY29zKHJvdEkpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLnRhbihyb3RCKSkpO1xuXG5cdCAgdmFyIGxhbWJkYSA9IHRoaXMubGFtYmRhMCArIEkgLyB0aGlzLmFscGhhO1xuXG5cdCAgdmFyIFMgPSAwO1xuXHQgIHZhciBwaHkgPSBiO1xuXHQgIHZhciBwcmV2UGh5ID0gLTEwMDA7XG5cdCAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cdCAgd2hpbGUgKE1hdGguYWJzKHBoeSAtIHByZXZQaHkpID4gMC4wMDAwMDAxKSB7XG5cdCAgICBpZiAoKytpdGVyYXRpb24gPiAyMCkge1xuXHQgICAgICAvLy4uLnJlcG9ydEVycm9yKFwib21lcmNGd2RJbmZpbml0eVwiKTtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgLy9TID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkgLyAyKSk7XG5cdCAgICBTID0gMSAvIHRoaXMuYWxwaGEgKiAoTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBiIC8gMikpIC0gdGhpcy5LKSArIHRoaXMuZSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgTWF0aC5hc2luKHRoaXMuZSAqIE1hdGguc2luKHBoeSkpIC8gMikpO1xuXHQgICAgcHJldlBoeSA9IHBoeTtcblx0ICAgIHBoeSA9IDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoUykpIC0gTWF0aC5QSSAvIDI7XG5cdCAgfVxuXG5cdCAgcC54ID0gbGFtYmRhO1xuXHQgIHAueSA9IHBoeTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdHZhciBuYW1lcyQ5ID0gW1wic29tZXJjXCJdO1xuXHR2YXIgc29tZXJjID0ge1xuXHQgIGluaXQ6IGluaXQkOCxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDcsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQ3LFxuXHQgIG5hbWVzOiBuYW1lcyQ5XG5cdH07XG5cblx0LyogSW5pdGlhbGl6ZSB0aGUgT2JsaXF1ZSBNZXJjYXRvciAgcHJvamVjdGlvblxuXHQgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gaW5pdCQ5KCkge1xuXHQgIHRoaXMubm9fb2ZmID0gdGhpcy5ub19vZmYgfHwgZmFsc2U7XG5cdCAgdGhpcy5ub19yb3QgPSB0aGlzLm5vX3JvdCB8fCBmYWxzZTtcblxuXHQgIGlmIChpc05hTih0aGlzLmswKSkge1xuXHQgICAgdGhpcy5rMCA9IDE7XG5cdCAgfVxuXHQgIHZhciBzaW5sYXQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuXHQgIHZhciBjb3NsYXQgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuXHQgIHZhciBjb24gPSB0aGlzLmUgKiBzaW5sYXQ7XG5cblx0ICB0aGlzLmJsID0gTWF0aC5zcXJ0KDEgKyB0aGlzLmVzIC8gKDEgLSB0aGlzLmVzKSAqIE1hdGgucG93KGNvc2xhdCwgNCkpO1xuXHQgIHRoaXMuYWwgPSB0aGlzLmEgKiB0aGlzLmJsICogdGhpcy5rMCAqIE1hdGguc3FydCgxIC0gdGhpcy5lcykgLyAoMSAtIGNvbiAqIGNvbik7XG5cdCAgdmFyIHQwID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDAsIHNpbmxhdCk7XG5cdCAgdmFyIGRsID0gdGhpcy5ibCAvIGNvc2xhdCAqIE1hdGguc3FydCgoMSAtIHRoaXMuZXMpIC8gKDEgLSBjb24gKiBjb24pKTtcblx0ICBpZiAoZGwgKiBkbCA8IDEpIHtcblx0ICAgIGRsID0gMTtcblx0ICB9XG5cdCAgdmFyIGZsO1xuXHQgIHZhciBnbDtcblx0ICBpZiAoIWlzTmFOKHRoaXMubG9uZ2MpKSB7XG5cdCAgICAvL0NlbnRyYWwgcG9pbnQgYW5kIGF6aW11dGggbWV0aG9kXG5cblx0ICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuXHQgICAgICBmbCA9IGRsICsgTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICBmbCA9IGRsIC0gTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuZWwgPSBmbCAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcblx0ICAgIGdsID0gMC41ICogKGZsIC0gMSAvIGZsKTtcblx0ICAgIHRoaXMuZ2FtbWEwID0gTWF0aC5hc2luKE1hdGguc2luKHRoaXMuYWxwaGEpIC8gZGwpO1xuXHQgICAgdGhpcy5sb25nMCA9IHRoaXMubG9uZ2MgLSBNYXRoLmFzaW4oZ2wgKiBNYXRoLnRhbih0aGlzLmdhbW1hMCkpIC8gdGhpcy5ibDtcblxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIC8vMiBwb2ludHMgbWV0aG9kXG5cdCAgICB2YXIgdDEgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MSwgTWF0aC5zaW4odGhpcy5sYXQxKSk7XG5cdCAgICB2YXIgdDIgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MiwgTWF0aC5zaW4odGhpcy5sYXQyKSk7XG5cdCAgICBpZiAodGhpcy5sYXQwID49IDApIHtcblx0ICAgICAgdGhpcy5lbCA9IChkbCArIE1hdGguc3FydChkbCAqIGRsIC0gMSkpICogTWF0aC5wb3codDAsIHRoaXMuYmwpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHRoaXMuZWwgPSAoZGwgLSBNYXRoLnNxcnQoZGwgKiBkbCAtIDEpKSAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcblx0ICAgIH1cblx0ICAgIHZhciBobCA9IE1hdGgucG93KHQxLCB0aGlzLmJsKTtcblx0ICAgIHZhciBsbCA9IE1hdGgucG93KHQyLCB0aGlzLmJsKTtcblx0ICAgIGZsID0gdGhpcy5lbCAvIGhsO1xuXHQgICAgZ2wgPSAwLjUgKiAoZmwgLSAxIC8gZmwpO1xuXHQgICAgdmFyIGpsID0gKHRoaXMuZWwgKiB0aGlzLmVsIC0gbGwgKiBobCkgLyAodGhpcy5lbCAqIHRoaXMuZWwgKyBsbCAqIGhsKTtcblx0ICAgIHZhciBwbCA9IChsbCAtIGhsKSAvIChsbCArIGhsKTtcblx0ICAgIHZhciBkbG9uMTIgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcyKTtcblx0ICAgIHRoaXMubG9uZzAgPSAwLjUgKiAodGhpcy5sb25nMSArIHRoaXMubG9uZzIpIC0gTWF0aC5hdGFuKGpsICogTWF0aC50YW4oMC41ICogdGhpcy5ibCAqIChkbG9uMTIpKSAvIHBsKSAvIHRoaXMuYmw7XG5cdCAgICB0aGlzLmxvbmcwID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwKTtcblx0ICAgIHZhciBkbG9uMTAgPSBhZGp1c3RfbG9uKHRoaXMubG9uZzEgLSB0aGlzLmxvbmcwKTtcblx0ICAgIHRoaXMuZ2FtbWEwID0gTWF0aC5hdGFuKE1hdGguc2luKHRoaXMuYmwgKiAoZGxvbjEwKSkgLyBnbCk7XG5cdCAgICB0aGlzLmFscGhhID0gTWF0aC5hc2luKGRsICogTWF0aC5zaW4odGhpcy5nYW1tYTApKTtcblx0ICB9XG5cblx0ICBpZiAodGhpcy5ub19vZmYpIHtcblx0ICAgIHRoaXMudWMgPSAwO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuXHQgICAgICB0aGlzLnVjID0gdGhpcy5hbCAvIHRoaXMuYmwgKiBNYXRoLmF0YW4yKE1hdGguc3FydChkbCAqIGRsIC0gMSksIE1hdGguY29zKHRoaXMuYWxwaGEpKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICB0aGlzLnVjID0gLTEgKiB0aGlzLmFsIC8gdGhpcy5ibCAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGRsICogZGwgLSAxKSwgTWF0aC5jb3ModGhpcy5hbHBoYSkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHR9XG5cblx0LyogT2JsaXF1ZSBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDgocCkge1xuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblx0ICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cdCAgdmFyIHVzLCB2cztcblx0ICB2YXIgY29uO1xuXHQgIGlmIChNYXRoLmFicyhNYXRoLmFicyhsYXQpIC0gSEFMRl9QSSkgPD0gRVBTTE4pIHtcblx0ICAgIGlmIChsYXQgPiAwKSB7XG5cdCAgICAgIGNvbiA9IC0xO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGNvbiA9IDE7XG5cdCAgICB9XG5cdCAgICB2cyA9IHRoaXMuYWwgLyB0aGlzLmJsICogTWF0aC5sb2coTWF0aC50YW4oRk9SVFBJICsgY29uICogdGhpcy5nYW1tYTAgKiAwLjUpKTtcblx0ICAgIHVzID0gLTEgKiBjb24gKiBIQUxGX1BJICogdGhpcy5hbCAvIHRoaXMuYmw7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdmFyIHQgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG5cdCAgICB2YXIgcWwgPSB0aGlzLmVsIC8gTWF0aC5wb3codCwgdGhpcy5ibCk7XG5cdCAgICB2YXIgc2wgPSAwLjUgKiAocWwgLSAxIC8gcWwpO1xuXHQgICAgdmFyIHRsID0gMC41ICogKHFsICsgMSAvIHFsKTtcblx0ICAgIHZhciB2bCA9IE1hdGguc2luKHRoaXMuYmwgKiAoZGxvbikpO1xuXHQgICAgdmFyIHVsID0gKHNsICogTWF0aC5zaW4odGhpcy5nYW1tYTApIC0gdmwgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkpIC8gdGw7XG5cdCAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnModWwpIC0gMSkgPD0gRVBTTE4pIHtcblx0ICAgICAgdnMgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgdnMgPSAwLjUgKiB0aGlzLmFsICogTWF0aC5sb2coKDEgLSB1bCkgLyAoMSArIHVsKSkgLyB0aGlzLmJsO1xuXHQgICAgfVxuXHQgICAgaWYgKE1hdGguYWJzKE1hdGguY29zKHRoaXMuYmwgKiAoZGxvbikpKSA8PSBFUFNMTikge1xuXHQgICAgICB1cyA9IHRoaXMuYWwgKiB0aGlzLmJsICogKGRsb24pO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHVzID0gdGhpcy5hbCAqIE1hdGguYXRhbjIoc2wgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkgKyB2bCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSwgTWF0aC5jb3ModGhpcy5ibCAqIGRsb24pKSAvIHRoaXMuYmw7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMubm9fcm90KSB7XG5cdCAgICBwLnggPSB0aGlzLngwICsgdXM7XG5cdCAgICBwLnkgPSB0aGlzLnkwICsgdnM7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXG5cdCAgICB1cyAtPSB0aGlzLnVjO1xuXHQgICAgcC54ID0gdGhpcy54MCArIHZzICogTWF0aC5jb3ModGhpcy5hbHBoYSkgKyB1cyAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuXHQgICAgcC55ID0gdGhpcy55MCArIHVzICogTWF0aC5jb3ModGhpcy5hbHBoYSkgLSB2cyAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuXHQgIH1cblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmVyc2UkOChwKSB7XG5cdCAgdmFyIHVzLCB2cztcblx0ICBpZiAodGhpcy5ub19yb3QpIHtcblx0ICAgIHZzID0gcC55IC0gdGhpcy55MDtcblx0ICAgIHVzID0gcC54IC0gdGhpcy54MDtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB2cyA9IChwLnggLSB0aGlzLngwKSAqIE1hdGguY29zKHRoaXMuYWxwaGEpIC0gKHAueSAtIHRoaXMueTApICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG5cdCAgICB1cyA9IChwLnkgLSB0aGlzLnkwKSAqIE1hdGguY29zKHRoaXMuYWxwaGEpICsgKHAueCAtIHRoaXMueDApICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG5cdCAgICB1cyArPSB0aGlzLnVjO1xuXHQgIH1cblx0ICB2YXIgcXAgPSBNYXRoLmV4cCgtMSAqIHRoaXMuYmwgKiB2cyAvIHRoaXMuYWwpO1xuXHQgIHZhciBzcCA9IDAuNSAqIChxcCAtIDEgLyBxcCk7XG5cdCAgdmFyIHRwID0gMC41ICogKHFwICsgMSAvIHFwKTtcblx0ICB2YXIgdnAgPSBNYXRoLnNpbih0aGlzLmJsICogdXMgLyB0aGlzLmFsKTtcblx0ICB2YXIgdXAgPSAodnAgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkgKyBzcCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSkgLyB0cDtcblx0ICB2YXIgdHMgPSBNYXRoLnBvdyh0aGlzLmVsIC8gTWF0aC5zcXJ0KCgxICsgdXApIC8gKDEgLSB1cCkpLCAxIC8gdGhpcy5ibCk7XG5cdCAgaWYgKE1hdGguYWJzKHVwIC0gMSkgPCBFUFNMTikge1xuXHQgICAgcC54ID0gdGhpcy5sb25nMDtcblx0ICAgIHAueSA9IEhBTEZfUEk7XG5cdCAgfVxuXHQgIGVsc2UgaWYgKE1hdGguYWJzKHVwICsgMSkgPCBFUFNMTikge1xuXHQgICAgcC54ID0gdGhpcy5sb25nMDtcblx0ICAgIHAueSA9IC0xICogSEFMRl9QSTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBwLnkgPSBwaGkyeih0aGlzLmUsIHRzKTtcblx0ICAgIHAueCA9IGFkanVzdF9sb24odGhpcy5sb25nMCAtIE1hdGguYXRhbjIoc3AgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkgLSB2cCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSwgTWF0aC5jb3ModGhpcy5ibCAqIHVzIC8gdGhpcy5hbCkpIC8gdGhpcy5ibCk7XG5cdCAgfVxuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDEwID0gW1wiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JcIiwgXCJIb3RpbmUgT2JsaXF1ZSBNZXJjYXRvclwiLCBcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yX0F6aW11dGhfTmF0dXJhbF9PcmlnaW5cIiwgXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcl9BemltdXRoX0NlbnRlclwiLCBcIm9tZXJjXCJdO1xuXHR2YXIgb21lcmMgPSB7XG5cdCAgaW5pdDogaW5pdCQ5LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkOCxcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDgsXG5cdCAgbmFtZXM6IG5hbWVzJDEwXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQxMCgpIHtcblxuXHQgIC8vIGFycmF5IG9mOiAgcl9tYWoscl9taW4sbGF0MSxsYXQyLGNfbG9uLGNfbGF0LGZhbHNlX2Vhc3QsZmFsc2Vfbm9ydGhcblx0ICAvL2RvdWJsZSBjX2xhdDsgICAgICAgICAgICAgICAgICAgLyogY2VudGVyIGxhdGl0dWRlICAgICAgICAgICAgICAgICAgICAgICovXG5cdCAgLy9kb3VibGUgY19sb247ICAgICAgICAgICAgICAgICAgIC8qIGNlbnRlciBsb25naXR1ZGUgICAgICAgICAgICAgICAgICAgICAqL1xuXHQgIC8vZG91YmxlIGxhdDE7ICAgICAgICAgICAgICAgICAgICAvKiBmaXJzdCBzdGFuZGFyZCBwYXJhbGxlbCAgICAgICAgICAgICAgKi9cblx0ICAvL2RvdWJsZSBsYXQyOyAgICAgICAgICAgICAgICAgICAgLyogc2Vjb25kIHN0YW5kYXJkIHBhcmFsbGVsICAgICAgICAgICAgICovXG5cdCAgLy9kb3VibGUgcl9tYWo7ICAgICAgICAgICAgICAgICAgIC8qIG1ham9yIGF4aXMgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHQgIC8vZG91YmxlIHJfbWluOyAgICAgICAgICAgICAgICAgICAvKiBtaW5vciBheGlzICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblx0ICAvL2RvdWJsZSBmYWxzZV9lYXN0OyAgICAgICAgICAgICAgLyogeCBvZmZzZXQgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICovXG5cdCAgLy9kb3VibGUgZmFsc2Vfbm9ydGg7ICAgICAgICAgICAgIC8qIHkgb2Zmc2V0IGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAqL1xuXG5cdCAgaWYgKCF0aGlzLmxhdDIpIHtcblx0ICAgIHRoaXMubGF0MiA9IHRoaXMubGF0MTtcblx0ICB9IC8vaWYgbGF0MiBpcyBub3QgZGVmaW5lZFxuXHQgIGlmICghdGhpcy5rMCkge1xuXHQgICAgdGhpcy5rMCA9IDE7XG5cdCAgfVxuXHQgIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG5cdCAgdGhpcy55MCA9IHRoaXMueTAgfHwgMDtcblx0ICAvLyBTdGFuZGFyZCBQYXJhbGxlbHMgY2Fubm90IGJlIGVxdWFsIGFuZCBvbiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgZXF1YXRvclxuXHQgIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgdGVtcCA9IHRoaXMuYiAvIHRoaXMuYTtcblx0ICB0aGlzLmUgPSBNYXRoLnNxcnQoMSAtIHRlbXAgKiB0ZW1wKTtcblxuXHQgIHZhciBzaW4xID0gTWF0aC5zaW4odGhpcy5sYXQxKTtcblx0ICB2YXIgY29zMSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG5cdCAgdmFyIG1zMSA9IG1zZm56KHRoaXMuZSwgc2luMSwgY29zMSk7XG5cdCAgdmFyIHRzMSA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQxLCBzaW4xKTtcblxuXHQgIHZhciBzaW4yID0gTWF0aC5zaW4odGhpcy5sYXQyKTtcblx0ICB2YXIgY29zMiA9IE1hdGguY29zKHRoaXMubGF0Mik7XG5cdCAgdmFyIG1zMiA9IG1zZm56KHRoaXMuZSwgc2luMiwgY29zMik7XG5cdCAgdmFyIHRzMiA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQyLCBzaW4yKTtcblxuXHQgIHZhciB0czAgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MCwgTWF0aC5zaW4odGhpcy5sYXQwKSk7XG5cblx0ICBpZiAoTWF0aC5hYnModGhpcy5sYXQxIC0gdGhpcy5sYXQyKSA+IEVQU0xOKSB7XG5cdCAgICB0aGlzLm5zID0gTWF0aC5sb2cobXMxIC8gbXMyKSAvIE1hdGgubG9nKHRzMSAvIHRzMik7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdGhpcy5ucyA9IHNpbjE7XG5cdCAgfVxuXHQgIGlmIChpc05hTih0aGlzLm5zKSkge1xuXHQgICAgdGhpcy5ucyA9IHNpbjE7XG5cdCAgfVxuXHQgIHRoaXMuZjAgPSBtczEgLyAodGhpcy5ucyAqIE1hdGgucG93KHRzMSwgdGhpcy5ucykpO1xuXHQgIHRoaXMucmggPSB0aGlzLmEgKiB0aGlzLmYwICogTWF0aC5wb3codHMwLCB0aGlzLm5zKTtcblx0ICBpZiAoIXRoaXMudGl0bGUpIHtcblx0ICAgIHRoaXMudGl0bGUgPSBcIkxhbWJlcnQgQ29uZm9ybWFsIENvbmljXCI7XG5cdCAgfVxuXHR9XG5cblx0Ly8gTGFtYmVydCBDb25mb3JtYWwgY29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdGZ1bmN0aW9uIGZvcndhcmQkOShwKSB7XG5cblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cblx0ICAvLyBzaW5ndWxhciBjYXNlcyA6XG5cdCAgaWYgKE1hdGguYWJzKDIgKiBNYXRoLmFicyhsYXQpIC0gTWF0aC5QSSkgPD0gRVBTTE4pIHtcblx0ICAgIGxhdCA9IHNpZ24obGF0KSAqIChIQUxGX1BJIC0gMiAqIEVQU0xOKTtcblx0ICB9XG5cblx0ICB2YXIgY29uID0gTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpO1xuXHQgIHZhciB0cywgcmgxO1xuXHQgIGlmIChjb24gPiBFUFNMTikge1xuXHQgICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG5cdCAgICByaDEgPSB0aGlzLmEgKiB0aGlzLmYwICogTWF0aC5wb3codHMsIHRoaXMubnMpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGNvbiA9IGxhdCAqIHRoaXMubnM7XG5cdCAgICBpZiAoY29uIDw9IDApIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByaDEgPSAwO1xuXHQgIH1cblx0ICB2YXIgdGhldGEgPSB0aGlzLm5zICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblx0ICBwLnggPSB0aGlzLmswICogKHJoMSAqIE1hdGguc2luKHRoZXRhKSkgKyB0aGlzLngwO1xuXHQgIHAueSA9IHRoaXMuazAgKiAodGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKSkgKyB0aGlzLnkwO1xuXG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvLyBMYW1iZXJ0IENvbmZvcm1hbCBDb25pYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ZnVuY3Rpb24gaW52ZXJzZSQ5KHApIHtcblxuXHQgIHZhciByaDEsIGNvbiwgdHM7XG5cdCAgdmFyIGxhdCwgbG9uO1xuXHQgIHZhciB4ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5rMDtcblx0ICB2YXIgeSA9ICh0aGlzLnJoIC0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5rMCk7XG5cdCAgaWYgKHRoaXMubnMgPiAwKSB7XG5cdCAgICByaDEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdCAgICBjb24gPSAxO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHJoMSA9IC1NYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdCAgICBjb24gPSAtMTtcblx0ICB9XG5cdCAgdmFyIHRoZXRhID0gMDtcblx0ICBpZiAocmgxICE9PSAwKSB7XG5cdCAgICB0aGV0YSA9IE1hdGguYXRhbjIoKGNvbiAqIHgpLCAoY29uICogeSkpO1xuXHQgIH1cblx0ICBpZiAoKHJoMSAhPT0gMCkgfHwgKHRoaXMubnMgPiAwKSkge1xuXHQgICAgY29uID0gMSAvIHRoaXMubnM7XG5cdCAgICB0cyA9IE1hdGgucG93KChyaDEgLyAodGhpcy5hICogdGhpcy5mMCkpLCBjb24pO1xuXHQgICAgbGF0ID0gcGhpMnoodGhpcy5lLCB0cyk7XG5cdCAgICBpZiAobGF0ID09PSAtOTk5OSkge1xuXHQgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBsYXQgPSAtSEFMRl9QSTtcblx0ICB9XG5cdCAgbG9uID0gYWRqdXN0X2xvbih0aGV0YSAvIHRoaXMubnMgKyB0aGlzLmxvbmcwKTtcblxuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMTEgPSBbXCJMYW1iZXJ0IFRhbmdlbnRpYWwgQ29uZm9ybWFsIENvbmljIFByb2plY3Rpb25cIiwgXCJMYW1iZXJ0X0NvbmZvcm1hbF9Db25pY1wiLCBcIkxhbWJlcnRfQ29uZm9ybWFsX0NvbmljXzJTUFwiLCBcImxjY1wiXTtcblx0dmFyIGxjYyA9IHtcblx0ICBpbml0OiBpbml0JDEwLFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkOSxcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDksXG5cdCAgbmFtZXM6IG5hbWVzJDExXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQxMSgpIHtcblx0ICB0aGlzLmEgPSA2Mzc3Mzk3LjE1NTtcblx0ICB0aGlzLmVzID0gMC4wMDY2NzQzNzIyMzA2MTQ7XG5cdCAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuXHQgIGlmICghdGhpcy5sYXQwKSB7XG5cdCAgICB0aGlzLmxhdDAgPSAwLjg2MzkzNzk3OTczNzE5Mztcblx0ICB9XG5cdCAgaWYgKCF0aGlzLmxvbmcwKSB7XG5cdCAgICB0aGlzLmxvbmcwID0gMC43NDE3NjQ5MzIwOTc1OTAxIC0gMC4zMDgzNDE1MDExODU2NjU7XG5cdCAgfVxuXHQgIC8qIGlmIHNjYWxlIG5vdCBzZXQgZGVmYXVsdCB0byAwLjk5OTkgKi9cblx0ICBpZiAoIXRoaXMuazApIHtcblx0ICAgIHRoaXMuazAgPSAwLjk5OTk7XG5cdCAgfVxuXHQgIHRoaXMuczQ1ID0gMC43ODUzOTgxNjMzOTc0NDg7IC8qIDQ1ICovXG5cdCAgdGhpcy5zOTAgPSAyICogdGhpcy5zNDU7XG5cdCAgdGhpcy5maTAgPSB0aGlzLmxhdDA7XG5cdCAgdGhpcy5lMiA9IHRoaXMuZXM7XG5cdCAgdGhpcy5lID0gTWF0aC5zcXJ0KHRoaXMuZTIpO1xuXHQgIHRoaXMuYWxmYSA9IE1hdGguc3FydCgxICsgKHRoaXMuZTIgKiBNYXRoLnBvdyhNYXRoLmNvcyh0aGlzLmZpMCksIDQpKSAvICgxIC0gdGhpcy5lMikpO1xuXHQgIHRoaXMudXEgPSAxLjA0MjE2ODU2MzgwNDc0O1xuXHQgIHRoaXMudTAgPSBNYXRoLmFzaW4oTWF0aC5zaW4odGhpcy5maTApIC8gdGhpcy5hbGZhKTtcblx0ICB0aGlzLmcgPSBNYXRoLnBvdygoMSArIHRoaXMuZSAqIE1hdGguc2luKHRoaXMuZmkwKSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKHRoaXMuZmkwKSksIHRoaXMuYWxmYSAqIHRoaXMuZSAvIDIpO1xuXHQgIHRoaXMuayA9IE1hdGgudGFuKHRoaXMudTAgLyAyICsgdGhpcy5zNDUpIC8gTWF0aC5wb3coTWF0aC50YW4odGhpcy5maTAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpICogdGhpcy5nO1xuXHQgIHRoaXMuazEgPSB0aGlzLmswO1xuXHQgIHRoaXMubjAgPSB0aGlzLmEgKiBNYXRoLnNxcnQoMSAtIHRoaXMuZTIpIC8gKDEgLSB0aGlzLmUyICogTWF0aC5wb3coTWF0aC5zaW4odGhpcy5maTApLCAyKSk7XG5cdCAgdGhpcy5zMCA9IDEuMzcwMDgzNDYyODE1NTU7XG5cdCAgdGhpcy5uID0gTWF0aC5zaW4odGhpcy5zMCk7XG5cdCAgdGhpcy5ybzAgPSB0aGlzLmsxICogdGhpcy5uMCAvIE1hdGgudGFuKHRoaXMuczApO1xuXHQgIHRoaXMuYWQgPSB0aGlzLnM5MCAtIHRoaXMudXE7XG5cdH1cblxuXHQvKiBlbGxpcHNvaWQgKi9cblx0LyogY2FsY3VsYXRlIHh5IGZyb20gbGF0L2xvbiAqL1xuXHQvKiBDb25zdGFudHMsIGlkZW50aWNhbCB0byBpbnZlcnNlIHRyYW5zZm9ybSBmdW5jdGlvbiAqL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDEwKHApIHtcblx0ICB2YXIgZ2ZpLCB1LCBkZWx0YXYsIHMsIGQsIGVwcywgcm87XG5cdCAgdmFyIGxvbiA9IHAueDtcblx0ICB2YXIgbGF0ID0gcC55O1xuXHQgIHZhciBkZWx0YV9sb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIC8qIFRyYW5zZm9ybWF0aW9uICovXG5cdCAgZ2ZpID0gTWF0aC5wb3coKCgxICsgdGhpcy5lICogTWF0aC5zaW4obGF0KSkgLyAoMSAtIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpKSwgKHRoaXMuYWxmYSAqIHRoaXMuZSAvIDIpKTtcblx0ICB1ID0gMiAqIChNYXRoLmF0YW4odGhpcy5rICogTWF0aC5wb3coTWF0aC50YW4obGF0IC8gMiArIHRoaXMuczQ1KSwgdGhpcy5hbGZhKSAvIGdmaSkgLSB0aGlzLnM0NSk7XG5cdCAgZGVsdGF2ID0gLWRlbHRhX2xvbiAqIHRoaXMuYWxmYTtcblx0ICBzID0gTWF0aC5hc2luKE1hdGguY29zKHRoaXMuYWQpICogTWF0aC5zaW4odSkgKyBNYXRoLnNpbih0aGlzLmFkKSAqIE1hdGguY29zKHUpICogTWF0aC5jb3MoZGVsdGF2KSk7XG5cdCAgZCA9IE1hdGguYXNpbihNYXRoLmNvcyh1KSAqIE1hdGguc2luKGRlbHRhdikgLyBNYXRoLmNvcyhzKSk7XG5cdCAgZXBzID0gdGhpcy5uICogZDtcblx0ICBybyA9IHRoaXMucm8wICogTWF0aC5wb3coTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSksIHRoaXMubikgLyBNYXRoLnBvdyhNYXRoLnRhbihzIC8gMiArIHRoaXMuczQ1KSwgdGhpcy5uKTtcblx0ICBwLnkgPSBybyAqIE1hdGguY29zKGVwcykgLyAxO1xuXHQgIHAueCA9IHJvICogTWF0aC5zaW4oZXBzKSAvIDE7XG5cblx0ICBpZiAoIXRoaXMuY3plY2gpIHtcblx0ICAgIHAueSAqPSAtMTtcblx0ICAgIHAueCAqPSAtMTtcblx0ICB9XG5cdCAgcmV0dXJuIChwKTtcblx0fVxuXG5cdC8qIGNhbGN1bGF0ZSBsYXQvbG9uIGZyb20geHkgKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQxMChwKSB7XG5cdCAgdmFyIHUsIGRlbHRhdiwgcywgZCwgZXBzLCBybywgZmkxO1xuXHQgIHZhciBvaztcblxuXHQgIC8qIFRyYW5zZm9ybWF0aW9uICovXG5cdCAgLyogcmV2ZXJ0IHksIHgqL1xuXHQgIHZhciB0bXAgPSBwLng7XG5cdCAgcC54ID0gcC55O1xuXHQgIHAueSA9IHRtcDtcblx0ICBpZiAoIXRoaXMuY3plY2gpIHtcblx0ICAgIHAueSAqPSAtMTtcblx0ICAgIHAueCAqPSAtMTtcblx0ICB9XG5cdCAgcm8gPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcblx0ICBlcHMgPSBNYXRoLmF0YW4yKHAueSwgcC54KTtcblx0ICBkID0gZXBzIC8gTWF0aC5zaW4odGhpcy5zMCk7XG5cdCAgcyA9IDIgKiAoTWF0aC5hdGFuKE1hdGgucG93KHRoaXMucm8wIC8gcm8sIDEgLyB0aGlzLm4pICogTWF0aC50YW4odGhpcy5zMCAvIDIgKyB0aGlzLnM0NSkpIC0gdGhpcy5zNDUpO1xuXHQgIHUgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5hZCkgKiBNYXRoLnNpbihzKSAtIE1hdGguc2luKHRoaXMuYWQpICogTWF0aC5jb3MocykgKiBNYXRoLmNvcyhkKSk7XG5cdCAgZGVsdGF2ID0gTWF0aC5hc2luKE1hdGguY29zKHMpICogTWF0aC5zaW4oZCkgLyBNYXRoLmNvcyh1KSk7XG5cdCAgcC54ID0gdGhpcy5sb25nMCAtIGRlbHRhdiAvIHRoaXMuYWxmYTtcblx0ICBmaTEgPSB1O1xuXHQgIG9rID0gMDtcblx0ICB2YXIgaXRlciA9IDA7XG5cdCAgZG8ge1xuXHQgICAgcC55ID0gMiAqIChNYXRoLmF0YW4oTWF0aC5wb3codGhpcy5rLCAtIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coTWF0aC50YW4odSAvIDIgKyB0aGlzLnM0NSksIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihmaTEpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4oZmkxKSksIHRoaXMuZSAvIDIpKSAtIHRoaXMuczQ1KTtcblx0ICAgIGlmIChNYXRoLmFicyhmaTEgLSBwLnkpIDwgMC4wMDAwMDAwMDAxKSB7XG5cdCAgICAgIG9rID0gMTtcblx0ICAgIH1cblx0ICAgIGZpMSA9IHAueTtcblx0ICAgIGl0ZXIgKz0gMTtcblx0ICB9IHdoaWxlIChvayA9PT0gMCAmJiBpdGVyIDwgMTUpO1xuXHQgIGlmIChpdGVyID49IDE1KSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICByZXR1cm4gKHApO1xuXHR9XG5cblx0dmFyIG5hbWVzJDEyID0gW1wiS3JvdmFrXCIsIFwia3JvdmFrXCJdO1xuXHR2YXIga3JvdmFrID0ge1xuXHQgIGluaXQ6IGluaXQkMTEsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCQxMCxcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDEwLFxuXHQgIG5hbWVzOiBuYW1lcyQxMlxuXHR9O1xuXG5cdHZhciBtbGZuID0gZnVuY3Rpb24oZTAsIGUxLCBlMiwgZTMsIHBoaSkge1xuXHQgIHJldHVybiAoZTAgKiBwaGkgLSBlMSAqIE1hdGguc2luKDIgKiBwaGkpICsgZTIgKiBNYXRoLnNpbig0ICogcGhpKSAtIGUzICogTWF0aC5zaW4oNiAqIHBoaSkpO1xuXHR9O1xuXG5cdHZhciBlMGZuID0gZnVuY3Rpb24oeCkge1xuXHQgIHJldHVybiAoMSAtIDAuMjUgKiB4ICogKDEgKyB4IC8gMTYgKiAoMyArIDEuMjUgKiB4KSkpO1xuXHR9O1xuXG5cdHZhciBlMWZuID0gZnVuY3Rpb24oeCkge1xuXHQgIHJldHVybiAoMC4zNzUgKiB4ICogKDEgKyAwLjI1ICogeCAqICgxICsgMC40Njg3NSAqIHgpKSk7XG5cdH07XG5cblx0dmFyIGUyZm4gPSBmdW5jdGlvbih4KSB7XG5cdCAgcmV0dXJuICgwLjA1ODU5Mzc1ICogeCAqIHggKiAoMSArIDAuNzUgKiB4KSk7XG5cdH07XG5cblx0dmFyIGUzZm4gPSBmdW5jdGlvbih4KSB7XG5cdCAgcmV0dXJuICh4ICogeCAqIHggKiAoMzUgLyAzMDcyKSk7XG5cdH07XG5cblx0dmFyIGdOID0gZnVuY3Rpb24oYSwgZSwgc2lucGhpKSB7XG5cdCAgdmFyIHRlbXAgPSBlICogc2lucGhpO1xuXHQgIHJldHVybiBhIC8gTWF0aC5zcXJ0KDEgLSB0ZW1wICogdGVtcCk7XG5cdH07XG5cblx0dmFyIGFkanVzdF9sYXQgPSBmdW5jdGlvbih4KSB7XG5cdCAgcmV0dXJuIChNYXRoLmFicyh4KSA8IEhBTEZfUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBNYXRoLlBJKSk7XG5cdH07XG5cblx0dmFyIGltbGZuID0gZnVuY3Rpb24obWwsIGUwLCBlMSwgZTIsIGUzKSB7XG5cdCAgdmFyIHBoaTtcblx0ICB2YXIgZHBoaTtcblxuXHQgIHBoaSA9IG1sIC8gZTA7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG5cdCAgICBkcGhpID0gKG1sIC0gKGUwICogcGhpIC0gZTEgKiBNYXRoLnNpbigyICogcGhpKSArIGUyICogTWF0aC5zaW4oNCAqIHBoaSkgLSBlMyAqIE1hdGguc2luKDYgKiBwaGkpKSkgLyAoZTAgLSAyICogZTEgKiBNYXRoLmNvcygyICogcGhpKSArIDQgKiBlMiAqIE1hdGguY29zKDQgKiBwaGkpIC0gNiAqIGUzICogTWF0aC5jb3MoNiAqIHBoaSkpO1xuXHQgICAgcGhpICs9IGRwaGk7XG5cdCAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG5cdCAgICAgIHJldHVybiBwaGk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8uLnJlcG9ydEVycm9yKFwiSU1MRk4tQ09OVjpMYXRpdHVkZSBmYWlsZWQgdG8gY29udmVyZ2UgYWZ0ZXIgMTUgaXRlcmF0aW9uc1wiKTtcblx0ICByZXR1cm4gTmFOO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXQkMTIoKSB7XG5cdCAgaWYgKCF0aGlzLnNwaGVyZSkge1xuXHQgICAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG5cdCAgICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcblx0ICAgIHRoaXMuZTIgPSBlMmZuKHRoaXMuZXMpO1xuXHQgICAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cdCAgICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcblx0ICB9XG5cdH1cblxuXHQvKiBDYXNzaW5pIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuXHQgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gZm9yd2FyZCQxMShwKSB7XG5cblx0ICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuXHQgICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdCAgdmFyIHgsIHk7XG5cdCAgdmFyIGxhbSA9IHAueDtcblx0ICB2YXIgcGhpID0gcC55O1xuXHQgIGxhbSA9IGFkanVzdF9sb24obGFtIC0gdGhpcy5sb25nMCk7XG5cblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHggPSB0aGlzLmEgKiBNYXRoLmFzaW4oTWF0aC5jb3MocGhpKSAqIE1hdGguc2luKGxhbSkpO1xuXHQgICAgeSA9IHRoaXMuYSAqIChNYXRoLmF0YW4yKE1hdGgudGFuKHBoaSksIE1hdGguY29zKGxhbSkpIC0gdGhpcy5sYXQwKTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICAvL2VsbGlwc29pZFxuXHQgICAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG5cdCAgICB2YXIgY29zcGhpID0gTWF0aC5jb3MocGhpKTtcblx0ICAgIHZhciBubCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBzaW5waGkpO1xuXHQgICAgdmFyIHRsID0gTWF0aC50YW4ocGhpKSAqIE1hdGgudGFuKHBoaSk7XG5cdCAgICB2YXIgYWwgPSBsYW0gKiBNYXRoLmNvcyhwaGkpO1xuXHQgICAgdmFyIGFzcSA9IGFsICogYWw7XG5cdCAgICB2YXIgY2wgPSB0aGlzLmVzICogY29zcGhpICogY29zcGhpIC8gKDEgLSB0aGlzLmVzKTtcblx0ICAgIHZhciBtbCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgcGhpKTtcblxuXHQgICAgeCA9IG5sICogYWwgKiAoMSAtIGFzcSAqIHRsICogKDEgLyA2IC0gKDggLSB0bCArIDggKiBjbCkgKiBhc3EgLyAxMjApKTtcblx0ICAgIHkgPSBtbCAtIHRoaXMubWwwICsgbmwgKiBzaW5waGkgLyBjb3NwaGkgKiBhc3EgKiAoMC41ICsgKDUgLSB0bCArIDYgKiBjbCkgKiBhc3EgLyAyNCk7XG5cblxuXHQgIH1cblxuXHQgIHAueCA9IHggKyB0aGlzLngwO1xuXHQgIHAueSA9IHkgKyB0aGlzLnkwO1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0LyogSW52ZXJzZSBlcXVhdGlvbnNcblx0ICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGludmVyc2UkMTEocCkge1xuXHQgIHAueCAtPSB0aGlzLngwO1xuXHQgIHAueSAtPSB0aGlzLnkwO1xuXHQgIHZhciB4ID0gcC54IC8gdGhpcy5hO1xuXHQgIHZhciB5ID0gcC55IC8gdGhpcy5hO1xuXHQgIHZhciBwaGksIGxhbTtcblxuXHQgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgdmFyIGRkID0geSArIHRoaXMubGF0MDtcblx0ICAgIHBoaSA9IE1hdGguYXNpbihNYXRoLnNpbihkZCkgKiBNYXRoLmNvcyh4KSk7XG5cdCAgICBsYW0gPSBNYXRoLmF0YW4yKE1hdGgudGFuKHgpLCBNYXRoLmNvcyhkZCkpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIC8qIGVsbGlwc29pZCAqL1xuXHQgICAgdmFyIG1sMSA9IHRoaXMubWwwIC8gdGhpcy5hICsgeTtcblx0ICAgIHZhciBwaGkxID0gaW1sZm4obWwxLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcblx0ICAgIGlmIChNYXRoLmFicyhNYXRoLmFicyhwaGkxKSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG5cdCAgICAgIHAueCA9IHRoaXMubG9uZzA7XG5cdCAgICAgIHAueSA9IEhBTEZfUEk7XG5cdCAgICAgIGlmICh5IDwgMCkge1xuXHQgICAgICAgIHAueSAqPSAtMTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gcDtcblx0ICAgIH1cblx0ICAgIHZhciBubDEgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4ocGhpMSkpO1xuXG5cdCAgICB2YXIgcmwxID0gbmwxICogbmwxICogbmwxIC8gdGhpcy5hIC8gdGhpcy5hICogKDEgLSB0aGlzLmVzKTtcblx0ICAgIHZhciB0bDEgPSBNYXRoLnBvdyhNYXRoLnRhbihwaGkxKSwgMik7XG5cdCAgICB2YXIgZGwgPSB4ICogdGhpcy5hIC8gbmwxO1xuXHQgICAgdmFyIGRzcSA9IGRsICogZGw7XG5cdCAgICBwaGkgPSBwaGkxIC0gbmwxICogTWF0aC50YW4ocGhpMSkgLyBybDEgKiBkbCAqIGRsICogKDAuNSAtICgxICsgMyAqIHRsMSkgKiBkbCAqIGRsIC8gMjQpO1xuXHQgICAgbGFtID0gZGwgKiAoMSAtIGRzcSAqICh0bDEgLyAzICsgKDEgKyAzICogdGwxKSAqIHRsMSAqIGRzcSAvIDE1KSkgLyBNYXRoLmNvcyhwaGkxKTtcblxuXHQgIH1cblxuXHQgIHAueCA9IGFkanVzdF9sb24obGFtICsgdGhpcy5sb25nMCk7XG5cdCAgcC55ID0gYWRqdXN0X2xhdChwaGkpO1xuXHQgIHJldHVybiBwO1xuXG5cdH1cblxuXHR2YXIgbmFtZXMkMTMgPSBbXCJDYXNzaW5pXCIsIFwiQ2Fzc2luaV9Tb2xkbmVyXCIsIFwiY2Fzc1wiXTtcblx0dmFyIGNhc3MgPSB7XG5cdCAgaW5pdDogaW5pdCQxMixcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDExLFxuXHQgIGludmVyc2U6IGludmVyc2UkMTEsXG5cdCAgbmFtZXM6IG5hbWVzJDEzXG5cdH07XG5cblx0dmFyIHFzZm56ID0gZnVuY3Rpb24oZWNjZW50LCBzaW5waGkpIHtcblx0ICB2YXIgY29uO1xuXHQgIGlmIChlY2NlbnQgPiAxLjBlLTcpIHtcblx0ICAgIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcblx0ICAgIHJldHVybiAoKDEgLSBlY2NlbnQgKiBlY2NlbnQpICogKHNpbnBoaSAvICgxIC0gY29uICogY29uKSAtICgwLjUgLyBlY2NlbnQpICogTWF0aC5sb2coKDEgLSBjb24pIC8gKDEgKyBjb24pKSkpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHJldHVybiAoMiAqIHNpbnBoaSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qXG5cdCAgcmVmZXJlbmNlXG5cdCAgICBcIk5ldyBFcXVhbC1BcmVhIE1hcCBQcm9qZWN0aW9ucyBmb3IgTm9uY2lyY3VsYXIgUmVnaW9uc1wiLCBKb2huIFAuIFNueWRlcixcblx0ICAgIFRoZSBBbWVyaWNhbiBDYXJ0b2dyYXBoZXIsIFZvbCAxNSwgTm8uIDQsIE9jdG9iZXIgMTk4OCwgcHAuIDM0MS0zNTUuXG5cdCAgKi9cblxuXHR2YXIgU19QT0xFID0gMTtcblxuXHR2YXIgTl9QT0xFID0gMjtcblx0dmFyIEVRVUlUID0gMztcblx0dmFyIE9CTElRID0gNDtcblxuXHQvKiBJbml0aWFsaXplIHRoZSBMYW1iZXJ0IEF6aW11dGhhbCBFcXVhbCBBcmVhIHByb2plY3Rpb25cblx0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBpbml0JDEzKCkge1xuXHQgIHZhciB0ID0gTWF0aC5hYnModGhpcy5sYXQwKTtcblx0ICBpZiAoTWF0aC5hYnModCAtIEhBTEZfUEkpIDwgRVBTTE4pIHtcblx0ICAgIHRoaXMubW9kZSA9IHRoaXMubGF0MCA8IDAgPyB0aGlzLlNfUE9MRSA6IHRoaXMuTl9QT0xFO1xuXHQgIH1cblx0ICBlbHNlIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG5cdCAgICB0aGlzLm1vZGUgPSB0aGlzLkVRVUlUO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHRoaXMubW9kZSA9IHRoaXMuT0JMSVE7XG5cdCAgfVxuXHQgIGlmICh0aGlzLmVzID4gMCkge1xuXHQgICAgdmFyIHNpbnBoaTtcblxuXHQgICAgdGhpcy5xcCA9IHFzZm56KHRoaXMuZSwgMSk7XG5cdCAgICB0aGlzLm1tZiA9IDAuNSAvICgxIC0gdGhpcy5lcyk7XG5cdCAgICB0aGlzLmFwYSA9IGF1dGhzZXQodGhpcy5lcyk7XG5cdCAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuXHQgICAgY2FzZSB0aGlzLk5fUE9MRTpcblx0ICAgICAgdGhpcy5kZCA9IDE7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSB0aGlzLlNfUE9MRTpcblx0ICAgICAgdGhpcy5kZCA9IDE7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSB0aGlzLkVRVUlUOlxuXHQgICAgICB0aGlzLnJxID0gTWF0aC5zcXJ0KDAuNSAqIHRoaXMucXApO1xuXHQgICAgICB0aGlzLmRkID0gMSAvIHRoaXMucnE7XG5cdCAgICAgIHRoaXMueG1mID0gMTtcblx0ICAgICAgdGhpcy55bWYgPSAwLjUgKiB0aGlzLnFwO1xuXHQgICAgICBicmVhaztcblx0ICAgIGNhc2UgdGhpcy5PQkxJUTpcblx0ICAgICAgdGhpcy5ycSA9IE1hdGguc3FydCgwLjUgKiB0aGlzLnFwKTtcblx0ICAgICAgc2lucGhpID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcblx0ICAgICAgdGhpcy5zaW5iMSA9IHFzZm56KHRoaXMuZSwgc2lucGhpKSAvIHRoaXMucXA7XG5cdCAgICAgIHRoaXMuY29zYjEgPSBNYXRoLnNxcnQoMSAtIHRoaXMuc2luYjEgKiB0aGlzLnNpbmIxKTtcblx0ICAgICAgdGhpcy5kZCA9IE1hdGguY29zKHRoaXMubGF0MCkgLyAoTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogc2lucGhpICogc2lucGhpKSAqIHRoaXMucnEgKiB0aGlzLmNvc2IxKTtcblx0ICAgICAgdGhpcy55bWYgPSAodGhpcy54bWYgPSB0aGlzLnJxKSAvIHRoaXMuZGQ7XG5cdCAgICAgIHRoaXMueG1mICo9IHRoaXMuZGQ7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcblx0ICAgICAgdGhpcy5zaW5waDAgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuXHQgICAgICB0aGlzLmNvc3BoMCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0LyogTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGZvcndhcmQkMTIocCkge1xuXG5cdCAgLyogRm9yd2FyZCBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHZhciB4LCB5LCBjb3NsYW0sIHNpbmxhbSwgc2lucGhpLCBxLCBzaW5iLCBjb3NiLCBiLCBjb3NwaGk7XG5cdCAgdmFyIGxhbSA9IHAueDtcblx0ICB2YXIgcGhpID0gcC55O1xuXG5cdCAgbGFtID0gYWRqdXN0X2xvbihsYW0gLSB0aGlzLmxvbmcwKTtcblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHNpbnBoaSA9IE1hdGguc2luKHBoaSk7XG5cdCAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuXHQgICAgY29zbGFtID0gTWF0aC5jb3MobGFtKTtcblx0ICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG5cdCAgICAgIHkgPSAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSA/IDEgKyBjb3NwaGkgKiBjb3NsYW0gOiAxICsgdGhpcy5zaW5waDAgKiBzaW5waGkgKyB0aGlzLmNvc3BoMCAqIGNvc3BoaSAqIGNvc2xhbTtcblx0ICAgICAgaWYgKHkgPD0gRVBTTE4pIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgICB5ID0gTWF0aC5zcXJ0KDIgLyB5KTtcblx0ICAgICAgeCA9IHkgKiBjb3NwaGkgKiBNYXRoLnNpbihsYW0pO1xuXHQgICAgICB5ICo9ICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpID8gc2lucGhpIDogdGhpcy5jb3NwaDAgKiBzaW5waGkgLSB0aGlzLnNpbnBoMCAqIGNvc3BoaSAqIGNvc2xhbTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUgfHwgdGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkge1xuXHQgICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuXHQgICAgICAgIGNvc2xhbSA9IC1jb3NsYW07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKE1hdGguYWJzKHBoaSArIHRoaXMucGhpMCkgPCBFUFNMTikge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHkgPSBGT1JUUEkgLSBwaGkgKiAwLjU7XG5cdCAgICAgIHkgPSAyICogKCh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSA/IE1hdGguY29zKHkpIDogTWF0aC5zaW4oeSkpO1xuXHQgICAgICB4ID0geSAqIE1hdGguc2luKGxhbSk7XG5cdCAgICAgIHkgKj0gY29zbGFtO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHNpbmIgPSAwO1xuXHQgICAgY29zYiA9IDA7XG5cdCAgICBiID0gMDtcblx0ICAgIGNvc2xhbSA9IE1hdGguY29zKGxhbSk7XG5cdCAgICBzaW5sYW0gPSBNYXRoLnNpbihsYW0pO1xuXHQgICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcblx0ICAgIHEgPSBxc2Zueih0aGlzLmUsIHNpbnBoaSk7XG5cdCAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuXHQgICAgICBzaW5iID0gcSAvIHRoaXMucXA7XG5cdCAgICAgIGNvc2IgPSBNYXRoLnNxcnQoMSAtIHNpbmIgKiBzaW5iKTtcblx0ICAgIH1cblx0ICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG5cdCAgICBjYXNlIHRoaXMuT0JMSVE6XG5cdCAgICAgIGIgPSAxICsgdGhpcy5zaW5iMSAqIHNpbmIgKyB0aGlzLmNvc2IxICogY29zYiAqIGNvc2xhbTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICBjYXNlIHRoaXMuRVFVSVQ6XG5cdCAgICAgIGIgPSAxICsgY29zYiAqIGNvc2xhbTtcblx0ICAgICAgYnJlYWs7XG5cdCAgICBjYXNlIHRoaXMuTl9QT0xFOlxuXHQgICAgICBiID0gSEFMRl9QSSArIHBoaTtcblx0ICAgICAgcSA9IHRoaXMucXAgLSBxO1xuXHQgICAgICBicmVhaztcblx0ICAgIGNhc2UgdGhpcy5TX1BPTEU6XG5cdCAgICAgIGIgPSBwaGkgLSBIQUxGX1BJO1xuXHQgICAgICBxID0gdGhpcy5xcCArIHE7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgaWYgKE1hdGguYWJzKGIpIDwgRVBTTE4pIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuXHQgICAgY2FzZSB0aGlzLk9CTElROlxuXHQgICAgY2FzZSB0aGlzLkVRVUlUOlxuXHQgICAgICBiID0gTWF0aC5zcXJ0KDIgLyBiKTtcblx0ICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkge1xuXHQgICAgICAgIHkgPSB0aGlzLnltZiAqIGIgKiAodGhpcy5jb3NiMSAqIHNpbmIgLSB0aGlzLnNpbmIxICogY29zYiAqIGNvc2xhbSk7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSB7XG5cdCAgICAgICAgeSA9IChiID0gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc2IgKiBjb3NsYW0pKSkgKiBzaW5iICogdGhpcy55bWY7XG5cdCAgICAgIH1cblx0ICAgICAgeCA9IHRoaXMueG1mICogYiAqIGNvc2IgKiBzaW5sYW07XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSB0aGlzLk5fUE9MRTpcblx0ICAgIGNhc2UgdGhpcy5TX1BPTEU6XG5cdCAgICAgIGlmIChxID49IDApIHtcblx0ICAgICAgICB4ID0gKGIgPSBNYXRoLnNxcnQocSkpICogc2lubGFtO1xuXHQgICAgICAgIHkgPSBjb3NsYW0gKiAoKHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpID8gYiA6IC1iKTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICB4ID0geSA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcC54ID0gdGhpcy5hICogeCArIHRoaXMueDA7XG5cdCAgcC55ID0gdGhpcy5hICogeSArIHRoaXMueTA7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvKiBJbnZlcnNlIGVxdWF0aW9uc1xuXHQgIC0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQxMihwKSB7XG5cdCAgcC54IC09IHRoaXMueDA7XG5cdCAgcC55IC09IHRoaXMueTA7XG5cdCAgdmFyIHggPSBwLnggLyB0aGlzLmE7XG5cdCAgdmFyIHkgPSBwLnkgLyB0aGlzLmE7XG5cdCAgdmFyIGxhbSwgcGhpLCBjQ2UsIHNDZSwgcSwgcmhvLCBhYjtcblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHZhciBjb3N6ID0gMCxcblx0ICAgICAgcmgsIHNpbnogPSAwO1xuXG5cdCAgICByaCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0ICAgIHBoaSA9IHJoICogMC41O1xuXHQgICAgaWYgKHBoaSA+IDEpIHtcblx0ICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICBwaGkgPSAyICogTWF0aC5hc2luKHBoaSk7XG5cdCAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuXHQgICAgICBzaW56ID0gTWF0aC5zaW4ocGhpKTtcblx0ICAgICAgY29zeiA9IE1hdGguY29zKHBoaSk7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuXHQgICAgY2FzZSB0aGlzLkVRVUlUOlxuXHQgICAgICBwaGkgPSAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSA/IDAgOiBNYXRoLmFzaW4oeSAqIHNpbnogLyByaCk7XG5cdCAgICAgIHggKj0gc2luejtcblx0ICAgICAgeSA9IGNvc3ogKiByaDtcblx0ICAgICAgYnJlYWs7XG5cdCAgICBjYXNlIHRoaXMuT0JMSVE6XG5cdCAgICAgIHBoaSA9IChNYXRoLmFicyhyaCkgPD0gRVBTTE4pID8gdGhpcy5waGkwIDogTWF0aC5hc2luKGNvc3ogKiB0aGlzLnNpbnBoMCArIHkgKiBzaW56ICogdGhpcy5jb3NwaDAgLyByaCk7XG5cdCAgICAgIHggKj0gc2lueiAqIHRoaXMuY29zcGgwO1xuXHQgICAgICB5ID0gKGNvc3ogLSBNYXRoLnNpbihwaGkpICogdGhpcy5zaW5waDApICogcmg7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSB0aGlzLk5fUE9MRTpcblx0ICAgICAgeSA9IC15O1xuXHQgICAgICBwaGkgPSBIQUxGX1BJIC0gcGhpO1xuXHQgICAgICBicmVhaztcblx0ICAgIGNhc2UgdGhpcy5TX1BPTEU6XG5cdCAgICAgIHBoaSAtPSBIQUxGX1BJO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIGxhbSA9ICh5ID09PSAwICYmICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQgfHwgdGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSkgPyAwIDogTWF0aC5hdGFuMih4LCB5KTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBhYiA9IDA7XG5cdCAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5FUVVJVCkge1xuXHQgICAgICB4IC89IHRoaXMuZGQ7XG5cdCAgICAgIHkgKj0gdGhpcy5kZDtcblx0ICAgICAgcmhvID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHQgICAgICBpZiAocmhvIDwgRVBTTE4pIHtcblx0ICAgICAgICBwLnggPSAwO1xuXHQgICAgICAgIHAueSA9IHRoaXMucGhpMDtcblx0ICAgICAgICByZXR1cm4gcDtcblx0ICAgICAgfVxuXHQgICAgICBzQ2UgPSAyICogTWF0aC5hc2luKDAuNSAqIHJobyAvIHRoaXMucnEpO1xuXHQgICAgICBjQ2UgPSBNYXRoLmNvcyhzQ2UpO1xuXHQgICAgICB4ICo9IChzQ2UgPSBNYXRoLnNpbihzQ2UpKTtcblx0ICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkge1xuXHQgICAgICAgIGFiID0gY0NlICogdGhpcy5zaW5iMSArIHkgKiBzQ2UgKiB0aGlzLmNvc2IxIC8gcmhvO1xuXHQgICAgICAgIHEgPSB0aGlzLnFwICogYWI7XG5cdCAgICAgICAgeSA9IHJobyAqIHRoaXMuY29zYjEgKiBjQ2UgLSB5ICogdGhpcy5zaW5iMSAqIHNDZTtcblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICBhYiA9IHkgKiBzQ2UgLyByaG87XG5cdCAgICAgICAgcSA9IHRoaXMucXAgKiBhYjtcblx0ICAgICAgICB5ID0gcmhvICogY0NlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuTl9QT0xFIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5TX1BPTEUpIHtcblx0ICAgICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5OX1BPTEUpIHtcblx0ICAgICAgICB5ID0gLXk7XG5cdCAgICAgIH1cblx0ICAgICAgcSA9ICh4ICogeCArIHkgKiB5KTtcblx0ICAgICAgaWYgKCFxKSB7XG5cdCAgICAgICAgcC54ID0gMDtcblx0ICAgICAgICBwLnkgPSB0aGlzLnBoaTA7XG5cdCAgICAgICAgcmV0dXJuIHA7XG5cdCAgICAgIH1cblx0ICAgICAgYWIgPSAxIC0gcSAvIHRoaXMucXA7XG5cdCAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG5cdCAgICAgICAgYWIgPSAtYWI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGxhbSA9IE1hdGguYXRhbjIoeCwgeSk7XG5cdCAgICBwaGkgPSBhdXRobGF0KE1hdGguYXNpbihhYiksIHRoaXMuYXBhKTtcblx0ICB9XG5cblx0ICBwLnggPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBsYW0pO1xuXHQgIHAueSA9IHBoaTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qIGRldGVybWluZSBsYXRpdHVkZSBmcm9tIGF1dGhhbGljIGxhdGl0dWRlICovXG5cdHZhciBQMDAgPSAwLjMzMzMzMzMzMzMzMzMzMzMzMzMzO1xuXG5cdHZhciBQMDEgPSAwLjE3MjIyMjIyMjIyMjIyMjIyMjIyO1xuXHR2YXIgUDAyID0gMC4xMDI1NzkzNjUwNzkzNjUwNzkzNjtcblx0dmFyIFAxMCA9IDAuMDYzODg4ODg4ODg4ODg4ODg4ODg7XG5cdHZhciBQMTEgPSAwLjA2NjQwMjExNjQwMjExNjQwMjExO1xuXHR2YXIgUDIwID0gMC4wMTY0MTUwMTI5NDIxOTE1NDQ0MztcblxuXHRmdW5jdGlvbiBhdXRoc2V0KGVzKSB7XG5cdCAgdmFyIHQ7XG5cdCAgdmFyIEFQQSA9IFtdO1xuXHQgIEFQQVswXSA9IGVzICogUDAwO1xuXHQgIHQgPSBlcyAqIGVzO1xuXHQgIEFQQVswXSArPSB0ICogUDAxO1xuXHQgIEFQQVsxXSA9IHQgKiBQMTA7XG5cdCAgdCAqPSBlcztcblx0ICBBUEFbMF0gKz0gdCAqIFAwMjtcblx0ICBBUEFbMV0gKz0gdCAqIFAxMTtcblx0ICBBUEFbMl0gPSB0ICogUDIwO1xuXHQgIHJldHVybiBBUEE7XG5cdH1cblxuXHRmdW5jdGlvbiBhdXRobGF0KGJldGEsIEFQQSkge1xuXHQgIHZhciB0ID0gYmV0YSArIGJldGE7XG5cdCAgcmV0dXJuIChiZXRhICsgQVBBWzBdICogTWF0aC5zaW4odCkgKyBBUEFbMV0gKiBNYXRoLnNpbih0ICsgdCkgKyBBUEFbMl0gKiBNYXRoLnNpbih0ICsgdCArIHQpKTtcblx0fVxuXG5cdHZhciBuYW1lcyQxNCA9IFtcIkxhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWFcIiwgXCJMYW1iZXJ0X0F6aW11dGhhbF9FcXVhbF9BcmVhXCIsIFwibGFlYVwiXTtcblx0dmFyIGxhZWEgPSB7XG5cdCAgaW5pdDogaW5pdCQxMyxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDEyLFxuXHQgIGludmVyc2U6IGludmVyc2UkMTIsXG5cdCAgbmFtZXM6IG5hbWVzJDE0LFxuXHQgIFNfUE9MRTogU19QT0xFLFxuXHQgIE5fUE9MRTogTl9QT0xFLFxuXHQgIEVRVUlUOiBFUVVJVCxcblx0ICBPQkxJUTogT0JMSVFcblx0fTtcblxuXHR2YXIgYXNpbnogPSBmdW5jdGlvbih4KSB7XG5cdCAgaWYgKE1hdGguYWJzKHgpID4gMSkge1xuXHQgICAgeCA9ICh4ID4gMSkgPyAxIDogLTE7XG5cdCAgfVxuXHQgIHJldHVybiBNYXRoLmFzaW4oeCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQxNCgpIHtcblxuXHQgIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuXHQgIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcblx0ICB0aGlzLmUzID0gTWF0aC5zcXJ0KHRoaXMuZXMpO1xuXG5cdCAgdGhpcy5zaW5fcG8gPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuXHQgIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcblx0ICB0aGlzLnQxID0gdGhpcy5zaW5fcG87XG5cdCAgdGhpcy5jb24gPSB0aGlzLnNpbl9wbztcblx0ICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG5cdCAgdGhpcy5xczEgPSBxc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9wbywgdGhpcy5jb3NfcG8pO1xuXG5cdCAgdGhpcy5zaW5fcG8gPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuXHQgIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcblx0ICB0aGlzLnQyID0gdGhpcy5zaW5fcG87XG5cdCAgdGhpcy5tczIgPSBtc2Zueih0aGlzLmUzLCB0aGlzLnNpbl9wbywgdGhpcy5jb3NfcG8pO1xuXHQgIHRoaXMucXMyID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuXHQgIHRoaXMuc2luX3BvID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcblx0ICB0aGlzLmNvc19wbyA9IE1hdGguY29zKHRoaXMubGF0MCk7XG5cdCAgdGhpcy50MyA9IHRoaXMuc2luX3BvO1xuXHQgIHRoaXMucXMwID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuXHQgIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpID4gRVBTTE4pIHtcblx0ICAgIHRoaXMubnMwID0gKHRoaXMubXMxICogdGhpcy5tczEgLSB0aGlzLm1zMiAqIHRoaXMubXMyKSAvICh0aGlzLnFzMiAtIHRoaXMucXMxKTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB0aGlzLm5zMCA9IHRoaXMuY29uO1xuXHQgIH1cblx0ICB0aGlzLmMgPSB0aGlzLm1zMSAqIHRoaXMubXMxICsgdGhpcy5uczAgKiB0aGlzLnFzMTtcblx0ICB0aGlzLnJoID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogdGhpcy5xczApIC8gdGhpcy5uczA7XG5cdH1cblxuXHQvKiBBbGJlcnMgQ29uaWNhbCBFcXVhbCBBcmVhIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuXHQgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDEzKHApIHtcblxuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblxuXHQgIHRoaXMuc2luX3BoaSA9IE1hdGguc2luKGxhdCk7XG5cdCAgdGhpcy5jb3NfcGhpID0gTWF0aC5jb3MobGF0KTtcblxuXHQgIHZhciBxcyA9IHFzZm56KHRoaXMuZTMsIHRoaXMuc2luX3BoaSwgdGhpcy5jb3NfcGhpKTtcblx0ICB2YXIgcmgxID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogcXMpIC8gdGhpcy5uczA7XG5cdCAgdmFyIHRoZXRhID0gdGhpcy5uczAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciB4ID0gcmgxICogTWF0aC5zaW4odGhldGEpICsgdGhpcy54MDtcblx0ICB2YXIgeSA9IHRoaXMucmggLSByaDEgKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLnkwO1xuXG5cdCAgcC54ID0geDtcblx0ICBwLnkgPSB5O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW52ZXJzZSQxMyhwKSB7XG5cdCAgdmFyIHJoMSwgcXMsIGNvbiwgdGhldGEsIGxvbiwgbGF0O1xuXG5cdCAgcC54IC09IHRoaXMueDA7XG5cdCAgcC55ID0gdGhpcy5yaCAtIHAueSArIHRoaXMueTA7XG5cdCAgaWYgKHRoaXMubnMwID49IDApIHtcblx0ICAgIHJoMSA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuXHQgICAgY29uID0gMTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICByaDEgPSAtTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgICBjb24gPSAtMTtcblx0ICB9XG5cdCAgdGhldGEgPSAwO1xuXHQgIGlmIChyaDEgIT09IDApIHtcblx0ICAgIHRoZXRhID0gTWF0aC5hdGFuMihjb24gKiBwLngsIGNvbiAqIHAueSk7XG5cdCAgfVxuXHQgIGNvbiA9IHJoMSAqIHRoaXMubnMwIC8gdGhpcy5hO1xuXHQgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgbGF0ID0gTWF0aC5hc2luKCh0aGlzLmMgLSBjb24gKiBjb24pIC8gKDIgKiB0aGlzLm5zMCkpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHFzID0gKHRoaXMuYyAtIGNvbiAqIGNvbikgLyB0aGlzLm5zMDtcblx0ICAgIGxhdCA9IHRoaXMucGhpMXoodGhpcy5lMywgcXMpO1xuXHQgIH1cblxuXHQgIGxvbiA9IGFkanVzdF9sb24odGhldGEgLyB0aGlzLm5zMCArIHRoaXMubG9uZzApO1xuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvKiBGdW5jdGlvbiB0byBjb21wdXRlIHBoaTEsIHRoZSBsYXRpdHVkZSBmb3IgdGhlIGludmVyc2Ugb2YgdGhlXG5cdCAgIEFsYmVycyBDb25pY2FsIEVxdWFsLUFyZWEgcHJvamVjdGlvbi5cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIHBoaTF6KGVjY2VudCwgcXMpIHtcblx0ICB2YXIgc2lucGhpLCBjb3NwaGksIGNvbiwgY29tLCBkcGhpO1xuXHQgIHZhciBwaGkgPSBhc2lueigwLjUgKiBxcyk7XG5cdCAgaWYgKGVjY2VudCA8IEVQU0xOKSB7XG5cdCAgICByZXR1cm4gcGhpO1xuXHQgIH1cblxuXHQgIHZhciBlY2NudHMgPSBlY2NlbnQgKiBlY2NlbnQ7XG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMjU7IGkrKykge1xuXHQgICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcblx0ICAgIGNvc3BoaSA9IE1hdGguY29zKHBoaSk7XG5cdCAgICBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG5cdCAgICBjb20gPSAxIC0gY29uICogY29uO1xuXHQgICAgZHBoaSA9IDAuNSAqIGNvbSAqIGNvbSAvIGNvc3BoaSAqIChxcyAvICgxIC0gZWNjbnRzKSAtIHNpbnBoaSAvIGNvbSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuXHQgICAgcGhpID0gcGhpICsgZHBoaTtcblx0ICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAxZS03KSB7XG5cdCAgICAgIHJldHVybiBwaGk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG5hbWVzJDE1ID0gW1wiQWxiZXJzX0NvbmljX0VxdWFsX0FyZWFcIiwgXCJBbGJlcnNcIiwgXCJhZWFcIl07XG5cdHZhciBhZWEgPSB7XG5cdCAgaW5pdDogaW5pdCQxNCxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDEzLFxuXHQgIGludmVyc2U6IGludmVyc2UkMTMsXG5cdCAgbmFtZXM6IG5hbWVzJDE1LFxuXHQgIHBoaTF6OiBwaGkxelxuXHR9O1xuXG5cdC8qXG5cdCAgcmVmZXJlbmNlOlxuXHQgICAgV29sZnJhbSBNYXRod29ybGQgXCJHbm9tb25pYyBQcm9qZWN0aW9uXCJcblx0ICAgIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vR25vbW9uaWNQcm9qZWN0aW9uLmh0bWxcblx0ICAgIEFjY2Vzc2VkOiAxMnRoIE5vdmVtYmVyIDIwMDlcblx0ICAqL1xuXHRmdW5jdGlvbiBpbml0JDE1KCkge1xuXG5cdCAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuXHQgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ICB0aGlzLnNpbl9wMTQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuXHQgIHRoaXMuY29zX3AxNCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG5cdCAgLy8gQXBwcm94aW1hdGlvbiBmb3IgcHJvamVjdGluZyBwb2ludHMgdG8gdGhlIGhvcml6b24gKGluZmluaXR5KVxuXHQgIHRoaXMuaW5maW5pdHlfZGlzdCA9IDEwMDAgKiB0aGlzLmE7XG5cdCAgdGhpcy5yYyA9IDE7XG5cdH1cblxuXHQvKiBHbm9tb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGZvcndhcmQkMTQocCkge1xuXHQgIHZhciBzaW5waGksIGNvc3BoaTsgLyogc2luIGFuZCBjb3MgdmFsdWUgICAgICAgICovXG5cdCAgdmFyIGRsb247IC8qIGRlbHRhIGxvbmdpdHVkZSB2YWx1ZSAgICAgICovXG5cdCAgdmFyIGNvc2xvbjsgLyogY29zIG9mIGxvbmdpdHVkZSAgICAgICAgKi9cblx0ICB2YXIga3NwOyAvKiBzY2FsZSBmYWN0b3IgICAgICAgICAgKi9cblx0ICB2YXIgZztcblx0ICB2YXIgeCwgeTtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cdCAgLyogRm9yd2FyZCBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXG5cdCAgc2lucGhpID0gTWF0aC5zaW4obGF0KTtcblx0ICBjb3NwaGkgPSBNYXRoLmNvcyhsYXQpO1xuXG5cdCAgY29zbG9uID0gTWF0aC5jb3MoZGxvbik7XG5cdCAgZyA9IHRoaXMuc2luX3AxNCAqIHNpbnBoaSArIHRoaXMuY29zX3AxNCAqIGNvc3BoaSAqIGNvc2xvbjtcblx0ICBrc3AgPSAxO1xuXHQgIGlmICgoZyA+IDApIHx8IChNYXRoLmFicyhnKSA8PSBFUFNMTikpIHtcblx0ICAgIHggPSB0aGlzLngwICsgdGhpcy5hICoga3NwICogY29zcGhpICogTWF0aC5zaW4oZGxvbikgLyBnO1xuXHQgICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBrc3AgKiAodGhpcy5jb3NfcDE0ICogc2lucGhpIC0gdGhpcy5zaW5fcDE0ICogY29zcGhpICogY29zbG9uKSAvIGc7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXG5cdCAgICAvLyBQb2ludCBpcyBpbiB0aGUgb3Bwb3NpbmcgaGVtaXNwaGVyZSBhbmQgaXMgdW5wcm9qZWN0YWJsZVxuXHQgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byByZXR1cm4gYSByZWFzb25hYmxlIHBvaW50LCBzbyB3ZSBwcm9qZWN0XG5cdCAgICAvLyB0byBpbmZpbml0eSwgb24gYSBiZWFyaW5nXG5cdCAgICAvLyBlcXVpdmFsZW50IHRvIHRoZSBub3J0aGVybiBoZW1pc3BoZXJlIGVxdWl2YWxlbnRcblx0ICAgIC8vIFRoaXMgaXMgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb24gZm9yIHNob3J0IHNoYXBlcyBhbmQgbGluZXMgdGhhdFxuXHQgICAgLy8gc3RyYWRkbGUgdGhlIGhvcml6b24uXG5cblx0ICAgIHggPSB0aGlzLngwICsgdGhpcy5pbmZpbml0eV9kaXN0ICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG5cdCAgICB5ID0gdGhpcy55MCArIHRoaXMuaW5maW5pdHlfZGlzdCAqICh0aGlzLmNvc19wMTQgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTQgKiBjb3NwaGkgKiBjb3Nsb24pO1xuXG5cdCAgfVxuXHQgIHAueCA9IHg7XG5cdCAgcC55ID0geTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmVyc2UkMTQocCkge1xuXHQgIHZhciByaDsgLyogUmhvICovXG5cdCAgdmFyIHNpbmMsIGNvc2M7XG5cdCAgdmFyIGM7XG5cdCAgdmFyIGxvbiwgbGF0O1xuXG5cdCAgLyogSW52ZXJzZSBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHAueCA9IChwLnggLSB0aGlzLngwKSAvIHRoaXMuYTtcblx0ICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cblx0ICBwLnggLz0gdGhpcy5rMDtcblx0ICBwLnkgLz0gdGhpcy5rMDtcblxuXHQgIGlmICgocmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSkpIHtcblx0ICAgIGMgPSBNYXRoLmF0YW4yKHJoLCB0aGlzLnJjKTtcblx0ICAgIHNpbmMgPSBNYXRoLnNpbihjKTtcblx0ICAgIGNvc2MgPSBNYXRoLmNvcyhjKTtcblxuXHQgICAgbGF0ID0gYXNpbnooY29zYyAqIHRoaXMuc2luX3AxNCArIChwLnkgKiBzaW5jICogdGhpcy5jb3NfcDE0KSAvIHJoKTtcblx0ICAgIGxvbiA9IE1hdGguYXRhbjIocC54ICogc2luYywgcmggKiB0aGlzLmNvc19wMTQgKiBjb3NjIC0gcC55ICogdGhpcy5zaW5fcDE0ICogc2luYyk7XG5cdCAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBsb24pO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGxhdCA9IHRoaXMucGhpYzA7XG5cdCAgICBsb24gPSAwO1xuXHQgIH1cblxuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMTYgPSBbXCJnbm9tXCJdO1xuXHR2YXIgZ25vbSA9IHtcblx0ICBpbml0OiBpbml0JDE1LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMTQsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxNCxcblx0ICBuYW1lczogbmFtZXMkMTZcblx0fTtcblxuXHR2YXIgaXFzZm56ID0gZnVuY3Rpb24oZWNjZW50LCBxKSB7XG5cdCAgdmFyIHRlbXAgPSAxIC0gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC8gKDIgKiBlY2NlbnQpICogTWF0aC5sb2coKDEgLSBlY2NlbnQpIC8gKDEgKyBlY2NlbnQpKTtcblx0ICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocSkgLSB0ZW1wKSA8IDEuMEUtNikge1xuXHQgICAgaWYgKHEgPCAwKSB7XG5cdCAgICAgIHJldHVybiAoLTEgKiBIQUxGX1BJKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICByZXR1cm4gSEFMRl9QSTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy92YXIgcGhpID0gMC41KiBxLygxLWVjY2VudCplY2NlbnQpO1xuXHQgIHZhciBwaGkgPSBNYXRoLmFzaW4oMC41ICogcSk7XG5cdCAgdmFyIGRwaGk7XG5cdCAgdmFyIHNpbl9waGk7XG5cdCAgdmFyIGNvc19waGk7XG5cdCAgdmFyIGNvbjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDMwOyBpKyspIHtcblx0ICAgIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuXHQgICAgY29zX3BoaSA9IE1hdGguY29zKHBoaSk7XG5cdCAgICBjb24gPSBlY2NlbnQgKiBzaW5fcGhpO1xuXHQgICAgZHBoaSA9IE1hdGgucG93KDEgLSBjb24gKiBjb24sIDIpIC8gKDIgKiBjb3NfcGhpKSAqIChxIC8gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC0gc2luX3BoaSAvICgxIC0gY29uICogY29uKSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuXHQgICAgcGhpICs9IGRwaGk7XG5cdCAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG5cdCAgICAgIHJldHVybiBwaGk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy9jb25zb2xlLmxvZyhcIklRU0ZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDMwIGl0ZXJhdGlvbnNcIik7XG5cdCAgcmV0dXJuIE5hTjtcblx0fTtcblxuXHQvKlxuXHQgIHJlZmVyZW5jZTpcblx0ICAgIFwiQ2FydG9ncmFwaGljIFByb2plY3Rpb24gUHJvY2VkdXJlcyBmb3IgdGhlIFVOSVggRW52aXJvbm1lbnQtXG5cdCAgICBBIFVzZXIncyBNYW51YWxcIiBieSBHZXJhbGQgSS4gRXZlbmRlbixcblx0ICAgIFVTR1MgT3BlbiBGaWxlIFJlcG9ydCA5MC0yODRhbmQgUmVsZWFzZSA0IEludGVyaW0gUmVwb3J0cyAoMjAwMylcblx0Ki9cblx0ZnVuY3Rpb24gaW5pdCQxNigpIHtcblx0ICAvL25vLW9wXG5cdCAgaWYgKCF0aGlzLnNwaGVyZSkge1xuXHQgICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuXHQgIH1cblx0fVxuXG5cdC8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG5cdCAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDE1KHApIHtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cdCAgdmFyIHgsIHk7XG5cdCAgLyogRm9yd2FyZCBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogZGxvbiAqIE1hdGguY29zKHRoaXMubGF0X3RzKTtcblx0ICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5zaW4obGF0KSAvIE1hdGguY29zKHRoaXMubGF0X3RzKTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB2YXIgcXMgPSBxc2Zueih0aGlzLmUsIE1hdGguc2luKGxhdCkpO1xuXHQgICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiB0aGlzLmswICogZGxvbjtcblx0ICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogcXMgKiAwLjUgLyB0aGlzLmswO1xuXHQgIH1cblxuXHQgIHAueCA9IHg7XG5cdCAgcC55ID0geTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG5cdCAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBpbnZlcnNlJDE1KHApIHtcblx0ICBwLnggLT0gdGhpcy54MDtcblx0ICBwLnkgLT0gdGhpcy55MDtcblx0ICB2YXIgbG9uLCBsYXQ7XG5cblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChwLnggLyB0aGlzLmEpIC8gTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcblx0ICAgIGxhdCA9IE1hdGguYXNpbigocC55IC8gdGhpcy5hKSAqIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgbGF0ID0gaXFzZm56KHRoaXMuZSwgMiAqIHAueSAqIHRoaXMuazAgLyB0aGlzLmEpO1xuXHQgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgcC54IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcblx0ICB9XG5cblx0ICBwLnggPSBsb247XG5cdCAgcC55ID0gbGF0O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDE3ID0gW1wiY2VhXCJdO1xuXHR2YXIgY2VhID0ge1xuXHQgIGluaXQ6IGluaXQkMTYsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCQxNSxcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDE1LFxuXHQgIG5hbWVzOiBuYW1lcyQxN1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXQkMTcoKSB7XG5cblx0ICB0aGlzLngwID0gdGhpcy54MCB8fCAwO1xuXHQgIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG5cdCAgdGhpcy5sYXQwID0gdGhpcy5sYXQwIHx8IDA7XG5cdCAgdGhpcy5sb25nMCA9IHRoaXMubG9uZzAgfHwgMDtcblx0ICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG5cdCAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGUgfHwgXCJFcXVpZGlzdGFudCBDeWxpbmRyaWNhbCAoUGxhdGUgQ2FycmUpXCI7XG5cblx0ICB0aGlzLnJjID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuXHR9XG5cblx0Ly8gZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdGZ1bmN0aW9uIGZvcndhcmQkMTYocCkge1xuXG5cdCAgdmFyIGxvbiA9IHAueDtcblx0ICB2YXIgbGF0ID0gcC55O1xuXG5cdCAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciBkbGF0ID0gYWRqdXN0X2xhdChsYXQgLSB0aGlzLmxhdDApO1xuXHQgIHAueCA9IHRoaXMueDAgKyAodGhpcy5hICogZGxvbiAqIHRoaXMucmMpO1xuXHQgIHAueSA9IHRoaXMueTAgKyAodGhpcy5hICogZGxhdCk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvLyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ZnVuY3Rpb24gaW52ZXJzZSQxNihwKSB7XG5cblx0ICB2YXIgeCA9IHAueDtcblx0ICB2YXIgeSA9IHAueTtcblxuXHQgIHAueCA9IGFkanVzdF9sb24odGhpcy5sb25nMCArICgoeCAtIHRoaXMueDApIC8gKHRoaXMuYSAqIHRoaXMucmMpKSk7XG5cdCAgcC55ID0gYWRqdXN0X2xhdCh0aGlzLmxhdDAgKyAoKHkgLSB0aGlzLnkwKSAvICh0aGlzLmEpKSk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMTggPSBbXCJFcXVpcmVjdGFuZ3VsYXJcIiwgXCJFcXVpZGlzdGFudF9DeWxpbmRyaWNhbFwiLCBcImVxY1wiXTtcblx0dmFyIGVxYyA9IHtcblx0ICBpbml0OiBpbml0JDE3LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMTYsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxNixcblx0ICBuYW1lczogbmFtZXMkMThcblx0fTtcblxuXHR2YXIgTUFYX0lURVIkMiA9IDIwO1xuXG5cdGZ1bmN0aW9uIGluaXQkMTgoKSB7XG5cdCAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuXHQgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG5cdCAgdGhpcy5lcyA9IDEgLSBNYXRoLnBvdyh0aGlzLnRlbXAsIDIpOyAvLyBkZXZhaXQgZXRyZSBkYW5zIHRtZXJjLmpzIG1haXMgbiB5IGVzdCBwYXMgZG9uYyBqZSBjb21tZW50ZSBzaW5vbiByZXRvdXIgZGUgdmFsZXVycyBudWxsZXNcblx0ICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG5cdCAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5tbDAgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MCk7IC8vc2kgcXVlIGRlcyB6ZXJvcyBsZSBjYWxjdWwgbmUgc2UgZmFpdCBwYXNcblx0fVxuXG5cdC8qIFBvbHljb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGZvcndhcmQkMTcocCkge1xuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblx0ICB2YXIgeCwgeSwgZWw7XG5cdCAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIGVsID0gZGxvbiAqIE1hdGguc2luKGxhdCk7XG5cdCAgaWYgKHRoaXMuc3BoZXJlKSB7XG5cdCAgICBpZiAoTWF0aC5hYnMobGF0KSA8PSBFUFNMTikge1xuXHQgICAgICB4ID0gdGhpcy5hICogZGxvbjtcblx0ICAgICAgeSA9IC0xICogdGhpcy5hICogdGhpcy5sYXQwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHggPSB0aGlzLmEgKiBNYXRoLnNpbihlbCkgLyBNYXRoLnRhbihsYXQpO1xuXHQgICAgICB5ID0gdGhpcy5hICogKGFkanVzdF9sYXQobGF0IC0gdGhpcy5sYXQwKSArICgxIC0gTWF0aC5jb3MoZWwpKSAvIE1hdGgudGFuKGxhdCkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG5cdCAgICAgIHggPSB0aGlzLmEgKiBkbG9uO1xuXHQgICAgICB5ID0gLTEgKiB0aGlzLm1sMDtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICB2YXIgbmwgPSBnTih0aGlzLmEsIHRoaXMuZSwgTWF0aC5zaW4obGF0KSkgLyBNYXRoLnRhbihsYXQpO1xuXHQgICAgICB4ID0gbmwgKiBNYXRoLnNpbihlbCk7XG5cdCAgICAgIHkgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCkgLSB0aGlzLm1sMCArIG5sICogKDEgLSBNYXRoLmNvcyhlbCkpO1xuXHQgICAgfVxuXG5cdCAgfVxuXHQgIHAueCA9IHggKyB0aGlzLngwO1xuXHQgIHAueSA9IHkgKyB0aGlzLnkwO1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0LyogSW52ZXJzZSBlcXVhdGlvbnNcblx0ICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGludmVyc2UkMTcocCkge1xuXHQgIHZhciBsb24sIGxhdCwgeCwgeSwgaTtcblx0ICB2YXIgYWwsIGJsO1xuXHQgIHZhciBwaGksIGRwaGk7XG5cdCAgeCA9IHAueCAtIHRoaXMueDA7XG5cdCAgeSA9IHAueSAtIHRoaXMueTA7XG5cblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIGlmIChNYXRoLmFicyh5ICsgdGhpcy5hICogdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuXHQgICAgICBsb24gPSBhZGp1c3RfbG9uKHggLyB0aGlzLmEgKyB0aGlzLmxvbmcwKTtcblx0ICAgICAgbGF0ID0gMDtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICBhbCA9IHRoaXMubGF0MCArIHkgLyB0aGlzLmE7XG5cdCAgICAgIGJsID0geCAqIHggLyB0aGlzLmEgLyB0aGlzLmEgKyBhbCAqIGFsO1xuXHQgICAgICBwaGkgPSBhbDtcblx0ICAgICAgdmFyIHRhbnBoaTtcblx0ICAgICAgZm9yIChpID0gTUFYX0lURVIkMjsgaTsgLS1pKSB7XG5cdCAgICAgICAgdGFucGhpID0gTWF0aC50YW4ocGhpKTtcblx0ICAgICAgICBkcGhpID0gLTEgKiAoYWwgKiAocGhpICogdGFucGhpICsgMSkgLSBwaGkgLSAwLjUgKiAocGhpICogcGhpICsgYmwpICogdGFucGhpKSAvICgocGhpIC0gYWwpIC8gdGFucGhpIC0gMSk7XG5cdCAgICAgICAgcGhpICs9IGRwaGk7XG5cdCAgICAgICAgaWYgKE1hdGguYWJzKGRwaGkpIDw9IEVQU0xOKSB7XG5cdCAgICAgICAgICBsYXQgPSBwaGk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKE1hdGguYXNpbih4ICogTWF0aC50YW4ocGhpKSAvIHRoaXMuYSkpIC8gTWF0aC5zaW4obGF0KSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgaWYgKE1hdGguYWJzKHkgKyB0aGlzLm1sMCkgPD0gRVBTTE4pIHtcblx0ICAgICAgbGF0ID0gMDtcblx0ICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvIHRoaXMuYSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblxuXHQgICAgICBhbCA9ICh0aGlzLm1sMCArIHkpIC8gdGhpcy5hO1xuXHQgICAgICBibCA9IHggKiB4IC8gdGhpcy5hIC8gdGhpcy5hICsgYWwgKiBhbDtcblx0ICAgICAgcGhpID0gYWw7XG5cdCAgICAgIHZhciBjbCwgbWxuLCBtbG5wLCBtYTtcblx0ICAgICAgdmFyIGNvbjtcblx0ICAgICAgZm9yIChpID0gTUFYX0lURVIkMjsgaTsgLS1pKSB7XG5cdCAgICAgICAgY29uID0gdGhpcy5lICogTWF0aC5zaW4ocGhpKTtcblx0ICAgICAgICBjbCA9IE1hdGguc3FydCgxIC0gY29uICogY29uKSAqIE1hdGgudGFuKHBoaSk7XG5cdCAgICAgICAgbWxuID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBwaGkpO1xuXHQgICAgICAgIG1sbnAgPSB0aGlzLmUwIC0gMiAqIHRoaXMuZTEgKiBNYXRoLmNvcygyICogcGhpKSArIDQgKiB0aGlzLmUyICogTWF0aC5jb3MoNCAqIHBoaSkgLSA2ICogdGhpcy5lMyAqIE1hdGguY29zKDYgKiBwaGkpO1xuXHQgICAgICAgIG1hID0gbWxuIC8gdGhpcy5hO1xuXHQgICAgICAgIGRwaGkgPSAoYWwgKiAoY2wgKiBtYSArIDEpIC0gbWEgLSAwLjUgKiBjbCAqIChtYSAqIG1hICsgYmwpKSAvICh0aGlzLmVzICogTWF0aC5zaW4oMiAqIHBoaSkgKiAobWEgKiBtYSArIGJsIC0gMiAqIGFsICogbWEpIC8gKDQgKiBjbCkgKyAoYWwgLSBtYSkgKiAoY2wgKiBtbG5wIC0gMiAvIE1hdGguc2luKDIgKiBwaGkpKSAtIG1sbnApO1xuXHQgICAgICAgIHBoaSAtPSBkcGhpO1xuXHQgICAgICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSBFUFNMTikge1xuXHQgICAgICAgICAgbGF0ID0gcGhpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgLy9sYXQ9cGhpNHoodGhpcy5lLHRoaXMuZTAsdGhpcy5lMSx0aGlzLmUyLHRoaXMuZTMsYWwsYmwsMCwwKTtcblx0ICAgICAgY2wgPSBNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBNYXRoLnBvdyhNYXRoLnNpbihsYXQpLCAyKSkgKiBNYXRoLnRhbihsYXQpO1xuXHQgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmFzaW4oeCAqIGNsIC8gdGhpcy5hKSAvIE1hdGguc2luKGxhdCkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMTkgPSBbXCJQb2x5Y29uaWNcIiwgXCJwb2x5XCJdO1xuXHR2YXIgcG9seSA9IHtcblx0ICBpbml0OiBpbml0JDE4LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMTcsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxNyxcblx0ICBuYW1lczogbmFtZXMkMTlcblx0fTtcblxuXHQvKlxuXHQgIHJlZmVyZW5jZVxuXHQgICAgRGVwYXJ0bWVudCBvZiBMYW5kIGFuZCBTdXJ2ZXkgVGVjaG5pY2FsIENpcmN1bGFyIDE5NzMvMzJcblx0ICAgICAgaHR0cDovL3d3dy5saW56LmdvdnQubnovZG9jcy9taXNjZWxsYW5lb3VzL256LW1hcC1kZWZpbml0aW9uLnBkZlxuXHQgICAgT1NHIFRlY2huaWNhbCBSZXBvcnQgNC4xXG5cdCAgICAgIGh0dHA6Ly93d3cubGluei5nb3Z0Lm56L2RvY3MvbWlzY2VsbGFuZW91cy9uem1nLnBkZlxuXHQgICovXG5cblx0LyoqXG5cdCAqIGl0ZXJhdGlvbnM6IE51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJlZmluZSBpbnZlcnNlIHRyYW5zZm9ybS5cblx0ICogICAgIDAgLT4ga20gYWNjdXJhY3lcblx0ICogICAgIDEgLT4gbSBhY2N1cmFjeSAtLSBzdWl0YWJsZSBmb3IgbW9zdCBtYXBwaW5nIGFwcGxpY2F0aW9uc1xuXHQgKiAgICAgMiAtPiBtbSBhY2N1cmFjeVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGluaXQkMTkoKSB7XG5cdCAgdGhpcy5BID0gW107XG5cdCAgdGhpcy5BWzFdID0gMC42Mzk5MTc1MDczO1xuXHQgIHRoaXMuQVsyXSA9IC0wLjEzNTg3OTc2MTM7XG5cdCAgdGhpcy5BWzNdID0gMC4wNjMyOTQ0MDk7XG5cdCAgdGhpcy5BWzRdID0gLTAuMDI1MjY4NTM7XG5cdCAgdGhpcy5BWzVdID0gMC4wMTE3ODc5O1xuXHQgIHRoaXMuQVs2XSA9IC0wLjAwNTUxNjE7XG5cdCAgdGhpcy5BWzddID0gMC4wMDI2OTA2O1xuXHQgIHRoaXMuQVs4XSA9IC0wLjAwMTMzMztcblx0ICB0aGlzLkFbOV0gPSAwLjAwMDY3O1xuXHQgIHRoaXMuQVsxMF0gPSAtMC4wMDAzNDtcblxuXHQgIHRoaXMuQl9yZSA9IFtdO1xuXHQgIHRoaXMuQl9pbSA9IFtdO1xuXHQgIHRoaXMuQl9yZVsxXSA9IDAuNzU1Nzg1MzIyODtcblx0ICB0aGlzLkJfaW1bMV0gPSAwO1xuXHQgIHRoaXMuQl9yZVsyXSA9IDAuMjQ5MjA0NjQ2O1xuXHQgIHRoaXMuQl9pbVsyXSA9IDAuMDAzMzcxNTA3O1xuXHQgIHRoaXMuQl9yZVszXSA9IC0wLjAwMTU0MTczOTtcblx0ICB0aGlzLkJfaW1bM10gPSAwLjA0MTA1ODU2MDtcblx0ICB0aGlzLkJfcmVbNF0gPSAtMC4xMDE2MjkwNztcblx0ICB0aGlzLkJfaW1bNF0gPSAwLjAxNzI3NjA5O1xuXHQgIHRoaXMuQl9yZVs1XSA9IC0wLjI2NjIzNDg5O1xuXHQgIHRoaXMuQl9pbVs1XSA9IC0wLjM2MjQ5MjE4O1xuXHQgIHRoaXMuQl9yZVs2XSA9IC0wLjY4NzA5ODM7XG5cdCAgdGhpcy5CX2ltWzZdID0gLTEuMTY1MTk2NztcblxuXHQgIHRoaXMuQ19yZSA9IFtdO1xuXHQgIHRoaXMuQ19pbSA9IFtdO1xuXHQgIHRoaXMuQ19yZVsxXSA9IDEuMzIzMTI3MDQzOTtcblx0ICB0aGlzLkNfaW1bMV0gPSAwO1xuXHQgIHRoaXMuQ19yZVsyXSA9IC0wLjU3NzI0NTc4OTtcblx0ICB0aGlzLkNfaW1bMl0gPSAtMC4wMDc4MDk1OTg7XG5cdCAgdGhpcy5DX3JlWzNdID0gMC41MDgzMDc1MTM7XG5cdCAgdGhpcy5DX2ltWzNdID0gLTAuMTEyMjA4OTUyO1xuXHQgIHRoaXMuQ19yZVs0XSA9IC0wLjE1MDk0NzYyO1xuXHQgIHRoaXMuQ19pbVs0XSA9IDAuMTgyMDA2MDI7XG5cdCAgdGhpcy5DX3JlWzVdID0gMS4wMTQxODE3OTtcblx0ICB0aGlzLkNfaW1bNV0gPSAxLjY0NDk3Njk2O1xuXHQgIHRoaXMuQ19yZVs2XSA9IDEuOTY2MDU0OTtcblx0ICB0aGlzLkNfaW1bNl0gPSAyLjUxMjc2NDU7XG5cblx0ICB0aGlzLkQgPSBbXTtcblx0ICB0aGlzLkRbMV0gPSAxLjU2MjcwMTQyNDM7XG5cdCAgdGhpcy5EWzJdID0gMC41MTg1NDA2Mzk4O1xuXHQgIHRoaXMuRFszXSA9IC0wLjAzMzMzMDk4O1xuXHQgIHRoaXMuRFs0XSA9IC0wLjEwNTI5MDY7XG5cdCAgdGhpcy5EWzVdID0gLTAuMDM2ODU5NDtcblx0ICB0aGlzLkRbNl0gPSAwLjAwNzMxNztcblx0ICB0aGlzLkRbN10gPSAwLjAxMjIwO1xuXHQgIHRoaXMuRFs4XSA9IDAuMDAzOTQ7XG5cdCAgdGhpcy5EWzldID0gLTAuMDAxMztcblx0fVxuXG5cdC8qKlxuXHQgICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgRm9yd2FyZCAgLSBsb25nL2xhdCB0byB4L3lcblx0ICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcblx0ICAqL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDE4KHApIHtcblx0ICB2YXIgbjtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cblx0ICB2YXIgZGVsdGFfbGF0ID0gbGF0IC0gdGhpcy5sYXQwO1xuXHQgIHZhciBkZWx0YV9sb24gPSBsb24gLSB0aGlzLmxvbmcwO1xuXG5cdCAgLy8gMS4gQ2FsY3VsYXRlIGRfcGhpIGFuZCBkX3BzaSAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkX2xhbWJkYVxuXHQgIC8vIEZvciB0aGlzIGFsZ29yaXRobSwgZGVsdGFfbGF0aXR1ZGUgaXMgaW4gc2Vjb25kcyBvZiBhcmMgeCAxMC01LCBzbyB3ZSBuZWVkIHRvIHNjYWxlIHRvIHRob3NlIHVuaXRzLiBMb25naXR1ZGUgaXMgcmFkaWFucy5cblx0ICB2YXIgZF9waGkgPSBkZWx0YV9sYXQgLyBTRUNfVE9fUkFEICogMUUtNTtcblx0ICB2YXIgZF9sYW1iZGEgPSBkZWx0YV9sb247XG5cdCAgdmFyIGRfcGhpX24gPSAxOyAvLyBkX3BoaV4wXG5cblx0ICB2YXIgZF9wc2kgPSAwO1xuXHQgIGZvciAobiA9IDE7IG4gPD0gMTA7IG4rKykge1xuXHQgICAgZF9waGlfbiA9IGRfcGhpX24gKiBkX3BoaTtcblx0ICAgIGRfcHNpID0gZF9wc2kgKyB0aGlzLkFbbl0gKiBkX3BoaV9uO1xuXHQgIH1cblxuXHQgIC8vIDIuIENhbGN1bGF0ZSB0aGV0YVxuXHQgIHZhciB0aF9yZSA9IGRfcHNpO1xuXHQgIHZhciB0aF9pbSA9IGRfbGFtYmRhO1xuXG5cdCAgLy8gMy4gQ2FsY3VsYXRlIHpcblx0ICB2YXIgdGhfbl9yZSA9IDE7XG5cdCAgdmFyIHRoX25faW0gPSAwOyAvLyB0aGV0YV4wXG5cdCAgdmFyIHRoX25fcmUxO1xuXHQgIHZhciB0aF9uX2ltMTtcblxuXHQgIHZhciB6X3JlID0gMDtcblx0ICB2YXIgel9pbSA9IDA7XG5cdCAgZm9yIChuID0gMTsgbiA8PSA2OyBuKyspIHtcblx0ICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuXHQgICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG5cdCAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG5cdCAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG5cdCAgICB6X3JlID0gel9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltO1xuXHQgICAgel9pbSA9IHpfaW0gKyB0aGlzLkJfaW1bbl0gKiB0aF9uX3JlICsgdGhpcy5CX3JlW25dICogdGhfbl9pbTtcblx0ICB9XG5cblx0ICAvLyA0LiBDYWxjdWxhdGUgZWFzdGluZyBhbmQgbm9ydGhpbmdcblx0ICBwLnggPSAoel9pbSAqIHRoaXMuYSkgKyB0aGlzLngwO1xuXHQgIHAueSA9ICh6X3JlICogdGhpcy5hKSArIHRoaXMueTA7XG5cblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qKlxuXHQgICAgTmV3IFplYWxhbmQgTWFwIEdyaWQgSW52ZXJzZSAgLSAgeC95IHRvIGxvbmcvbGF0XG5cdCAgKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQxOChwKSB7XG5cdCAgdmFyIG47XG5cdCAgdmFyIHggPSBwLng7XG5cdCAgdmFyIHkgPSBwLnk7XG5cblx0ICB2YXIgZGVsdGFfeCA9IHggLSB0aGlzLngwO1xuXHQgIHZhciBkZWx0YV95ID0geSAtIHRoaXMueTA7XG5cblx0ICAvLyAxLiBDYWxjdWxhdGUgelxuXHQgIHZhciB6X3JlID0gZGVsdGFfeSAvIHRoaXMuYTtcblx0ICB2YXIgel9pbSA9IGRlbHRhX3ggLyB0aGlzLmE7XG5cblx0ICAvLyAyYS4gQ2FsY3VsYXRlIHRoZXRhIC0gZmlyc3QgYXBwcm94aW1hdGlvbiBnaXZlcyBrbSBhY2N1cmFjeVxuXHQgIHZhciB6X25fcmUgPSAxO1xuXHQgIHZhciB6X25faW0gPSAwOyAvLyB6XjBcblx0ICB2YXIgel9uX3JlMTtcblx0ICB2YXIgel9uX2ltMTtcblxuXHQgIHZhciB0aF9yZSA9IDA7XG5cdCAgdmFyIHRoX2ltID0gMDtcblx0ICBmb3IgKG4gPSAxOyBuIDw9IDY7IG4rKykge1xuXHQgICAgel9uX3JlMSA9IHpfbl9yZSAqIHpfcmUgLSB6X25faW0gKiB6X2ltO1xuXHQgICAgel9uX2ltMSA9IHpfbl9pbSAqIHpfcmUgKyB6X25fcmUgKiB6X2ltO1xuXHQgICAgel9uX3JlID0gel9uX3JlMTtcblx0ICAgIHpfbl9pbSA9IHpfbl9pbTE7XG5cdCAgICB0aF9yZSA9IHRoX3JlICsgdGhpcy5DX3JlW25dICogel9uX3JlIC0gdGhpcy5DX2ltW25dICogel9uX2ltO1xuXHQgICAgdGhfaW0gPSB0aF9pbSArIHRoaXMuQ19pbVtuXSAqIHpfbl9yZSArIHRoaXMuQ19yZVtuXSAqIHpfbl9pbTtcblx0ICB9XG5cblx0ICAvLyAyYi4gSXRlcmF0ZSB0byByZWZpbmUgdGhlIGFjY3VyYWN5IG9mIHRoZSBjYWxjdWxhdGlvblxuXHQgIC8vICAgICAgICAwIGl0ZXJhdGlvbnMgZ2l2ZXMga20gYWNjdXJhY3lcblx0ICAvLyAgICAgICAgMSBpdGVyYXRpb24gZ2l2ZXMgbSBhY2N1cmFjeSAtLSBnb29kIGVub3VnaCBmb3IgbW9zdCBtYXBwaW5nIGFwcGxpY2F0aW9uc1xuXHQgIC8vICAgICAgICAyIGl0ZXJhdGlvbnMgYml2ZXMgbW0gYWNjdXJhY3lcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICB2YXIgdGhfbl9yZSA9IHRoX3JlO1xuXHQgICAgdmFyIHRoX25faW0gPSB0aF9pbTtcblx0ICAgIHZhciB0aF9uX3JlMTtcblx0ICAgIHZhciB0aF9uX2ltMTtcblxuXHQgICAgdmFyIG51bV9yZSA9IHpfcmU7XG5cdCAgICB2YXIgbnVtX2ltID0gel9pbTtcblx0ICAgIGZvciAobiA9IDI7IG4gPD0gNjsgbisrKSB7XG5cdCAgICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuXHQgICAgICB0aF9uX2ltMSA9IHRoX25faW0gKiB0aF9yZSArIHRoX25fcmUgKiB0aF9pbTtcblx0ICAgICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuXHQgICAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG5cdCAgICAgIG51bV9yZSA9IG51bV9yZSArIChuIC0gMSkgKiAodGhpcy5CX3JlW25dICogdGhfbl9yZSAtIHRoaXMuQl9pbVtuXSAqIHRoX25faW0pO1xuXHQgICAgICBudW1faW0gPSBudW1faW0gKyAobiAtIDEpICogKHRoaXMuQl9pbVtuXSAqIHRoX25fcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX2ltKTtcblx0ICAgIH1cblxuXHQgICAgdGhfbl9yZSA9IDE7XG5cdCAgICB0aF9uX2ltID0gMDtcblx0ICAgIHZhciBkZW5fcmUgPSB0aGlzLkJfcmVbMV07XG5cdCAgICB2YXIgZGVuX2ltID0gdGhpcy5CX2ltWzFdO1xuXHQgICAgZm9yIChuID0gMjsgbiA8PSA2OyBuKyspIHtcblx0ICAgICAgdGhfbl9yZTEgPSB0aF9uX3JlICogdGhfcmUgLSB0aF9uX2ltICogdGhfaW07XG5cdCAgICAgIHRoX25faW0xID0gdGhfbl9pbSAqIHRoX3JlICsgdGhfbl9yZSAqIHRoX2ltO1xuXHQgICAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG5cdCAgICAgIHRoX25faW0gPSB0aF9uX2ltMTtcblx0ICAgICAgZGVuX3JlID0gZGVuX3JlICsgbiAqICh0aGlzLkJfcmVbbl0gKiB0aF9uX3JlIC0gdGhpcy5CX2ltW25dICogdGhfbl9pbSk7XG5cdCAgICAgIGRlbl9pbSA9IGRlbl9pbSArIG4gKiAodGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW0pO1xuXHQgICAgfVxuXG5cdCAgICAvLyBDb21wbGV4IGRpdmlzaW9uXG5cdCAgICB2YXIgZGVuMiA9IGRlbl9yZSAqIGRlbl9yZSArIGRlbl9pbSAqIGRlbl9pbTtcblx0ICAgIHRoX3JlID0gKG51bV9yZSAqIGRlbl9yZSArIG51bV9pbSAqIGRlbl9pbSkgLyBkZW4yO1xuXHQgICAgdGhfaW0gPSAobnVtX2ltICogZGVuX3JlIC0gbnVtX3JlICogZGVuX2ltKSAvIGRlbjI7XG5cdCAgfVxuXG5cdCAgLy8gMy4gQ2FsY3VsYXRlIGRfcGhpICAgICAgICAgICAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZF9sYW1iZGFcblx0ICB2YXIgZF9wc2kgPSB0aF9yZTtcblx0ICB2YXIgZF9sYW1iZGEgPSB0aF9pbTtcblx0ICB2YXIgZF9wc2lfbiA9IDE7IC8vIGRfcHNpXjBcblxuXHQgIHZhciBkX3BoaSA9IDA7XG5cdCAgZm9yIChuID0gMTsgbiA8PSA5OyBuKyspIHtcblx0ICAgIGRfcHNpX24gPSBkX3BzaV9uICogZF9wc2k7XG5cdCAgICBkX3BoaSA9IGRfcGhpICsgdGhpcy5EW25dICogZF9wc2lfbjtcblx0ICB9XG5cblx0ICAvLyA0LiBDYWxjdWxhdGUgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZVxuXHQgIC8vIGRfcGhpIGlzIGNhbGN1YXRlZCBpbiBzZWNvbmQgb2YgYXJjICogMTBeLTUsIHNvIHdlIG5lZWQgdG8gc2NhbGUgYmFjayB0byByYWRpYW5zLiBkX2xhbWJkYSBpcyBpbiByYWRpYW5zLlxuXHQgIHZhciBsYXQgPSB0aGlzLmxhdDAgKyAoZF9waGkgKiBTRUNfVE9fUkFEICogMUU1KTtcblx0ICB2YXIgbG9uID0gdGhpcy5sb25nMCArIGRfbGFtYmRhO1xuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblxuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDIwID0gW1wiTmV3X1plYWxhbmRfTWFwX0dyaWRcIiwgXCJuem1nXCJdO1xuXHR2YXIgbnptZyA9IHtcblx0ICBpbml0OiBpbml0JDE5LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMTgsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxOCxcblx0ICBuYW1lczogbmFtZXMkMjBcblx0fTtcblxuXHQvKlxuXHQgIHJlZmVyZW5jZVxuXHQgICAgXCJOZXcgRXF1YWwtQXJlYSBNYXAgUHJvamVjdGlvbnMgZm9yIE5vbmNpcmN1bGFyIFJlZ2lvbnNcIiwgSm9obiBQLiBTbnlkZXIsXG5cdCAgICBUaGUgQW1lcmljYW4gQ2FydG9ncmFwaGVyLCBWb2wgMTUsIE5vLiA0LCBPY3RvYmVyIDE5ODgsIHBwLiAzNDEtMzU1LlxuXHQgICovXG5cblxuXHQvKiBJbml0aWFsaXplIHRoZSBNaWxsZXIgQ3lsaW5kcmljYWwgcHJvamVjdGlvblxuXHQgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBpbml0JDIwKCkge1xuXHQgIC8vbm8tb3Bcblx0fVxuXG5cdC8qIE1pbGxlciBDeWxpbmRyaWNhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGZvcndhcmQkMTkocCkge1xuXHQgIHZhciBsb24gPSBwLng7XG5cdCAgdmFyIGxhdCA9IHAueTtcblx0ICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuXHQgICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdCAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciB4ID0gdGhpcy54MCArIHRoaXMuYSAqIGRsb247XG5cdCAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgLyA0KSArIChsYXQgLyAyLjUpKSkgKiAxLjI1O1xuXG5cdCAgcC54ID0geDtcblx0ICBwLnkgPSB5O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0LyogTWlsbGVyIEN5bGluZHJpY2FsIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuXHQgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQxOShwKSB7XG5cdCAgcC54IC09IHRoaXMueDA7XG5cdCAgcC55IC09IHRoaXMueTA7XG5cblx0ICB2YXIgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgcC54IC8gdGhpcy5hKTtcblx0ICB2YXIgbGF0ID0gMi41ICogKE1hdGguYXRhbihNYXRoLmV4cCgwLjggKiBwLnkgLyB0aGlzLmEpKSAtIE1hdGguUEkgLyA0KTtcblxuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMjEgPSBbXCJNaWxsZXJfQ3lsaW5kcmljYWxcIiwgXCJtaWxsXCJdO1xuXHR2YXIgbWlsbCA9IHtcblx0ICBpbml0OiBpbml0JDIwLFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMTksXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQxOSxcblx0ICBuYW1lczogbmFtZXMkMjFcblx0fTtcblxuXHR2YXIgTUFYX0lURVIkMyA9IDIwO1xuXHRmdW5jdGlvbiBpbml0JDIxKCkge1xuXHQgIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2Vcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ICBpZiAoIXRoaXMuc3BoZXJlKSB7XG5cdCAgICB0aGlzLmVuID0gcGpfZW5mbih0aGlzLmVzKTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICB0aGlzLm4gPSAxO1xuXHQgICAgdGhpcy5tID0gMDtcblx0ICAgIHRoaXMuZXMgPSAwO1xuXHQgICAgdGhpcy5DX3kgPSBNYXRoLnNxcnQoKHRoaXMubSArIDEpIC8gdGhpcy5uKTtcblx0ICAgIHRoaXMuQ194ID0gdGhpcy5DX3kgLyAodGhpcy5tICsgMSk7XG5cdCAgfVxuXG5cdH1cblxuXHQvKiBTaW51c29pZGFsIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuXHQgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gZm9yd2FyZCQyMChwKSB7XG5cdCAgdmFyIHgsIHk7XG5cdCAgdmFyIGxvbiA9IHAueDtcblx0ICB2YXIgbGF0ID0gcC55O1xuXHQgIC8qIEZvcndhcmQgZXF1YXRpb25zXG5cdCAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdCAgbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblxuXHQgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgaWYgKCF0aGlzLm0pIHtcblx0ICAgICAgbGF0ID0gdGhpcy5uICE9PSAxID8gTWF0aC5hc2luKHRoaXMubiAqIE1hdGguc2luKGxhdCkpIDogbGF0O1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHZhciBrID0gdGhpcy5uICogTWF0aC5zaW4obGF0KTtcblx0ICAgICAgZm9yICh2YXIgaSA9IE1BWF9JVEVSJDM7IGk7IC0taSkge1xuXHQgICAgICAgIHZhciBWID0gKHRoaXMubSAqIGxhdCArIE1hdGguc2luKGxhdCkgLSBrKSAvICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcblx0ICAgICAgICBsYXQgLT0gVjtcblx0ICAgICAgICBpZiAoTWF0aC5hYnMoVikgPCBFUFNMTikge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB4ID0gdGhpcy5hICogdGhpcy5DX3ggKiBsb24gKiAodGhpcy5tICsgTWF0aC5jb3MobGF0KSk7XG5cdCAgICB5ID0gdGhpcy5hICogdGhpcy5DX3kgKiBsYXQ7XG5cblx0ICB9XG5cdCAgZWxzZSB7XG5cblx0ICAgIHZhciBzID0gTWF0aC5zaW4obGF0KTtcblx0ICAgIHZhciBjID0gTWF0aC5jb3MobGF0KTtcblx0ICAgIHkgPSB0aGlzLmEgKiBwal9tbGZuKGxhdCwgcywgYywgdGhpcy5lbik7XG5cdCAgICB4ID0gdGhpcy5hICogbG9uICogYyAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKTtcblx0ICB9XG5cblx0ICBwLnggPSB4O1xuXHQgIHAueSA9IHk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBpbnZlcnNlJDIwKHApIHtcblx0ICB2YXIgbGF0LCB0ZW1wLCBsb24sIHM7XG5cblx0ICBwLnggLT0gdGhpcy54MDtcblx0ICBsb24gPSBwLnggLyB0aGlzLmE7XG5cdCAgcC55IC09IHRoaXMueTA7XG5cdCAgbGF0ID0gcC55IC8gdGhpcy5hO1xuXG5cdCAgaWYgKHRoaXMuc3BoZXJlKSB7XG5cdCAgICBsYXQgLz0gdGhpcy5DX3k7XG5cdCAgICBsb24gPSBsb24gLyAodGhpcy5DX3ggKiAodGhpcy5tICsgTWF0aC5jb3MobGF0KSkpO1xuXHQgICAgaWYgKHRoaXMubSkge1xuXHQgICAgICBsYXQgPSBhc2lueigodGhpcy5tICogbGF0ICsgTWF0aC5zaW4obGF0KSkgLyB0aGlzLm4pO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodGhpcy5uICE9PSAxKSB7XG5cdCAgICAgIGxhdCA9IGFzaW56KE1hdGguc2luKGxhdCkgLyB0aGlzLm4pO1xuXHQgICAgfVxuXHQgICAgbG9uID0gYWRqdXN0X2xvbihsb24gKyB0aGlzLmxvbmcwKTtcblx0ICAgIGxhdCA9IGFkanVzdF9sYXQobGF0KTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBsYXQgPSBwal9pbnZfbWxmbihwLnkgLyB0aGlzLmEsIHRoaXMuZXMsIHRoaXMuZW4pO1xuXHQgICAgcyA9IE1hdGguYWJzKGxhdCk7XG5cdCAgICBpZiAocyA8IEhBTEZfUEkpIHtcblx0ICAgICAgcyA9IE1hdGguc2luKGxhdCk7XG5cdCAgICAgIHRlbXAgPSB0aGlzLmxvbmcwICsgcC54ICogTWF0aC5zcXJ0KDEgLSB0aGlzLmVzICogcyAqIHMpIC8gKHRoaXMuYSAqIE1hdGguY29zKGxhdCkpO1xuXHQgICAgICAvL3RlbXAgPSB0aGlzLmxvbmcwICsgcC54IC8gKHRoaXMuYSAqIE1hdGguY29zKGxhdCkpO1xuXHQgICAgICBsb24gPSBhZGp1c3RfbG9uKHRlbXApO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoKHMgLSBFUFNMTikgPCBIQUxGX1BJKSB7XG5cdCAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMjIgPSBbXCJTaW51c29pZGFsXCIsIFwic2ludVwiXTtcblx0dmFyIHNpbnUgPSB7XG5cdCAgaW5pdDogaW5pdCQyMSxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDIwLFxuXHQgIGludmVyc2U6IGludmVyc2UkMjAsXG5cdCAgbmFtZXM6IG5hbWVzJDIyXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQyMigpIHt9XG5cdC8qIE1vbGx3ZWlkZSBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDIxKHApIHtcblxuXHQgIC8qIEZvcndhcmQgZXF1YXRpb25zXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cblx0ICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblx0ICB2YXIgdGhldGEgPSBsYXQ7XG5cdCAgdmFyIGNvbiA9IE1hdGguUEkgKiBNYXRoLnNpbihsYXQpO1xuXG5cdCAgLyogSXRlcmF0ZSB1c2luZyB0aGUgTmV3dG9uLVJhcGhzb24gbWV0aG9kIHRvIGZpbmQgdGhldGFcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHdoaWxlICh0cnVlKSB7XG5cdCAgICB2YXIgZGVsdGFfdGhldGEgPSAtKHRoZXRhICsgTWF0aC5zaW4odGhldGEpIC0gY29uKSAvICgxICsgTWF0aC5jb3ModGhldGEpKTtcblx0ICAgIHRoZXRhICs9IGRlbHRhX3RoZXRhO1xuXHQgICAgaWYgKE1hdGguYWJzKGRlbHRhX3RoZXRhKSA8IEVQU0xOKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICB0aGV0YSAvPSAyO1xuXG5cdCAgLyogSWYgdGhlIGxhdGl0dWRlIGlzIDkwIGRlZywgZm9yY2UgdGhlIHggY29vcmRpbmF0ZSB0byBiZSBcIjAgKyBmYWxzZSBlYXN0aW5nXCJcblx0ICAgICAgIHRoaXMgaXMgZG9uZSBoZXJlIGJlY2F1c2Ugb2YgcHJlY2lzaW9uIHByb2JsZW1zIHdpdGggXCJjb3ModGhldGEpXCJcblx0ICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ICBpZiAoTWF0aC5QSSAvIDIgLSBNYXRoLmFicyhsYXQpIDwgRVBTTE4pIHtcblx0ICAgIGRlbHRhX2xvbiA9IDA7XG5cdCAgfVxuXHQgIHZhciB4ID0gMC45MDAzMTYzMTYxNTggKiB0aGlzLmEgKiBkZWx0YV9sb24gKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLngwO1xuXHQgIHZhciB5ID0gMS40MTQyMTM1NjIzNzMxICogdGhpcy5hICogTWF0aC5zaW4odGhldGEpICsgdGhpcy55MDtcblxuXHQgIHAueCA9IHg7XG5cdCAgcC55ID0geTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmVyc2UkMjEocCkge1xuXHQgIHZhciB0aGV0YTtcblx0ICB2YXIgYXJnO1xuXG5cdCAgLyogSW52ZXJzZSBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHAueCAtPSB0aGlzLngwO1xuXHQgIHAueSAtPSB0aGlzLnkwO1xuXHQgIGFyZyA9IHAueSAvICgxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEpO1xuXG5cdCAgLyogQmVjYXVzZSBvZiBkaXZpc2lvbiBieSB6ZXJvIHByb2JsZW1zLCAnYXJnJyBjYW4gbm90IGJlIDEuICBUaGVyZWZvcmVcblx0ICAgICAgIGEgbnVtYmVyIHZlcnkgY2xvc2UgdG8gb25lIGlzIHVzZWQgaW5zdGVhZC5cblx0ICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIGlmIChNYXRoLmFicyhhcmcpID4gMC45OTk5OTk5OTk5OTkpIHtcblx0ICAgIGFyZyA9IDAuOTk5OTk5OTk5OTk5O1xuXHQgIH1cblx0ICB0aGV0YSA9IE1hdGguYXNpbihhcmcpO1xuXHQgIHZhciBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAocC54IC8gKDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogTWF0aC5jb3ModGhldGEpKSkpO1xuXHQgIGlmIChsb24gPCAoLU1hdGguUEkpKSB7XG5cdCAgICBsb24gPSAtTWF0aC5QSTtcblx0ICB9XG5cdCAgaWYgKGxvbiA+IE1hdGguUEkpIHtcblx0ICAgIGxvbiA9IE1hdGguUEk7XG5cdCAgfVxuXHQgIGFyZyA9ICgyICogdGhldGEgKyBNYXRoLnNpbigyICogdGhldGEpKSAvIE1hdGguUEk7XG5cdCAgaWYgKE1hdGguYWJzKGFyZykgPiAxKSB7XG5cdCAgICBhcmcgPSAxO1xuXHQgIH1cblx0ICB2YXIgbGF0ID0gTWF0aC5hc2luKGFyZyk7XG5cblx0ICBwLnggPSBsb247XG5cdCAgcC55ID0gbGF0O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0dmFyIG5hbWVzJDIzID0gW1wiTW9sbHdlaWRlXCIsIFwibW9sbFwiXTtcblx0dmFyIG1vbGwgPSB7XG5cdCAgaW5pdDogaW5pdCQyMixcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDIxLFxuXHQgIGludmVyc2U6IGludmVyc2UkMjEsXG5cdCAgbmFtZXM6IG5hbWVzJDIzXG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQyMygpIHtcblxuXHQgIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2Vcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdCAgLy8gU3RhbmRhcmQgUGFyYWxsZWxzIGNhbm5vdCBiZSBlcXVhbCBhbmQgb24gb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGVxdWF0b3Jcblx0ICBpZiAoTWF0aC5hYnModGhpcy5sYXQxICsgdGhpcy5sYXQyKSA8IEVQU0xOKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHRoaXMubGF0MiA9IHRoaXMubGF0MiB8fCB0aGlzLmxhdDE7XG5cdCAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuXHQgIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcblx0ICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG5cdCAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG5cdCAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cblx0ICB0aGlzLnNpbnBoaSA9IE1hdGguc2luKHRoaXMubGF0MSk7XG5cdCAgdGhpcy5jb3NwaGkgPSBNYXRoLmNvcyh0aGlzLmxhdDEpO1xuXG5cdCAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG5cdCAgdGhpcy5tbDEgPSBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MSk7XG5cblx0ICBpZiAoTWF0aC5hYnModGhpcy5sYXQxIC0gdGhpcy5sYXQyKSA8IEVQU0xOKSB7XG5cdCAgICB0aGlzLm5zID0gdGhpcy5zaW5waGk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuXHQgICAgdGhpcy5jb3NwaGkgPSBNYXRoLmNvcyh0aGlzLmxhdDIpO1xuXHQgICAgdGhpcy5tczIgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG5cdCAgICB0aGlzLm1sMiA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQyKTtcblx0ICAgIHRoaXMubnMgPSAodGhpcy5tczEgLSB0aGlzLm1zMikgLyAodGhpcy5tbDIgLSB0aGlzLm1sMSk7XG5cdCAgfVxuXHQgIHRoaXMuZyA9IHRoaXMubWwxICsgdGhpcy5tczEgLyB0aGlzLm5zO1xuXHQgIHRoaXMubWwwID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApO1xuXHQgIHRoaXMucmggPSB0aGlzLmEgKiAodGhpcy5nIC0gdGhpcy5tbDApO1xuXHR9XG5cblx0LyogRXF1aWRpc3RhbnQgQ29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG5cdCAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBmb3J3YXJkJDIyKHApIHtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cdCAgdmFyIHJoMTtcblxuXHQgIC8qIEZvcndhcmQgZXF1YXRpb25zXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBsYXQpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciBtbCA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgbGF0KTtcblx0ICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBtbCk7XG5cdCAgfVxuXHQgIHZhciB0aGV0YSA9IHRoaXMubnMgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciB4ID0gdGhpcy54MCArIHJoMSAqIE1hdGguc2luKHRoZXRhKTtcblx0ICB2YXIgeSA9IHRoaXMueTAgKyB0aGlzLnJoIC0gcmgxICogTWF0aC5jb3ModGhldGEpO1xuXHQgIHAueCA9IHg7XG5cdCAgcC55ID0geTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdC8qIEludmVyc2UgZXF1YXRpb25zXG5cdCAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRmdW5jdGlvbiBpbnZlcnNlJDIyKHApIHtcblx0ICBwLnggLT0gdGhpcy54MDtcblx0ICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcblx0ICB2YXIgY29uLCByaDEsIGxhdCwgbG9uO1xuXHQgIGlmICh0aGlzLm5zID49IDApIHtcblx0ICAgIHJoMSA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuXHQgICAgY29uID0gMTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICByaDEgPSAtTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgICBjb24gPSAtMTtcblx0ICB9XG5cdCAgdmFyIHRoZXRhID0gMDtcblx0ICBpZiAocmgxICE9PSAwKSB7XG5cdCAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLnNwaGVyZSkge1xuXHQgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgdGhldGEgLyB0aGlzLm5zKTtcblx0ICAgIGxhdCA9IGFkanVzdF9sYXQodGhpcy5nIC0gcmgxIC8gdGhpcy5hKTtcblx0ICAgIHAueCA9IGxvbjtcblx0ICAgIHAueSA9IGxhdDtcblx0ICAgIHJldHVybiBwO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciBtbCA9IHRoaXMuZyAtIHJoMSAvIHRoaXMuYTtcblx0ICAgIGxhdCA9IGltbGZuKG1sLCB0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcblx0ICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHRoZXRhIC8gdGhpcy5ucyk7XG5cdCAgICBwLnggPSBsb247XG5cdCAgICBwLnkgPSBsYXQ7XG5cdCAgICByZXR1cm4gcDtcblx0ICB9XG5cblx0fVxuXG5cdHZhciBuYW1lcyQyNCA9IFtcIkVxdWlkaXN0YW50X0NvbmljXCIsIFwiZXFkY1wiXTtcblx0dmFyIGVxZGMgPSB7XG5cdCAgaW5pdDogaW5pdCQyMyxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDIyLFxuXHQgIGludmVyc2U6IGludmVyc2UkMjIsXG5cdCAgbmFtZXM6IG5hbWVzJDI0XG5cdH07XG5cblx0LyogSW5pdGlhbGl6ZSB0aGUgVmFuIERlciBHcmludGVuIHByb2plY3Rpb25cblx0ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gaW5pdCQyNCgpIHtcblx0ICAvL3RoaXMuUiA9IDYzNzA5OTc7IC8vUmFkaXVzIG9mIGVhcnRoXG5cdCAgdGhpcy5SID0gdGhpcy5hO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9yd2FyZCQyMyhwKSB7XG5cblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cblx0ICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuXHQgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcblx0ICB2YXIgeCwgeTtcblxuXHQgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG5cdCAgICB4ID0gdGhpcy54MCArIHRoaXMuUiAqIGRsb247XG5cdCAgICB5ID0gdGhpcy55MDtcblx0ICB9XG5cdCAgdmFyIHRoZXRhID0gYXNpbnooMiAqIE1hdGguYWJzKGxhdCAvIE1hdGguUEkpKTtcblx0ICBpZiAoKE1hdGguYWJzKGRsb24pIDw9IEVQU0xOKSB8fCAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSkge1xuXHQgICAgeCA9IHRoaXMueDA7XG5cdCAgICBpZiAobGF0ID49IDApIHtcblx0ICAgICAgeSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogTWF0aC50YW4oMC41ICogdGhldGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIHkgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIC1NYXRoLnRhbigwLjUgKiB0aGV0YSk7XG5cdCAgICB9XG5cdCAgICAvLyAgcmV0dXJuKE9LKTtcblx0ICB9XG5cdCAgdmFyIGFsID0gMC41ICogTWF0aC5hYnMoKE1hdGguUEkgLyBkbG9uKSAtIChkbG9uIC8gTWF0aC5QSSkpO1xuXHQgIHZhciBhc3EgPSBhbCAqIGFsO1xuXHQgIHZhciBzaW50aCA9IE1hdGguc2luKHRoZXRhKTtcblx0ICB2YXIgY29zdGggPSBNYXRoLmNvcyh0aGV0YSk7XG5cblx0ICB2YXIgZyA9IGNvc3RoIC8gKHNpbnRoICsgY29zdGggLSAxKTtcblx0ICB2YXIgZ3NxID0gZyAqIGc7XG5cdCAgdmFyIG0gPSBnICogKDIgLyBzaW50aCAtIDEpO1xuXHQgIHZhciBtc3EgPSBtICogbTtcblx0ICB2YXIgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChhbCAqIChnIC0gbXNxKSArIE1hdGguc3FydChhc3EgKiAoZyAtIG1zcSkgKiAoZyAtIG1zcSkgLSAobXNxICsgYXNxKSAqIChnc3EgLSBtc3EpKSkgLyAobXNxICsgYXNxKTtcblx0ICBpZiAoZGxvbiA8IDApIHtcblx0ICAgIGNvbiA9IC1jb247XG5cdCAgfVxuXHQgIHggPSB0aGlzLngwICsgY29uO1xuXHQgIC8vY29uID0gTWF0aC5hYnMoY29uIC8gKE1hdGguUEkgKiB0aGlzLlIpKTtcblx0ICB2YXIgcSA9IGFzcSArIGc7XG5cdCAgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChtICogcSAtIGFsICogTWF0aC5zcXJ0KChtc3EgKyBhc3EpICogKGFzcSArIDEpIC0gcSAqIHEpKSAvIChtc3EgKyBhc3EpO1xuXHQgIGlmIChsYXQgPj0gMCkge1xuXHQgICAgLy95ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbiAtIDIgKiBhbCAqIGNvbik7XG5cdCAgICB5ID0gdGhpcy55MCArIGNvbjtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICAvL3kgPSB0aGlzLnkwIC0gTWF0aC5QSSAqIHRoaXMuUiAqIE1hdGguc3FydCgxIC0gY29uICogY29uIC0gMiAqIGFsICogY29uKTtcblx0ICAgIHkgPSB0aGlzLnkwIC0gY29uO1xuXHQgIH1cblx0ICBwLnggPSB4O1xuXHQgIHAueSA9IHk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvKiBWYW4gRGVyIEdyaW50ZW4gaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG5cdCAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0ZnVuY3Rpb24gaW52ZXJzZSQyMyhwKSB7XG5cdCAgdmFyIGxvbiwgbGF0O1xuXHQgIHZhciB4eCwgeXksIHh5cywgYzEsIGMyLCBjMztcblx0ICB2YXIgYTE7XG5cdCAgdmFyIG0xO1xuXHQgIHZhciBjb247XG5cdCAgdmFyIHRoMTtcblx0ICB2YXIgZDtcblxuXHQgIC8qIGludmVyc2UgZXF1YXRpb25zXG5cdCAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG5cdCAgcC54IC09IHRoaXMueDA7XG5cdCAgcC55IC09IHRoaXMueTA7XG5cdCAgY29uID0gTWF0aC5QSSAqIHRoaXMuUjtcblx0ICB4eCA9IHAueCAvIGNvbjtcblx0ICB5eSA9IHAueSAvIGNvbjtcblx0ICB4eXMgPSB4eCAqIHh4ICsgeXkgKiB5eTtcblx0ICBjMSA9IC1NYXRoLmFicyh5eSkgKiAoMSArIHh5cyk7XG5cdCAgYzIgPSBjMSAtIDIgKiB5eSAqIHl5ICsgeHggKiB4eDtcblx0ICBjMyA9IC0yICogYzEgKyAxICsgMiAqIHl5ICogeXkgKyB4eXMgKiB4eXM7XG5cdCAgZCA9IHl5ICogeXkgLyBjMyArICgyICogYzIgKiBjMiAqIGMyIC8gYzMgLyBjMyAvIGMzIC0gOSAqIGMxICogYzIgLyBjMyAvIGMzKSAvIDI3O1xuXHQgIGExID0gKGMxIC0gYzIgKiBjMiAvIDMgLyBjMykgLyBjMztcblx0ICBtMSA9IDIgKiBNYXRoLnNxcnQoLWExIC8gMyk7XG5cdCAgY29uID0gKCgzICogZCkgLyBhMSkgLyBtMTtcblx0ICBpZiAoTWF0aC5hYnMoY29uKSA+IDEpIHtcblx0ICAgIGlmIChjb24gPj0gMCkge1xuXHQgICAgICBjb24gPSAxO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIGNvbiA9IC0xO1xuXHQgICAgfVxuXHQgIH1cblx0ICB0aDEgPSBNYXRoLmFjb3MoY29uKSAvIDM7XG5cdCAgaWYgKHAueSA+PSAwKSB7XG5cdCAgICBsYXQgPSAoLW0xICogTWF0aC5jb3ModGgxICsgTWF0aC5QSSAvIDMpIC0gYzIgLyAzIC8gYzMpICogTWF0aC5QSTtcblx0ICB9XG5cdCAgZWxzZSB7XG5cdCAgICBsYXQgPSAtKC1tMSAqIE1hdGguY29zKHRoMSArIE1hdGguUEkgLyAzKSAtIGMyIC8gMyAvIGMzKSAqIE1hdGguUEk7XG5cdCAgfVxuXG5cdCAgaWYgKE1hdGguYWJzKHh4KSA8IEVQU0xOKSB7XG5cdCAgICBsb24gPSB0aGlzLmxvbmcwO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguUEkgKiAoeHlzIC0gMSArIE1hdGguc3FydCgxICsgMiAqICh4eCAqIHh4IC0geXkgKiB5eSkgKyB4eXMgKiB4eXMpKSAvIDIgLyB4eCk7XG5cdCAgfVxuXG5cdCAgcC54ID0gbG9uO1xuXHQgIHAueSA9IGxhdDtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdHZhciBuYW1lcyQyNSA9IFtcIlZhbl9kZXJfR3JpbnRlbl9JXCIsIFwiVmFuRGVyR3JpbnRlblwiLCBcInZhbmRnXCJdO1xuXHR2YXIgdmFuZGcgPSB7XG5cdCAgaW5pdDogaW5pdCQyNCxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDIzLFxuXHQgIGludmVyc2U6IGludmVyc2UkMjMsXG5cdCAgbmFtZXM6IG5hbWVzJDI1XG5cdH07XG5cblx0ZnVuY3Rpb24gaW5pdCQyNSgpIHtcblx0ICB0aGlzLnNpbl9wMTIgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuXHQgIHRoaXMuY29zX3AxMiA9IE1hdGguY29zKHRoaXMubGF0MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3J3YXJkJDI0KHApIHtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cdCAgdmFyIHNpbnBoaSA9IE1hdGguc2luKHAueSk7XG5cdCAgdmFyIGNvc3BoaSA9IE1hdGguY29zKHAueSk7XG5cdCAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXHQgIHZhciBlMCwgZTEsIGUyLCBlMywgTWxwLCBNbCwgdGFucGhpLCBObDEsIE5sLCBwc2ksIEF6LCBHLCBILCBHSCwgSHMsIGMsIGtwLCBjb3NfYywgcywgczIsIHMzLCBzNCwgczU7XG5cdCAgaWYgKHRoaXMuc3BoZXJlKSB7XG5cdCAgICBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyIC0gMSkgPD0gRVBTTE4pIHtcblx0ICAgICAgLy9Ob3J0aCBQb2xlIGNhc2Vcblx0ICAgICAgcC54ID0gdGhpcy54MCArIHRoaXMuYSAqIChIQUxGX1BJIC0gbGF0KSAqIE1hdGguc2luKGRsb24pO1xuXHQgICAgICBwLnkgPSB0aGlzLnkwIC0gdGhpcy5hICogKEhBTEZfUEkgLSBsYXQpICogTWF0aC5jb3MoZGxvbik7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyICsgMSkgPD0gRVBTTE4pIHtcblx0ICAgICAgLy9Tb3V0aCBQb2xlIGNhc2Vcblx0ICAgICAgcC54ID0gdGhpcy54MCArIHRoaXMuYSAqIChIQUxGX1BJICsgbGF0KSAqIE1hdGguc2luKGRsb24pO1xuXHQgICAgICBwLnkgPSB0aGlzLnkwICsgdGhpcy5hICogKEhBTEZfUEkgKyBsYXQpICogTWF0aC5jb3MoZGxvbik7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIC8vZGVmYXVsdCBjYXNlXG5cdCAgICAgIGNvc19jID0gdGhpcy5zaW5fcDEyICogc2lucGhpICsgdGhpcy5jb3NfcDEyICogY29zcGhpICogTWF0aC5jb3MoZGxvbik7XG5cdCAgICAgIGMgPSBNYXRoLmFjb3MoY29zX2MpO1xuXHQgICAgICBrcCA9IGMgLyBNYXRoLnNpbihjKTtcblx0ICAgICAgcC54ID0gdGhpcy54MCArIHRoaXMuYSAqIGtwICogY29zcGhpICogTWF0aC5zaW4oZGxvbik7XG5cdCAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiBrcCAqICh0aGlzLmNvc19wMTIgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTIgKiBjb3NwaGkgKiBNYXRoLmNvcyhkbG9uKSk7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGUwID0gZTBmbih0aGlzLmVzKTtcblx0ICAgIGUxID0gZTFmbih0aGlzLmVzKTtcblx0ICAgIGUyID0gZTJmbih0aGlzLmVzKTtcblx0ICAgIGUzID0gZTNmbih0aGlzLmVzKTtcblx0ICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuXHQgICAgICAvL05vcnRoIFBvbGUgY2FzZVxuXHQgICAgICBNbHAgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBIQUxGX1BJKTtcblx0ICAgICAgTWwgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBsYXQpO1xuXHQgICAgICBwLnggPSB0aGlzLngwICsgKE1scCAtIE1sKSAqIE1hdGguc2luKGRsb24pO1xuXHQgICAgICBwLnkgPSB0aGlzLnkwIC0gKE1scCAtIE1sKSAqIE1hdGguY29zKGRsb24pO1xuXHQgICAgICByZXR1cm4gcDtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuc2luX3AxMiArIDEpIDw9IEVQU0xOKSB7XG5cdCAgICAgIC8vU291dGggUG9sZSBjYXNlXG5cdCAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuXHQgICAgICBNbCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIGxhdCk7XG5cdCAgICAgIHAueCA9IHRoaXMueDAgKyAoTWxwICsgTWwpICogTWF0aC5zaW4oZGxvbik7XG5cdCAgICAgIHAueSA9IHRoaXMueTAgKyAoTWxwICsgTWwpICogTWF0aC5jb3MoZGxvbik7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIC8vRGVmYXVsdCBjYXNlXG5cdCAgICAgIHRhbnBoaSA9IHNpbnBoaSAvIGNvc3BoaTtcblx0ICAgICAgTmwxID0gZ04odGhpcy5hLCB0aGlzLmUsIHRoaXMuc2luX3AxMik7XG5cdCAgICAgIE5sID0gZ04odGhpcy5hLCB0aGlzLmUsIHNpbnBoaSk7XG5cdCAgICAgIHBzaSA9IE1hdGguYXRhbigoMSAtIHRoaXMuZXMpICogdGFucGhpICsgdGhpcy5lcyAqIE5sMSAqIHRoaXMuc2luX3AxMiAvIChObCAqIGNvc3BoaSkpO1xuXHQgICAgICBBeiA9IE1hdGguYXRhbjIoTWF0aC5zaW4oZGxvbiksIHRoaXMuY29zX3AxMiAqIE1hdGgudGFuKHBzaSkgLSB0aGlzLnNpbl9wMTIgKiBNYXRoLmNvcyhkbG9uKSk7XG5cdCAgICAgIGlmIChBeiA9PT0gMCkge1xuXHQgICAgICAgIHMgPSBNYXRoLmFzaW4odGhpcy5jb3NfcDEyICogTWF0aC5zaW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKHBzaSkpO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2UgaWYgKE1hdGguYWJzKE1hdGguYWJzKEF6KSAtIE1hdGguUEkpIDw9IEVQU0xOKSB7XG5cdCAgICAgICAgcyA9IC1NYXRoLmFzaW4odGhpcy5jb3NfcDEyICogTWF0aC5zaW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKHBzaSkpO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIHMgPSBNYXRoLmFzaW4oTWF0aC5zaW4oZGxvbikgKiBNYXRoLmNvcyhwc2kpIC8gTWF0aC5zaW4oQXopKTtcblx0ICAgICAgfVxuXHQgICAgICBHID0gdGhpcy5lICogdGhpcy5zaW5fcDEyIC8gTWF0aC5zcXJ0KDEgLSB0aGlzLmVzKTtcblx0ICAgICAgSCA9IHRoaXMuZSAqIHRoaXMuY29zX3AxMiAqIE1hdGguY29zKEF6KSAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyk7XG5cdCAgICAgIEdIID0gRyAqIEg7XG5cdCAgICAgIEhzID0gSCAqIEg7XG5cdCAgICAgIHMyID0gcyAqIHM7XG5cdCAgICAgIHMzID0gczIgKiBzO1xuXHQgICAgICBzNCA9IHMzICogcztcblx0ICAgICAgczUgPSBzNCAqIHM7XG5cdCAgICAgIGMgPSBObDEgKiBzICogKDEgLSBzMiAqIEhzICogKDEgLSBIcykgLyA2ICsgczMgLyA4ICogR0ggKiAoMSAtIDIgKiBIcykgKyBzNCAvIDEyMCAqIChIcyAqICg0IC0gNyAqIEhzKSAtIDMgKiBHICogRyAqICgxIC0gNyAqIEhzKSkgLSBzNSAvIDQ4ICogR0gpO1xuXHQgICAgICBwLnggPSB0aGlzLngwICsgYyAqIE1hdGguc2luKEF6KTtcblx0ICAgICAgcC55ID0gdGhpcy55MCArIGMgKiBNYXRoLmNvcyhBeik7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgIH1cblxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnZlcnNlJDI0KHApIHtcblx0ICBwLnggLT0gdGhpcy54MDtcblx0ICBwLnkgLT0gdGhpcy55MDtcblx0ICB2YXIgcmgsIHosIHNpbnosIGNvc3osIGxvbiwgbGF0LCBjb24sIGUwLCBlMSwgZTIsIGUzLCBNbHAsIE0sIE4xLCBwc2ksIEF6LCBjb3NBeiwgdG1wLCBBLCBCLCBELCBFZSwgRjtcblx0ICBpZiAodGhpcy5zcGhlcmUpIHtcblx0ICAgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgICBpZiAocmggPiAoMiAqIEhBTEZfUEkgKiB0aGlzLmEpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHogPSByaCAvIHRoaXMuYTtcblxuXHQgICAgc2lueiA9IE1hdGguc2luKHopO1xuXHQgICAgY29zeiA9IE1hdGguY29zKHopO1xuXG5cdCAgICBsb24gPSB0aGlzLmxvbmcwO1xuXHQgICAgaWYgKE1hdGguYWJzKHJoKSA8PSBFUFNMTikge1xuXHQgICAgICBsYXQgPSB0aGlzLmxhdDA7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgbGF0ID0gYXNpbnooY29zeiAqIHRoaXMuc2luX3AxMiArIChwLnkgKiBzaW56ICogdGhpcy5jb3NfcDEyKSAvIHJoKTtcblx0ICAgICAgY29uID0gTWF0aC5hYnModGhpcy5sYXQwKSAtIEhBTEZfUEk7XG5cdCAgICAgIGlmIChNYXRoLmFicyhjb24pIDw9IEVQU0xOKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG5cdCAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSBwLnkpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgLSBNYXRoLmF0YW4yKC1wLngsIHAueSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBlbHNlIHtcblx0ICAgICAgICAvKmNvbiA9IGNvc3ogLSB0aGlzLnNpbl9wMTIgKiBNYXRoLnNpbihsYXQpO1xuXHQgICAgICAgIGlmICgoTWF0aC5hYnMoY29uKSA8IEVQU0xOKSAmJiAoTWF0aC5hYnMocC54KSA8IEVQU0xOKSkge1xuXHQgICAgICAgICAgLy9uby1vcCwganVzdCBrZWVwIHRoZSBsb24gdmFsdWUgYXMgaXNcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIHRlbXAgPSBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSk7XG5cdCAgICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSkpO1xuXHQgICAgICAgIH0qL1xuXHQgICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogc2lueiwgcmggKiB0aGlzLmNvc19wMTIgKiBjb3N6IC0gcC55ICogdGhpcy5zaW5fcDEyICogc2lueikpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHAueCA9IGxvbjtcblx0ICAgIHAueSA9IGxhdDtcblx0ICAgIHJldHVybiBwO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIGUwID0gZTBmbih0aGlzLmVzKTtcblx0ICAgIGUxID0gZTFmbih0aGlzLmVzKTtcblx0ICAgIGUyID0gZTJmbih0aGlzLmVzKTtcblx0ICAgIGUzID0gZTNmbih0aGlzLmVzKTtcblx0ICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuXHQgICAgICAvL05vcnRoIHBvbGUgY2FzZVxuXHQgICAgICBNbHAgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBIQUxGX1BJKTtcblx0ICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcblx0ICAgICAgTSA9IE1scCAtIHJoO1xuXHQgICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG5cdCAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCAtIDEgKiBwLnkpKTtcblx0ICAgICAgcC54ID0gbG9uO1xuXHQgICAgICBwLnkgPSBsYXQ7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyICsgMSkgPD0gRVBTTE4pIHtcblx0ICAgICAgLy9Tb3V0aCBwb2xlIGNhc2Vcblx0ICAgICAgTWxwID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgSEFMRl9QSSk7XG5cdCAgICAgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgICAgIE0gPSByaCAtIE1scDtcblxuXHQgICAgICBsYXQgPSBpbWxmbihNIC8gdGhpcy5hLCBlMCwgZTEsIGUyLCBlMyk7XG5cdCAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCBwLnkpKTtcblx0ICAgICAgcC54ID0gbG9uO1xuXHQgICAgICBwLnkgPSBsYXQ7XG5cdCAgICAgIHJldHVybiBwO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgIC8vZGVmYXVsdCBjYXNlXG5cdCAgICAgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgICAgIEF6ID0gTWF0aC5hdGFuMihwLngsIHAueSk7XG5cdCAgICAgIE4xID0gZ04odGhpcy5hLCB0aGlzLmUsIHRoaXMuc2luX3AxMik7XG5cdCAgICAgIGNvc0F6ID0gTWF0aC5jb3MoQXopO1xuXHQgICAgICB0bXAgPSB0aGlzLmUgKiB0aGlzLmNvc19wMTIgKiBjb3NBejtcblx0ICAgICAgQSA9IC10bXAgKiB0bXAgLyAoMSAtIHRoaXMuZXMpO1xuXHQgICAgICBCID0gMyAqIHRoaXMuZXMgKiAoMSAtIEEpICogdGhpcy5zaW5fcDEyICogdGhpcy5jb3NfcDEyICogY29zQXogLyAoMSAtIHRoaXMuZXMpO1xuXHQgICAgICBEID0gcmggLyBOMTtcblx0ICAgICAgRWUgPSBEIC0gQSAqICgxICsgQSkgKiBNYXRoLnBvdyhELCAzKSAvIDYgLSBCICogKDEgKyAzICogQSkgKiBNYXRoLnBvdyhELCA0KSAvIDI0O1xuXHQgICAgICBGID0gMSAtIEEgKiBFZSAqIEVlIC8gMiAtIEQgKiBFZSAqIEVlICogRWUgLyA2O1xuXHQgICAgICBwc2kgPSBNYXRoLmFzaW4odGhpcy5zaW5fcDEyICogTWF0aC5jb3MoRWUpICsgdGhpcy5jb3NfcDEyICogTWF0aC5zaW4oRWUpICogY29zQXopO1xuXHQgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmFzaW4oTWF0aC5zaW4oQXopICogTWF0aC5zaW4oRWUpIC8gTWF0aC5jb3MocHNpKSkpO1xuXHQgICAgICBsYXQgPSBNYXRoLmF0YW4oKDEgLSB0aGlzLmVzICogRiAqIHRoaXMuc2luX3AxMiAvIE1hdGguc2luKHBzaSkpICogTWF0aC50YW4ocHNpKSAvICgxIC0gdGhpcy5lcykpO1xuXHQgICAgICBwLnggPSBsb247XG5cdCAgICAgIHAueSA9IGxhdDtcblx0ICAgICAgcmV0dXJuIHA7XG5cdCAgICB9XG5cdCAgfVxuXG5cdH1cblxuXHR2YXIgbmFtZXMkMjYgPSBbXCJBemltdXRoYWxfRXF1aWRpc3RhbnRcIiwgXCJhZXFkXCJdO1xuXHR2YXIgYWVxZCA9IHtcblx0ICBpbml0OiBpbml0JDI1LFxuXHQgIGZvcndhcmQ6IGZvcndhcmQkMjQsXG5cdCAgaW52ZXJzZTogaW52ZXJzZSQyNCxcblx0ICBuYW1lczogbmFtZXMkMjZcblx0fTtcblxuXHRmdW5jdGlvbiBpbml0JDI2KCkge1xuXHQgIC8vZG91YmxlIHRlbXA7ICAgICAgLyogdGVtcG9yYXJ5IHZhcmlhYmxlICAgICovXG5cblx0ICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG5cdCAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHRoaXMuc2luX3AxNCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG5cdCAgdGhpcy5jb3NfcDE0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcblx0fVxuXG5cdC8qIE9ydGhvZ3JhcGhpYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcblx0ICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdGZ1bmN0aW9uIGZvcndhcmQkMjUocCkge1xuXHQgIHZhciBzaW5waGksIGNvc3BoaTsgLyogc2luIGFuZCBjb3MgdmFsdWUgICAgICAgICovXG5cdCAgdmFyIGRsb247IC8qIGRlbHRhIGxvbmdpdHVkZSB2YWx1ZSAgICAgICovXG5cdCAgdmFyIGNvc2xvbjsgLyogY29zIG9mIGxvbmdpdHVkZSAgICAgICAgKi9cblx0ICB2YXIga3NwOyAvKiBzY2FsZSBmYWN0b3IgICAgICAgICAgKi9cblx0ICB2YXIgZywgeCwgeTtcblx0ICB2YXIgbG9uID0gcC54O1xuXHQgIHZhciBsYXQgPSBwLnk7XG5cdCAgLyogRm9yd2FyZCBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuXG5cdCAgc2lucGhpID0gTWF0aC5zaW4obGF0KTtcblx0ICBjb3NwaGkgPSBNYXRoLmNvcyhsYXQpO1xuXG5cdCAgY29zbG9uID0gTWF0aC5jb3MoZGxvbik7XG5cdCAgZyA9IHRoaXMuc2luX3AxNCAqIHNpbnBoaSArIHRoaXMuY29zX3AxNCAqIGNvc3BoaSAqIGNvc2xvbjtcblx0ICBrc3AgPSAxO1xuXHQgIGlmICgoZyA+IDApIHx8IChNYXRoLmFicyhnKSA8PSBFUFNMTikpIHtcblx0ICAgIHggPSB0aGlzLmEgKiBrc3AgKiBjb3NwaGkgKiBNYXRoLnNpbihkbG9uKTtcblx0ICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICoga3NwICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbik7XG5cdCAgfVxuXHQgIHAueCA9IHg7XG5cdCAgcC55ID0geTtcblx0ICByZXR1cm4gcDtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmVyc2UkMjUocCkge1xuXHQgIHZhciByaDsgLyogaGVpZ2h0IGFib3ZlIGVsbGlwc29pZCAgICAgICovXG5cdCAgdmFyIHo7IC8qIGFuZ2xlICAgICAgICAgICovXG5cdCAgdmFyIHNpbnosIGNvc3o7IC8qIHNpbiBvZiB6IGFuZCBjb3Mgb2YgeiAgICAgICovXG5cdCAgdmFyIGNvbjtcblx0ICB2YXIgbG9uLCBsYXQ7XG5cdCAgLyogSW52ZXJzZSBlcXVhdGlvbnNcblx0ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQgIHAueCAtPSB0aGlzLngwO1xuXHQgIHAueSAtPSB0aGlzLnkwO1xuXHQgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG5cdCAgeiA9IGFzaW56KHJoIC8gdGhpcy5hKTtcblxuXHQgIHNpbnogPSBNYXRoLnNpbih6KTtcblx0ICBjb3N6ID0gTWF0aC5jb3Moeik7XG5cblx0ICBsb24gPSB0aGlzLmxvbmcwO1xuXHQgIGlmIChNYXRoLmFicyhyaCkgPD0gRVBTTE4pIHtcblx0ICAgIGxhdCA9IHRoaXMubGF0MDtcblx0ICAgIHAueCA9IGxvbjtcblx0ICAgIHAueSA9IGxhdDtcblx0ICAgIHJldHVybiBwO1xuXHQgIH1cblx0ICBsYXQgPSBhc2lueihjb3N6ICogdGhpcy5zaW5fcDE0ICsgKHAueSAqIHNpbnogKiB0aGlzLmNvc19wMTQpIC8gcmgpO1xuXHQgIGNvbiA9IE1hdGguYWJzKHRoaXMubGF0MCkgLSBIQUxGX1BJO1xuXHQgIGlmIChNYXRoLmFicyhjb24pIDw9IEVQU0xOKSB7XG5cdCAgICBpZiAodGhpcy5sYXQwID49IDApIHtcblx0ICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gcC55KSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwIC0gTWF0aC5hdGFuMigtcC54LCBwLnkpKTtcblx0ICAgIH1cblx0ICAgIHAueCA9IGxvbjtcblx0ICAgIHAueSA9IGxhdDtcblx0ICAgIHJldHVybiBwO1xuXHQgIH1cblx0ICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKChwLnggKiBzaW56KSwgcmggKiB0aGlzLmNvc19wMTQgKiBjb3N6IC0gcC55ICogdGhpcy5zaW5fcDE0ICogc2lueikpO1xuXHQgIHAueCA9IGxvbjtcblx0ICBwLnkgPSBsYXQ7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHR2YXIgbmFtZXMkMjcgPSBbXCJvcnRob1wiXTtcblx0dmFyIG9ydGhvID0ge1xuXHQgIGluaXQ6IGluaXQkMjYsXG5cdCAgZm9yd2FyZDogZm9yd2FyZCQyNSxcblx0ICBpbnZlcnNlOiBpbnZlcnNlJDI1LFxuXHQgIG5hbWVzOiBuYW1lcyQyN1xuXHR9O1xuXG5cdC8vIFFTQyBwcm9qZWN0aW9uIHJld3JpdHRlbiBmcm9tIHRoZSBvcmlnaW5hbCBQUk9KNFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vT1NHZW8vcHJvai40L2Jsb2IvbWFzdGVyL3NyYy9QSl9xc2MuY1xuXG5cdC8qIGNvbnN0YW50cyAqL1xuXHR2YXIgRkFDRV9FTlVNID0ge1xuXHQgICAgRlJPTlQ6IDEsXG5cdCAgICBSSUdIVDogMixcblx0ICAgIEJBQ0s6IDMsXG5cdCAgICBMRUZUOiA0LFxuXHQgICAgVE9QOiA1LFxuXHQgICAgQk9UVE9NOiA2XG5cdH07XG5cblx0dmFyIEFSRUFfRU5VTSA9IHtcblx0ICAgIEFSRUFfMDogMSxcblx0ICAgIEFSRUFfMTogMixcblx0ICAgIEFSRUFfMjogMyxcblx0ICAgIEFSRUFfMzogNFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXQkMjcoKSB7XG5cblx0ICB0aGlzLngwID0gdGhpcy54MCB8fCAwO1xuXHQgIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG5cdCAgdGhpcy5sYXQwID0gdGhpcy5sYXQwIHx8IDA7XG5cdCAgdGhpcy5sb25nMCA9IHRoaXMubG9uZzAgfHwgMDtcblx0ICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG5cdCAgdGhpcy50aXRsZSA9IHRoaXMudGl0bGUgfHwgXCJRdWFkcmlsYXRlcmFsaXplZCBTcGhlcmljYWwgQ3ViZVwiO1xuXG5cdCAgLyogRGV0ZXJtaW5lIHRoZSBjdWJlIGZhY2UgZnJvbSB0aGUgY2VudGVyIG9mIHByb2plY3Rpb24uICovXG5cdCAgaWYgKHRoaXMubGF0MCA+PSBIQUxGX1BJIC0gRk9SVFBJIC8gMi4wKSB7XG5cdCAgICB0aGlzLmZhY2UgPSBGQUNFX0VOVU0uVE9QO1xuXHQgIH0gZWxzZSBpZiAodGhpcy5sYXQwIDw9IC0oSEFMRl9QSSAtIEZPUlRQSSAvIDIuMCkpIHtcblx0ICAgIHRoaXMuZmFjZSA9IEZBQ0VfRU5VTS5CT1RUT007XG5cdCAgfSBlbHNlIGlmIChNYXRoLmFicyh0aGlzLmxvbmcwKSA8PSBGT1JUUEkpIHtcblx0ICAgIHRoaXMuZmFjZSA9IEZBQ0VfRU5VTS5GUk9OVDtcblx0ICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMubG9uZzApIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcblx0ICAgIHRoaXMuZmFjZSA9IHRoaXMubG9uZzAgPiAwLjAgPyBGQUNFX0VOVU0uUklHSFQgOiBGQUNFX0VOVU0uTEVGVDtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5mYWNlID0gRkFDRV9FTlVNLkJBQ0s7XG5cdCAgfVxuXG5cdCAgLyogRmlsbCBpbiB1c2VmdWwgdmFsdWVzIGZvciB0aGUgZWxsaXBzb2lkIDwtPiBzcGhlcmUgc2hpZnRcblx0ICAgKiBkZXNjcmliZWQgaW4gW0xLMTJdLiAqL1xuXHQgIGlmICh0aGlzLmVzICE9PSAwKSB7XG5cdCAgICB0aGlzLm9uZV9taW51c19mID0gMSAtICh0aGlzLmEgLSB0aGlzLmIpIC8gdGhpcy5hO1xuXHQgICAgdGhpcy5vbmVfbWludXNfZl9zcXVhcmVkID0gdGhpcy5vbmVfbWludXNfZiAqIHRoaXMub25lX21pbnVzX2Y7XG5cdCAgfVxuXHR9XG5cblx0Ly8gUVNDIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRmdW5jdGlvbiBmb3J3YXJkJDI2KHApIHtcblx0ICB2YXIgeHkgPSB7eDogMCwgeTogMH07XG5cdCAgdmFyIGxhdCwgbG9uO1xuXHQgIHZhciB0aGV0YSwgcGhpO1xuXHQgIHZhciB0LCBtdTtcblx0ICAvKiBudTsgKi9cblx0ICB2YXIgYXJlYSA9IHt2YWx1ZTogMH07XG5cblx0ICAvLyBtb3ZlIGxvbiBhY2NvcmRpbmcgdG8gcHJvamVjdGlvbidzIGxvblxuXHQgIHAueCAtPSB0aGlzLmxvbmcwO1xuXG5cdCAgLyogQ29udmVydCB0aGUgZ2VvZGV0aWMgbGF0aXR1ZGUgdG8gYSBnZW9jZW50cmljIGxhdGl0dWRlLlxuXHQgICAqIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIHNoaWZ0IGZyb20gdGhlIGVsbGlwc29pZCB0byB0aGUgc3BoZXJlXG5cdCAgICogZGVzY3JpYmVkIGluIFtMSzEyXS4gKi9cblx0ICBpZiAodGhpcy5lcyAhPT0gMCkgey8vaWYgKFAtPmVzICE9IDApIHtcblx0ICAgIGxhdCA9IE1hdGguYXRhbih0aGlzLm9uZV9taW51c19mX3NxdWFyZWQgKiBNYXRoLnRhbihwLnkpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgbGF0ID0gcC55O1xuXHQgIH1cblxuXHQgIC8qIENvbnZlcnQgdGhlIGlucHV0IGxhdCwgbG9uIGludG8gdGhldGEsIHBoaSBhcyB1c2VkIGJ5IFFTQy5cblx0ICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIGN1YmUgZmFjZSBhbmQgdGhlIGFyZWEgb24gaXQuXG5cdCAgICogRm9yIHRoZSB0b3AgYW5kIGJvdHRvbSBmYWNlLCB3ZSBjYW4gY29tcHV0ZSB0aGV0YSBhbmQgcGhpXG5cdCAgICogZGlyZWN0bHkgZnJvbSBwaGksIGxhbS4gRm9yIHRoZSBvdGhlciBmYWNlcywgd2UgbXVzdCB1c2Vcblx0ICAgKiB1bml0IHNwaGVyZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXMgYXMgYW4gaW50ZXJtZWRpYXRlIHN0ZXAuICovXG5cdCAgbG9uID0gcC54OyAvL2xvbiA9IGxwLmxhbTtcblx0ICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uVE9QKSB7XG5cdCAgICBwaGkgPSBIQUxGX1BJIC0gbGF0O1xuXHQgICAgaWYgKGxvbiA+PSBGT1JUUEkgJiYgbG9uIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG5cdCAgICAgIHRoZXRhID0gbG9uIC0gSEFMRl9QSTtcblx0ICAgIH0gZWxzZSBpZiAobG9uID4gSEFMRl9QSSArIEZPUlRQSSB8fCBsb24gPD0gLShIQUxGX1BJICsgRk9SVFBJKSkge1xuXHQgICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMTtcblx0ICAgICAgdGhldGEgPSAobG9uID4gMC4wID8gbG9uIC0gU1BJIDogbG9uICsgU1BJKTtcblx0ICAgIH0gZWxzZSBpZiAobG9uID4gLShIQUxGX1BJICsgRk9SVFBJKSAmJiBsb24gPD0gLUZPUlRQSSkge1xuXHQgICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMjtcblx0ICAgICAgdGhldGEgPSBsb24gKyBIQUxGX1BJO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzM7XG5cdCAgICAgIHRoZXRhID0gbG9uO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQk9UVE9NKSB7XG5cdCAgICBwaGkgPSBIQUxGX1BJICsgbGF0O1xuXHQgICAgaWYgKGxvbiA+PSBGT1JUUEkgJiYgbG9uIDw9IEhBTEZfUEkgKyBGT1JUUEkpIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG5cdCAgICAgIHRoZXRhID0gLWxvbiArIEhBTEZfUEk7XG5cdCAgICB9IGVsc2UgaWYgKGxvbiA8IEZPUlRQSSAmJiBsb24gPj0gLUZPUlRQSSkge1xuXHQgICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMTtcblx0ICAgICAgdGhldGEgPSAtbG9uO1xuXHQgICAgfSBlbHNlIGlmIChsb24gPCAtRk9SVFBJICYmIGxvbiA+PSAtKEhBTEZfUEkgKyBGT1JUUEkpKSB7XG5cdCAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8yO1xuXHQgICAgICB0aGV0YSA9IC1sb24gLSBIQUxGX1BJO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzM7XG5cdCAgICAgIHRoZXRhID0gKGxvbiA+IDAuMCA/IC1sb24gKyBTUEkgOiAtbG9uIC0gU1BJKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIHEsIHIsIHM7XG5cdCAgICB2YXIgc2lubGF0LCBjb3NsYXQ7XG5cdCAgICB2YXIgc2lubG9uLCBjb3Nsb247XG5cblx0ICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuXHQgICAgICBsb24gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihsb24sICtIQUxGX1BJKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQkFDSykge1xuXHQgICAgICBsb24gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihsb24sICtTUEkpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG5cdCAgICAgIGxvbiA9IHFzY19zaGlmdF9sb25fb3JpZ2luKGxvbiwgLUhBTEZfUEkpO1xuXHQgICAgfVxuXHQgICAgc2lubGF0ID0gTWF0aC5zaW4obGF0KTtcblx0ICAgIGNvc2xhdCA9IE1hdGguY29zKGxhdCk7XG5cdCAgICBzaW5sb24gPSBNYXRoLnNpbihsb24pO1xuXHQgICAgY29zbG9uID0gTWF0aC5jb3MobG9uKTtcblx0ICAgIHEgPSBjb3NsYXQgKiBjb3Nsb247XG5cdCAgICByID0gY29zbGF0ICogc2lubG9uO1xuXHQgICAgcyA9IHNpbmxhdDtcblxuXHQgICAgaWYgKHRoaXMuZmFjZSA9PT0gRkFDRV9FTlVNLkZST05UKSB7XG5cdCAgICAgIHBoaSA9IE1hdGguYWNvcyhxKTtcblx0ICAgICAgdGhldGEgPSBxc2NfZndkX2VxdWF0X2ZhY2VfdGhldGEocGhpLCBzLCByLCBhcmVhKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uUklHSFQpIHtcblx0ICAgICAgcGhpID0gTWF0aC5hY29zKHIpO1xuXHQgICAgICB0aGV0YSA9IHFzY19md2RfZXF1YXRfZmFjZV90aGV0YShwaGksIHMsIC1xLCBhcmVhKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQkFDSykge1xuXHQgICAgICBwaGkgPSBNYXRoLmFjb3MoLXEpO1xuXHQgICAgICB0aGV0YSA9IHFzY19md2RfZXF1YXRfZmFjZV90aGV0YShwaGksIHMsIC1yLCBhcmVhKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uTEVGVCkge1xuXHQgICAgICBwaGkgPSBNYXRoLmFjb3MoLXIpO1xuXHQgICAgICB0aGV0YSA9IHFzY19md2RfZXF1YXRfZmFjZV90aGV0YShwaGksIHMsIHEsIGFyZWEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLyogSW1wb3NzaWJsZSAqL1xuXHQgICAgICBwaGkgPSB0aGV0YSA9IDA7XG5cdCAgICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8wO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qIENvbXB1dGUgbXUgYW5kIG51IGZvciB0aGUgYXJlYSBvZiBkZWZpbml0aW9uLlxuXHQgICAqIEZvciBtdSwgc2VlIEVxLiAoMy0yMSkgaW4gW09MNzZdLCBidXQgbm90ZSB0aGUgdHlwb3M6XG5cdCAgICogY29tcGFyZSB3aXRoIEVxLiAoMy0xNCkuIEZvciBudSwgc2VlIEVxLiAoMy0zOCkuICovXG5cdCAgbXUgPSBNYXRoLmF0YW4oKDEyIC8gU1BJKSAqICh0aGV0YSArIE1hdGguYWNvcyhNYXRoLnNpbih0aGV0YSkgKiBNYXRoLmNvcyhGT1JUUEkpKSAtIEhBTEZfUEkpKTtcblx0ICB0ID0gTWF0aC5zcXJ0KCgxIC0gTWF0aC5jb3MocGhpKSkgLyAoTWF0aC5jb3MobXUpICogTWF0aC5jb3MobXUpKSAvICgxIC0gTWF0aC5jb3MoTWF0aC5hdGFuKDEgLyBNYXRoLmNvcyh0aGV0YSkpKSkpO1xuXG5cdCAgLyogQXBwbHkgdGhlIHJlc3VsdCB0byB0aGUgcmVhbCBhcmVhLiAqL1xuXHQgIGlmIChhcmVhLnZhbHVlID09PSBBUkVBX0VOVU0uQVJFQV8xKSB7XG5cdCAgICBtdSArPSBIQUxGX1BJO1xuXHQgIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMikge1xuXHQgICAgbXUgKz0gU1BJO1xuXHQgIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMykge1xuXHQgICAgbXUgKz0gMS41ICogU1BJO1xuXHQgIH1cblxuXHQgIC8qIE5vdyBjb21wdXRlIHgsIHkgZnJvbSBtdSBhbmQgbnUgKi9cblx0ICB4eS54ID0gdCAqIE1hdGguY29zKG11KTtcblx0ICB4eS55ID0gdCAqIE1hdGguc2luKG11KTtcblx0ICB4eS54ID0geHkueCAqIHRoaXMuYSArIHRoaXMueDA7XG5cdCAgeHkueSA9IHh5LnkgKiB0aGlzLmEgKyB0aGlzLnkwO1xuXG5cdCAgcC54ID0geHkueDtcblx0ICBwLnkgPSB4eS55O1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0Ly8gUVNDIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRmdW5jdGlvbiBpbnZlcnNlJDI2KHApIHtcblx0ICB2YXIgbHAgPSB7bGFtOiAwLCBwaGk6IDB9O1xuXHQgIHZhciBtdSwgbnUsIGNvc211LCB0YW5udTtcblx0ICB2YXIgdGFudGhldGEsIHRoZXRhLCBjb3NwaGksIHBoaTtcblx0ICB2YXIgdDtcblx0ICB2YXIgYXJlYSA9IHt2YWx1ZTogMH07XG5cblx0ICAvKiBkZS1vZmZzZXQgKi9cblx0ICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG5cdCAgcC55ID0gKHAueSAtIHRoaXMueTApIC8gdGhpcy5hO1xuXG5cdCAgLyogQ29udmVydCB0aGUgaW5wdXQgeCwgeSB0byB0aGUgbXUgYW5kIG51IGFuZ2xlcyBhcyB1c2VkIGJ5IFFTQy5cblx0ICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIGFyZWEgb2YgdGhlIGN1YmUgZmFjZS4gKi9cblx0ICBudSA9IE1hdGguYXRhbihNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KSk7XG5cdCAgbXUgPSBNYXRoLmF0YW4yKHAueSwgcC54KTtcblx0ICBpZiAocC54ID49IDAuMCAmJiBwLnggPj0gTWF0aC5hYnMocC55KSkge1xuXHQgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzA7XG5cdCAgfSBlbHNlIGlmIChwLnkgPj0gMC4wICYmIHAueSA+PSBNYXRoLmFicyhwLngpKSB7XG5cdCAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMTtcblx0ICAgIG11IC09IEhBTEZfUEk7XG5cdCAgfSBlbHNlIGlmIChwLnggPCAwLjAgJiYgLXAueCA+PSBNYXRoLmFicyhwLnkpKSB7XG5cdCAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMjtcblx0ICAgIG11ID0gKG11IDwgMC4wID8gbXUgKyBTUEkgOiBtdSAtIFNQSSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGFyZWEudmFsdWUgPSBBUkVBX0VOVU0uQVJFQV8zO1xuXHQgICAgbXUgKz0gSEFMRl9QSTtcblx0ICB9XG5cblx0ICAvKiBDb21wdXRlIHBoaSBhbmQgdGhldGEgZm9yIHRoZSBhcmVhIG9mIGRlZmluaXRpb24uXG5cdCAgICogVGhlIGludmVyc2UgcHJvamVjdGlvbiBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBvcmlnaW5hbCBwYXBlciwgYnV0IHNvbWVcblx0ICAgKiBnb29kIGhpbnRzIGNhbiBiZSBmb3VuZCBoZXJlIChhcyBvZiAyMDExLTEyLTE0KTpcblx0ICAgKiBodHRwOi8vZml0cy5nc2ZjLm5hc2EuZ292L2ZpdHNiaXRzL3NhZi45My9zYWYuOTMwMlxuXHQgICAqIChzZWFyY2ggZm9yIFwiTWVzc2FnZS1JZDogPDkzMDIxODE3NTkuQUEyNTQ3NyBhdCBmaXRzLmN2Lm5yYW8uZWR1PlwiKSAqL1xuXHQgIHQgPSAoU1BJIC8gMTIpICogTWF0aC50YW4obXUpO1xuXHQgIHRhbnRoZXRhID0gTWF0aC5zaW4odCkgLyAoTWF0aC5jb3ModCkgLSAoMSAvIE1hdGguc3FydCgyKSkpO1xuXHQgIHRoZXRhID0gTWF0aC5hdGFuKHRhbnRoZXRhKTtcblx0ICBjb3NtdSA9IE1hdGguY29zKG11KTtcblx0ICB0YW5udSA9IE1hdGgudGFuKG51KTtcblx0ICBjb3NwaGkgPSAxIC0gY29zbXUgKiBjb3NtdSAqIHRhbm51ICogdGFubnUgKiAoMSAtIE1hdGguY29zKE1hdGguYXRhbigxIC8gTWF0aC5jb3ModGhldGEpKSkpO1xuXHQgIGlmIChjb3NwaGkgPCAtMSkge1xuXHQgICAgY29zcGhpID0gLTE7XG5cdCAgfSBlbHNlIGlmIChjb3NwaGkgPiArMSkge1xuXHQgICAgY29zcGhpID0gKzE7XG5cdCAgfVxuXG5cdCAgLyogQXBwbHkgdGhlIHJlc3VsdCB0byB0aGUgcmVhbCBhcmVhIG9uIHRoZSBjdWJlIGZhY2UuXG5cdCAgICogRm9yIHRoZSB0b3AgYW5kIGJvdHRvbSBmYWNlLCB3ZSBjYW4gY29tcHV0ZSBwaGkgYW5kIGxhbSBkaXJlY3RseS5cblx0ICAgKiBGb3IgdGhlIG90aGVyIGZhY2VzLCB3ZSBtdXN0IHVzZSB1bml0IHNwaGVyZSBjYXJ0ZXNpYW4gY29vcmRpbmF0ZXNcblx0ICAgKiBhcyBhbiBpbnRlcm1lZGlhdGUgc3RlcC4gKi9cblx0ICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uVE9QKSB7XG5cdCAgICBwaGkgPSBNYXRoLmFjb3MoY29zcGhpKTtcblx0ICAgIGxwLnBoaSA9IEhBTEZfUEkgLSBwaGk7XG5cdCAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuXHQgICAgICBscC5sYW0gPSB0aGV0YSArIEhBTEZfUEk7XG5cdCAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcblx0ICAgICAgbHAubGFtID0gKHRoZXRhIDwgMC4wID8gdGhldGEgKyBTUEkgOiB0aGV0YSAtIFNQSSk7XG5cdCAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcblx0ICAgICAgbHAubGFtID0gdGhldGEgLSBIQUxGX1BJO1xuXHQgICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG5cdCAgICAgIGxwLmxhbSA9IHRoZXRhO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQk9UVE9NKSB7XG5cdCAgICBwaGkgPSBNYXRoLmFjb3MoY29zcGhpKTtcblx0ICAgIGxwLnBoaSA9IHBoaSAtIEhBTEZfUEk7XG5cdCAgICBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMCkge1xuXHQgICAgICBscC5sYW0gPSAtdGhldGEgKyBIQUxGX1BJO1xuXHQgICAgfSBlbHNlIGlmIChhcmVhLnZhbHVlID09PSBBUkVBX0VOVU0uQVJFQV8xKSB7XG5cdCAgICAgIGxwLmxhbSA9IC10aGV0YTtcblx0ICAgIH0gZWxzZSBpZiAoYXJlYS52YWx1ZSA9PT0gQVJFQV9FTlVNLkFSRUFfMikge1xuXHQgICAgICBscC5sYW0gPSAtdGhldGEgLSBIQUxGX1BJO1xuXHQgICAgfSBlbHNlIC8qIGFyZWEudmFsdWUgPT0gQVJFQV9FTlVNLkFSRUFfMyAqLyB7XG5cdCAgICAgIGxwLmxhbSA9ICh0aGV0YSA8IDAuMCA/IC10aGV0YSAtIFNQSSA6IC10aGV0YSArIFNQSSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8qIENvbXB1dGUgcGhpIGFuZCBsYW0gdmlhIGNhcnRlc2lhbiB1bml0IHNwaGVyZSBjb29yZGluYXRlcy4gKi9cblx0ICAgIHZhciBxLCByLCBzO1xuXHQgICAgcSA9IGNvc3BoaTtcblx0ICAgIHQgPSBxICogcTtcblx0ICAgIGlmICh0ID49IDEpIHtcblx0ICAgICAgcyA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzID0gTWF0aC5zcXJ0KDEgLSB0KSAqIE1hdGguc2luKHRoZXRhKTtcblx0ICAgIH1cblx0ICAgIHQgKz0gcyAqIHM7XG5cdCAgICBpZiAodCA+PSAxKSB7XG5cdCAgICAgIHIgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgciA9IE1hdGguc3FydCgxIC0gdCk7XG5cdCAgICB9XG5cdCAgICAvKiBSb3RhdGUgcSxyLHMgaW50byB0aGUgY29ycmVjdCBhcmVhLiAqL1xuXHQgICAgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzEpIHtcblx0ICAgICAgdCA9IHI7XG5cdCAgICAgIHIgPSAtcztcblx0ICAgICAgcyA9IHQ7XG5cdCAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzIpIHtcblx0ICAgICAgciA9IC1yO1xuXHQgICAgICBzID0gLXM7XG5cdCAgICB9IGVsc2UgaWYgKGFyZWEudmFsdWUgPT09IEFSRUFfRU5VTS5BUkVBXzMpIHtcblx0ICAgICAgdCA9IHI7XG5cdCAgICAgIHIgPSBzO1xuXHQgICAgICBzID0gLXQ7XG5cdCAgICB9XG5cdCAgICAvKiBSb3RhdGUgcSxyLHMgaW50byB0aGUgY29ycmVjdCBjdWJlIGZhY2UuICovXG5cdCAgICBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uUklHSFQpIHtcblx0ICAgICAgdCA9IHE7XG5cdCAgICAgIHEgPSAtcjtcblx0ICAgICAgciA9IHQ7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuZmFjZSA9PT0gRkFDRV9FTlVNLkJBQ0spIHtcblx0ICAgICAgcSA9IC1xO1xuXHQgICAgICByID0gLXI7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuZmFjZSA9PT0gRkFDRV9FTlVNLkxFRlQpIHtcblx0ICAgICAgdCA9IHE7XG5cdCAgICAgIHEgPSByO1xuXHQgICAgICByID0gLXQ7XG5cdCAgICB9XG5cdCAgICAvKiBOb3cgY29tcHV0ZSBwaGkgYW5kIGxhbSBmcm9tIHRoZSB1bml0IHNwaGVyZSBjb29yZGluYXRlcy4gKi9cblx0ICAgIGxwLnBoaSA9IE1hdGguYWNvcygtcykgLSBIQUxGX1BJO1xuXHQgICAgbHAubGFtID0gTWF0aC5hdGFuMihyLCBxKTtcblx0ICAgIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5SSUdIVCkge1xuXHQgICAgICBscC5sYW0gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihscC5sYW0sIC1IQUxGX1BJKTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5mYWNlID09PSBGQUNFX0VOVU0uQkFDSykge1xuXHQgICAgICBscC5sYW0gPSBxc2Nfc2hpZnRfbG9uX29yaWdpbihscC5sYW0sIC1TUEkpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmZhY2UgPT09IEZBQ0VfRU5VTS5MRUZUKSB7XG5cdCAgICAgIGxwLmxhbSA9IHFzY19zaGlmdF9sb25fb3JpZ2luKGxwLmxhbSwgK0hBTEZfUEkpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qIEFwcGx5IHRoZSBzaGlmdCBmcm9tIHRoZSBzcGhlcmUgdG8gdGhlIGVsbGlwc29pZCBhcyBkZXNjcmliZWRcblx0ICAgKiBpbiBbTEsxMl0uICovXG5cdCAgaWYgKHRoaXMuZXMgIT09IDApIHtcblx0ICAgIHZhciBpbnZlcnRfc2lnbjtcblx0ICAgIHZhciB0YW5waGksIHhhO1xuXHQgICAgaW52ZXJ0X3NpZ24gPSAobHAucGhpIDwgMCA/IDEgOiAwKTtcblx0ICAgIHRhbnBoaSA9IE1hdGgudGFuKGxwLnBoaSk7XG5cdCAgICB4YSA9IHRoaXMuYiAvIE1hdGguc3FydCh0YW5waGkgKiB0YW5waGkgKyB0aGlzLm9uZV9taW51c19mX3NxdWFyZWQpO1xuXHQgICAgbHAucGhpID0gTWF0aC5hdGFuKE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgLSB4YSAqIHhhKSAvICh0aGlzLm9uZV9taW51c19mICogeGEpKTtcblx0ICAgIGlmIChpbnZlcnRfc2lnbikge1xuXHQgICAgICBscC5waGkgPSAtbHAucGhpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGxwLmxhbSArPSB0aGlzLmxvbmcwO1xuXHQgIHAueCA9IGxwLmxhbTtcblx0ICBwLnkgPSBscC5waGk7XG5cdCAgcmV0dXJuIHA7XG5cdH1cblxuXHQvKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGZvcndhcmQgcHJvamVjdGlvbjogY29tcHV0ZSB0aGUgdGhldGEgYW5nbGVcblx0ICogYW5kIGRldGVybWluZSB0aGUgYXJlYSBudW1iZXIuICovXG5cdGZ1bmN0aW9uIHFzY19md2RfZXF1YXRfZmFjZV90aGV0YShwaGksIHksIHgsIGFyZWEpIHtcblx0ICB2YXIgdGhldGE7XG5cdCAgaWYgKHBoaSA8IEVQU0xOKSB7XG5cdCAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcblx0ICAgIHRoZXRhID0gMC4wO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGV0YSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdCAgICBpZiAoTWF0aC5hYnModGhldGEpIDw9IEZPUlRQSSkge1xuXHQgICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMDtcblx0ICAgIH0gZWxzZSBpZiAodGhldGEgPiBGT1JUUEkgJiYgdGhldGEgPD0gSEFMRl9QSSArIEZPUlRQSSkge1xuXHQgICAgICBhcmVhLnZhbHVlID0gQVJFQV9FTlVNLkFSRUFfMTtcblx0ICAgICAgdGhldGEgLT0gSEFMRl9QSTtcblx0ICAgIH0gZWxzZSBpZiAodGhldGEgPiBIQUxGX1BJICsgRk9SVFBJIHx8IHRoZXRhIDw9IC0oSEFMRl9QSSArIEZPUlRQSSkpIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzI7XG5cdCAgICAgIHRoZXRhID0gKHRoZXRhID49IDAuMCA/IHRoZXRhIC0gU1BJIDogdGhldGEgKyBTUEkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXJlYS52YWx1ZSA9IEFSRUFfRU5VTS5BUkVBXzM7XG5cdCAgICAgIHRoZXRhICs9IEhBTEZfUEk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiB0aGV0YTtcblx0fVxuXG5cdC8qIEhlbHBlciBmdW5jdGlvbjogc2hpZnQgdGhlIGxvbmdpdHVkZS4gKi9cblx0ZnVuY3Rpb24gcXNjX3NoaWZ0X2xvbl9vcmlnaW4obG9uLCBvZmZzZXQpIHtcblx0ICB2YXIgc2xvbiA9IGxvbiArIG9mZnNldDtcblx0ICBpZiAoc2xvbiA8IC1TUEkpIHtcblx0ICAgIHNsb24gKz0gVFdPX1BJO1xuXHQgIH0gZWxzZSBpZiAoc2xvbiA+ICtTUEkpIHtcblx0ICAgIHNsb24gLT0gVFdPX1BJO1xuXHQgIH1cblx0ICByZXR1cm4gc2xvbjtcblx0fVxuXG5cdHZhciBuYW1lcyQyOCA9IFtcIlF1YWRyaWxhdGVyYWxpemVkIFNwaGVyaWNhbCBDdWJlXCIsIFwiUXVhZHJpbGF0ZXJhbGl6ZWRfU3BoZXJpY2FsX0N1YmVcIiwgXCJxc2NcIl07XG5cdHZhciBxc2MgPSB7XG5cdCAgaW5pdDogaW5pdCQyNyxcblx0ICBmb3J3YXJkOiBmb3J3YXJkJDI2LFxuXHQgIGludmVyc2U6IGludmVyc2UkMjYsXG5cdCAgbmFtZXM6IG5hbWVzJDI4XG5cdH07XG5cblx0dmFyIGluY2x1ZGVkUHJvamVjdGlvbnMgPSBmdW5jdGlvbihwcm9qNCl7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQodG1lcmMpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGV0bWVyYyk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQodXRtKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChzdGVyZWEpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHN0ZXJlKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChzb21lcmMpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG9tZXJjKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChsY2MpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGtyb3Zhayk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoY2Fzcyk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobGFlYSk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoYWVhKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChnbm9tKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChjZWEpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGVxYyk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQocG9seSk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobnptZyk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobWlsbCk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoc2ludSk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQobW9sbCk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQoZXFkYyk7XG5cdCAgcHJvajQuUHJvai5wcm9qZWN0aW9ucy5hZGQodmFuZGcpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKGFlcWQpO1xuXHQgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKG9ydGhvKTtcblx0ICBwcm9qNC5Qcm9qLnByb2plY3Rpb25zLmFkZChxc2MpO1xuXHR9O1xuXG5cdHByb2o0JDEuZGVmYXVsdERhdHVtID0gJ1dHUzg0JzsgLy9kZWZhdWx0IGRhdHVtXG5cdHByb2o0JDEuUHJvaiA9IFByb2plY3Rpb24kMTtcblx0cHJvajQkMS5XR1M4NCA9IG5ldyBwcm9qNCQxLlByb2ooJ1dHUzg0Jyk7XG5cdHByb2o0JDEuUG9pbnQgPSBQb2ludDtcblx0cHJvajQkMS50b1BvaW50ID0gdG9Qb2ludDtcblx0cHJvajQkMS5kZWZzID0gZGVmcztcblx0cHJvajQkMS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cdHByb2o0JDEubWdycyA9IG1ncnM7XG5cdHByb2o0JDEudmVyc2lvbiA9IHZlcnNpb247XG5cdGluY2x1ZGVkUHJvamVjdGlvbnMocHJvajQkMSk7XG5cblx0cmV0dXJuIHByb2o0JDE7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9qNC9kaXN0L3Byb2o0LXNyYy5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzA2ZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nvar _Config = __webpack_require__(5);\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    /**\n     * Contrôle des droits sur les ressources.\n     *\n     * @param {Object} options - liste des options\n     * @param {String} options.key - clef API\n     * @param {Array} options.resources - liste des ressources\n     * @param {Array} options.services - liste des services\n     * @returns {Object} rightManagement - undefined ou {\n     *       key : \"\",\n     *       service-1 : [resource-1, resource-2],\n     *       service-2 : [resource-1, resource-2]\n     * }\n     */\n    check: function check(options) {\n        // logger\n\n        var logger = _LoggerByDefault2.default.getLogger(\"checkrightmanagement\");\n\n        // si aucune option n'est renseignée...\n        if (!options) {\n            // message orienté pour le developpeur !\n            logger.error(\"WARNING : \" + \"no parameter specified !\");\n            return;\n        }\n\n        // les options\n        var _key = options.key;\n        var _resources = options.resources || [];\n        var _services = options.services || [];\n\n        // si aucune information sur les ressources,\n        // il est impossible de controler quelquechose !!!\n        if (!_resources || _resources.length === 0) {\n            // message orienté pour le developpeur !\n            logger.error(\"WARNING : \" + \"no parameter 'resources' specified !\");\n            return;\n        }\n\n        // si aucune information sur les services,\n        // il est impossible de controler quelquechose !!!\n        if (!_services || _services.length === 0) {\n            // message orienté pour le developpeur !\n            logger.error(\"WARNING : \" + \"no parameter 'services' specified !\");\n            return;\n        }\n\n        // les ressources controlées :\n        // Ex.\n        // {\n        //   \"Itineraire\"     : [\"Pieton\", \"Voiture\"],\n        //   \"Geocode\"        : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\", \"Administratif\"],\n        //   \"AutoCompletion\" : [\"PositionOfInterest\", \"StreetAddress\", \"CadastralParcel\", \"Administratif\"],\n        //   \"Elevation\"      : [\"SERVICE_CALCUL_ALTIMETRIQUE_RSC\"]\n        // }\n        var _rightManagement = {};\n\n        // la clef API n'est pas renseignée\n        if (!_key) {\n            // on verifie si l'autoconfiguration est disponible\n\n            if (!_Config2.default.isConfigLoaded()) {\n                // si l'autoconfiguration n'est pas chargée,\n                // aucune vérification des droits est possible...\n\n                logger.warn(\"WARNING : \" + \"The 'apiKey' parameter is missing, \" + \"and the contract key configuration has not been loaded, \" + \"so impossible to check yours rights !\");\n\n                return;\n            } else {\n                // si l'autoconfiguration est chargée,\n                // on recupere la clef API, et on en profitera ensuite pour controler\n                // les droits sur les ressources.\n\n                // FIXME par defaut, on recupere toujours la première...\n                _key = Object.keys(_Config2.default.configuration.generalOptions.apiKeys)[0];\n                logger.log(_key);\n            }\n        }\n\n        // la clef API est renseignée ou recuperée de l'autoconfiguration\n        if (_key) {\n            // on verifie si l'autoconfiguration est disponible\n\n            if (!_Config2.default.isConfigLoaded()) {\n                // si l'autoconfiguration n'est pas chargée,\n                // il est toujours possible de requeter le service avec une clef API,\n                // mais les droits sur les ressources ne sont pas garantis, on risque\n                // d'obtenir des erreurs 403 forbidden...\n                // la responsabilité revient à l'utilisateur (message d'information)...\n\n                logger.warn(\"WARNING : \" + \"the contract key configuration has not been loaded, \" + \"so be carefull !\");\n\n                // les ressouces non controlées\n                var _noRightManagement = {};\n\n                for (var i = 0; i < _services.length; i++) {\n                    var service = _services[i];\n                    _noRightManagement[service] = [];\n\n                    for (var j = 0; j < _resources.length; j++) {\n                        var resource = _resources[j];\n                        _noRightManagement[service].push(resource);\n                    }\n                }\n\n                // on ajoute la clef\n                _noRightManagement.key = _key;\n\n                logger.log(\"right management not checked\", _noRightManagement);\n\n                return _noRightManagement;\n            } else {\n                // si l'autoconf est chargée,\n                // on verifie la correspondance entre la clef et l'autoconfiguration,\n                // on previent l'utilisateur (message d'information) s'il n'a\n                // pas de droits sur certaines ressources ...\n\n                // doit on ecarter les ressources sans droit ?\n                // oui, si possible avec un message d'information pour l'utilisateur...\n\n                for (var k = 0; k < _resources.length; k++) {\n                    var _resource = _resources[k];\n\n                    for (var l = 0; l < _services.length; l++) {\n                        var _service = _services[l];\n\n                        var params = _Config2.default.getServiceParams(_resource, _service, _key);\n                        if (!params || Object.keys(params).length === 0) {\n                            logger.warn(\"WARNING : \" + \"The contract key configuration has no rights to load this geoportal \" + \"resource (\" + _resource + \") \" + \"for this service (\" + _service + \") \");\n                            continue;\n                        }\n\n                        if (!_rightManagement[_service]) {\n                            _rightManagement[_service] = [];\n                        }\n\n                        _rightManagement[_service].push(_resource);\n                    }\n                }\n\n                if (!_rightManagement || Object.keys(_rightManagement).length === 0) {\n                    logger.warn(\"WARNING : \" + \"The contract key configuration has been loaded, \" + \"and the 'apiKey' parameter has been set, \" + \"but, there is a problem on the mapping between the contract and the key !\");\n                    return;\n                }\n\n                // on ajoute la clef\n                _rightManagement.key = _key;\n\n                logger.log(\"right management checked\", _rightManagement);\n\n                return _rightManagement;\n            }\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzP2I2OGYiXSwibmFtZXMiOlsiY2hlY2siLCJvcHRpb25zIiwibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiZXJyb3IiLCJfa2V5Iiwia2V5IiwiX3Jlc291cmNlcyIsInJlc291cmNlcyIsIl9zZXJ2aWNlcyIsInNlcnZpY2VzIiwibGVuZ3RoIiwiX3JpZ2h0TWFuYWdlbWVudCIsIkNvbmZpZyIsImlzQ29uZmlnTG9hZGVkIiwid2FybiIsIk9iamVjdCIsImtleXMiLCJjb25maWd1cmF0aW9uIiwiZ2VuZXJhbE9wdGlvbnMiLCJhcGlLZXlzIiwibG9nIiwiX25vUmlnaHRNYW5hZ2VtZW50IiwiaSIsInNlcnZpY2UiLCJqIiwicmVzb3VyY2UiLCJwdXNoIiwiayIsIl9yZXNvdXJjZSIsImwiLCJfc2VydmljZSIsInBhcmFtcyIsImdldFNlcnZpY2VQYXJhbXMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztrQkFFZTtBQUNYOzs7Ozs7Ozs7Ozs7O0FBYUFBLFdBQVEsZUFBVUMsT0FBVixFQUFtQjtBQUN2Qjs7QUFFQSxZQUFJQyxTQUFTQywwQkFBT0MsU0FBUCxDQUFpQixzQkFBakIsQ0FBYjs7QUFFQTtBQUNBLFlBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ1Y7QUFDQUMsbUJBQU9HLEtBQVAsQ0FBYSxlQUNULDBCQURKO0FBRUE7QUFDSDs7QUFFRDtBQUNBLFlBQUlDLE9BQU9MLFFBQVFNLEdBQW5CO0FBQ0EsWUFBSUMsYUFBYVAsUUFBUVEsU0FBUixJQUFxQixFQUF0QztBQUNBLFlBQUlDLFlBQVlULFFBQVFVLFFBQVIsSUFBb0IsRUFBcEM7O0FBRUE7QUFDQTtBQUNBLFlBQUksQ0FBQ0gsVUFBRCxJQUFlQSxXQUFXSSxNQUFYLEtBQXNCLENBQXpDLEVBQTRDO0FBQ3hDO0FBQ0FWLG1CQUFPRyxLQUFQLENBQWEsZUFDVCxzQ0FESjtB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Z0JBQUQsSUFBcUJJLE9BQU9DLElBQVAsQ0FBWUwsZ0JBQVosRUFBOEJELE1BQTlCLEtBQXlDLENBQWxFLEVBQXFFO0FBQ2pFViwyQkFBT2MsSUFBUCxDQUFZLGVBQ1Isa0RBRFEsR0FFUiwyQ0FGUSxHQUdSLDJFQUhKO0FBSUE7QUFDSDs7QUFFRDtBQUNBSCxpQ0FBaUJOLEdBQWpCLEdBQXVCRCxJQUF2Qjs7QUFFQUosdUJBQU9vQixHQUFQLENBQVcsMEJBQVgsRUFBdUNULGdCQUF2Qzs7QUFFQSx1QkFBT0EsZ0JBQVA7QUFDSDtBQUNKO0FBQ0o7QUF2S1UsQyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcbmltcG9ydCBDb25maWcgZnJvbSBcIi4vQ29uZmlnXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBDb250csO0bGUgZGVzIGRyb2l0cyBzdXIgbGVzIHJlc3NvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGxpc3RlIGRlcyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMua2V5IC0gY2xlZiBBUElcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnJlc291cmNlcyAtIGxpc3RlIGRlcyByZXNzb3VyY2VzXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5zZXJ2aWNlcyAtIGxpc3RlIGRlcyBzZXJ2aWNlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHJpZ2h0TWFuYWdlbWVudCAtIHVuZGVmaW5lZCBvdSB7XG4gICAgICogICAgICAga2V5IDogXCJcIixcbiAgICAgKiAgICAgICBzZXJ2aWNlLTEgOiBbcmVzb3VyY2UtMSwgcmVzb3VyY2UtMl0sXG4gICAgICogICAgICAgc2VydmljZS0yIDogW3Jlc291cmNlLTEsIHJlc291cmNlLTJdXG4gICAgICogfVxuICAgICAqL1xuICAgIGNoZWNrIDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbG9nZ2VyXG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJjaGVja3JpZ2h0bWFuYWdlbWVudFwiKTtcblxuICAgICAgICAvLyBzaSBhdWN1bmUgb3B0aW9uIG4nZXN0IHJlbnNlaWduw6llLi4uXG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gbWVzc2FnZSBvcmllbnTDqSBwb3VyIGxlIGRldmVsb3BwZXVyICFcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgXCJubyBwYXJhbWV0ZXIgc3BlY2lmaWVkICFcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXMgb3B0aW9uc1xuICAgICAgICB2YXIgX2tleSA9IG9wdGlvbnMua2V5O1xuICAgICAgICB2YXIgX3Jlc291cmNlcyA9IG9wdGlvbnMucmVzb3VyY2VzIHx8IFtdO1xuICAgICAgICB2YXIgX3NlcnZpY2VzID0gb3B0aW9ucy5zZXJ2aWNlcyB8fCBbXTtcblxuICAgICAgICAvLyBzaSBhdWN1bmUgaW5mb3JtYXRpb24gc3VyIGxlcyByZXNzb3VyY2VzLFxuICAgICAgICAvLyBpbCBlc3QgaW1wb3NzaWJsZSBkZSBjb250cm9sZXIgcXVlbHF1ZWNob3NlICEhIVxuICAgICAgICBpZiAoIV9yZXNvdXJjZXMgfHwgX3Jlc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2Ugb3JpZW50w6kgcG91ciBsZSBkZXZlbG9wcGV1ciAhXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJXQVJOSU5HIDogXCIgK1xuICAgICAgICAgICAgICAgIFwibm8gcGFyYW1ldGVyICdyZXNvdXJjZXMnIHNwZWNpZmllZCAhXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2kgYXVjdW5lIGluZm9ybWF0aW9uIHN1ciBsZXMgc2VydmljZXMsXG4gICAgICAgIC8vIGlsIGVzdCBpbXBvc3NpYmxlIGRlIGNvbnRyb2xlciBxdWVscXVlY2hvc2UgISEhXG4gICAgICAgIGlmICghX3NlcnZpY2VzIHx8IF9zZXJ2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG1lc3NhZ2Ugb3JpZW50w6kgcG91ciBsZSBkZXZlbG9wcGV1ciAhXG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJXQVJOSU5HIDogXCIgK1xuICAgICAgICAgICAgICAgIFwibm8gcGFyYW1ldGVyICdzZXJ2aWNlcycgc3BlY2lmaWVkICFcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXMgcmVzc291cmNlcyBjb250cm9sw6llcyA6XG4gICAgICAgIC8vIEV4LlxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgXCJJdGluZXJhaXJlXCIgICAgIDogW1wiUGlldG9uXCIsIFwiVm9pdHVyZVwiXSxcbiAgICAgICAgLy8gICBcIkdlb2NvZGVcIiAgICAgICAgOiBbXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJTdHJlZXRBZGRyZXNzXCIsIFwiQ2FkYXN0cmFsUGFyY2VsXCIsIFwiQWRtaW5pc3RyYXRpZlwiXSxcbiAgICAgICAgLy8gICBcIkF1dG9Db21wbGV0aW9uXCIgOiBbXCJQb3NpdGlvbk9mSW50ZXJlc3RcIiwgXCJTdHJlZXRBZGRyZXNzXCIsIFwiQ2FkYXN0cmFsUGFyY2VsXCIsIFwiQWRtaW5pc3RyYXRpZlwiXSxcbiAgICAgICAgLy8gICBcIkVsZXZhdGlvblwiICAgICAgOiBbXCJTRVJWSUNFX0NBTENVTF9BTFRJTUVUUklRVUVfUlNDXCJdXG4gICAgICAgIC8vIH1cbiAgICAgICAgdmFyIF9yaWdodE1hbmFnZW1lbnQgPSB7fTtcblxuICAgICAgICAvLyBsYSBjbGVmIEFQSSBuJ2VzdCBwYXMgcmVuc2VpZ27DqWVcbiAgICAgICAgaWYgKCFfa2V5KSB7XG4gICAgICAgICAgICAvLyBvbiB2ZXJpZmllIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gZXN0IGRpc3BvbmlibGVcblxuICAgICAgICAgICAgaWYgKCFDb25maWcuaXNDb25maWdMb2FkZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHNpIGwnYXV0b2NvbmZpZ3VyYXRpb24gbidlc3QgcGFzIGNoYXJnw6llLFxuICAgICAgICAgICAgICAgIC8vIGF1Y3VuZSB2w6lyaWZpY2F0aW9uIGRlcyBkcm9pdHMgZXN0IHBvc3NpYmxlLi4uXG5cbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlICdhcGlLZXknIHBhcmFtZXRlciBpcyBtaXNzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgbm90IGJlZW4gbG9hZGVkLCBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwic28gaW1wb3NzaWJsZSB0byBjaGVjayB5b3VycyByaWdodHMgIVwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2kgbCdhdXRvY29uZmlndXJhdGlvbiBlc3QgY2hhcmfDqWUsXG4gICAgICAgICAgICAgICAgLy8gb24gcmVjdXBlcmUgbGEgY2xlZiBBUEksIGV0IG9uIGVuIHByb2ZpdGVyYSBlbnN1aXRlIHBvdXIgY29udHJvbGVyXG4gICAgICAgICAgICAgICAgLy8gbGVzIGRyb2l0cyBzdXIgbGVzIHJlc3NvdXJjZXMuXG5cbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBwYXIgZGVmYXV0LCBvbiByZWN1cGVyZSB0b3Vqb3VycyBsYSBwcmVtacOocmUuLi5cbiAgICAgICAgICAgICAgICBfa2V5ID0gT2JqZWN0LmtleXMoQ29uZmlnLmNvbmZpZ3VyYXRpb24uZ2VuZXJhbE9wdGlvbnMuYXBpS2V5cylbMF07XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhfa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxhIGNsZWYgQVBJIGVzdCByZW5zZWlnbsOpZSBvdSByZWN1cGVyw6llIGRlIGwnYXV0b2NvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKF9rZXkpIHtcbiAgICAgICAgICAgIC8vIG9uIHZlcmlmaWUgc2kgbCdhdXRvY29uZmlndXJhdGlvbiBlc3QgZGlzcG9uaWJsZVxuXG4gICAgICAgICAgICBpZiAoIUNvbmZpZy5pc0NvbmZpZ0xvYWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2kgbCdhdXRvY29uZmlndXJhdGlvbiBuJ2VzdCBwYXMgY2hhcmfDqWUsXG4gICAgICAgICAgICAgICAgLy8gaWwgZXN0IHRvdWpvdXJzIHBvc3NpYmxlIGRlIHJlcXVldGVyIGxlIHNlcnZpY2UgYXZlYyB1bmUgY2xlZiBBUEksXG4gICAgICAgICAgICAgICAgLy8gbWFpcyBsZXMgZHJvaXRzIHN1ciBsZXMgcmVzc291cmNlcyBuZSBzb250IHBhcyBnYXJhbnRpcywgb24gcmlzcXVlXG4gICAgICAgICAgICAgICAgLy8gZCdvYnRlbmlyIGRlcyBlcnJldXJzIDQwMyBmb3JiaWRkZW4uLi5cbiAgICAgICAgICAgICAgICAvLyBsYSByZXNwb25zYWJpbGl0w6kgcmV2aWVudCDDoCBsJ3V0aWxpc2F0ZXVyIChtZXNzYWdlIGQnaW5mb3JtYXRpb24pLi4uXG5cbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwidGhlIGNvbnRyYWN0IGtleSBjb25maWd1cmF0aW9uIGhhcyBub3QgYmVlbiBsb2FkZWQsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJzbyBiZSBjYXJlZnVsbCAhXCIpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGVzIHJlc3NvdWNlcyBub24gY29udHJvbMOpZXNcbiAgICAgICAgICAgICAgICB2YXIgX25vUmlnaHRNYW5hZ2VtZW50ID0ge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9zZXJ2aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmljZSA9IF9zZXJ2aWNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgX25vUmlnaHRNYW5hZ2VtZW50W3NlcnZpY2VdID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfcmVzb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBfcmVzb3VyY2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX25vUmlnaHRNYW5hZ2VtZW50W3NlcnZpY2VdLnB1c2gocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb24gYWpvdXRlIGxhIGNsZWZcbiAgICAgICAgICAgICAgICBfbm9SaWdodE1hbmFnZW1lbnQua2V5ID0gX2tleTtcblxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IG5vdCBjaGVja2VkXCIsIF9ub1JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX25vUmlnaHRNYW5hZ2VtZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzaSBsJ2F1dG9jb25mIGVzdCBjaGFyZ8OpZSxcbiAgICAgICAgICAgICAgICAvLyBvbiB2ZXJpZmllIGxhIGNvcnJlc3BvbmRhbmNlIGVudHJlIGxhIGNsZWYgZXQgbCdhdXRvY29uZmlndXJhdGlvbixcbiAgICAgICAgICAgICAgICAvLyBvbiBwcmV2aWVudCBsJ3V0aWxpc2F0ZXVyIChtZXNzYWdlIGQnaW5mb3JtYXRpb24pIHMnaWwgbidhXG4gICAgICAgICAgICAgICAgLy8gcGFzIGRlIGRyb2l0cyBzdXIgY2VydGFpbmVzIHJlc3NvdXJjZXMgLi4uXG5cbiAgICAgICAgICAgICAgICAvLyBkb2l0IG9uIGVjYXJ0ZXIgbGVzIHJlc3NvdXJjZXMgc2FucyBkcm9pdCA/XG4gICAgICAgICAgICAgICAgLy8gb3VpLCBzaSBwb3NzaWJsZSBhdmVjIHVuIG1lc3NhZ2UgZCdpbmZvcm1hdGlvbiBwb3VyIGwndXRpbGlzYXRldXIuLi5cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX3Jlc291cmNlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc291cmNlID0gX3Jlc291cmNlc1trXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IF9zZXJ2aWNlcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXJ2aWNlID0gX3NlcnZpY2VzW2xdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gQ29uZmlnLmdldFNlcnZpY2VQYXJhbXMoX3Jlc291cmNlLCBfc2VydmljZSwgX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtcyB8fCBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORyA6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgY29udHJhY3Qga2V5IGNvbmZpZ3VyYXRpb24gaGFzIG5vIHJpZ2h0cyB0byBsb2FkIHRoaXMgZ2VvcG9ydGFsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZXNvdXJjZSAoXCIgKyBfcmVzb3VyY2UgKyBcIikgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvciB0aGlzIHNlcnZpY2UgKFwiICsgX3NlcnZpY2UgKyBcIikgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9yaWdodE1hbmFnZW1lbnRbX3NlcnZpY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JpZ2h0TWFuYWdlbWVudFtfc2VydmljZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX3JpZ2h0TWFuYWdlbWVudFtfc2VydmljZV0ucHVzaChfcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFfcmlnaHRNYW5hZ2VtZW50IHx8IE9iamVjdC5rZXlzKF9yaWdodE1hbmFnZW1lbnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkcgOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRoZSBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBsb2FkZWQsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYW5kIHRoZSAnYXBpS2V5JyBwYXJhbWV0ZXIgaGFzIGJlZW4gc2V0LCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJ1dCwgdGhlcmUgaXMgYSBwcm9ibGVtIG9uIHRoZSBtYXBwaW5nIGJldHdlZW4gdGhlIGNvbnRyYWN0IGFuZCB0aGUga2V5ICFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbiBham91dGUgbGEgY2xlZlxuICAgICAgICAgICAgICAgIF9yaWdodE1hbmFnZW1lbnQua2V5ID0gX2tleTtcblxuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJyaWdodCBtYW5hZ2VtZW50IGNoZWNrZWRcIiwgX3JpZ2h0TWFuYWdlbWVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX3JpZ2h0TWFuYWdlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tbW9uL1V0aWxzL0NoZWNrUmlnaHRNYW5hZ2VtZW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar MousePositionDOM = {\n\n    /**\n    * Add uuid to the tag ID\n    * @param {String} id - id selector\n    * @returns {String} uid - id selector with an unique id\n    */\n    _addUID: function _addUID(id) {\n        var uid = this._uid ? id + \"-\" + this._uid : id;\n        return uid;\n    },\n\n    /**\n     * Main container (DOM)\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMainContainerElement: function _createMainContainerElement() {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPmousePosition\");\n        container.className = \"GPwidget\";\n        return container;\n    },\n\n    // ################################################################### //\n    // ################### Methods of main container ##################### //\n    // ################################################################### //\n\n    /**\n     * Hidden checkbox for minimizing/maximizing\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createShowMousePositionElement: function _createShowMousePositionElement() {\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPshowMousePosition\");\n        input.type = \"checkbox\";\n        return input;\n    },\n\n    /**\n     * Show mouse position control\n     * @param {Boolean} isDesktop - specifies if the support is desktop or tactile\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createShowMousePositionPictoElement: function _createShowMousePositionPictoElement(isDesktop) {\n        // contexte d'execution\n        var self = this;\n\n        var label = document.createElement(\"label\");\n        label.id = this._addUID(\"GPshowMousePositionPicto\");\n        label.className = \"GPshowAdvancedToolPicto\";\n        label.htmlFor = this._addUID(\"GPshowMousePosition\");\n        label.title = \"Afficher les coordonnées du curseur\";\n\n        // FIXME detection disponible dans le JS !\n        // Detection : test for desktop or tactile\n        // var isDesktop = true;\n        // var userAgent = window.navigator.userAgent.toLowerCase();\n        // if (userAgent.indexOf(\"iphone\") !== -1 ||\n        // userAgent.indexOf(\"ipod\") !== -1 ||\n        // userAgent.indexOf(\"ipad\") !== -1 ||\n        // userAgent.indexOf(\"android\") !== -1 ||\n        // userAgent.indexOf(\"mobile\") !== -1 ||\n        // userAgent.indexOf(\"blackberry\") !== -1 ||\n        // userAgent.indexOf(\"tablet\") !== -1 ||\n        // userAgent.indexOf(\"phone\") !== -1 ||\n        // userAgent.indexOf(\"touch\") !== -1 ) {\n        //     isDesktop = false;\n        // }\n        // if (userAgent.indexOf(\"msie\") !== -1 ||\n        // userAgent.indexOf(\"trident\") !== -1) {\n        //     isDesktop = true;\n        // }\n\n        // Show map center localisation if panel opened and tactile support\n        label.addEventListener(\"click\", function (e) {\n            var mapCenterClass = \"\";\n            if (!document.getElementById(self._addUID(\"GPshowMousePosition\")).checked && !isDesktop) {\n                mapCenterClass = \"GPmapCenterVisible\";\n            }\n            document.getElementById(\"GPmapCenter\").className = mapCenterClass;\n            self.onShowMousePositionClick(e);\n        });\n\n        var spanOpen = document.createElement(\"span\");\n        spanOpen.id = this._addUID(\"GPshowMousePositionOpen\");\n        spanOpen.className = \"GPshowAdvancedToolOpen\";\n        label.appendChild(spanOpen);\n\n        return label;\n    },\n\n    /**\n     * mouse position panel\n     * @param {Boolean} [displayAltitude=true] - specifies if the altitude panel must be displayed\n     * @param {Boolean} [displayCoordinates=true] - specifies if the coordinates panel must be displayed\n     * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed\n     * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units\n     *\n     * FIXME\n     * don't call this._createMousePositionSettingsElement\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMousePositionPanelElement: function _createMousePositionPanelElement(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {\n        // default Values\n        displayAltitude = typeof displayAltitude === \"undefined\" ? true : displayAltitude;\n        displayCoordinates = typeof displayCoordinates === \"undefined\" ? true : displayCoordinates;\n        editCoordinates = typeof editCoordinates === \"undefined\" ? false : editCoordinates;\n\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPmousePositionPanel\");\n        div.className = \"GPpanel\";\n\n        div.appendChild(this._createMousePositionPanelHeaderElement());\n        div.appendChild(this._createMousePositionPanelBasicElement(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits));\n\n        var arraySettings = this._createShowMousePositionSettingsElement(displayCoordinates);\n        for (var j = 0; j < arraySettings.length; j++) {\n            div.appendChild(arraySettings[j]);\n        }\n\n        // FIXME on decompose la fonction pour les besoins du controle,\n        // on ajoutera ces childs à la main...\n        // div.appendChild(this._createMousePositionSettingsElement());\n\n        return div;\n    },\n\n    /**\n     * Map center localisation (tactile use)\n     *\n     * @returns {DOMElement} container\n     */\n    _createMapCenter: function _createMapCenter() {\n        var div = document.createElement(\"div\");\n        div.id = \"GPmapCenter\";\n        div.className = \"\";\n        return div;\n    },\n\n    // ################################################################### //\n    // ####################### Panel container ########################### //\n    // ################################################################### //\n\n    /**\n     * @returns {DOMElement} container\n     */\n    _createMousePositionPanelHeaderElement: function _createMousePositionPanelHeaderElement() {\n        var container = document.createElement(\"div\");\n        container.className = \"GPpanelHeader\";\n\n        var divTitle = document.createElement(\"div\");\n        divTitle.className = \"GPpanelTitle\";\n        divTitle.innerHTML = \"Coordonnées\";\n        container.appendChild(divTitle);\n\n        var divClose = document.createElement(\"div\");\n        divClose.id = \"GPmousePositionPanelClose\";\n        divClose.className = \"GPpanelClose\";\n        divClose.title = \"Fermer le panneau\";\n\n        // Link panel close / visibility checkbox\n        var self = this;\n        if (divClose.addEventListener) {\n            divClose.addEventListener(\"click\", function () {\n                document.getElementById(self._addUID(\"GPshowMousePositionPicto\")).click();\n            }, false);\n        } else if (divClose.attachEvent) {\n            divClose.attachEvent(\"onclick\", function () {\n                document.getElementById(self._addUID(\"GPshowMousePositionPicto\")).click();\n            });\n        }\n\n        container.appendChild(divClose);\n\n        return container;\n    },\n\n    /**\n     * coordinate panel\n     * @param {Boolean} [displayAltitude] - specifies if the altitude panel must be displayed\n     * @param {Boolean} [displayCoordinates] - specifies if the coordinates panel must be displayed\n     * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed\n     * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units\n     *\n     * FIXME\n     * call this._createMousePositionPanelBasicCoordinateElement\n     * call this._createMousePositionPanelBasicAltitudeElement\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMousePositionPanelBasicElement: function _createMousePositionPanelBasicElement(displayAltitude, displayCoordinates, editCoordinates, currentProjectionUnits) {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPmousePositionBasicPanel\");\n\n        // FIXME on devrait decomposer la fonction pour les besoins du controle,\n        // on ajoutera ces childs à la main...\n        container.appendChild(this._createMousePositionPanelBasicCoordinateElement(displayCoordinates, editCoordinates, currentProjectionUnits));\n        container.appendChild(this._createMousePositionPanelEditToolsElement(editCoordinates));\n        container.appendChild(this._createMousePositionPanelBasicAltitudeElement(displayAltitude));\n\n        return container;\n    },\n\n    /**\n     * create coordinate elements\n     *\n     * @param {String} coordType - (\"Lon\" ou \"Lat\")\n     * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed\n     *\n     * @returns {Array} list of DOM elements\n     */\n    _createCoordinateElement: function _createCoordinateElement(coordType, editCoordinates) {\n        var context = this;\n\n        if ([\"Lon\", \"Lat\"].indexOf(coordType) === -1) {\n            return [];\n        }\n\n        var list = [];\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPmousePosition\" + coordType);\n        input.title = editCoordinates === true ? \"Cliquer pour saisir des coordonnées\" : \"\";\n        input.readOnly = true;\n\n        if (editCoordinates) {\n            input.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeClick(true);\n            });\n            input.addEventListener(\"change\", function (e) {\n                this.classList.remove(\"error\");\n                var valid = context.validateExtentCoordinate(coordType, this.value, e);\n                valid ? this.classList.remove(\"error\") : this.classList.add(\"error\");\n            });\n        }\n        list.push(input);\n\n        var span = document.createElement(\"span\");\n        span.className = \"GPmousePositionUnits\";\n        list.push(span);\n\n        return list;\n    },\n\n    /**\n     *\n     * @param {String} coordType - (\"Lon\" ou \"Lat\")\n     * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed\n     *\n     * @returns {Array} list of DOM elements\n     */\n    _createDMSCoordinateElement: function _createDMSCoordinateElement(coordType, editCoordinates) {\n        if ([\"Lon\", \"Lat\"].indexOf(coordType) === -1) {\n            return [];\n        }\n\n        var context = this;\n\n        var list = [];\n\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPmousePosition\" + coordType + \"Degrees\");\n        input.className = \"GPSexagesimal\";\n        input.setAttribute(\"name\", \"degrees\");\n        input.title = editCoordinates === true ? \"Cliquer pour saisir des coordonnées\" : \"\";\n        input.readOnly = true;\n        input.dataset.min = 0;\n        input.dataset.max = coordType === \"Lon\" ? 180 : 90;\n        if (editCoordinates) {\n            input.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeClick(true);\n            });\n            input.addEventListener(\"change\", function () {\n                this.classList.remove(\"error\");\n                var valid = context._checkDMSDegrees(coordType, this);\n                valid ? this.classList.remove(\"error\") : this.classList.add(\"error\");\n            });\n        }\n        list.push(input);\n\n        var span = document.createElement(\"span\");\n        span.className = \"GPmousePositionSexagesimalLabel\";\n        span.innerHTML = \"°\";\n        list.push(span);\n\n        var input1 = document.createElement(\"input\");\n        input1.id = this._addUID(\"GPmousePosition\" + coordType + \"Minutes\");\n        input1.className = \"GPSexagesimal\";\n        input1.setAttribute(\"name\", \"minutes\");\n        input1.title = editCoordinates === true ? \"Cliquer pour saisir des coordonnées\" : \"\";\n        input1.readOnly = true;\n        input1.dataset.min = 0;\n        input1.dataset.max = 59;\n        if (editCoordinates) {\n            input1.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeClick(true);\n            });\n            input1.addEventListener(\"change\", function () {\n                this.classList.remove(\"error\");\n                var valid = context._checkDMSElement(this);\n                valid ? this.classList.remove(\"error\") : this.classList.add(\"error\");\n            });\n        }\n        list.push(input1);\n\n        var span1 = document.createElement(\"span\");\n        span1.className = \"GPmousePositionSexagesimalLabel\";\n        span1.innerHTML = \"'\";\n        list.push(span1);\n\n        var input2 = document.createElement(\"input\");\n        input2.id = this._addUID(\"GPmousePosition\" + coordType + \"Seconds\");\n        input2.className = \"GPSexagesimalsec\";\n        input2.setAttribute(\"name\", \"seconds\");\n        input2.title = editCoordinates === true ? \"Cliquer pour saisir des coordonnées\" : \"\";\n        input2.readOnly = true;\n        input2.dataset.min = 0;\n        input2.dataset.max = 59;\n        if (editCoordinates) {\n            input2.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeClick(true);\n            });\n            input2.addEventListener(\"change\", function () {\n                this.classList.remove(\"error\");\n                var valid = context._checkDMSElement(this, true);\n                valid ? this.classList.remove(\"error\") : this.classList.add(\"error\");\n            });\n        }\n        list.push(input2);\n\n        var span2 = document.createElement(\"span\");\n        span2.className = \"GPmousePositionSexagesimalLabel\";\n        span2.innerHTML = \"''\";\n        list.push(span2);\n\n        var select = document.createElement(\"select\");\n        select.id = this._addUID(\"GPmousePosition\" + coordType + \"Direction\");\n        select.className = \"GPmousePositionDirection\";\n        select.setAttribute(\"name\", \"direction\");\n        select.disabled = true;\n\n        var option = document.createElement(\"option\");\n        option.value = coordType === \"Lon\" ? \"E\" : \"N\";\n        option.innerHTML = coordType === \"Lon\" ? \"E\" : \"N\";\n        select.appendChild(option);\n\n        var option1 = document.createElement(\"option\");\n        option1.value = coordType === \"Lon\" ? \"O\" : \"S\";\n        option1.innerHTML = coordType === \"Lon\" ? \"O\" : \"S\";\n        select.appendChild(option1);\n        list.push(select);\n\n        return list;\n    },\n\n    /**\n     * @param {Boolean} [display=false] - specifies if the coordinates panel must be displayed\n     * @param {Boolean} [editCoordinates] - specifies if the coordinates edition is allowed\n     * @param {Boolean} [currentProjectionUnits] - specifies if the current projection units\n     *\n     * @returns {DOMElement} container\n     */\n    _createMousePositionPanelBasicCoordinateElement: function _createMousePositionPanelBasicCoordinateElement(display, editCoordinates, currentProjectionUnits) {\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPmousePositionCoordinate\");\n        div.style.display = display ? \"block\" : \"none\";\n\n        // latitude\n        var divLat = document.createElement(\"div\");\n\n        var spanLat = document.createElement(\"span\");\n        spanLat.className = \"GPmousePositionLabel\";\n        spanLat.id = this._addUID(\"GPmousePositionLatLabel\");\n        spanLat.innerHTML = \"Latitude : \";\n        divLat.appendChild(spanLat);\n\n        var span = document.createElement(\"span\");\n        span.id = this._addUID(\"GPmousePositionLatCoordinate\");\n\n        var arrayCoords;\n        if (currentProjectionUnits === \"DMS\") {\n            arrayCoords = this._createDMSCoordinateElement(\"Lat\", editCoordinates);\n        } else {\n            arrayCoords = this._createCoordinateElement(\"Lat\", editCoordinates);\n        }\n        for (var i = 0; i < arrayCoords.length; i++) {\n            span.appendChild(arrayCoords[i]);\n        }\n        divLat.appendChild(span);\n        div.appendChild(divLat);\n\n        // longitude\n        var divLon = document.createElement(\"div\");\n\n        var spanLon = document.createElement(\"span\");\n        spanLon.className = \"GPmousePositionLabel\";\n        spanLon.id = this._addUID(\"GPmousePositionLonLabel\");\n        spanLon.innerHTML = \"Longitude : \";\n        divLon.appendChild(spanLon);\n\n        var span1 = document.createElement(\"span\");\n        span1.id = this._addUID(\"GPmousePositionLonCoordinate\");\n\n        var arrayCoords1;\n        if (currentProjectionUnits === \"DMS\") {\n            arrayCoords1 = this._createDMSCoordinateElement(\"Lon\", editCoordinates);\n        } else {\n            arrayCoords1 = this._createCoordinateElement(\"Lon\", editCoordinates);\n        }\n        for (var j = 0; j < arrayCoords1.length; j++) {\n            span1.appendChild(arrayCoords1[j]);\n        }\n        divLon.appendChild(span1);\n        div.appendChild(divLon);\n\n        return div;\n    },\n\n    /**\n     * @param {Boolean} [display=false] - specifies if the altitude panel must be displayed\n     *\n     * @returns {DOMElement} container\n     */\n    _createMousePositionPanelBasicAltitudeElement: function _createMousePositionPanelBasicAltitudeElement(display) {\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPmousePositionAltitude\");\n        div.style.display = display ? \"block\" : \"none\";\n\n        var spanLabel = document.createElement(\"span\");\n        spanLabel.className = \"GPmousePositionLabel\";\n        spanLabel.innerHTML = \"Altitude : \";\n        div.appendChild(spanLabel);\n\n        var spanAlt = document.createElement(\"span\");\n        spanAlt.className = \"GPmousePositionCoords\";\n        spanAlt.id = this._addUID(\"GPmousePositionAlt\");\n        spanAlt.innerHTML = \"...\";\n        div.appendChild(spanAlt);\n\n        var spanUnits = document.createElement(\"span\");\n        spanUnits.className = \"GPmousePositionAltitudeUnits\";\n        spanUnits.innerHTML = \"m\";\n        div.appendChild(spanUnits);\n\n        return div;\n    },\n\n    /**\n     * @param {Boolean} [editCoordinates=false] - specifies if the coordinates edition is allowed\n     *\n     * @returns {DOMElement} container\n     */\n    _createMousePositionPanelEditToolsElement: function _createMousePositionPanelEditToolsElement(editCoordinates) {\n        var context = this;\n\n        var div = document.createElement(\"div\");\n        div.className = \"GPmousePositionPanelEditTools\";\n        div.id = this._addUID(\"GPmousePositionPanelEditTools\");\n        if (!editCoordinates) {\n            div.style.display = \"none\";\n        }\n\n        var span1 = document.createElement(\"span\");\n        span1.className = \"GPmousePositionEditTool\";\n        span1.id = this._addUID(\"GPmousePositionLocate\");\n        span1.title = editCoordinates === true ? \"Cliquer pour saisir des coordonnées\" : \"\";\n        if (editCoordinates) {\n            span1.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeLocateClick();\n            });\n        }\n        div.appendChild(span1);\n\n        var span2 = document.createElement(\"span\");\n        span2.className = \"GPmousePositionEditTool\";\n        span2.id = this._addUID(\"GPmousePositionCloseEdit\");\n        span2.title = \"Quitter la saisie des coordonnées\";\n        span2.style.display = \"none\";\n        if (editCoordinates) {\n            span2.addEventListener(\"click\", function () {\n                context.onMousePositionEditModeClick(false);\n            });\n        }\n        div.appendChild(span2);\n\n        return div;\n    },\n\n    // ################################################################### //\n    // #################### Settings container ########################### //\n    // ################################################################### //\n\n    /**\n     * @param {Boolean} [display=false] - specifies if the settings panel must be displayed\n     *\n     * @returns {DOMElement[]} array containing input and label elements\n     */\n    _createShowMousePositionSettingsElement: function _createShowMousePositionSettingsElement(display) {\n        var list = [];\n\n        var input = document.createElement(\"input\");\n        input.type = \"checkbox\";\n        input.id = this._addUID(\"GPshowMousePositionSettings\");\n\n        var label = document.createElement(\"label\");\n        label.id = this._addUID(\"GPshowMousePositionSettingsPicto\");\n        label.htmlFor = this._addUID(\"GPshowMousePositionSettings\");\n        label.title = \"Réglages\";\n        label.className = \"GPshowMoreOptions GPshowMousePositionSettingsPicto\"; // FIXME classname and id ?\n        label.style.display = display ? \"block\" : \"none\";\n\n        list.push(input);\n        list.push(label);\n\n        return list;\n    },\n\n    /**\n     * settings panel\n     * @param {Boolean} [display=true] - specifies if the settings panel must be displayed\n     *\n     * FIXME\n     * don't call this._createMousePositionSettingsSystemsElement\n     * don't call this._createMousePositionSettingsUnitsElement\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMousePositionSettingsElement: function _createMousePositionSettingsElement(display) {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPmousePositionSettings\");\n        container.style.display = display === undefined || display ? \"block\" : \"none\";\n\n        var span = document.createElement(\"span\");\n        span.className = \"GPmousePositionSettingsLabel\";\n        span.innerHTML = \"Système de référence\";\n        container.appendChild(span);\n\n        // FIXME on decompose la fonction pour les besoins du controle,\n        // on ajoutera ces childs à la main...\n        // FIXME tableau statique !\n        // var systems = [\n        //     {\n        //         code : \"GEOGRAPHIC\",\n        //         label : \"Géographique\"\n        //     },\n        //     {\n        //         code : \"MERCATOR\",\n        //         label : \"Mercator\"\n        //     },\n        //     {\n        //         code : \"LAMB93\",\n        //         label : \"Lambert 93\"\n        //     },\n        //     {\n        //         code : \"LAMB2E\",\n        //         label : \"Lambert II étendu\"\n        //     }\n        // ];\n        //\n        // var selectSystem = this._createMousePositionSettingsSystemsElement(systems);\n        //\n        // container.appendChild(selectSystem);\n\n        // FIXME on decompose la fonction pour les besoins du controle,\n        // on ajoutera ces childs à la main...\n        // FIXME tableau statique !\n        // var units = [\n        //     {\n        //         code : \"DEC\",\n        //         label : \"degrés décimaux\",\n        //     },\n        //     {\n        //         code : \"DMS\",\n        //         label : \"degrés sexagésimaux\",\n        //     },\n        //     {\n        //         code : \"RAD\",\n        //         label : \"radians\",\n        //     },\n        //     {\n        //         code : \"GON\",\n        //         label : \"grades\"\n        //     }\n        // ];\n        //\n        // var selectUnits = this._createMousePositionSettingsUnitsElement(units);\n        //\n        // container.appendChild(selectUnits);\n\n        return container;\n    },\n\n    /**\n     * @param {Object[]} systems - list of systems\n     *\n     * @returns {DOMElement} DOM element select\n     */\n    _createMousePositionSettingsSystemsElement: function _createMousePositionSettingsSystemsElement(systems) {\n        // contexte d'execution\n        var context = this;\n\n        var selectSystem = document.createElement(\"select\");\n        selectSystem.id = this._addUID(\"GPmousePositionProjectionSystem\");\n        selectSystem.className = \"GPinputSelect GPmousePositionSettingsSelect\";\n        selectSystem.addEventListener(\"change\", function (e) {\n            context.onMousePositionProjectionSystemChange(e);\n        });\n        selectSystem.addEventListener(\"mouseover\", function (e) {\n            // FIXME mettre une condition si target === option\n            if (e.target.nodeName !== \"OPTION\") {\n                context.onMousePositionProjectionSystemMouseOver(e);\n            }\n        });\n\n        for (var i = 0; i < systems.length; i++) {\n            var obj = systems[i];\n            var option = document.createElement(\"option\");\n            option.value = obj.code;\n            option.text = obj.label || i;\n            // option.label = obj.label;\n            selectSystem.appendChild(option);\n        }\n\n        return selectSystem;\n    },\n\n    /**\n     * @param {Object[]} units - list of units\n     *\n     * @returns {DOMElement} DOM element select\n     */\n    _createMousePositionSettingsUnitsElement: function _createMousePositionSettingsUnitsElement(units) {\n        // contexte d'execution\n        var context = this;\n\n        var selectUnits = document.createElement(\"select\");\n        selectUnits.id = this._addUID(\"GPmousePositionProjectionUnits\");\n        selectUnits.className = \"GPinputSelect GPmousePositionSettingsSelect\";\n        selectUnits.addEventListener(\"change\", function (e) {\n            context.onMousePositionProjectionUnitsChange(e);\n        });\n\n        for (var j = 0; j < units.length; j++) {\n            var obj = units[j];\n            var option = document.createElement(\"option\");\n            option.value = obj.code ? obj.code : j;\n            option.text = obj.label || j;\n            // option.label = obj.label;\n            selectUnits.appendChild(option);\n        }\n\n        return selectUnits;\n    },\n\n    /**\n     * @param {String} [currentProjectionType=\"Metric\"] - \"Geographical\" or \"Metric\"\n     */\n    _resetLabelElements: function _resetLabelElements(currentProjectionType) {\n        // Changement des labels dans le formulaire de saisie\n        var spanLat = document.getElementById(this._addUID(\"GPmousePositionLatLabel\"));\n        spanLat.innerHTML = currentProjectionType === \"Geographical\" ? \"Latitude :\" : \"X :\";\n\n        var spanLon = document.getElementById(this._addUID(\"GPmousePositionLonLabel\"));\n        spanLon.innerHTML = currentProjectionType === \"Geographical\" ? \"Longitude :\" : \"Y :\";\n    },\n\n    /**\n     * @param {String} currentProjectionUnits - projection units\n     */\n    _resetUnitElements: function _resetUnitElements(currentProjectionUnits) {\n        var value = \"\";\n        if (currentProjectionUnits === \"M\" || currentProjectionUnits === \"KM\") {\n            value = currentProjectionUnits.toLowerCase();\n        }\n\n        var elts = document.getElementsByClassName(\"GPmousePositionUnits\");\n        for (var e = 0; e < elts.length; e++) {\n            elts[e].innerHTML = value;\n        }\n    },\n\n    /**\n     * @method _resetCoordinateElements\n     * @param {Boolean} editCoordinates - edit coordinates option\n     * @param {String} currentProjectionType - current projection type\n     * @param {String} currentProjectionUnits - current projection unit\n     */\n    _resetCoordinateElements: function _resetCoordinateElements(editCoordinates, currentProjectionType, currentProjectionUnits) {\n        // Suppression de tous les enfants de GPmousePositionLatCoordinate\n        var latElt = document.getElementById(this._addUID(\"GPmousePositionLatCoordinate\"));\n        while (latElt.firstChild) {\n            latElt.removeChild(latElt.firstChild);\n        }\n\n        var arrayCoords;\n        if (currentProjectionUnits === \"DMS\") {\n            arrayCoords = this._createDMSCoordinateElement(\"Lat\", editCoordinates);\n        } else {\n            arrayCoords = this._createCoordinateElement(\"Lat\", editCoordinates);\n        }\n        for (var i = 0; i < arrayCoords.length; i++) {\n            latElt.appendChild(arrayCoords[i]);\n        }\n\n        // Suppression de tous les enfants de GPmousePositionLonCoordinate\n        var lonElt = document.getElementById(this._addUID(\"GPmousePositionLonCoordinate\"));\n        while (lonElt.firstChild) {\n            lonElt.removeChild(lonElt.firstChild);\n        }\n\n        var arrayCoords1;\n        if (currentProjectionUnits === \"DMS\") {\n            arrayCoords1 = this._createDMSCoordinateElement(\"Lon\", editCoordinates);\n        } else {\n            arrayCoords1 = this._createCoordinateElement(\"Lon\", editCoordinates);\n        }\n        for (var j = 0; j < arrayCoords1.length; j++) {\n            lonElt.appendChild(arrayCoords1[j]);\n        }\n\n        // FIXME on simule un deplacement ?\n        // this.onMapMove();\n    },\n\n    /**\n     * Set/unset editing mode\n     *\n     * @method _setEditMode\n     * @param {Boolean} editing - active edit coordinates mode\n     */\n    _setEditMode: function _setEditMode(editing) {\n        var locateElt = document.getElementById(this._addUID(\"GPmousePositionLocate\"));\n        locateElt.title = editing ? \"Aller à la position ...\" : \"Cliquer pour saisir des coordonnées\";\n\n        var closeEditElt = document.getElementById(this._addUID(\"GPmousePositionCloseEdit\"));\n        closeEditElt.style.display = editing ? \"inline-block\" : \"none\";\n\n        var selector = \"div[id^=\" + this._addUID(\"GPmousePositionCoordinate\") + \"]\";\n        var inputs = document.querySelectorAll(selector + \" input\");\n        for (var i = 0; i < inputs.length; i++) {\n            inputs[i].readOnly = !editing;\n            if (editing) {\n                inputs[i].value = \"\";\n                inputs[i].classList.remove(\"error\");\n            }\n        }\n        var selects = document.querySelectorAll(selector + \" select\");\n        for (var j = 0; j < selects.length; j++) {\n            selects[j].disabled = !editing;\n        }\n    },\n\n    /**\n     *\n     * @param {DOMElement} input - input element\n     * @param {Boolean} isFloat - check for float value\n     *\n     * @returns {Boolean} true if input value is within bounds\n     */\n    _checkDMSElement: function _checkDMSElement(input, isFloat) {\n        var b = isFloat !== undefined;\n\n        var value = input.value;\n        if (b) {\n            value = value.replace(\",\", \".\");\n        }\n        if (isNaN(value)) {\n            return false;\n        }\n\n        var v = parseFloat(value);\n        if (!b && (v | 0) !== v) {\n            // is it an integer\n            return false;\n        }\n\n        var min = Number(input.dataset.min);\n        var max = Number(input.dataset.max);\n        return v >= min && v <= max;\n    },\n\n    /**\n     * @param {String} coordType - \"Lon\" or \"Lat\"\n     * @param {DOMElement} input - input element\n     *\n     * @returns {Boolean} true if input value is within bounds\n     */\n    _checkDMSDegrees: function _checkDMSDegrees(coordType, input) {\n        if (isNaN(input.value)) {\n            return false;\n        }\n\n        var v = parseFloat(input.value);\n        if ((v | 0) !== v) {\n            // is it an integer\n            return false;\n        }\n\n        var min = Number(input.dataset.min);\n        var max = Number(input.dataset.max);\n        if (v < min || v > max) {\n            return false;\n        }\n\n        var inputMinutes = document.getElementById(this._addUID(\"GPmousePosition\" + coordType + \"Minutes\"));\n        var inputSeconds = document.getElementById(this._addUID(\"GPmousePosition\" + coordType + \"Seconds\"));\n\n        if (v >= max) {\n            inputMinutes.dataset.max = 0;\n            inputSeconds.dataset.max = 0;\n        } else {\n            inputMinutes.dataset.max = 59;\n            inputSeconds.dataset.max = 59.9999;\n        }\n\n        return true;\n    },\n\n    // ################################################################### //\n    // ####################### handlers Event ############################ //\n    // ################################################################### //\n\n    /**\n     * Function displaying coordinates from cursor position (desktop)\n     * or map center (tactile)\n     * @param {Object} coordinate - coordinates\n     */\n    GPdisplayCoords: function GPdisplayCoords(coordinate) {\n        // Compute coords in case of cursor position (desktop)\n        if (coordinate && coordinate != null) {\n            var labelLon = document.getElementById(this._addUID(\"GPmousePositionLonLabel\"));\n            var labelLat = document.getElementById(this._addUID(\"GPmousePositionLatLabel\"));\n\n            if (coordinate.x || coordinate.y) {\n                labelLat.innerHTML = \"X : \";\n                labelLon.innerHTML = \"Y : \";\n            } else if (coordinate.e || coordinate.n) {\n                labelLat.innerHTML = \"E : \";\n                labelLon.innerHTML = \"N : \";\n            } else {\n                labelLat.innerHTML = \"Latitude : \";\n                labelLon.innerHTML = \"Longitude : \";\n            }\n\n            if (_typeof(coordinate.lat) === \"object\" && _typeof(coordinate.lng) === \"object\") {\n                var parts = {\n                    lng: \"Lon\",\n                    lat: \"Lat\"\n                };\n                var units = [\"Degrees\", \"Minutes\", \"Seconds\"];\n                for (var p in parts) {\n                    for (var u = 0; u < units.length; ++u) {\n                        var selector = \"GPmousePosition\" + parts[p] + units[u];\n                        var elt = document.getElementById(this._addUID(selector));\n                        var key = units[u].charAt(0).toLowerCase();\n                        elt.value = coordinate[p][key];\n                    }\n                }\n                // directions\n                document.getElementById(this._addUID(\"GPmousePositionLonDirection\")).value = coordinate.lng.direction;\n                document.getElementById(this._addUID(\"GPmousePositionLatDirection\")).value = coordinate.lat.direction;\n            } else {\n                var elLat = document.getElementById(this._addUID(\"GPmousePositionLat\"));\n                var elLon = document.getElementById(this._addUID(\"GPmousePositionLon\"));\n\n                elLat.value = coordinate.x || coordinate.lat || coordinate.e || \"0\";\n                elLon.value = coordinate.y || coordinate.lng || coordinate.lon || coordinate.n || \"0\";\n\n                // les unites\n                var unit = coordinate.unit === undefined ? \"\" : coordinate.unit;\n                var elements = document.getElementsByClassName(\"GPmousePositionUnits\");\n                for (var n = 0; n < elements.length; ++n) {\n                    elements[n].innerHTML = unit;\n                }\n            }\n        }\n    },\n\n    /**\n     * Function displaying altitude from cursor position (desktop)\n     * or map center (tactile)\n     * @param {Object} coordinate - coordinates\n     * @param {Number} altitudeTimeoutDelay - when the mouse stop moving, delay before the altitude request is launched\n     * @param {Number} noDataValue - the no data value\n     * @param {Number} noDataValueTolerance - the no data value tolerance\n     */\n    GPdisplayElevation: function GPdisplayElevation(coordinate, altitudeTimeoutDelay, noDataValue, noDataValueTolerance) {\n        // contexte d'execution\n        var self = this;\n\n        // Latency for altitude request\n        var altitudeTimeout;\n        if (!altitudeTimeoutDelay) {\n            altitudeTimeoutDelay = 500;\n        }\n\n        clearTimeout(altitudeTimeout);\n        document.getElementById(this._addUID(\"GPmousePositionAlt\")).innerHTML = \"...\";\n\n        if (noDataValue == null) {\n            noDataValue = -99999;\n        }\n        if (noDataValueTolerance == null) {\n            noDataValueTolerance = 99980;\n        }\n        var maxThreshold = noDataValue + noDataValueTolerance;\n        var minThreshold = noDataValue - noDataValueTolerance;\n\n        // Compute coords in case of cursor position (desktop)\n        if (coordinate && coordinate != null) {\n            // If no altitude panel, don't call altitude request\n            if (document.getElementById(this._addUID(\"GPmousePositionAltitude\"))) {\n                altitudeTimeout = setTimeout(function () {\n                    self.onRequestAltitude(coordinate, function (z) {\n                        if (minThreshold < z && z < maxThreshold) {\n                            self.GPresetElevation();\n                        } else {\n                            document.getElementById(self._addUID(\"GPmousePositionAlt\")).innerHTML = z;\n                        }\n                    });\n                }, altitudeTimeoutDelay);\n            }\n        }\n    },\n\n    /**\n     * Function reseting altitude value\n     */\n    GPresetElevation: function GPresetElevation() {\n        if (document.getElementById(this._addUID(\"GPmousePositionAltitude\"))) {\n            document.getElementById(this._addUID(\"GPmousePositionAlt\")).innerHTML = \"---\";\n        }\n    }\n};\n\nexports.default = MousePositionDOM;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL01vdXNlUG9zaXRpb25ET00uanM/MzA2OCJdLCJuYW1lcyI6WyJNb3VzZVBvc2l0aW9uRE9NIiwiX2FkZFVJRCIsImlkIiwidWlkIiwiX3VpZCIsIl9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIl9jcmVhdGVTaG93TW91c2VQb3NpdGlvbkVsZW1lbnQiLCJpbnB1dCIsInR5cGUiLCJfY3JlYXRlU2hvd01vdXNlUG9zaXRpb25QaWN0b0VsZW1lbnQiLCJpc0Rlc2t0b3AiLCJzZWxmIiwibGFiZWwiLCJodG1sRm9yIiwidGl0bGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsIm1hcENlbnRlckNsYXNzIiwiZ2V0RWxlbWVudEJ5SWQiLCJjaGVja2VkIiwib25TaG93TW91c2VQb3NpdGlvbkNsaWNrIiwic3Bhbk9wZW4iLCJhcHBlbmRDaGlsZCIsIl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxFbGVtZW50IiwiZGlzcGxheUFsdGl0dWRlIiwiZGlzcGxheUNvb3JkaW5hdGVzIiwiZWRpdENvb3JkaW5hdGVzIiwiY3VycmVudFByb2plY3Rpb25Vbml0cyIsImRpdiIsIl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxIZWFkZXJFbGVtZW50IiwiX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljRWxlbWVudCIsImFycmF5U2V0dGluZ3MiLCJfY3JlYXRlU2hvd01vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQiLCJqIiwibGVuZ3RoIiwiX2NyZWF0ZU1hcENlbnRlciIsImRpdlRpdGxlIiwiaW5uZXJIVE1MIiwiZGl2Q2xvc2UiLCJjbGljayIsImF0dGFjaEV2ZW50IiwiX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljQ29vcmRpbmF0ZUVsZW1lbnQiLCJfY3JlYXRlTW91c2VQb3NpdGlvblBhbmVsRWRpdFRvb2xzRWxlbWVudCIsIl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxCYXNpY0FsdGl0dWRlRWxlbWVudCIsIl9jcmVhdGVDb29yZGluYXRlRWxlbWVudCIsImNvb3JkVHlwZSIsImNvbnRleHQiLCJpbmRleE9mIiwibGlzdCIsInJlYWRPbmx5Iiwib25Nb3VzZVBvc2l0aW9uRWRpdE1vZGVDbGljayIsImNsYXNzTGlzdCIsInJlbW92ZSIsInZhbGlkIiwidmFsaWRhdGVFeHRlbnRDb29yZGluYXRlIiwidmFsdWUiLCJhZGQiLCJwdXNoIiwic3BhbiIsIl9jcmVhdGVETVNDb29yZGluYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImRhdGFzZXQiLCJtaW4iLCJtYXgiLCJfY2hlY2tETVNEZWdyZWVzIiwiaW5wdXQxIiwiX2NoZWNrRE1TRWxlbWVudCIsInNwYW4xIiwiaW5wdXQyIiwic3BhbjIiLCJzZWxlY3QiLCJkaXNhYmxlZCIsIm9wdGlvbiIsIm9wdGlvbjEiLCJkaXNwbGF5Iiwic3R5bGUiLCJkaXZMYXQiLCJzcGFuTGF0IiwiYXJyYXlDb29yZHMiLCJpIiwiZGl2TG9uIiwic3BhbkxvbiIsImFycmF5Q29vcmRzMSIsInNwYW5MYWJlbCIsInNwYW5BbHQiLCJzcGFuVW5pdHMiLCJvbk1vdXNlUG9zaXRpb25FZGl0TW9kZUxvY2F0ZUNsaWNrIiwiX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQiLCJ1bmRlZmluZWQiLCJfY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzU3lzdGVtc0VsZW1lbnQiLCJzeXN0ZW1zIiwic2VsZWN0U3lzdGVtIiwib25Nb3VzZVBvc2l0aW9uUHJvamVjdGlvblN5c3RlbUNoYW5nZSIsInRhcmdldCIsIm5vZGVOYW1lIiwib25Nb3VzZVBvc2l0aW9uUHJvamVjdGlvblN5c3RlbU1vdXNlT3ZlciIsIm9iaiIsImNvZGUiLCJ0ZXh0IiwiX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc1VuaXRzRWxlbWVudCIsInVuaXRzIiwic2VsZWN0VW5pdHMiLCJvbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uVW5pdHNDaGFuZ2UiLCJfcmVzZXRMYWJlbEVsZW1lbnRzIiwiY3VycmVudFByb2plY3Rpb25UeXBlIiwiX3Jlc2V0VW5pdEVsZW1lbnRzIiwidG9Mb3dlckNhc2UiLCJlbHRzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9yZXNldENvb3JkaW5hdGVFbGVtZW50cyIsImxhdEVsdCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImxvbkVsdCIsIl9zZXRFZGl0TW9kZSIsImVkaXRpbmciLCJsb2NhdGVFbHQiLCJjbG9zZUVkaXRFbHQiLCJzZWxlY3RvciIsImlucHV0cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZWxlY3RzIiwiaXNGbG9hdCIsImIiLCJyZXBsYWNlIiwiaXNOYU4iLCJ2IiwicGFyc2VGbG9hdCIsIk51bWJlciIsImlucHV0TWludXRlcyIsImlucHV0U2Vjb25kcyIsIkdQZGlzcGxheUNvb3JkcyIsImNvb3JkaW5hdGUiLCJsYWJlbExvbiIsImxhYmVsTGF0IiwieCIsInkiLCJuIiwibGF0IiwibG5nIiwicGFydHMiLCJwIiwidSIsImVsdCIsImtleSIsImNoYXJBdCIsImRpcmVjdGlvbiIsImVsTGF0IiwiZWxMb24iLCJsb24iLCJ1bml0IiwiZWxlbWVudHMiLCJHUGRpc3BsYXlFbGV2YXRpb24iLCJhbHRpdHVkZVRpbWVvdXREZWxheSIsIm5vRGF0YVZhbHVlIiwibm9EYXRhVmFsdWVUb2xlcmFuY2UiLCJhbHRpdHVkZVRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJtYXhUaHJlc2hvbGQiLCJtaW5UaHJlc2hvbGQiLCJzZXRUaW1lb3V0Iiwib25SZXF1ZXN0QWx0aXR1ZGUiLCJ6IiwiR1ByZXNldEVsZXZhdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxJQUFJQSxtQkFBbUI7O0FBRW5COzs7OztBQUtBQyxhQUFVLGlCQUFVQyxFQUFWLEVBQWM7QUFDcEIsWUFBSUMsTUFBTyxLQUFLQyxJQUFOLEdBQWNGLEtBQUss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QUNBLGdCQUFJakksU0FBU2UsY0FBVCxDQUF3QixLQUFLckIsT0FBTCxDQUFhLHlCQUFiLENBQXhCLENBQUosRUFBc0U7QUFDbEUrSixrQ0FBa0JJLFdBQVcsWUFBWTtBQUNyQ3JKLHlCQUFLc0osaUJBQUwsQ0FBdUI3QixVQUF2QixFQUFtQyxVQUFVOEIsQ0FBVixFQUFhO0FBQzVDLDRCQUFJSCxlQUFlRyxDQUFmLElBQW9CQSxJQUFJSixZQUE1QixFQUEwQztBQUN0Q25KLGlDQUFLd0osZ0JBQUw7QUFDSCx5QkFGRCxNQUVPO0FBQ0hoSyxxQ0FBU2UsY0FBVCxDQUF3QlAsS0FBS2QsT0FBTCxDQUFhLG9CQUFiLENBQXhCLEVBQTREd0MsU0FBNUQsR0FBd0U2SCxDQUF4RTtBQUNIO0FBQ0oscUJBTkQ7QUFPSCxpQkFSaUIsRUFRZlQsb0JBUmUsQ0FBbEI7QUFTSDtBQUNKO0FBQ0osS0E1NUJrQjs7QUE4NUJuQjs7O0FBR0FVLHNCQUFtQiw0QkFBWTtBQUMzQixZQUFJaEssU0FBU2UsY0FBVCxDQUF3QixLQUFLckIsT0FBTCxDQUFhLHlCQUFiLENBQXhCLENBQUosRUFBc0U7QUFDbEVNLHFCQUFTZSxjQUFULENBQXdCLEtBQUtyQixPQUFMLENBQWEsb0JBQWIsQ0FBeEIsRUFBNER3QyxTQUE1RCxHQUF3RSxLQUF4RTtBQUNIO0FBQ0o7QUFyNkJrQixDQUF2Qjs7a0JBdzZCZXpDLGdCIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIE1vdXNlUG9zaXRpb25ET00gPSB7XG5cbiAgICAvKipcbiAgICAqIEFkZCB1dWlkIHRvIHRoZSB0YWcgSURcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIGlkIHNlbGVjdG9yXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1aWQgLSBpZCBzZWxlY3RvciB3aXRoIGFuIHVuaXF1ZSBpZFxuICAgICovXG4gICAgX2FkZFVJRCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgdWlkID0gKHRoaXMuX3VpZCkgPyBpZCArIFwiLVwiICsgdGhpcy5fdWlkIDogaWQ7XG4gICAgICAgIHJldHVybiB1aWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1haW4gY29udGFpbmVyIChET00pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25cIik7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQd2lkZ2V0XCI7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIE1ldGhvZHMgb2YgbWFpbiBjb250YWluZXIgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgLyoqXG4gICAgICogSGlkZGVuIGNoZWNrYm94IGZvciBtaW5pbWl6aW5nL21heGltaXppbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVTaG93TW91c2VQb3NpdGlvbkVsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dNb3VzZVBvc2l0aW9uXCIpO1xuICAgICAgICBpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgbW91c2UgcG9zaXRpb24gY29udHJvbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEZXNrdG9wIC0gc3BlY2lmaWVzIGlmIHRoZSBzdXBwb3J0IGlzIGRlc2t0b3Agb3IgdGFjdGlsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZVNob3dNb3VzZVBvc2l0aW9uUGljdG9FbGVtZW50IDogZnVuY3Rpb24gKGlzRGVza3RvcCkge1xuICAgICAgICAvLyBjb250ZXh0ZSBkJ2V4ZWN1dGlvblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICBsYWJlbC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd01vdXNlUG9zaXRpb25QaWN0b1wiKTtcbiAgICAgICAgbGFiZWwuY2xhc3NOYW1lID0gXCJHUHNob3dBZHZhbmNlZFRvb2xQaWN0b1wiO1xuICAgICAgICBsYWJlbC5odG1sRm9yID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93TW91c2VQb3NpdGlvblwiKTtcbiAgICAgICAgbGFiZWwudGl0bGUgPSBcIkFmZmljaGVyIGxlcyBjb29yZG9ubsOpZXMgZHUgY3Vyc2V1clwiO1xuXG4gICAgICAgIC8vIEZJWE1FIGRldGVjdGlvbiBkaXNwb25pYmxlIGRhbnMgbGUgSlMgIVxuICAgICAgICAvLyBEZXRlY3Rpb24gOiB0ZXN0IGZvciBkZXNrdG9wIG9yIHRhY3RpbGVcbiAgICAgICAgLy8gdmFyIGlzRGVza3RvcCA9IHRydWU7XG4gICAgICAgIC8vIHZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBpZiAodXNlckFnZW50LmluZGV4T2YoXCJpcGhvbmVcIikgIT09IC0xIHx8XG4gICAgICAgIC8vIHVzZXJBZ2VudC5pbmRleE9mKFwiaXBvZFwiKSAhPT0gLTEgfHxcbiAgICAgICAgLy8gdXNlckFnZW50LmluZGV4T2YoXCJpcGFkXCIpICE9PSAtMSB8fFxuICAgICAgICAvLyB1c2VyQWdlbnQuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xIHx8XG4gICAgICAgIC8vIHVzZXJBZ2VudC5pbmRleE9mKFwibW9iaWxlXCIpICE9PSAtMSB8fFxuICAgICAgICAvLyB1c2VyQWdlbnQuaW5kZXhPZihcImJsYWNrYmVycnlcIikgIT09IC0xIHx8XG4gICAgICAgIC8vIHVzZXJBZ2VudC5pbmRleE9mKFwidGFibGV0XCIpICE9PSAtMSB8fFxuICAgICAgICAvLyB1c2VyQWdlbnQuaW5kZXhPZihcInBob25lXCIpICE9PSAtMSB8fFxuICAgICAgICAvLyB1c2VyQWdlbnQuaW5kZXhPZihcInRvdWNoXCIpICE9PSAtMSApIHtcbiAgICAgICAgLy8gICAgIGlzRGVza3RvcCA9IGZhbHNlO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh1c2VyQWdlbnQuaW5kZXhPZihcIm1zaWVcIikgIT09IC0xIHx8XG4gICAgICAgIC8vIHVzZXJBZ2VudC5pbmRleE9mKFwidHJpZGVudFwiKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gICAgIGlzRGVza3RvcCA9IHRydWU7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBTaG93IG1hcCBjZW50ZXIgbG9jYWxpc2F0aW9uIGlmIHBhbmVsIG9wZW5lZCBhbmQgdGFjdGlsZSBzdXBwb3J0XG4gICAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIG1hcENlbnRlckNsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1BzaG93TW91c2VQb3NpdGlvblwiKSkuY2hlY2tlZCAmJiAhaXNEZXNrdG9wKSB7XG4gICAgICAgICAgICAgICAgbWFwQ2VudGVyQ2xhc3MgPSBcIkdQbWFwQ2VudGVyVmlzaWJsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJHUG1hcENlbnRlclwiKS5jbGFzc05hbWUgPSBtYXBDZW50ZXJDbGFzcztcbiAgICAgICAgICAgIHNlbGYub25TaG93TW91c2VQb3NpdGlvbkNsaWNrKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Bhbk9wZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbk9wZW4uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dNb3VzZVBvc2l0aW9uT3BlblwiKTtcbiAgICAgICAgc3Bhbk9wZW4uY2xhc3NOYW1lID0gXCJHUHNob3dBZHZhbmNlZFRvb2xPcGVuXCI7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHNwYW5PcGVuKTtcblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1vdXNlIHBvc2l0aW9uIHBhbmVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGxheUFsdGl0dWRlPXRydWVdIC0gc3BlY2lmaWVzIGlmIHRoZSBhbHRpdHVkZSBwYW5lbCBtdXN0IGJlIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Rpc3BsYXlDb29yZGluYXRlcz10cnVlXSAtIHNwZWNpZmllcyBpZiB0aGUgY29vcmRpbmF0ZXMgcGFuZWwgbXVzdCBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtlZGl0Q29vcmRpbmF0ZXM9ZmFsc2VdIC0gc3BlY2lmaWVzIGlmIHRoZSBjb29yZGluYXRlcyBlZGl0aW9uIGlzIGFsbG93ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdXJyZW50UHJvamVjdGlvblVuaXRzXSAtIHNwZWNpZmllcyBpZiB0aGUgY3VycmVudCBwcm9qZWN0aW9uIHVuaXRzXG4gICAgICpcbiAgICAgKiBGSVhNRVxuICAgICAqIGRvbid0IGNhbGwgdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzRWxlbWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEVsZW1lbnQgOiBmdW5jdGlvbiAoZGlzcGxheUFsdGl0dWRlLCBkaXNwbGF5Q29vcmRpbmF0ZXMsIGVkaXRDb29yZGluYXRlcywgY3VycmVudFByb2plY3Rpb25Vbml0cykge1xuICAgICAgICAvLyBkZWZhdWx0IFZhbHVlc1xuICAgICAgICBkaXNwbGF5QWx0aXR1ZGUgPSAodHlwZW9mIGRpc3BsYXlBbHRpdHVkZSA9PT0gXCJ1bmRlZmluZWRcIikgPyB0cnVlIDogZGlzcGxheUFsdGl0dWRlO1xuICAgICAgICBkaXNwbGF5Q29vcmRpbmF0ZXMgPSAodHlwZW9mIGRpc3BsYXlDb29yZGluYXRlcyA9PT0gXCJ1bmRlZmluZWRcIikgPyB0cnVlIDogZGlzcGxheUNvb3JkaW5hdGVzO1xuICAgICAgICBlZGl0Q29vcmRpbmF0ZXMgPSAodHlwZW9mIGVkaXRDb29yZGluYXRlcyA9PT0gXCJ1bmRlZmluZWRcIikgPyBmYWxzZSA6IGVkaXRDb29yZGluYXRlcztcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uUGFuZWxcIik7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIkdQcGFuZWxcIjtcblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblBhbmVsSGVhZGVyRWxlbWVudCgpKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljRWxlbWVudChkaXNwbGF5QWx0aXR1ZGUsIGRpc3BsYXlDb29yZGluYXRlcywgZWRpdENvb3JkaW5hdGVzLCBjdXJyZW50UHJvamVjdGlvblVuaXRzKSk7XG5cbiAgICAgICAgdmFyIGFycmF5U2V0dGluZ3MgPSB0aGlzLl9jcmVhdGVTaG93TW91c2VQb3NpdGlvblNldHRpbmdzRWxlbWVudChkaXNwbGF5Q29vcmRpbmF0ZXMpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5U2V0dGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChhcnJheVNldHRpbmdzW2pdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJWE1FIG9uIGRlY29tcG9zZSBsYSBmb25jdGlvbiBwb3VyIGxlcyBiZXNvaW5zIGR1IGNvbnRyb2xlLFxuICAgICAgICAvLyBvbiBham91dGVyYSBjZXMgY2hpbGRzIMOgIGxhIG1haW4uLi5cbiAgICAgICAgLy8gZGl2LmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25TZXR0aW5nc0VsZW1lbnQoKSk7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFwIGNlbnRlciBsb2NhbGlzYXRpb24gKHRhY3RpbGUgdXNlKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIF9jcmVhdGVNYXBDZW50ZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSBcIkdQbWFwQ2VudGVyXCI7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgUGFuZWwgY29udGFpbmVyICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBfY3JlYXRlTW91c2VQb3NpdGlvblBhbmVsSGVhZGVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcIkdQcGFuZWxIZWFkZXJcIjtcblxuICAgICAgICB2YXIgZGl2VGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXZUaXRsZS5jbGFzc05hbWUgPSBcIkdQcGFuZWxUaXRsZVwiO1xuICAgICAgICBkaXZUaXRsZS5pbm5lckhUTUwgPSBcIkNvb3Jkb25uw6llc1wiO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2VGl0bGUpO1xuXG4gICAgICAgIHZhciBkaXZDbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdkNsb3NlLmlkID0gXCJHUG1vdXNlUG9zaXRpb25QYW5lbENsb3NlXCI7XG4gICAgICAgIGRpdkNsb3NlLmNsYXNzTmFtZSA9IFwiR1BwYW5lbENsb3NlXCI7XG4gICAgICAgIGRpdkNsb3NlLnRpdGxlID0gXCJGZXJtZXIgbGUgcGFubmVhdVwiO1xuXG4gICAgICAgIC8vIExpbmsgcGFuZWwgY2xvc2UgLyB2aXNpYmlsaXR5IGNoZWNrYm94XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGRpdkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGRpdkNsb3NlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1BzaG93TW91c2VQb3NpdGlvblBpY3RvXCIpKS5jbGljaygpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpdkNsb3NlLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICBkaXZDbG9zZS5hdHRhY2hFdmVudChcIm9uY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQc2hvd01vdXNlUG9zaXRpb25QaWN0b1wiKSkuY2xpY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdkNsb3NlKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb29yZGluYXRlIHBhbmVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGxheUFsdGl0dWRlXSAtIHNwZWNpZmllcyBpZiB0aGUgYWx0aXR1ZGUgcGFuZWwgbXVzdCBiZSBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkaXNwbGF5Q29vcmRpbmF0ZXNdIC0gc3BlY2lmaWVzIGlmIHRoZSBjb29yZGluYXRlcyBwYW5lbCBtdXN0IGJlIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VkaXRDb29yZGluYXRlc10gLSBzcGVjaWZpZXMgaWYgdGhlIGNvb3JkaW5hdGVzIGVkaXRpb24gaXMgYWxsb3dlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnJlbnRQcm9qZWN0aW9uVW5pdHNdIC0gc3BlY2lmaWVzIGlmIHRoZSBjdXJyZW50IHByb2plY3Rpb24gdW5pdHNcbiAgICAgKlxuICAgICAqIEZJWE1FXG4gICAgICogY2FsbCB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxCYXNpY0Nvb3JkaW5hdGVFbGVtZW50XG4gICAgICogY2FsbCB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxCYXNpY0FsdGl0dWRlRWxlbWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljRWxlbWVudCA6IGZ1bmN0aW9uIChkaXNwbGF5QWx0aXR1ZGUsIGRpc3BsYXlDb29yZGluYXRlcywgZWRpdENvb3JkaW5hdGVzLCBjdXJyZW50UHJvamVjdGlvblVuaXRzKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25CYXNpY1BhbmVsXCIpO1xuXG4gICAgICAgIC8vIEZJWE1FIG9uIGRldnJhaXQgZGVjb21wb3NlciBsYSBmb25jdGlvbiBwb3VyIGxlcyBiZXNvaW5zIGR1IGNvbnRyb2xlLFxuICAgICAgICAvLyBvbiBham91dGVyYSBjZXMgY2hpbGRzIMOgIGxhIG1haW4uLi5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljQ29vcmRpbmF0ZUVsZW1lbnQoZGlzcGxheUNvb3JkaW5hdGVzLCBlZGl0Q29vcmRpbmF0ZXMsIGN1cnJlbnRQcm9qZWN0aW9uVW5pdHMpKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEVkaXRUb29sc0VsZW1lbnQoZWRpdENvb3JkaW5hdGVzKSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxCYXNpY0FsdGl0dWRlRWxlbWVudChkaXNwbGF5QWx0aXR1ZGUpKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgY29vcmRpbmF0ZSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvb3JkVHlwZSAtIChcIkxvblwiIG91IFwiTGF0XCIpXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZWRpdENvb3JkaW5hdGVzPWZhbHNlXSAtIHNwZWNpZmllcyBpZiB0aGUgY29vcmRpbmF0ZXMgZWRpdGlvbiBpcyBhbGxvd2VkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2YgRE9NIGVsZW1lbnRzXG4gICAgICovXG4gICAgX2NyZWF0ZUNvb3JkaW5hdGVFbGVtZW50IDogZnVuY3Rpb24gKGNvb3JkVHlwZSwgZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICBpZiAoW1wiTG9uXCIsIFwiTGF0XCJdLmluZGV4T2YoY29vcmRUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25cIiArIGNvb3JkVHlwZSk7XG4gICAgICAgIGlucHV0LnRpdGxlID0gZWRpdENvb3JkaW5hdGVzID09PSB0cnVlID8gXCJDbGlxdWVyIHBvdXIgc2Fpc2lyIGRlcyBjb29yZG9ubsOpZXNcIiA6IFwiXCI7XG4gICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25Nb3VzZVBvc2l0aW9uRWRpdE1vZGVDbGljayh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IGNvbnRleHQudmFsaWRhdGVFeHRlbnRDb29yZGluYXRlKGNvb3JkVHlwZSwgdGhpcy52YWx1ZSwgZSk7XG4gICAgICAgICAgICAgICAgdmFsaWQgPyB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKSA6IHRoaXMuY2xhc3NMaXN0LmFkZChcImVycm9yXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGlucHV0KTtcblxuICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiR1Btb3VzZVBvc2l0aW9uVW5pdHNcIjtcbiAgICAgICAgbGlzdC5wdXNoKHNwYW4pO1xuXG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb29yZFR5cGUgLSAoXCJMb25cIiBvdSBcIkxhdFwiKVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VkaXRDb29yZGluYXRlcz1mYWxzZV0gLSBzcGVjaWZpZXMgaWYgdGhlIGNvb3JkaW5hdGVzIGVkaXRpb24gaXMgYWxsb3dlZFxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIERPTSBlbGVtZW50c1xuICAgICAqL1xuICAgIF9jcmVhdGVETVNDb29yZGluYXRlRWxlbWVudCA6IGZ1bmN0aW9uIChjb29yZFR5cGUsIGVkaXRDb29yZGluYXRlcykge1xuICAgICAgICBpZiAoW1wiTG9uXCIsIFwiTGF0XCJdLmluZGV4T2YoY29vcmRUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25cIiArIGNvb3JkVHlwZSArIFwiRGVncmVlc1wiKTtcbiAgICAgICAgaW5wdXQuY2xhc3NOYW1lID0gXCJHUFNleGFnZXNpbWFsXCI7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJkZWdyZWVzXCIpO1xuICAgICAgICBpbnB1dC50aXRsZSA9IGVkaXRDb29yZGluYXRlcyA9PT0gdHJ1ZSA/IFwiQ2xpcXVlciBwb3VyIHNhaXNpciBkZXMgY29vcmRvbm7DqWVzXCIgOiBcIlwiO1xuICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWU7XG4gICAgICAgIGlucHV0LmRhdGFzZXQubWluID0gMDtcbiAgICAgICAgaW5wdXQuZGF0YXNldC5tYXggPSAoY29vcmRUeXBlID09PSBcIkxvblwiKSA/IDE4MCA6IDkwO1xuICAgICAgICBpZiAoZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25Nb3VzZVBvc2l0aW9uRWRpdE1vZGVDbGljayh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gY29udGV4dC5fY2hlY2tETVNEZWdyZWVzKGNvb3JkVHlwZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdmFsaWQgPyB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKSA6IHRoaXMuY2xhc3NMaXN0LmFkZChcImVycm9yXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGlucHV0KTtcblxuICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiR1Btb3VzZVBvc2l0aW9uU2V4YWdlc2ltYWxMYWJlbFwiO1xuICAgICAgICBzcGFuLmlubmVySFRNTCA9IFwiwrBcIjtcbiAgICAgICAgbGlzdC5wdXNoKHNwYW4pO1xuXG4gICAgICAgIHZhciBpbnB1dDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0MS5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblwiICsgY29vcmRUeXBlICsgXCJNaW51dGVzXCIpO1xuICAgICAgICBpbnB1dDEuY2xhc3NOYW1lID0gXCJHUFNleGFnZXNpbWFsXCI7XG4gICAgICAgIGlucHV0MS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwibWludXRlc1wiKTtcbiAgICAgICAgaW5wdXQxLnRpdGxlID0gZWRpdENvb3JkaW5hdGVzID09PSB0cnVlID8gXCJDbGlxdWVyIHBvdXIgc2Fpc2lyIGRlcyBjb29yZG9ubsOpZXNcIiA6IFwiXCI7XG4gICAgICAgIGlucHV0MS5yZWFkT25seSA9IHRydWU7XG4gICAgICAgIGlucHV0MS5kYXRhc2V0Lm1pbiA9IDA7XG4gICAgICAgIGlucHV0MS5kYXRhc2V0Lm1heCA9IDU5O1xuICAgICAgICBpZiAoZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBpbnB1dDEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTW91c2VQb3NpdGlvbkVkaXRNb2RlQ2xpY2sodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlucHV0MS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWQgPSBjb250ZXh0Ll9jaGVja0RNU0VsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgdmFsaWQgPyB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKSA6IHRoaXMuY2xhc3NMaXN0LmFkZChcImVycm9yXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKGlucHV0MSk7XG5cbiAgICAgICAgdmFyIHNwYW4xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4xLmNsYXNzTmFtZSA9IFwiR1Btb3VzZVBvc2l0aW9uU2V4YWdlc2ltYWxMYWJlbFwiO1xuICAgICAgICBzcGFuMS5pbm5lckhUTUwgPSBcIidcIjtcbiAgICAgICAgbGlzdC5wdXNoKHNwYW4xKTtcblxuICAgICAgICB2YXIgaW5wdXQyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpbnB1dDIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25cIiArIGNvb3JkVHlwZSArIFwiU2Vjb25kc1wiKTtcbiAgICAgICAgaW5wdXQyLmNsYXNzTmFtZSA9IFwiR1BTZXhhZ2VzaW1hbHNlY1wiO1xuICAgICAgICBpbnB1dDIuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcInNlY29uZHNcIik7XG4gICAgICAgIGlucHV0Mi50aXRsZSA9IGVkaXRDb29yZGluYXRlcyA9PT0gdHJ1ZSA/IFwiQ2xpcXVlciBwb3VyIHNhaXNpciBkZXMgY29vcmRvbm7DqWVzXCIgOiBcIlwiO1xuICAgICAgICBpbnB1dDIucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICBpbnB1dDIuZGF0YXNldC5taW4gPSAwO1xuICAgICAgICBpbnB1dDIuZGF0YXNldC5tYXggPSA1OTtcbiAgICAgICAgaWYgKGVkaXRDb29yZGluYXRlcykge1xuICAgICAgICAgICAgaW5wdXQyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk1vdXNlUG9zaXRpb25FZGl0TW9kZUNsaWNrKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpbnB1dDIuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gY29udGV4dC5fY2hlY2tETVNFbGVtZW50KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhbGlkID8gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIikgOiB0aGlzLmNsYXNzTGlzdC5hZGQoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QucHVzaChpbnB1dDIpO1xuXG4gICAgICAgIHZhciBzcGFuMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuMi5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvblNleGFnZXNpbWFsTGFiZWxcIjtcbiAgICAgICAgc3BhbjIuaW5uZXJIVE1MID0gXCInJ1wiO1xuICAgICAgICBsaXN0LnB1c2goc3BhbjIpO1xuXG4gICAgICAgIHZhciBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgICAgICBzZWxlY3QuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25cIiArIGNvb3JkVHlwZSArIFwiRGlyZWN0aW9uXCIpO1xuICAgICAgICBzZWxlY3QuY2xhc3NOYW1lID0gXCJHUG1vdXNlUG9zaXRpb25EaXJlY3Rpb25cIjtcbiAgICAgICAgc2VsZWN0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJkaXJlY3Rpb25cIik7XG4gICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IChjb29yZFR5cGUgPT09IFwiTG9uXCIpID8gXCJFXCIgOiBcIk5cIjtcbiAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IChjb29yZFR5cGUgPT09IFwiTG9uXCIpID8gXCJFXCIgOiBcIk5cIjtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG5cbiAgICAgICAgdmFyIG9wdGlvbjEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICBvcHRpb24xLnZhbHVlID0gKGNvb3JkVHlwZSA9PT0gXCJMb25cIikgPyBcIk9cIiA6IFwiU1wiO1xuICAgICAgICBvcHRpb24xLmlubmVySFRNTCA9IChjb29yZFR5cGUgPT09IFwiTG9uXCIpID8gXCJPXCIgOiBcIlNcIjtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbjEpO1xuICAgICAgICBsaXN0LnB1c2goc2VsZWN0KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGxheT1mYWxzZV0gLSBzcGVjaWZpZXMgaWYgdGhlIGNvb3JkaW5hdGVzIHBhbmVsIG11c3QgYmUgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZWRpdENvb3JkaW5hdGVzXSAtIHNwZWNpZmllcyBpZiB0aGUgY29vcmRpbmF0ZXMgZWRpdGlvbiBpcyBhbGxvd2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY3VycmVudFByb2plY3Rpb25Vbml0c10gLSBzcGVjaWZpZXMgaWYgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiB1bml0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIF9jcmVhdGVNb3VzZVBvc2l0aW9uUGFuZWxCYXNpY0Nvb3JkaW5hdGVFbGVtZW50IDogZnVuY3Rpb24gKGRpc3BsYXksIGVkaXRDb29yZGluYXRlcywgY3VycmVudFByb2plY3Rpb25Vbml0cykge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQ29vcmRpbmF0ZVwiKTtcbiAgICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5ID8gXCJibG9ja1wiIDogXCJub25lXCI7XG5cbiAgICAgICAgLy8gbGF0aXR1ZGVcbiAgICAgICAgdmFyIGRpdkxhdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgdmFyIHNwYW5MYXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3BhbkxhdC5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvbkxhYmVsXCI7XG4gICAgICAgIHNwYW5MYXQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25MYXRMYWJlbFwiKTtcbiAgICAgICAgc3BhbkxhdC5pbm5lckhUTUwgPSBcIkxhdGl0dWRlIDogXCI7XG4gICAgICAgIGRpdkxhdC5hcHBlbmRDaGlsZChzcGFuTGF0KTtcblxuICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTGF0Q29vcmRpbmF0ZVwiKTtcblxuICAgICAgICB2YXIgYXJyYXlDb29yZHM7XG4gICAgICAgIGlmIChjdXJyZW50UHJvamVjdGlvblVuaXRzID09PSBcIkRNU1wiKSB7XG4gICAgICAgICAgICBhcnJheUNvb3JkcyA9IHRoaXMuX2NyZWF0ZURNU0Nvb3JkaW5hdGVFbGVtZW50KFwiTGF0XCIsIGVkaXRDb29yZGluYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheUNvb3JkcyA9IHRoaXMuX2NyZWF0ZUNvb3JkaW5hdGVFbGVtZW50KFwiTGF0XCIsIGVkaXRDb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhcnJheUNvb3Jkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGl2TGF0LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZGl2TGF0KTtcblxuICAgICAgICAvLyBsb25naXR1ZGVcbiAgICAgICAgdmFyIGRpdkxvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgdmFyIHNwYW5Mb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbkxvbi5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvbkxhYmVsXCI7XG4gICAgICAgIHNwYW5Mb24uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25Mb25MYWJlbFwiKTtcbiAgICAgICAgc3Bhbkxvbi5pbm5lckhUTUwgPSBcIkxvbmdpdHVkZSA6IFwiO1xuICAgICAgICBkaXZMb24uYXBwZW5kQ2hpbGQoc3Bhbkxvbik7XG5cbiAgICAgICAgdmFyIHNwYW4xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4xLmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTG9uQ29vcmRpbmF0ZVwiKTtcblxuICAgICAgICB2YXIgYXJyYXlDb29yZHMxO1xuICAgICAgICBpZiAoY3VycmVudFByb2plY3Rpb25Vbml0cyA9PT0gXCJETVNcIikge1xuICAgICAgICAgICAgYXJyYXlDb29yZHMxID0gdGhpcy5fY3JlYXRlRE1TQ29vcmRpbmF0ZUVsZW1lbnQoXCJMb25cIiwgZWRpdENvb3JkaW5hdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5Q29vcmRzMSA9IHRoaXMuX2NyZWF0ZUNvb3JkaW5hdGVFbGVtZW50KFwiTG9uXCIsIGVkaXRDb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheUNvb3JkczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHNwYW4xLmFwcGVuZENoaWxkKGFycmF5Q29vcmRzMVtqXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGl2TG9uLmFwcGVuZENoaWxkKHNwYW4xKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGRpdkxvbik7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGxheT1mYWxzZV0gLSBzcGVjaWZpZXMgaWYgdGhlIGFsdGl0dWRlIHBhbmVsIG11c3QgYmUgZGlzcGxheWVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEJhc2ljQWx0aXR1ZGVFbGVtZW50IDogZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkFsdGl0dWRlXCIpO1xuICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgPyBcImJsb2NrXCIgOiBcIm5vbmVcIjtcblxuICAgICAgICB2YXIgc3BhbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5MYWJlbC5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvbkxhYmVsXCI7XG4gICAgICAgIHNwYW5MYWJlbC5pbm5lckhUTUwgPSBcIkFsdGl0dWRlIDogXCI7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChzcGFuTGFiZWwpO1xuXG4gICAgICAgIHZhciBzcGFuQWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5BbHQuY2xhc3NOYW1lID0gXCJHUG1vdXNlUG9zaXRpb25Db29yZHNcIjtcbiAgICAgICAgc3BhbkFsdC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkFsdFwiKTtcbiAgICAgICAgc3BhbkFsdC5pbm5lckhUTUwgPSBcIi4uLlwiO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3BhbkFsdCk7XG5cbiAgICAgICAgdmFyIHNwYW5Vbml0cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuVW5pdHMuY2xhc3NOYW1lID0gXCJHUG1vdXNlUG9zaXRpb25BbHRpdHVkZVVuaXRzXCI7XG4gICAgICAgIHNwYW5Vbml0cy5pbm5lckhUTUwgPSBcIm1cIjtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHNwYW5Vbml0cyk7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZWRpdENvb3JkaW5hdGVzPWZhbHNlXSAtIHNwZWNpZmllcyBpZiB0aGUgY29vcmRpbmF0ZXMgZWRpdGlvbiBpcyBhbGxvd2VkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgX2NyZWF0ZU1vdXNlUG9zaXRpb25QYW5lbEVkaXRUb29sc0VsZW1lbnQgOiBmdW5jdGlvbiAoZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1Btb3VzZVBvc2l0aW9uUGFuZWxFZGl0VG9vbHNcIjtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uUGFuZWxFZGl0VG9vbHNcIik7XG4gICAgICAgIGlmICghZWRpdENvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYW4xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4xLmNsYXNzTmFtZSA9IFwiR1Btb3VzZVBvc2l0aW9uRWRpdFRvb2xcIjtcbiAgICAgICAgc3BhbjEuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25Mb2NhdGVcIik7XG4gICAgICAgIHNwYW4xLnRpdGxlID0gZWRpdENvb3JkaW5hdGVzID09PSB0cnVlID8gXCJDbGlxdWVyIHBvdXIgc2Fpc2lyIGRlcyBjb29yZG9ubsOpZXNcIiA6IFwiXCI7XG4gICAgICAgIGlmIChlZGl0Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHNwYW4xLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk1vdXNlUG9zaXRpb25FZGl0TW9kZUxvY2F0ZUNsaWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoc3BhbjEpO1xuXG4gICAgICAgIHZhciBzcGFuMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuMi5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvbkVkaXRUb29sXCI7XG4gICAgICAgIHNwYW4yLmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQ2xvc2VFZGl0XCIpO1xuICAgICAgICBzcGFuMi50aXRsZSA9IFwiUXVpdHRlciBsYSBzYWlzaWUgZGVzIGNvb3Jkb25uw6llc1wiO1xuICAgICAgICBzcGFuMi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGlmIChlZGl0Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHNwYW4yLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk1vdXNlUG9zaXRpb25FZGl0TW9kZUNsaWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChzcGFuMik7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIFNldHRpbmdzIGNvbnRhaW5lciAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkaXNwbGF5PWZhbHNlXSAtIHNwZWNpZmllcyBpZiB0aGUgc2V0dGluZ3MgcGFuZWwgbXVzdCBiZSBkaXNwbGF5ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50W119IGFycmF5IGNvbnRhaW5pbmcgaW5wdXQgYW5kIGxhYmVsIGVsZW1lbnRzXG4gICAgICovXG4gICAgX2NyZWF0ZVNob3dNb3VzZVBvc2l0aW9uU2V0dGluZ3NFbGVtZW50IDogZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIGlucHV0LmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93TW91c2VQb3NpdGlvblNldHRpbmdzXCIpO1xuXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgbGFiZWwuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dNb3VzZVBvc2l0aW9uU2V0dGluZ3NQaWN0b1wiKTtcbiAgICAgICAgbGFiZWwuaHRtbEZvciA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd01vdXNlUG9zaXRpb25TZXR0aW5nc1wiKTtcbiAgICAgICAgbGFiZWwudGl0bGUgPSBcIlLDqWdsYWdlc1wiO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcIkdQc2hvd01vcmVPcHRpb25zIEdQc2hvd01vdXNlUG9zaXRpb25TZXR0aW5nc1BpY3RvXCI7IC8vIEZJWE1FIGNsYXNzbmFtZSBhbmQgaWQgP1xuICAgICAgICBsYWJlbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuXG4gICAgICAgIGxpc3QucHVzaChpbnB1dCk7XG4gICAgICAgIGxpc3QucHVzaChsYWJlbCk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNldHRpbmdzIHBhbmVsXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGxheT10cnVlXSAtIHNwZWNpZmllcyBpZiB0aGUgc2V0dGluZ3MgcGFuZWwgbXVzdCBiZSBkaXNwbGF5ZWRcbiAgICAgKlxuICAgICAqIEZJWE1FXG4gICAgICogZG9uJ3QgY2FsbCB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uU2V0dGluZ3NTeXN0ZW1zRWxlbWVudFxuICAgICAqIGRvbid0IGNhbGwgdGhpcy5fY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzVW5pdHNFbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzRWxlbWVudCA6IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25TZXR0aW5nc1wiKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAoZGlzcGxheSA9PT0gdW5kZWZpbmVkIHx8IGRpc3BsYXkpID8gXCJibG9ja1wiIDogXCJub25lXCI7XG5cbiAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcIkdQbW91c2VQb3NpdGlvblNldHRpbmdzTGFiZWxcIjtcbiAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSBcIlN5c3TDqG1lIGRlIHLDqWbDqXJlbmNlXCI7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzcGFuKTtcblxuICAgICAgICAvLyBGSVhNRSBvbiBkZWNvbXBvc2UgbGEgZm9uY3Rpb24gcG91ciBsZXMgYmVzb2lucyBkdSBjb250cm9sZSxcbiAgICAgICAgLy8gb24gYWpvdXRlcmEgY2VzIGNoaWxkcyDDoCBsYSBtYWluLi4uXG4gICAgICAgIC8vIEZJWE1FIHRhYmxlYXUgc3RhdGlxdWUgIVxuICAgICAgICAvLyB2YXIgc3lzdGVtcyA9IFtcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBjb2RlIDogXCJHRU9HUkFQSElDXCIsXG4gICAgICAgIC8vICAgICAgICAgbGFiZWwgOiBcIkfDqW9ncmFwaGlxdWVcIlxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBjb2RlIDogXCJNRVJDQVRPUlwiLFxuICAgICAgICAvLyAgICAgICAgIGxhYmVsIDogXCJNZXJjYXRvclwiXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGNvZGUgOiBcIkxBTUI5M1wiLFxuICAgICAgICAvLyAgICAgICAgIGxhYmVsIDogXCJMYW1iZXJ0IDkzXCJcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgY29kZSA6IFwiTEFNQjJFXCIsXG4gICAgICAgIC8vICAgICAgICAgbGFiZWwgOiBcIkxhbWJlcnQgSUkgw6l0ZW5kdVwiXG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIF07XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHZhciBzZWxlY3RTeXN0ZW0gPSB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uU2V0dGluZ3NTeXN0ZW1zRWxlbWVudChzeXN0ZW1zKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGVjdFN5c3RlbSk7XG5cbiAgICAgICAgLy8gRklYTUUgb24gZGVjb21wb3NlIGxhIGZvbmN0aW9uIHBvdXIgbGVzIGJlc29pbnMgZHUgY29udHJvbGUsXG4gICAgICAgIC8vIG9uIGFqb3V0ZXJhIGNlcyBjaGlsZHMgw6AgbGEgbWFpbi4uLlxuICAgICAgICAvLyBGSVhNRSB0YWJsZWF1IHN0YXRpcXVlICFcbiAgICAgICAgLy8gdmFyIHVuaXRzID0gW1xuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGNvZGUgOiBcIkRFQ1wiLFxuICAgICAgICAvLyAgICAgICAgIGxhYmVsIDogXCJkZWdyw6lzIGTDqWNpbWF1eFwiLFxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBjb2RlIDogXCJETVNcIixcbiAgICAgICAgLy8gICAgICAgICBsYWJlbCA6IFwiZGVncsOpcyBzZXhhZ8Opc2ltYXV4XCIsXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGNvZGUgOiBcIlJBRFwiLFxuICAgICAgICAvLyAgICAgICAgIGxhYmVsIDogXCJyYWRpYW5zXCIsXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIGNvZGUgOiBcIkdPTlwiLFxuICAgICAgICAvLyAgICAgICAgIGxhYmVsIDogXCJncmFkZXNcIlxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyBdO1xuICAgICAgICAvL1xuICAgICAgICAvLyB2YXIgc2VsZWN0VW5pdHMgPSB0aGlzLl9jcmVhdGVNb3VzZVBvc2l0aW9uU2V0dGluZ3NVbml0c0VsZW1lbnQodW5pdHMpO1xuICAgICAgICAvL1xuICAgICAgICAvLyBjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZWN0VW5pdHMpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHN5c3RlbXMgLSBsaXN0IG9mIHN5c3RlbXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudCBzZWxlY3RcbiAgICAgKi9cbiAgICBfY3JlYXRlTW91c2VQb3NpdGlvblNldHRpbmdzU3lzdGVtc0VsZW1lbnQgOiBmdW5jdGlvbiAoc3lzdGVtcykge1xuICAgICAgICAvLyBjb250ZXh0ZSBkJ2V4ZWN1dGlvblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNlbGVjdFN5c3RlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICAgIHNlbGVjdFN5c3RlbS5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblByb2plY3Rpb25TeXN0ZW1cIik7XG4gICAgICAgIHNlbGVjdFN5c3RlbS5jbGFzc05hbWUgPSBcIkdQaW5wdXRTZWxlY3QgR1Btb3VzZVBvc2l0aW9uU2V0dGluZ3NTZWxlY3RcIjtcbiAgICAgICAgc2VsZWN0U3lzdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGNvbnRleHQub25Nb3VzZVBvc2l0aW9uUHJvamVjdGlvblN5c3RlbUNoYW5nZShlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdFN5c3RlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBtZXR0cmUgdW5lIGNvbmRpdGlvbiBzaSB0YXJnZXQgPT09IG9wdGlvblxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lICE9PSBcIk9QVElPTlwiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uU3lzdGVtTW91c2VPdmVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5c3RlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBzeXN0ZW1zW2ldO1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBvYmouY29kZTtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0ID0gb2JqLmxhYmVsIHx8IGk7XG4gICAgICAgICAgICAvLyBvcHRpb24ubGFiZWwgPSBvYmoubGFiZWw7XG4gICAgICAgICAgICBzZWxlY3RTeXN0ZW0uYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RTeXN0ZW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHVuaXRzIC0gbGlzdCBvZiB1bml0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50IHNlbGVjdFxuICAgICAqL1xuICAgIF9jcmVhdGVNb3VzZVBvc2l0aW9uU2V0dGluZ3NVbml0c0VsZW1lbnQgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgLy8gY29udGV4dGUgZCdleGVjdXRpb25cbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzZWxlY3RVbml0cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICAgIHNlbGVjdFVuaXRzLmlkID0gdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uUHJvamVjdGlvblVuaXRzXCIpO1xuICAgICAgICBzZWxlY3RVbml0cy5jbGFzc05hbWUgPSBcIkdQaW5wdXRTZWxlY3QgR1Btb3VzZVBvc2l0aW9uU2V0dGluZ3NTZWxlY3RcIjtcbiAgICAgICAgc2VsZWN0VW5pdHMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgY29udGV4dC5vbk1vdXNlUG9zaXRpb25Qcm9qZWN0aW9uVW5pdHNDaGFuZ2UoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdW5pdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB1bml0c1tqXTtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gKG9iai5jb2RlKSA/IG9iai5jb2RlIDogajtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0ID0gb2JqLmxhYmVsIHx8IGo7XG4gICAgICAgICAgICAvLyBvcHRpb24ubGFiZWwgPSBvYmoubGFiZWw7XG4gICAgICAgICAgICBzZWxlY3RVbml0cy5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdFVuaXRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2N1cnJlbnRQcm9qZWN0aW9uVHlwZT1cIk1ldHJpY1wiXSAtIFwiR2VvZ3JhcGhpY2FsXCIgb3IgXCJNZXRyaWNcIlxuICAgICAqL1xuICAgIF9yZXNldExhYmVsRWxlbWVudHMgOiBmdW5jdGlvbiAoY3VycmVudFByb2plY3Rpb25UeXBlKSB7XG4gICAgICAgIC8vIENoYW5nZW1lbnQgZGVzIGxhYmVscyBkYW5zIGxlIGZvcm11bGFpcmUgZGUgc2Fpc2llXG4gICAgICAgIHZhciBzcGFuTGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTGF0TGFiZWxcIikpO1xuICAgICAgICBzcGFuTGF0LmlubmVySFRNTCA9IGN1cnJlbnRQcm9qZWN0aW9uVHlwZSA9PT0gXCJHZW9ncmFwaGljYWxcIiA/IFwiTGF0aXR1ZGUgOlwiIDogXCJYIDpcIjtcblxuICAgICAgICB2YXIgc3BhbkxvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkxvbkxhYmVsXCIpKTtcbiAgICAgICAgc3Bhbkxvbi5pbm5lckhUTUwgPSBjdXJyZW50UHJvamVjdGlvblR5cGUgPT09IFwiR2VvZ3JhcGhpY2FsXCIgPyBcIkxvbmdpdHVkZSA6XCIgOiBcIlkgOlwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFByb2plY3Rpb25Vbml0cyAtIHByb2plY3Rpb24gdW5pdHNcbiAgICAgKi9cbiAgICBfcmVzZXRVbml0RWxlbWVudHMgOiBmdW5jdGlvbiAoY3VycmVudFByb2plY3Rpb25Vbml0cykge1xuICAgICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgICBpZiAoY3VycmVudFByb2plY3Rpb25Vbml0cyA9PT0gXCJNXCIgfHwgY3VycmVudFByb2plY3Rpb25Vbml0cyA9PT0gXCJLTVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGN1cnJlbnRQcm9qZWN0aW9uVW5pdHMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbW91c2VQb3NpdGlvblVuaXRzXCIpO1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVsdHMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgIGVsdHNbZV0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfcmVzZXRDb29yZGluYXRlRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVkaXRDb29yZGluYXRlcyAtIGVkaXQgY29vcmRpbmF0ZXMgb3B0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRQcm9qZWN0aW9uVHlwZSAtIGN1cnJlbnQgcHJvamVjdGlvbiB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRQcm9qZWN0aW9uVW5pdHMgLSBjdXJyZW50IHByb2plY3Rpb24gdW5pdFxuICAgICAqL1xuICAgIF9yZXNldENvb3JkaW5hdGVFbGVtZW50cyA6IGZ1bmN0aW9uIChlZGl0Q29vcmRpbmF0ZXMsIGN1cnJlbnRQcm9qZWN0aW9uVHlwZSwgY3VycmVudFByb2plY3Rpb25Vbml0cykge1xuICAgICAgICAvLyBTdXBwcmVzc2lvbiBkZSB0b3VzIGxlcyBlbmZhbnRzIGRlIEdQbW91c2VQb3NpdGlvbkxhdENvb3JkaW5hdGVcbiAgICAgICAgdmFyIGxhdEVsdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkxhdENvb3JkaW5hdGVcIikpO1xuICAgICAgICB3aGlsZSAobGF0RWx0LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGxhdEVsdC5yZW1vdmVDaGlsZChsYXRFbHQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyYXlDb29yZHM7XG4gICAgICAgIGlmIChjdXJyZW50UHJvamVjdGlvblVuaXRzID09PSBcIkRNU1wiKSB7XG4gICAgICAgICAgICBhcnJheUNvb3JkcyA9IHRoaXMuX2NyZWF0ZURNU0Nvb3JkaW5hdGVFbGVtZW50KFwiTGF0XCIsIGVkaXRDb29yZGluYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheUNvb3JkcyA9IHRoaXMuX2NyZWF0ZUNvb3JkaW5hdGVFbGVtZW50KFwiTGF0XCIsIGVkaXRDb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGF0RWx0LmFwcGVuZENoaWxkKGFycmF5Q29vcmRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHByZXNzaW9uIGRlIHRvdXMgbGVzIGVuZmFudHMgZGUgR1Btb3VzZVBvc2l0aW9uTG9uQ29vcmRpbmF0ZVxuICAgICAgICB2YXIgbG9uRWx0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTG9uQ29vcmRpbmF0ZVwiKSk7XG4gICAgICAgIHdoaWxlIChsb25FbHQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgbG9uRWx0LnJlbW92ZUNoaWxkKGxvbkVsdC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJheUNvb3JkczE7XG4gICAgICAgIGlmIChjdXJyZW50UHJvamVjdGlvblVuaXRzID09PSBcIkRNU1wiKSB7XG4gICAgICAgICAgICBhcnJheUNvb3JkczEgPSB0aGlzLl9jcmVhdGVETVNDb29yZGluYXRlRWxlbWVudChcIkxvblwiLCBlZGl0Q29vcmRpbmF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlDb29yZHMxID0gdGhpcy5fY3JlYXRlQ29vcmRpbmF0ZUVsZW1lbnQoXCJMb25cIiwgZWRpdENvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Q29vcmRzMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbG9uRWx0LmFwcGVuZENoaWxkKGFycmF5Q29vcmRzMVtqXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBvbiBzaW11bGUgdW4gZGVwbGFjZW1lbnQgP1xuICAgICAgICAvLyB0aGlzLm9uTWFwTW92ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQvdW5zZXQgZWRpdGluZyBtb2RlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9zZXRFZGl0TW9kZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZWRpdGluZyAtIGFjdGl2ZSBlZGl0IGNvb3JkaW5hdGVzIG1vZGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdE1vZGUgOiBmdW5jdGlvbiAoZWRpdGluZykge1xuICAgICAgICB2YXIgbG9jYXRlRWx0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTG9jYXRlXCIpKTtcbiAgICAgICAgbG9jYXRlRWx0LnRpdGxlID0gZWRpdGluZyA/IFwiQWxsZXIgw6AgbGEgcG9zaXRpb24gLi4uXCIgOiBcIkNsaXF1ZXIgcG91ciBzYWlzaXIgZGVzIGNvb3Jkb25uw6llc1wiO1xuXG4gICAgICAgIHZhciBjbG9zZUVkaXRFbHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25DbG9zZUVkaXRcIikpO1xuICAgICAgICBjbG9zZUVkaXRFbHQuc3R5bGUuZGlzcGxheSA9IGVkaXRpbmcgPyBcImlubGluZS1ibG9ja1wiIDogXCJub25lXCI7XG5cbiAgICAgICAgdmFyIHNlbGVjdG9yID0gXCJkaXZbaWRePVwiICsgdGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQ29vcmRpbmF0ZVwiKSArIFwiXVwiO1xuICAgICAgICB2YXIgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciArIFwiIGlucHV0XCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRzW2ldLnJlYWRPbmx5ID0gIWVkaXRpbmc7XG4gICAgICAgICAgICBpZiAoZWRpdGluZykge1xuICAgICAgICAgICAgICAgIGlucHV0c1tpXS52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaW5wdXRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IgKyBcIiBzZWxlY3RcIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgc2VsZWN0c1tqXS5kaXNhYmxlZCA9ICFlZGl0aW5nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBpbnB1dCAtIGlucHV0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRmxvYXQgLSBjaGVjayBmb3IgZmxvYXQgdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGlucHV0IHZhbHVlIGlzIHdpdGhpbiBib3VuZHNcbiAgICAgKi9cbiAgICBfY2hlY2tETVNFbGVtZW50IDogZnVuY3Rpb24gKGlucHV0LCBpc0Zsb2F0KSB7XG4gICAgICAgIHZhciBiID0gaXNGbG9hdCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKFwiLFwiLCBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFiICYmICh2IHwgMCkgIT09IHYpIHsgLy8gaXMgaXQgYW4gaW50ZWdlclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pbiA9IE51bWJlcihpbnB1dC5kYXRhc2V0Lm1pbik7XG4gICAgICAgIHZhciBtYXggPSBOdW1iZXIoaW5wdXQuZGF0YXNldC5tYXgpO1xuICAgICAgICByZXR1cm4gKHYgPj0gbWluICYmIHYgPD0gbWF4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvb3JkVHlwZSAtIFwiTG9uXCIgb3IgXCJMYXRcIlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gaW5wdXQgLSBpbnB1dCBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbnB1dCB2YWx1ZSBpcyB3aXRoaW4gYm91bmRzXG4gICAgICovXG4gICAgX2NoZWNrRE1TRGVncmVlcyA6IGZ1bmN0aW9uIChjb29yZFR5cGUsIGlucHV0KSB7XG4gICAgICAgIGlmIChpc05hTihpbnB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ID0gcGFyc2VGbG9hdChpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlmICgodiB8IDApICE9PSB2KSB7IC8vIGlzIGl0IGFuIGludGVnZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW4gPSBOdW1iZXIoaW5wdXQuZGF0YXNldC5taW4pO1xuICAgICAgICB2YXIgbWF4ID0gTnVtYmVyKGlucHV0LmRhdGFzZXQubWF4KTtcbiAgICAgICAgaWYgKHYgPCBtaW4gfHwgdiA+IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0TWludXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblwiICsgY29vcmRUeXBlICsgXCJNaW51dGVzXCIpKTtcbiAgICAgICAgdmFyIGlucHV0U2Vjb25kcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvblwiICsgY29vcmRUeXBlICsgXCJTZWNvbmRzXCIpKTtcblxuICAgICAgICBpZiAodiA+PSBtYXgpIHtcbiAgICAgICAgICAgIGlucHV0TWludXRlcy5kYXRhc2V0Lm1heCA9IDA7XG4gICAgICAgICAgICBpbnB1dFNlY29uZHMuZGF0YXNldC5tYXggPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNaW51dGVzLmRhdGFzZXQubWF4ID0gNTk7XG4gICAgICAgICAgICBpbnB1dFNlY29uZHMuZGF0YXNldC5tYXggPSA1OS45OTk5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBoYW5kbGVycyBFdmVudCAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gZGlzcGxheWluZyBjb29yZGluYXRlcyBmcm9tIGN1cnNvciBwb3NpdGlvbiAoZGVza3RvcClcbiAgICAgKiBvciBtYXAgY2VudGVyICh0YWN0aWxlKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZGluYXRlIC0gY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBHUGRpc3BsYXlDb29yZHMgOiBmdW5jdGlvbiAoY29vcmRpbmF0ZSkge1xuICAgICAgICAvLyBDb21wdXRlIGNvb3JkcyBpbiBjYXNlIG9mIGN1cnNvciBwb3NpdGlvbiAoZGVza3RvcClcbiAgICAgICAgaWYgKGNvb3JkaW5hdGUgJiYgY29vcmRpbmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxMb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25Mb25MYWJlbFwiKSk7XG4gICAgICAgICAgICB2YXIgbGFiZWxMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25MYXRMYWJlbFwiKSk7XG5cbiAgICAgICAgICAgIGlmIChjb29yZGluYXRlLnggfHwgY29vcmRpbmF0ZS55KSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXQuaW5uZXJIVE1MID0gXCJYIDogXCI7XG4gICAgICAgICAgICAgICAgbGFiZWxMb24uaW5uZXJIVE1MID0gXCJZIDogXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb3JkaW5hdGUuZSB8fCBjb29yZGluYXRlLm4pIHtcbiAgICAgICAgICAgICAgICBsYWJlbExhdC5pbm5lckhUTUwgPSBcIkUgOiBcIjtcbiAgICAgICAgICAgICAgICBsYWJlbExvbi5pbm5lckhUTUwgPSBcIk4gOiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxMYXQuaW5uZXJIVE1MID0gXCJMYXRpdHVkZSA6IFwiO1xuICAgICAgICAgICAgICAgIGxhYmVsTG9uLmlubmVySFRNTCA9IFwiTG9uZ2l0dWRlIDogXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZS5sYXQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvb3JkaW5hdGUubG5nID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICBsbmcgOiBcIkxvblwiLFxuICAgICAgICAgICAgICAgICAgICBsYXQgOiBcIkxhdFwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgdW5pdHMgPSBbXCJEZWdyZWVzXCIsIFwiTWludXRlc1wiLCBcIlNlY29uZHNcIl07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IHVuaXRzLmxlbmd0aDsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBcIkdQbW91c2VQb3NpdGlvblwiICsgcGFydHNbcF0gKyB1bml0c1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB1bml0c1t1XS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdC52YWx1ZSA9IGNvb3JkaW5hdGVbcF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rpb25zXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uTG9uRGlyZWN0aW9uXCIpKS52YWx1ZSA9IGNvb3JkaW5hdGUubG5nLmRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25MYXREaXJlY3Rpb25cIikpLnZhbHVlID0gY29vcmRpbmF0ZS5sYXQuZGlyZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxMYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25MYXRcIikpO1xuICAgICAgICAgICAgICAgIHZhciBlbExvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbW91c2VQb3NpdGlvbkxvblwiKSk7XG5cbiAgICAgICAgICAgICAgICBlbExhdC52YWx1ZSA9IGNvb3JkaW5hdGUueCB8fCBjb29yZGluYXRlLmxhdCB8fCBjb29yZGluYXRlLmUgfHwgXCIwXCI7XG4gICAgICAgICAgICAgICAgZWxMb24udmFsdWUgPSBjb29yZGluYXRlLnkgfHwgY29vcmRpbmF0ZS5sbmcgfHwgY29vcmRpbmF0ZS5sb24gfHwgY29vcmRpbmF0ZS5uIHx8IFwiMFwiO1xuXG4gICAgICAgICAgICAgICAgLy8gbGVzIHVuaXRlc1xuICAgICAgICAgICAgICAgIHZhciB1bml0ID0gKGNvb3JkaW5hdGUudW5pdCA9PT0gdW5kZWZpbmVkKSA/IFwiXCIgOiBjb29yZGluYXRlLnVuaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbW91c2VQb3NpdGlvblVuaXRzXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZWxlbWVudHMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbbl0uaW5uZXJIVE1MID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gZGlzcGxheWluZyBhbHRpdHVkZSBmcm9tIGN1cnNvciBwb3NpdGlvbiAoZGVza3RvcClcbiAgICAgKiBvciBtYXAgY2VudGVyICh0YWN0aWxlKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZGluYXRlIC0gY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWx0aXR1ZGVUaW1lb3V0RGVsYXkgLSB3aGVuIHRoZSBtb3VzZSBzdG9wIG1vdmluZywgZGVsYXkgYmVmb3JlIHRoZSBhbHRpdHVkZSByZXF1ZXN0IGlzIGxhdW5jaGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5vRGF0YVZhbHVlIC0gdGhlIG5vIGRhdGEgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9EYXRhVmFsdWVUb2xlcmFuY2UgLSB0aGUgbm8gZGF0YSB2YWx1ZSB0b2xlcmFuY2VcbiAgICAgKi9cbiAgICBHUGRpc3BsYXlFbGV2YXRpb24gOiBmdW5jdGlvbiAoY29vcmRpbmF0ZSwgYWx0aXR1ZGVUaW1lb3V0RGVsYXksIG5vRGF0YVZhbHVlLCBub0RhdGFWYWx1ZVRvbGVyYW5jZSkge1xuICAgICAgICAvLyBjb250ZXh0ZSBkJ2V4ZWN1dGlvblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gTGF0ZW5jeSBmb3IgYWx0aXR1ZGUgcmVxdWVzdFxuICAgICAgICB2YXIgYWx0aXR1ZGVUaW1lb3V0O1xuICAgICAgICBpZiAoIWFsdGl0dWRlVGltZW91dERlbGF5KSB7XG4gICAgICAgICAgICBhbHRpdHVkZVRpbWVvdXREZWxheSA9IDUwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dChhbHRpdHVkZVRpbWVvdXQpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25BbHRcIikpLmlubmVySFRNTCA9IFwiLi4uXCI7XG5cbiAgICAgICAgaWYgKG5vRGF0YVZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vRGF0YVZhbHVlID0gLTk5OTk5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub0RhdGFWYWx1ZVRvbGVyYW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub0RhdGFWYWx1ZVRvbGVyYW5jZSA9IDk5OTgwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXhUaHJlc2hvbGQgPSBub0RhdGFWYWx1ZSArIG5vRGF0YVZhbHVlVG9sZXJhbmNlO1xuICAgICAgICB2YXIgbWluVGhyZXNob2xkID0gbm9EYXRhVmFsdWUgLSBub0RhdGFWYWx1ZVRvbGVyYW5jZTtcblxuICAgICAgICAvLyBDb21wdXRlIGNvb3JkcyBpbiBjYXNlIG9mIGN1cnNvciBwb3NpdGlvbiAoZGVza3RvcClcbiAgICAgICAgaWYgKGNvb3JkaW5hdGUgJiYgY29vcmRpbmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhbHRpdHVkZSBwYW5lbCwgZG9uJ3QgY2FsbCBhbHRpdHVkZSByZXF1ZXN0XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQWx0aXR1ZGVcIikpKSB7XG4gICAgICAgICAgICAgICAgYWx0aXR1ZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25SZXF1ZXN0QWx0aXR1ZGUoY29vcmRpbmF0ZSwgZnVuY3Rpb24gKHopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5UaHJlc2hvbGQgPCB6ICYmIHogPCBtYXhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkdQcmVzZXRFbGV2YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQWx0XCIpKS5pbm5lckhUTUwgPSB6O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBhbHRpdHVkZVRpbWVvdXREZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gcmVzZXRpbmcgYWx0aXR1ZGUgdmFsdWVcbiAgICAgKi9cbiAgICBHUHJlc2V0RWxldmF0aW9uIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1Btb3VzZVBvc2l0aW9uQWx0aXR1ZGVcIikpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG1vdXNlUG9zaXRpb25BbHRcIikpLmlubmVySFRNTCA9IFwiLS0tXCI7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVBvc2l0aW9uRE9NO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0NvbW1vbi9Db250cm9scy9Nb3VzZVBvc2l0aW9uRE9NLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n* implementation :\n* cf. http://uihacker.blogspot.fr/2011/07/javascript-formatting-latitudelongitude.html?m=1\n* cf. http://andrew.hedges.name/experiments/convert_lat_long/\n* FIXME formater la sortie\n* cf. http://mottie.github.io/javascript-number-formatter/\n* cf. https://github.com/j-/number-formatter\n*\n*/\n/** ... */\nvar PositionFormater = {\n\n    /** ... */\n    NORTH: \"N\",\n\n    /** ... */\n    SOUTH: \"S\",\n\n    /** ... */\n    EAST: \"E\",\n\n    /** ... */\n    WEST: \"W\",\n\n    /** ... */\n    digitSecond: 2,\n\n    /** ... */\n    digitDecimal: 5,\n\n    /** ... */\n    digitRadian: 8,\n\n    roundToDecimal: function roundToDecimal(inputNum, numPoints) {\n        var multiplier = Math.pow(10, numPoints);\n        return Math.round(inputNum * multiplier) / multiplier;\n    },\n\n    decimalToRadian: function decimalToRadian(location) {\n        var d = 0.01745329251994329577;\n        return this.roundToDecimal(location * d, this.digitRadian);\n    },\n\n    decimalToGrade: function decimalToGrade(location) {\n        var d = 1.11111111111111111111;\n        return this.roundToDecimal(location * d, this.digitRadian);\n    },\n\n    decimalToDMS: function decimalToDMS(location, hemisphere) {\n        if (location < 0) {\n            location *= -1; // strip dash '-'\n        }\n\n        var degrees = Math.floor(location); // strip decimal remainer for degrees\n        var minutesFromRemainder = (location - degrees) * 60; // multiply the remainer by 60\n        var minutes = Math.floor(minutesFromRemainder); // get minutes from integer\n        var secondsFromRemainder = (minutesFromRemainder - minutes) * 60; // multiply the remainer by 60\n        var seconds = this.roundToDecimal(secondsFromRemainder, this.digitSecond); // get minutes by rounding to integer\n\n        var dms = degrees + \"° \" + minutes + \"' \" + seconds + \"\\\" \";\n        if (hemisphere) {\n            dms += hemisphere;\n        }\n\n        return dms;\n    },\n\n    decimalLatToDMS: function decimalLatToDMS(location) {\n        var hemisphere = location < 0 ? this.SOUTH : this.NORTH; // south if negative\n        return this.decimalToDMS(location, hemisphere);\n    },\n\n    decimalLongToDMS: function decimalLongToDMS(location) {\n        var hemisphere = location < 0 ? this.WEST : this.EAST; // west if negative\n        return this.decimalToDMS(location, hemisphere);\n    },\n\n    DMSToDecimal: function DMSToDecimal(degrees, minutes, seconds, hemisphere) {\n        var ddVal = degrees + minutes / 60 + seconds / 3600;\n        ddVal = hemisphere === this.SOUTH || hemisphere === this.WEST ? ddVal * -1 : ddVal;\n\n        var decimal = this.roundToDecimal(ddVal, this.digitDecimal);\n        return decimal;\n    }\n\n};\n\nexports.default = PositionFormater;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL1V0aWxzL1Bvc2l0aW9uRm9ybWF0ZXIuanM/YWFjMiJdLCJuYW1lcyI6WyJQb3NpdGlvbkZvcm1hdGVyIiwiTk9SVEgiLCJTT1VUSCIsIkVBU1QiLCJXRVNUIiwiZGlnaXRTZWNvbmQiLCJkaWdpdERlY2ltYWwiLCJkaWdpdFJhZGlhbiIsInJvdW5kVG9EZWNpbWFsIiwiaW5wdXROdW0iLCJudW1Qb2ludHMiLCJtdWx0aXBsaWVyIiwiTWF0aCIsInBvdyIsInJvdW5kIiwiZGVjaW1hbFRvUmFkaWFuIiwibG9jYXRpb24iLCJkIiwiZGVjaW1hbFRvR3JhZGUiLCJkZWNpbWFsVG9ETVMiLCJoZW1pc3BoZXJlIiwiZGVncmVlcyIsImZsb29yIiwibWludXRlc0Zyb21SZW1haW5kZXIiLCJtaW51dGVzIiwic2Vjb25kc0Zyb21SZW1haW5kZXIiLCJzZWNvbmRzIiwiZG1zIiwiZGVjaW1hbExhdFRvRE1TIiwiZGVjaW1hbExvbmdUb0RNUyIsIkRNU1RvRGVjaW1hbCIsImRkVmFsIiwiZGVjaW1hbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7O0FBU0E7QUFDQSxJQUFJQSxtQkFBbUI7O0FBRW5CO0FBQ0FDLFdBQVEsR0FIVzs7QUFLbkI7QUFDQUMsV0FBUSxHQU5XOztBQVFuQjtBQUNBQyxVQUFPLEdBVFk7O0FBV25CO0FBQ0FDLFVBQU8sR0FaWTs7QUFjbkI7QUFDQUMsaUJBQWMsQ0FmSzs7QUFpQm5CO0FBQ0FDLGtCQUFlLENBbEJJOztBQW9CbkI7QUFDQUMsaUJBQWMsQ0FyQks7O0FBdUJuQkMsb0JBQWlCLHdCQUFVQyxRQUFWLEVBQW9CQyxTQUFwQixFQUErQjtBQUM1QyxZQUFJQyxhQUFhQyxLQUFLQyxHQUFMLENBQVMsRUFBVCxFQUFhSCxTQUFiLENBQWpCO0FBQ0EsZUFBT0UsS0FBS0UsS0FBTCxDQUFXTCxXQUFXRSxVQUF0QixJQUFvQ0EsVUFBM0M7QUFDSCxLQTFCa0I7O0FBNEJuQkkscUJBQWtCLHlCQUFVQyxRQUFWLEVBQW9CO0FBQ2xDLFlBQUlDLElBQUksc0JBQVI7QUFDQSxlQUFPLEtBQUtULGNBQUwsQ0FBb0JRLFdBQVdDLENBQS9CLEVBQWtDLEtBQUtWLFdBQXZDLENBQVA7QUFDSCxLQS9Ca0I7O0FBaUNuQlcsb0JBQWlCLHdCQUFVRixRQUFWLEVBQW9CO0FBQ2pDLFlBQUlDLElBQUksc0JBQVI7QUFDQSxlQUFPLEtBQUtULGNBQUwsQ0FBb0JRLFdBQVdDLENBQS9CLEVBQWtDLEtBQUtWLFdBQXZDLENBQVA7QUFDSCxLQXBDa0I7O0FBc0NuQlksa0JBQWUsc0JBQVVILFFBQVYsRUFBb0JJLFVBQXBCLEVBQWdDO0FBQzNDLFlBQUlKLFdBQVcsQ0FBZixFQUFrQjtBQUNkQSx3QkFBWSxDQUFDLENBQWIsQ0FEYyxDQUNFO0FBQ25COztBQUVELFlBQUlLLFVBQVVULEtBQUtVLEtBQUwsQ0FBV04sUUFBWCxDQUFkLENBTDJDLENBS1A7QUFDcEMsWUFBSU8sdUJBQXVCLENBQUNQLFdBQVdLLE9BQVosSUFBdUIsRUFBbEQsQ0FOMkMsQ0FNVztBQUN0RCxZQUFJRyxVQUFVWixLQUFLVSxLQUFMLENBQVdDLG9CQUFYLENBQWQsQ0FQMkMsQ0FPSztBQUNoRCxZQUFJRSx1QkFBdUIsQ0FBQ0YsdUJBQXVCQyxPQUF4QixJQUFtQyxFQUE5RCxDQVIyQyxDQVF1QjtBQUNsRSxZQUFJRSxVQUFVLEtBQUtsQixjQUFMLENBQW9CaUIsb0JBQXBCLEVBQTBDLEtBQUtwQixXQUEvQyxDQUFkLENBVDJDLENBU2dDOztBQUUzRSxZQUFJc0IsTUFBTU4sVUFBVSxJQUFWLEdBQWlCRyxPQUFqQixHQUEyQixJQUEzQixHQUFrQ0UsT0FBbEMsR0FBNEMsS0FBdEQ7QUFDQSxZQUFJTixVQUFKLEVBQWdCO0FBQ1pPLG1CQUFPUCxVQUFQO0FBQ0g7O0FBRUQsZUFBT08sR0FBUDtBQUNILEtBdkRrQjs7QUF5RG5CQyxxQkFBa0IseUJBQVVaLFFBQVYsRUFBb0I7QUFDbEMsWUFBSUksYUFBY0osV0FBVyxDQUFaLEdBQWlCLEtBQUtkLEtBQXRCLEdBQThCLEtBQUtELEtBQXBELENBRGtDLENBQ3lCO0FBQzNELGVBQU8sS0FBS2tCLFlBQUwsQ0FBa0JILFFBQWxCLEVBQTRCSSxVQUE1QixDQUFQO0FBQ0gsS0E1RGtCOztBQThEbkJTLHNCQUFtQiwwQkFBVWIsUUFBVixFQUFvQjtBQUNuQyxZQUFJSSxhQUFjSixXQUFXLENBQVosR0FBaUIsS0FBS1osSUFBdEIsR0FBNkIsS0FBS0QsSUFBbkQsQ0FEbUMsQ0FDc0I7QUFDekQsZUFBTyxLQUFLZ0IsWUFBTCxDQUFrQkgsUUFBbEIsRUFBNEJJLFVBQTVCLENBQVA7QUFDSCxLQWpFa0I7O0FBbUVuQlUsa0JBQWUsc0JBQVVULE9BQVYsRUFBbUJHLE9BQW5CLEVBQTRCRSxPQUE1QixFQUFxQ04sVUFBckMsRUFBaUQ7QUFDNUQsWUFBSVcsUUFBUVYsVUFBVUcsVUFBVSxFQUFwQixHQUF5QkUsVUFBVSxJQUEvQztBQUNBSyxnQkFBU1gsZUFBZSxLQUFLbEIsS0FBcEIsSUFBNkJrQixlQUFlLEtBQUtoQixJQUFsRCxHQUEwRDJCLFFBQVEsQ0FBQyxDQUFuRSxHQUF1RUEsS0FBL0U7O0FBRUEsWUFBSUMsVUFBVSxLQUFLeEIsY0FBTCxDQUFvQnVCLEtBQXBCLEVBQTJCLEtBQUt6QixZQUFoQyxDQUFkO0FBQ0EsZUFBTzBCLE9BQVA7QUFDSDs7QUF6RWtCLENBQXZCOztrQkE2RWVoQyxnQiIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBpbXBsZW1lbnRhdGlvbiA6XG4qIGNmLiBodHRwOi8vdWloYWNrZXIuYmxvZ3Nwb3QuZnIvMjAxMS8wNy9qYXZhc2NyaXB0LWZvcm1hdHRpbmctbGF0aXR1ZGVsb25naXR1ZGUuaHRtbD9tPTFcbiogY2YuIGh0dHA6Ly9hbmRyZXcuaGVkZ2VzLm5hbWUvZXhwZXJpbWVudHMvY29udmVydF9sYXRfbG9uZy9cbiogRklYTUUgZm9ybWF0ZXIgbGEgc29ydGllXG4qIGNmLiBodHRwOi8vbW90dGllLmdpdGh1Yi5pby9qYXZhc2NyaXB0LW51bWJlci1mb3JtYXR0ZXIvXG4qIGNmLiBodHRwczovL2dpdGh1Yi5jb20vai0vbnVtYmVyLWZvcm1hdHRlclxuKlxuKi9cbi8qKiAuLi4gKi9cbnZhciBQb3NpdGlvbkZvcm1hdGVyID0ge1xuXG4gICAgLyoqIC4uLiAqL1xuICAgIE5PUlRIIDogXCJOXCIsXG5cbiAgICAvKiogLi4uICovXG4gICAgU09VVEggOiBcIlNcIixcblxuICAgIC8qKiAuLi4gKi9cbiAgICBFQVNUIDogXCJFXCIsXG5cbiAgICAvKiogLi4uICovXG4gICAgV0VTVCA6IFwiV1wiLFxuXG4gICAgLyoqIC4uLiAqL1xuICAgIGRpZ2l0U2Vjb25kIDogMixcblxuICAgIC8qKiAuLi4gKi9cbiAgICBkaWdpdERlY2ltYWwgOiA1LFxuXG4gICAgLyoqIC4uLiAqL1xuICAgIGRpZ2l0UmFkaWFuIDogOCxcblxuICAgIHJvdW5kVG9EZWNpbWFsIDogZnVuY3Rpb24gKGlucHV0TnVtLCBudW1Qb2ludHMpIHtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgbnVtUG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoaW5wdXROdW0gKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgfSxcblxuICAgIGRlY2ltYWxUb1JhZGlhbiA6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgZCA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kVG9EZWNpbWFsKGxvY2F0aW9uICogZCwgdGhpcy5kaWdpdFJhZGlhbik7XG4gICAgfSxcblxuICAgIGRlY2ltYWxUb0dyYWRlIDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBkID0gMS4xMTExMTExMTExMTExMTExMTExMTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmRUb0RlY2ltYWwobG9jYXRpb24gKiBkLCB0aGlzLmRpZ2l0UmFkaWFuKTtcbiAgICB9LFxuXG4gICAgZGVjaW1hbFRvRE1TIDogZnVuY3Rpb24gKGxvY2F0aW9uLCBoZW1pc3BoZXJlKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGxvY2F0aW9uICo9IC0xOyAvLyBzdHJpcCBkYXNoICctJ1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZ3JlZXMgPSBNYXRoLmZsb29yKGxvY2F0aW9uKTsgLy8gc3RyaXAgZGVjaW1hbCByZW1haW5lciBmb3IgZGVncmVlc1xuICAgICAgICB2YXIgbWludXRlc0Zyb21SZW1haW5kZXIgPSAobG9jYXRpb24gLSBkZWdyZWVzKSAqIDYwOyAvLyBtdWx0aXBseSB0aGUgcmVtYWluZXIgYnkgNjBcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSBNYXRoLmZsb29yKG1pbnV0ZXNGcm9tUmVtYWluZGVyKTsgLy8gZ2V0IG1pbnV0ZXMgZnJvbSBpbnRlZ2VyXG4gICAgICAgIHZhciBzZWNvbmRzRnJvbVJlbWFpbmRlciA9IChtaW51dGVzRnJvbVJlbWFpbmRlciAtIG1pbnV0ZXMpICogNjA7IC8vIG11bHRpcGx5IHRoZSByZW1haW5lciBieSA2MFxuICAgICAgICB2YXIgc2Vjb25kcyA9IHRoaXMucm91bmRUb0RlY2ltYWwoc2Vjb25kc0Zyb21SZW1haW5kZXIsIHRoaXMuZGlnaXRTZWNvbmQpOyAvLyBnZXQgbWludXRlcyBieSByb3VuZGluZyB0byBpbnRlZ2VyXG5cbiAgICAgICAgdmFyIGRtcyA9IGRlZ3JlZXMgKyBcIsKwIFwiICsgbWludXRlcyArIFwiJyBcIiArIHNlY29uZHMgKyBcIlxcXCIgXCI7XG4gICAgICAgIGlmIChoZW1pc3BoZXJlKSB7XG4gICAgICAgICAgICBkbXMgKz0gaGVtaXNwaGVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkbXM7XG4gICAgfSxcblxuICAgIGRlY2ltYWxMYXRUb0RNUyA6IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICB2YXIgaGVtaXNwaGVyZSA9IChsb2NhdGlvbiA8IDApID8gdGhpcy5TT1VUSCA6IHRoaXMuTk9SVEg7IC8vIHNvdXRoIGlmIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxUb0RNUyhsb2NhdGlvbiwgaGVtaXNwaGVyZSk7XG4gICAgfSxcblxuICAgIGRlY2ltYWxMb25nVG9ETVMgOiBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgdmFyIGhlbWlzcGhlcmUgPSAobG9jYXRpb24gPCAwKSA/IHRoaXMuV0VTVCA6IHRoaXMuRUFTVDsgLy8gd2VzdCBpZiBuZWdhdGl2ZVxuICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsVG9ETVMobG9jYXRpb24sIGhlbWlzcGhlcmUpO1xuICAgIH0sXG5cbiAgICBETVNUb0RlY2ltYWwgOiBmdW5jdGlvbiAoZGVncmVlcywgbWludXRlcywgc2Vjb25kcywgaGVtaXNwaGVyZSkge1xuICAgICAgICB2YXIgZGRWYWwgPSBkZWdyZWVzICsgbWludXRlcyAvIDYwICsgc2Vjb25kcyAvIDM2MDA7XG4gICAgICAgIGRkVmFsID0gKGhlbWlzcGhlcmUgPT09IHRoaXMuU09VVEggfHwgaGVtaXNwaGVyZSA9PT0gdGhpcy5XRVNUKSA/IGRkVmFsICogLTEgOiBkZFZhbDtcblxuICAgICAgICB2YXIgZGVjaW1hbCA9IHRoaXMucm91bmRUb0RlY2ltYWwoZGRWYWwsIHRoaXMuZGlnaXREZWNpbWFsKTtcbiAgICAgICAgcmV0dXJuIGRlY2ltYWw7XG4gICAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQb3NpdGlvbkZvcm1hdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9Db250cm9scy9VdGlscy9Qb3NpdGlvbkZvcm1hdGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar CRS = {\n\n  /**\n   * CRS : WGS84\n   *\n   * @property EPSG:4326\n   * @private\n   */\n  \"EPSG:4326\": \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +units=degrees\",\n\n  /**\n   * CRS : PseudoMercator\n   *\n   * @property EPSG:3857\n   * @private\n   */\n  \"EPSG:3857\": \"+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs\",\n\n  /**\n   * CRS : Lambert 93\n   *\n   * @property EPSG:2154\n   * @private\n   */\n  \"EPSG:2154\": \"+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : Lambert 2 extended\n   *\n   * @property EPSG:27572\n   * @private\n   */\n  \"EPSG:27572\": \"+proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 20N (Guadeloupe, Martinique)\n   *\n   * @property EPSG:32620\n   * @private\n   */\n  \"EPSG:32620\": \"+proj=utm +zone=20 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 21N (Saint-Pierre-et-Miquelon)\n   *\n   * @property EPSG:4467\n   * @private\n   */\n  \"EPSG:4467\": \"+proj=utm +zone=21 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 22N (Guyane)\n   *\n   * @property EPSG:2972\n   * @private\n   */\n  \"EPSG:2972\": \"+proj=utm +zone=22 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 30N (France métropolitaine)\n   *\n   * @property EPSG:32630\n   * @private\n   */\n  \"EPSG:32630\": \"+proj=utm +zone=30 +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 31N (France métropolitaine)\n   *\n   * @property EPSG:32631\n   * @private\n   */\n  \"EPSG:32631\": \"+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 32N (France métropolitaine)\n   *\n   * @property EPSG:32632\n   * @private\n   */\n  \"EPSG:32632\": \"+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 38S (Mayotte)\n   *\n   * @property EPSG:4471\n   * @private\n   */\n  \"EPSG:4471\": \"+proj=utm +zone=38 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 40S (Réunion)\n   *\n   * @property EPSG:2975\n   * @private\n   */\n  \"EPSG:2975\": \"+proj=utm +zone=40 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 5S (Polynésie)\n   *\n   * @property EPSG:3296\n   * @private\n   */\n  \"EPSG:3296\": \"+proj=utm +zone=5 +south +ellps=GRS80 +towgs84=0.072,-0.507,-0.245,-0.0183,0.0003,-0.007,-0.0093 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 6S (Polynésie)\n   *\n   * @property EPSG:3297\n   * @private\n   */\n  \"EPSG:3297\": \"+proj=utm +zone=6 +south +ellps=GRS80 +towgs84=0.072,-0.507,-0.245,-0.0183,0.0003,-0.007,-0.0093 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 7S (Polynésie)\n   *\n   * @property EPSG:32707\n   * @private\n   */\n  \"EPSG:32707\": \"+proj=utm +zone=7 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 8S (Polynésie)\n   *\n   * @property EPSG:32708\n   * @private\n   */\n  \"EPSG:32708\": \"+proj=utm +zone=8 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 12N (Ile de Clipperton)\n   *\n   * @property EPSG:26912\n   * @private\n   */\n  \"EPSG:26912\": \"+proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 42S (Iles Kerguelen)\n   *\n   * @property EPSG:32742\n   * @private\n   */\n  \"EPSG:32742\": \"+proj=utm +zone=42 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 39S (Iles Crozet)\n   *\n   * @property EPSG:32739\n   * @private\n   */\n  \"EPSG:32739\": \"+proj=utm +zone=39 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 43S (Iles St-Paul et Amsterdam)\n   *\n   * @property EPSG:32743\n   * @private\n   */\n  \"EPSG:32743\": \"+proj=utm +zone=43 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : Stéréographique polaire (Terre Adelie)\n   *\n   * @property EPSG:2986\n   * @private\n   */\n  \"EPSG:2986\": \"\",\n\n  /**\n   * CRS : UTM 37S (Iles du canal de Mozambique)\n   *\n   * @property EPSG:32737\n   * @private\n   */\n  \"EPSG:32737\": \"+proj=utm +zone=37 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 38S (Iles du canal de Mozambique)\n   *\n   * @property EPSG:32738\n   * @private\n   */\n  \"EPSG:32738\": \"+proj=utm +zone=38 +south +datum=WGS84 +units=m +no_defs\",\n\n  /**\n   * CRS : UTM 1S (Wallis-et-Futuna)\n   *\n   * @property EPSG:2988\n   * @private\n   */\n  \"EPSG:2988\": \"+proj=utm +zone=1 +south +ellps=intl +towgs84=253,-132,-127,0,0,0,0 +units=m +no_defs\",\n\n  /**\n   * CRS : RGNC91-93 (Nouvelle-Calédonie)\n   *\n   * @property EPSG:3163\n   * @private\n   */\n  \"EPSG:3163\": \"+proj=lcc +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5 +lon_0=166 +x_0=400000 +y_0=300000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs\"\n};\n\nexports.default = CRS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NSUy9DUlMuanM/Y2ZmNCJdLCJuYW1lcyI6WyJDUlMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsTUFBTTs7QUFFTjs7Ozs7O0FBTUEsZUFBYywwRkFSUjs7QUFVTjs7Ozs7O0FBTUEsZUFBYywySEFoQlI7O0FBa0JOOzs7Ozs7QUFNQSxlQUFjLG1JQXhCUjs7QUEwQk47Ozs7OztBQU1BLGdCQUFlLHVLQWhDVDs7QUFrQ047Ozs7OztBQU1BLGdCQUFlLGdFQXhDVDs7QUEwQ047Ozs7OztBQU1BLGVBQWMsMEVBaERSOztBQWtETjs7Ozs7O0FBTUEsZUFBYywwRUF4RFI7O0FBMEROOzs7Ozs7QUFNQSxnQkFBZSxtREFoRVQ7O0FBa0VOOzs7Ozs7QUFNQSxnQkFBZSxtREF4RVQ7O0FBMEVOOzs7Ozs7QUFNQSxnQkFBZSxtREFoRlQ7O0FBa0ZOOzs7Ozs7QUFNQSxlQUFjLGlGQXhGUjs7QUEwRk47Ozs7OztBQU1BLGVBQWMsaUZBaEdSOztBQWtHTjs7Ozs7O0FBTUEsZUFBYyxvSEF4R1I7O0FBMEdOOzs7Ozs7QUFNQSxlQUFjLG9IQWhIUjs7QUFrSE47Ozs7OztBQU1BLGdCQUFlLHlEQXhIVDs7QUEwSE47Ozs7OztBQU1BLGdCQUFlLHlEQWhJVDs7QUFrSU47Ozs7OztBQU1BLGdCQUFlLDBFQXhJVDs7QUEwSU47Ozs7OztBQU1BLGdCQUFlLDBEQWhKVDs7QUFrSk47Ozs7OztBQU1BLGdCQUFlLDBEQXhKVDs7QUEwSk47Ozs7OztBQU1BLGdCQUFlLDBEQWhLVDs7QUFrS047Ozs7OztBQU1BLGVBQWMsRUF4S1I7O0FBMEtOOzs7Ozs7QUFNQSxnQkFBZSwwREFoTFQ7O0FBa0xOOzs7Ozs7QUFNQSxnQkFBZSwwREF4TFQ7O0FBMExOOzs7Ozs7QUFNQSxlQUFjLHVGQWhNUjs7QUFrTU47Ozs7OztBQU1BLGVBQWM7QUF4TVIsQ0FBVjs7a0JBMk1lQSxHIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIENSUyA9IHtcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFdHUzg0XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzo0MzI2XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6NDMyNlwiIDogXCIrdGl0bGU9V0dTIDg0IChsb25nL2xhdCkgK3Byb2o9bG9uZ2xhdCArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICtub19kZWZzICt1bml0cz1kZWdyZWVzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBQc2V1ZG9NZXJjYXRvclxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEVQU0c6Mzg1N1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjM4NTdcIiA6IFwiK3Byb2o9bWVyYyArYT02Mzc4MTM3ICtiPTYzNzgxMzcgK2xhdF90cz0wLjAgK2xvbl8wPTAuMCAreF8wPTAuMCAreV8wPTAgK2s9MS4wICt1bml0cz1tICtuYWRncmlkcz1AbnVsbCArd2t0ZXh0ICArbm9fZGVmc1wiLFxuXG4gICAgLyoqXG4gICAgICogQ1JTIDogTGFtYmVydCA5M1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IEVQU0c6MjE1NFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjIxNTRcIiA6IFwiK3Byb2o9bGNjICtsYXRfMT00OSArbGF0XzI9NDQgK2xhdF8wPTQ2LjUgK2xvbl8wPTMgK3hfMD03MDAwMDAgK3lfMD02NjAwMDAwICtlbGxwcz1HUlM4MCArdG93Z3M4ND0wLDAsMCwwLDAsMCwwICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBMYW1iZXJ0IDIgZXh0ZW5kZWRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjI3NTcyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6Mjc1NzJcIiA6IFwiK3Byb2o9bGNjICtsYXRfMT00Ni44ICtsYXRfMD00Ni44ICtsb25fMD0wICtrXzA9MC45OTk4Nzc0MiAreF8wPTYwMDAwMCAreV8wPTIyMDAwMDAgK2E9NjM3ODI0OS4yICtiPTYzNTY1MTUgK3Rvd2dzODQ9LTE2OCwtNjAsMzIwLDAsMCwwLDAgK3BtPXBhcmlzICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBVVE0gMjBOIChHdWFkZWxvdXBlLCBNYXJ0aW5pcXVlKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEVQU0c6MzI2MjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFwiRVBTRzozMjYyMFwiIDogXCIrcHJvaj11dG0gK3pvbmU9MjAgK2VsbHBzPVdHUzg0ICtkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmc1wiLFxuXG4gICAgLyoqXG4gICAgICogQ1JTIDogVVRNIDIxTiAoU2FpbnQtUGllcnJlLWV0LU1pcXVlbG9uKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEVQU0c6NDQ2N1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjQ0NjdcIiA6IFwiK3Byb2o9dXRtICt6b25lPTIxICtlbGxwcz1HUlM4MCArdG93Z3M4ND0wLDAsMCwwLDAsMCwwICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBVVE0gMjJOIChHdXlhbmUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzoyOTcyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6Mjk3MlwiIDogXCIrcHJvaj11dG0gK3pvbmU9MjIgK2VsbHBzPUdSUzgwICt0b3dnczg0PTAsMCwwLDAsMCwwLDAgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzME4gKEZyYW5jZSBtw6l0cm9wb2xpdGFpbmUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjYzMFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNjMwXCIgOiBcIitwcm9qPXV0bSArem9uZT0zMCArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzMU4gKEZyYW5jZSBtw6l0cm9wb2xpdGFpbmUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjYzMVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNjMxXCIgOiBcIitwcm9qPXV0bSArem9uZT0zMSArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzMk4gKEZyYW5jZSBtw6l0cm9wb2xpdGFpbmUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjYzMlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNjMyXCIgOiBcIitwcm9qPXV0bSArem9uZT0zMiArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzOFMgKE1heW90dGUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzo0NDcxXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6NDQ3MVwiIDogXCIrcHJvaj11dG0gK3pvbmU9MzggK3NvdXRoICtlbGxwcz1HUlM4MCArdG93Z3M4ND0wLDAsMCwwLDAsMCwwICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBVVE0gNDBTIChSw6l1bmlvbilcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjI5NzVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFwiRVBTRzoyOTc1XCIgOiBcIitwcm9qPXV0bSArem9uZT00MCArc291dGggK2VsbHBzPUdSUzgwICt0b3dnczg0PTAsMCwwLDAsMCwwLDAgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSA1UyAoUG9seW7DqXNpZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMyOTZcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFwiRVBTRzozMjk2XCIgOiBcIitwcm9qPXV0bSArem9uZT01ICtzb3V0aCArZWxscHM9R1JTODAgK3Rvd2dzODQ9MC4wNzIsLTAuNTA3LC0wLjI0NSwtMC4wMTgzLDAuMDAwMywtMC4wMDcsLTAuMDA5MyArdW5pdHM9bSArbm9fZGVmc1wiLFxuXG4gICAgLyoqXG4gICAgICogQ1JTIDogVVRNIDZTIChQb2x5bsOpc2llKVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IEVQU0c6MzI5N1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyOTdcIiA6IFwiK3Byb2o9dXRtICt6b25lPTYgK3NvdXRoICtlbGxwcz1HUlM4MCArdG93Z3M4ND0wLjA3MiwtMC41MDcsLTAuMjQ1LC0wLjAxODMsMC4wMDAzLC0wLjAwNywtMC4wMDkzICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBVVE0gN1MgKFBvbHluw6lzaWUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjcwN1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNzA3XCIgOiBcIitwcm9qPXV0bSArem9uZT03ICtzb3V0aCArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSA4UyAoUG9seW7DqXNpZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMyNzA4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6MzI3MDhcIiA6IFwiK3Byb2o9dXRtICt6b25lPTggK3NvdXRoICtkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmc1wiLFxuXG4gICAgLyoqXG4gICAgICogQ1JTIDogVVRNIDEyTiAoSWxlIGRlIENsaXBwZXJ0b24pXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzoyNjkxMlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjI2OTEyXCIgOiBcIitwcm9qPXV0bSArem9uZT0xMiArZWxscHM9R1JTODAgK3Rvd2dzODQ9MCwwLDAsMCwwLDAsMCArdW5pdHM9bSArbm9fZGVmc1wiLFxuXG4gICAgLyoqXG4gICAgICogQ1JTIDogVVRNIDQyUyAoSWxlcyBLZXJndWVsZW4pXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjc0MlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNzQyXCIgOiBcIitwcm9qPXV0bSArem9uZT00MiArc291dGggK2RhdHVtPVdHUzg0ICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBVVE0gMzlTIChJbGVzIENyb3pldClcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMyNzM5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6MzI3MzlcIiA6IFwiK3Byb2o9dXRtICt6b25lPTM5ICtzb3V0aCArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSA0M1MgKElsZXMgU3QtUGF1bCBldCBBbXN0ZXJkYW0pXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzozMjc0M1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgXCJFUFNHOjMyNzQzXCIgOiBcIitwcm9qPXV0bSArem9uZT00MyArc291dGggK2RhdHVtPVdHUzg0ICt1bml0cz1tICtub19kZWZzXCIsXG5cbiAgICAvKipcbiAgICAgKiBDUlMgOiBTdMOpcsOpb2dyYXBoaXF1ZSBwb2xhaXJlIChUZXJyZSBBZGVsaWUpXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgRVBTRzoyOTg2XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6Mjk4NlwiIDogXCJcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzN1MgKElsZXMgZHUgY2FuYWwgZGUgTW96YW1iaXF1ZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMyNzM3XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6MzI3MzdcIiA6IFwiK3Byb2o9dXRtICt6b25lPTM3ICtzb3V0aCArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAzOFMgKElsZXMgZHUgY2FuYWwgZGUgTW96YW1iaXF1ZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMyNzM4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBcIkVQU0c6MzI3MzhcIiA6IFwiK3Byb2o9dXRtICt6b25lPTM4ICtzb3V0aCArZGF0dW09V0dTODQgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFVUTSAxUyAoV2FsbGlzLWV0LUZ1dHVuYSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjI5ODhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFwiRVBTRzoyOTg4XCIgOiBcIitwcm9qPXV0bSArem9uZT0xICtzb3V0aCArZWxscHM9aW50bCArdG93Z3M4ND0yNTMsLTEzMiwtMTI3LDAsMCwwLDAgK3VuaXRzPW0gK25vX2RlZnNcIixcblxuICAgIC8qKlxuICAgICAqIENSUyA6IFJHTkM5MS05MyAoTm91dmVsbGUtQ2Fsw6lkb25pZSlcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBFUFNHOjMxNjNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFwiRVBTRzozMTYzXCIgOiBcIitwcm9qPWxjYyArbGF0XzE9LTIwLjY2NjY2NjY2NjY2NjY3ICtsYXRfMj0tMjIuMzMzMzMzMzMzMzMzMzMgK2xhdF8wPS0yMS41ICtsb25fMD0xNjYgK3hfMD00MDAwMDAgK3lfMD0zMDAwMDAgK2VsbHBzPUdSUzgwICt0b3dnczg0PTAsMCwwLDAsMCwwLDAgK3VuaXRzPW0gK25vX2RlZnNcIlxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ1JTO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9DUlMvQ1JTLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _SelectorID = __webpack_require__(3);\n\nvar _SelectorID2 = _interopRequireDefault(_SelectorID);\n\nvar _LayerSwitcherDOM = __webpack_require__(21);\n\nvar _LayerSwitcherDOM2 = _interopRequireDefault(_LayerSwitcherDOM);\n\nvar _Widget = __webpack_require__(4);\n\nvar _Widget2 = _interopRequireDefault(_Widget);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"LayerSwitcher\");\n\n/**\n * @classdesc\n * Control to manage globe layers : their order, visibility and opacity, and display their informations (title, description, legends, metadata...)\n *\n * @constructor\n * @extends {itowns.control.Widget}\n * @alias itowns.control.LayerSwitcher\n * @param {Object} lsOptions - control options\n * @param {Array} [lsOptions.layers] - list of layers to be configured. Each array element is an object, with following properties :\n * @param {String} [lsOptions.layers.id] - ol.layer.Layer layer to be configured (that has been added to globe)\n * @param {Object} [lsOptions.layers.config] - custom configuration object for layer information (title, description, legends, metadata, quicklook url), with following properties :\n * @param {String} [lsOptions.layers.config.title] - layer alias, to be displayed in widget layer list. E.g. : \"Cartes IGN\"\n * @param {String} [lsOptions.layers.config.description] - layer description, to be displayed on title hover, or in layer information panel.\n * @param {String} [lsOptions.layers.config.quicklookUrl] - link to a quick look image for this layer.\n * @param {Array} [lsOptions.layers.config.legends] - array of layer legends. Each array element is an object, with following properties :\n *      - url (String, mandatory) : link to a legend\n *      - minScaleDenominator (Number, optional) : min scale denominator for legend validity.\n * @param {Array} [lsOptions.layers.config.metadata] - array of layer metadata. Each array element is an object, with property url (String, mandatory) : link to a metadata\n * @param {Object} [lsOptions.options] - Itowns.control.Control options\n * @param {Boolean} [lsOptions.options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on globe loading.\n * @example\n * var layerSwitcher = new itowns.control.LayerSwitcher({\n *  layers : [\n *      {\n *          id : \"myLayer\",\n *          config : {\n *              title : \"test layer name 1\",\n *              description : \"test layer desc 1\",\n *          }\n *      }\n *  ],\n *  options : {\n *      collapsed : false\n *  }\n * ));\n */\nfunction LayerSwitcher(lsOptions) {\n    lsOptions = lsOptions || {};\n    var options = lsOptions.options || {};\n    var layers = lsOptions.layers || [];\n\n    if (!(this instanceof LayerSwitcher)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    if (layers && !Array.isArray(layers)) {\n        throw new Error(\"ERROR WRONG_TYPE : layers should be an array\");\n    }\n\n    if (options && (typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        throw new Error(\"ERROR WRONG_TYPE : options should be an object\");\n    }\n\n    this._initialize(options, layers);\n\n    var container = this._initContainer(options);\n    // property to save layers conf added after the LS is initialized\n    this._addedLayerConf = {};\n    var targetDiv = document.getElementById(options.target) || null;\n\n    _Widget2.default.call(this, {\n        name: \"LayerSwitcher\",\n        element: container,\n        target: targetDiv\n    });\n}\n\n/*\n * @lends module:LayerSwitcher\n */\nLayerSwitcher.prototype = Object.create(_Widget2.default.prototype, {});\n\n// retrieves methods of the common class LayerSwitcherDOM\n_Utils2.default.assign(LayerSwitcher.prototype, _LayerSwitcherDOM2.default);\n\n/**\n * Constructor (alias)\n *\n * @private\n */\nLayerSwitcher.prototype.constructor = LayerSwitcher;\n\n// ################################################################### //\n// ############## public methods (getters, setters) ################## //\n// ################################################################### //\n\n/**\n * Bind globe to control\n *\n * @param {GlobeViewExtended} globe - the globe\n */\nLayerSwitcher.prototype.setGlobe = function (globe) {\n    var layers;\n    if (globe) {\n        // in the case the control is added to the globe\n        var self = this;\n\n        // add options layers to layerlist.\n        // (only the layers configurated by the user in the options of the layerSwitcher )\n        // the other layers of the map will be added in the setGlobe method\n        for (var i = 0; i < this._initLayers.length; i++) {\n            // retrieves the layer...\n            var layer = null;\n\n            if (this._initLayers[i].id) {\n                layer = globe.getLayerById(this._initLayers[i].id);\n            }\n\n            if (layer && this._initLayers[i].displayed) {\n                // .. and the infos of the configuration if they exist (title, description, legends, quicklook, metadata)\n                var conf = this._initLayers[i].config || {};\n                var layerOptions = {\n                    title: conf.title || layer.title || this._initLayers[i].id,\n                    description: conf.description || null,\n                    legends: conf.legends || [],\n                    metadata: conf.metadata || [],\n                    quicklookUrl: conf.quicklookUrl || null\n                };\n                if (typeof conf.ipr !== \"undefined\") {\n                    layerOptions.ipr = conf.ipr;\n                }\n                if (typeof conf.opacity !== \"undefined\") {\n                    layerOptions.opacity = conf.opacity;\n                }\n                if (typeof conf.visibility !== \"undefined\") {\n                    layerOptions.visibility = conf.visibility;\n                }\n                this._layers[layer.id] = layerOptions;\n            }\n        }\n\n        // adds the layers\n        this._addGlobeLayers(globe);\n\n        // adding of listeners\n        this._callbacks.onOpacityLayerCallBack = function (e) {\n            self._updateLayerOpacity(e.target.id, e.new.opacity);\n        };\n\n        this._callbacks.onVisibilityLayerCallBack = function (e) {\n            self._updateLayerVisibility(e.target.id, e.new.visible);\n        };\n\n        // At every globe movement, layer switcher may be updated,\n        // according to layers on globe, and their range.\n        this._callbacks.onChangedViewCallBack = function (e) {\n            self._inRangeUpdate(e.colorLayersId);\n        };\n        globe.listen(_GlobeViewExtended2.default.EVENTS.PRE_RENDER, this._callbacks.onChangedViewCallBack);\n        // prerender events returns visible layers\n        globe.preRenderEventFetchColorLayersDisplayed();\n\n        this._callbacks.onAddedLayerCallBack = function (e) {\n            var id = e.layerId;\n            if (self) {\n                if (!self._layerDisplayedInLayerSwitcher(id)) {\n                    return;\n                }\n                var layer = self.getGlobe().getLayerById(id);\n                if (layer.type === \"elevation\") {\n                    return;\n                }\n                var layerConf = self._getLayerConf(id) || self._addedLayerConf[id];\n                if (layerConf) {\n                    self.addLayer(layer, layerConf);\n                } else {\n                    self.addLayer(layer);\n                }\n            }\n        };\n        globe.listen(_GlobeViewExtended2.default.EVENTS.LAYER_ADDED, this._callbacks.onAddedLayerCallBack);\n\n        this._callbacks.onRemovedLayerCallBack = function (e) {\n            var id = e.layerId;\n\n            // update the index max and delete the layer from the layerswitcher\n            if (self) {\n                self.removeLayer(id);\n            }\n        };\n        globe.listen(_GlobeViewExtended2.default.EVENTS.LAYER_REMOVED, this._callbacks.onRemovedLayerCallBack);\n\n        this._callbacks.onIndexLayerCallBack = function (e) {\n            var arraysEquals = function arraysEquals(a1, a2) {\n                if (a1.length !== a2.length) {\n                    return false;\n                }\n                for (var i = 0; i < a1.length; ++i) {\n                    if (a1[i] !== a2[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n\n            if (!arraysEquals(e.new.sequence, e.previous.sequence)) {\n                self._updateLayerListContainer();\n            }\n        };\n        globe.listen(_GlobeViewExtended2.default.EVENTS.LAYERS_ORDER_CHANGED, this._callbacks.onIndexLayerCallBack);\n\n        layers = globe.getColorLayers();\n        for (var ii = 0; ii < layers.length; ++ii) {\n            globe.addLayerListener(layers[ii], _GlobeViewExtended2.default.EVENTS.OPACITY_PROPERTY_CHANGED, this._callbacks.onOpacityLayerCallBack);\n            globe.addLayerListener(layers[ii], _GlobeViewExtended2.default.EVENTS.VISIBLE_PROPERTY_CHANGED, this._callbacks.onVisibilityLayerCallBack);\n            self._updateLayerVisibility(layers[ii].id, layers[ii].visible);\n            self._updateLayerOpacity(layers[ii].id, layers[ii].opacity);\n        }\n    } else {\n        // removes the listeners associated to the deleted layerswitcher\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.PRE_RENDER, this._callbacks.onChangedViewCallBack);\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.LAYER_ADDED, this._callbacks.onAddedLayerCallBack);\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.LAYER_REMOVED, this._callbacks.onRemovedLayerCallBack);\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.LAYERS_ORDER_CHANGED, this._callbacks.onIndexLayerCallBack);\n        layers = this._globe.getColorLayers();\n        for (var j = 0; j < layers.length; ++j) {\n            this._globe.removeLayerListener(layers[j], _GlobeViewExtended2.default.EVENTS.OPACITY_PROPERTY_CHANGED, this._callbacks.onOpacityLayerCallBack);\n            this._globe.removeLayerListener(layers[j], _GlobeViewExtended2.default.EVENTS.VISIBLE_PROPERTY_CHANGED, this._callbacks.onVisibilityLayerCallBack);\n        }\n        // deletes the layerSwitcher DOM\n        while (this._element.hasChildNodes()) {\n            this._element.removeChild(this._element.lastChild);\n        }\n        this._element.parentNode.removeChild(this._element);\n    }\n\n    // calls original setGlobe method\n    _Widget2.default.prototype.setGlobe.call(this, globe);\n};\n\n/**\n * Adds a new layer to control (when added to globe) or add new layer configuration\n *\n * @param {Object} layer - layer to add to layer switcher\n * @param {Object} [config] - additional options for layer configuration\n * @param {Object} [config.title] - layer title (default is layer identifier)\n * @param {Object} [config.description] - layer description (default is null)\n * @param {Object} [config.legends] - layer legends (default is an empty array)\n * @param {Object} [config.metadata] - layer metadata (default is an empty array)\n * @param {Object} [config.quicklookUrl] - layer quicklookUrl (default is null)\n * @example\n *   layerSwitcher.addLayer({\n *       layer : gpParcels,\n *       config : {\n *           title : \"Parcelles cadastrales\",\n *           description : \"description de la couche\",\n *           quicklookUrl : \"http://quicklookUrl.fr\"\n *       }\n *   })\n */\nLayerSwitcher.prototype.addLayer = function (layer, config) {\n    config = config || {};\n    var globe = this.getGlobe();\n\n    if (!layer) {\n        logger.error(\"LayerSwitcher:addLayer - missing layer parameter\");\n        return;\n    }\n\n    var id = layer.id;\n    if (id === \"undefined\") {\n        logger.error(\"LayerSwitcher:addLayer - configuration cannot be set for \" + layer + \" layer (layer id not found)\");\n        return;\n    }\n\n    // subscription to the events\n    globe.addLayerListener(layer, _GlobeViewExtended2.default.EVENTS.OPACITY_PROPERTY_CHANGED, this._callbacks.onOpacityLayerCallBack);\n    globe.addLayerListener(layer, _GlobeViewExtended2.default.EVENTS.VISIBLE_PROPERTY_CHANGED, this._callbacks.onVisibilityLayerCallBack);\n\n    // make sure layer is in globe layers\n    var LayerInGlobe = globe.getLayerById(id);\n\n    if (!LayerInGlobe) {\n        logger.error(\"LayerSwitcher:addLayer - configuration cannot be set for \", layer, \" layer (layer is not in globe layers )\");\n        return;\n    }\n\n    // if layer is not already in layers list, add it to control (layers list and container div)\n    if (!this._layers[id]) {\n        // 1. add layer to layers list\n        var layerInfos = this._getLayerInfo(layer) || {};\n        var layerOptions = {\n            title: config.title || layerInfos._title || id,\n            description: config.description || layerInfos._description || null,\n            legends: config.legends || layerInfos._legends || [],\n            metadata: config.metadata || layerInfos._metadata || [],\n            quicklookUrl: config.quicklookUrl || layerInfos._quicklookUrl || null\n        };\n        if (typeof config.ipr !== \"undefined\") {\n            layerOptions.ipr = config.ipr;\n            layer.attribution = layerOptions.ipr;\n        }\n        if (typeof config.opacity !== \"undefined\") {\n            layerOptions.opacity = config.opacity;\n            layer.opacity = layerOptions.opacity;\n        }\n        if (typeof config.visibility !== \"undefined\") {\n            layerOptions.visibility = config.visibility;\n            layer.visible = layerOptions.visibility;\n        }\n        this._layers[id] = layerOptions;\n\n        // creation of the div of the layer which will be added to the layerSwitcher\n        this._layers[id].div = this._createLayerDiv(id);\n\n        this._updateLayerListContainer();\n\n        // user may also add a new configuration for an already added layer\n    } else if (this._layers[id] && config) {\n        // add new configuration parameters to layer informations\n        for (var prop in config) {\n            if (config.hasOwnProperty(prop)) {\n                this._layers[id][prop] = config[prop];\n            }\n        }\n        if (typeof config.ipr !== \"undefined\") {\n            layer.attribution = config.ipr;\n        }\n        if (typeof config.opacity !== \"undefined\") {\n            layer.opacity = config.opacity;\n        }\n        if (typeof config.visibility !== \"undefined\") {\n            layer.visible = config.visibility;\n        }\n        // set new title in layer div\n        if (config.title) {\n            var nameDiv = document.getElementById(this._addUID(\"GPname_ID_\" + id));\n            if (nameDiv) {\n                nameDiv.innerHTML = config.title;\n                // FIXME a ajouter?\n                // nameDiv.title = config.description || config.title;\n            }\n        }\n        // add layer info picto if necessary\n        var infodiv = document.getElementById(this._addUID(\"GPinfo_ID_\" + id));\n        if (!document.getElementById(this._addUID(\"GPinfo_ID_\" + id)) && config.description && (config.legends || config.metadata || config.quicklookUrl)) {\n            var advancedTools = document.getElementById(this._addUID(\"GPadvancedTools_ID_\" + id));\n            if (advancedTools) {\n                advancedTools.appendChild(this._createAdvancedToolInformationElement({\n                    id: id\n                }));\n            }\n        }\n        // close layer info element if open, to update information.\n        if (infodiv && infodiv.className === \"GPlayerInfoOpened\") {\n            document.getElementById(this._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n            infodiv.className = \"GPlayerInfo\";\n        }\n    }\n};\n\n/**\n * Removes a layer from control\n *\n * @param {Object} layerId - layer to remove to layer switcher\n */\nLayerSwitcher.prototype.removeLayer = function (layerId) {\n    var layerList = document.getElementById(this._addUID(\"GPlayersList\"));\n    // close layer info element if open.\n    var infodiv = document.getElementById(this._addUID(\"GPinfo_ID_\" + layerId));\n    if (infodiv && infodiv.className === \"GPlayerInfoOpened\") {\n        document.getElementById(this._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n        infodiv.className = \"GPlayerInfo\";\n    }\n    // remove layer div\n    var layerDiv = document.getElementById(this._addUID(\"GPlayerSwitcher_ID_\" + layerId));\n    layerList.removeChild(layerDiv);\n\n    // removes layer of the layer list\n    delete this._layers[layerId];\n};\n\n/**\n * Collapse or display control main container\n *\n * @param {Boolean} collapsed - True to collapse control, False to display it\n */\nLayerSwitcher.prototype.setCollapsed = function (collapsed) {\n    if (collapsed === undefined) {\n        logger.error(\"LayerSwitcher:setCollapsed - missing collapsed parameter\");\n        return;\n    }\n    var isCollapsed = this.getCollapsed();\n    if (collapsed && isCollapsed || !collapsed && !isCollapsed) {\n        return;\n    }\n    // simulates the panel opening after a click\n    if (!isCollapsed) {\n        var layers = document.getElementsByClassName(\"GPlayerInfoOpened\");\n        for (var i = 0; i < layers.length; i++) {\n            layers[i].className = \"GPlayerInfo\";\n        }\n        document.getElementById(this._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n    }\n    document.getElementById(this._addUID(\"GPshowLayersList\")).checked = !collapsed;\n};\n\n/**\n * Returns true if widget is collapsed (minimize), false otherwise\n * @return {Boolean} is collapsed\n */\nLayerSwitcher.prototype.getCollapsed = function () {\n    return !document.getElementById(this._addUID(\"GPshowLayersList\")).checked;\n};\n\n// ################################################################### //\n// ##################### init component ############################## //\n// ################################################################### //\n\n/**\n * Initialize LayerSwitcher control (called by constructor)\n *\n * @param {Object} options - Itowns.control.Control options\n * @param {Array} layers - list of layers to be configured. Each array element is an object, with following properties :\n * @private\n */\nLayerSwitcher.prototype._initialize = function (options, layers) {\n    // id of the control ; used to suffix the CSS id (handles cases with severel controls on the same page)\n    this._uid = _SelectorID2.default.generate();\n\n    // {Object} control layers list. Each key is a layer id, and its value is an object of layers options (layer, id, opacity, visibility, title, description...)\n    this._layers = {};\n\n    // div which will contain the divs of the lists\n    this._layerListContainer = null;\n\n    // callbacks\n    this._callbacks = {};\n\n    // options\n    this._options = options;\n    this._initLayers = layers;\n};\n\n/**\n * Returns the layer configuration defined at widget initialization\n *\n * @method _getLayerConf\n * @param {String} layerId - layer id\n * @return {Object} layerConfig - layer configuration\n * @private\n */\nLayerSwitcher.prototype._getLayerConf = function (layerId) {\n    for (var i = 0; i < this._initLayers.length; ++i) {\n        if (this._initLayers[i].id === layerId) {\n            return this._initLayers[i].config;\n        }\n    }\n    return null;\n};\n\n/**\n * Indicates if the layer must be displayed in the layerSwitcher\n *\n * @method _layerDisplayedInLayerSwitcher\n * @param {String} layerId - layer id\n * @return {Boolean} displayed\n * @private\n */\nLayerSwitcher.prototype._layerDisplayedInLayerSwitcher = function (layerId) {\n    for (var i = 0; i < this._initLayers.length; ++i) {\n        if (this._initLayers[i].id === layerId) {\n            return typeof this._initLayers[i].displayed === \"undefined\" || this._initLayers[i].displayed;\n        }\n    }\n    return true;\n};\n\n/**\n * Creates control main container\n *\n * @method _initContainer\n * @param {Object} options - control options\n * @returns {DOMElement} container - widget container\n * @private\n */\nLayerSwitcher.prototype._initContainer = function (options) {\n    // creation of the main container\n    var container = this._createMainContainerElement();\n\n    // adding in the main container\n    var input = this._createMainLayersShowElement();\n    container.appendChild(input);\n\n    // handling of the \"collapsed\" mode\n    if (!options.collapsed) {\n        input.checked = \"checked\";\n    }\n    // adds the layer list in the main container\n    var divL = this._layerListContainer = this._createMainLayersElement();\n    container.appendChild(divL);\n\n    // creates the draggable mode\n    this._createDraggableElement(divL, this);\n\n    // adds the control picto in the main container\n    var picto = this._createMainPictoElement();\n    container.appendChild(picto);\n\n    // adds the info panel in the main container\n    var divI = this._createMainInfoElement();\n    container.appendChild(divI);\n\n    return container;\n};\n\n/**\n * Adds control layers to control main container\n *\n * @method _addGlobeLayers\n * @param {Object} globe - the Itowns.GlobeViewExtended object\n * @private\n */\nLayerSwitcher.prototype._addGlobeLayers = function (globe) {\n    // Retrieves the element which contains the different layers\n    var elementLayersList;\n    var childNodes = this.getElement().childNodes;\n\n    for (var i = 0; i < childNodes.length; i++) {\n        if (childNodes[i].id === this._addUID(\"GPlayersList\")) {\n            elementLayersList = childNodes[i];\n            break;\n        }\n    }\n    // reorders layers according to the layer stack (globe.getLayers returns an reverse ordenered array)\n    var layers = globe.getColorLayers();\n    var orderedLayers = layers.sort(function (a, b) {\n        return b.sequence - a.sequence;\n    });\n\n    // loop over all the layers of the map in order to add them to the control layer list (if they are not already added)\n    orderedLayers.forEach(function (layer) {\n        // adds the map layers to the list\n        var id;\n        id = layer.id;\n        if (!this._layerDisplayedInLayerSwitcher(id)) {\n            return;\n        }\n        var layerConf = this._getLayerConf(id) || this._addedLayerConf[id] || {};\n        var layerInfos = this._getLayerInfo(layer) || {};\n        if (!this._layers[id]) {\n            // if the layer is not yet in the layer list (this._layers), we add it\n            var layerOptions = {\n                title: layerConf.title || layerInfos._title || id,\n                description: layerConf.description || layerInfos._description || null,\n                legends: layerConf.legends || layerInfos._legends || [],\n                metadata: layerConf.metadata || layerInfos._metadata || [],\n                quicklookUrl: layerConf.quicklookUrl || layerInfos._quicklookUrl || null\n            };\n            this._layers[id] = layerOptions;\n        } else {\n            var lsLayerConf = this._layers[id];\n            if (typeof lsLayerConf.ipr !== \"undefined\") {\n                layer.options.attribution = lsLayerConf.ipr;\n            }\n            if (typeof lsLayerConf.opacity !== \"undefined\") {\n                layer.opacity = lsLayerConf.opacity;\n            }\n            if (typeof lsLayerConf.visibility !== \"undefined\") {\n                layer.visible = lsLayerConf.visibility;\n            }\n        }\n\n        var layerDiv = this._createLayerDiv(id);\n        this._layers[id].div = layerDiv;\n        elementLayersList.appendChild(layerDiv);\n    }, this);\n};\n\n/**\n * creates layer div (to append to control DOM element).\n *\n * @method _createLayerDiv\n * @param {String} layerId - layer id\n * @returns {DOMElement} layer div\n * @private\n */\nLayerSwitcher.prototype._createLayerDiv = function (layerId) {\n    var layerOptions = this._layers[layerId];\n    var isLegends = layerOptions.legends && layerOptions.legends.length !== 0;\n    var isMetadata = layerOptions.metadata && layerOptions.metadata.length !== 0;\n    var isQuicklookUrl = layerOptions.quicklookUrl;\n    if (isLegends || isMetadata || isQuicklookUrl) {\n        layerOptions.displayInformationElement = true;\n    }\n\n    // adds a specific div in the control for the layer\n    layerOptions.id = layerId;\n    var layerDiv = this._createContainerLayerElement(layerOptions);\n\n    if (!layerOptions.inRange) {\n        layerDiv.classList.add(\"outOfRange\");\n    }\n\n    return layerDiv;\n};\n\n// ################################################################### //\n// ######################### DOM events ############################## //\n// ################################################################### //\n\n/**\n * Changes layer opacity on layer opacity picto click\n *\n * @method _onChangeLayerOpacity\n * @param {Object} e - HTML event\n * @private\n */\nLayerSwitcher.prototype._onChangeLayerOpacity = function (e) {\n    var globe = this.getGlobe();\n    var layerID = this._resolveLayerId(e.target.id);\n\n    var opacityValue = e.target.value;\n    var opacityId = document.getElementById(this._addUID(\"GPopacityValue_ID_\" + layerID));\n    opacityId.innerHTML = opacityValue + \"%\";\n    globe.setLayerOpacity(layerID, opacityValue / 100);\n};\n\n/**\n * Updates picto opacity value on layer opacity change\n *\n * @method _updateLayerOpacity\n * @param {String} layerId - layer id\n * @param {Number} opacity - opacity value\n * @private\n */\nLayerSwitcher.prototype._updateLayerOpacity = function (layerId, opacity) {\n    if (opacity > 1) {\n        opacity = 1;\n    }\n    if (opacity < 0) {\n        opacity = 0;\n    }\n\n    var layerOpacityInput = document.getElementById(this._addUID(\"GPopacityValueDiv_ID_\" + layerId));\n    if (layerOpacityInput) {\n        layerOpacityInput.value = Math.round(opacity * 100);\n    }\n\n    var layerOpacitySpan = document.getElementById(this._addUID(\"GPopacityValue_ID_\" + layerId));\n    if (layerOpacitySpan) {\n        layerOpacitySpan.innerHTML = Math.round(opacity * 100) + \"%\";\n    }\n};\n\n/**\n * Changes layer visibility on layer visibility picto click\n *\n * @method _onVisibilityLayerClick\n * @param {Object} e - HTML event\n * @private\n */\nLayerSwitcher.prototype._onVisibilityLayerClick = function (e) {\n    var globe = this.getGlobe();\n\n    var layerID = this._resolveLayerId(e.target.id);\n    globe.setLayerVisibility(layerID, e.target.checked); // update viewer\n};\n\n/**\n * Changes picto visibility on layer visibility change\n *\n * @method _updateLayerVisibility\n * @param {String} layerId - layer id\n * @param {Boolean} visibility - visible if true\n * @private\n */\nLayerSwitcher.prototype._updateLayerVisibility = function (layerId, visibility) {\n    var layerVisibilityInput = document.getElementById(this._addUID(\"GPvisibility_ID_\" + layerId));\n    if (layerVisibilityInput) {\n        layerVisibilityInput.checked = visibility;\n    }\n};\n\n/**\n * Opens layer information panel on picto click\n *\n * @method _onOpenLayerInfoClick\n * @param {Event} e - MouseEvent\n * @private\n */\nLayerSwitcher.prototype._onOpenLayerInfoClick = function (e) {\n    var layerID = this._resolveLayerId(e.target.id);\n\n    var layerOptions = this._layers[layerID];\n\n    var panel;\n    var info;\n\n    // Close layer info panel\n    var divId = document.getElementById(e.target.id);\n    if (divId.className === \"GPlayerInfoOpened\") {\n        if (divId.classList !== undefined) {\n            divId.classList.remove(\"GPlayerInfoOpened\");\n            divId.classList.add(\"GPlayerInfo\");\n        }\n\n        panel = document.getElementById(this._addUID(\"GPlayerInfoPanel\"));\n        if (panel.classList !== undefined) {\n            panel.classList.remove(\"GPpanel\");\n            panel.classList.remove(\"GPlayerInfoPanelOpened\");\n            panel.classList.add(\"GPlayerInfoPanelClosed\");\n        }\n\n        info = document.getElementById(this._addUID(\"GPlayerInfoContent\"));\n        panel.removeChild(info);\n        return;\n    }\n\n    var layers = document.getElementsByClassName(\"GPlayerInfoOpened\");\n    for (var i = 0; i < layers.length; i++) {\n        layers[i].className = \"GPlayerInfo\";\n    }\n\n    // Open layer info panel\n    if (divId.classList !== undefined) {\n        divId.classList.remove(\"GPlayerInfo\");\n        divId.classList.add(\"GPlayerInfoOpened\");\n    }\n\n    panel = document.getElementById(this._addUID(\"GPlayerInfoPanel\"));\n    if (panel.classList !== undefined) {\n        panel.classList.add(\"GPpanel\");\n        panel.classList.remove(\"GPlayerInfoPanelClosed\");\n        panel.classList.add(\"GPlayerInfoPanelOpened\");\n    }\n\n    info = document.getElementById(this._addUID(\"GPlayerInfoContent\"));\n    if (info) {\n        panel.removeChild(info);\n    }\n\n    // on récupère les infos associées au layer pour mettre dynamiquement le contenu du panel d'informations\n    var obj = {\n        title: layerOptions.title,\n        description: layerOptions.description,\n        quicklookUrl: layerOptions.quicklookUrl,\n        metadata: layerOptions.metadata,\n        legends: layerOptions.legends\n    };\n\n    var infoLayer = this._createContainerLayerInfoElement(obj);\n    panel.appendChild(infoLayer);\n};\n\n/**\n * removes layer from layer switcher and globe on picto click\n *\n * @method _onDropLayerClick\n * @param {Event} e - MouseEvent\n * @private\n */\nLayerSwitcher.prototype._onDropLayerClick = function (e) {\n    var globe = this.getGlobe();\n\n    var layerID = this._resolveLayerId(e.target.id);\n    // removing the layer will trigger the event listener\n    // which will call this.removeLayer and delete the div\n    globe.removeLayer(layerID);\n\n    this._updateLayerListContainer();\n};\n\n/**\n * changes layers order on drag and drop\n *\n * @method _onDropLayerClick\n * @param {Event} e - HTML event\n * @private\n */\nLayerSwitcher.prototype._onDragAndDropLayerClick = function (e) {\n    var globe = this.getGlobe();\n\n    // Handling of the indexes : gives the little indexes (lowest layers) to the non-visible layers (displayed: false)\n    // when the index of a visible layer changes.\n    // Always moves the non-visible layers under the other layers (to not hide them)\n\n    if (e.newIndex - e.oldIndex === 0) {\n        return;\n    }\n\n    var targetIndex = null;\n    if (!e.newIndex || e.newIndex === 0) {\n        targetIndex = globe.getColorLayers().length - 1;\n    } else {\n        var layerTargetID = this._resolveLayerId(e.from.childNodes[e.newIndex + (e.newIndex - e.oldIndex < 0 ? 1 : -1)].id);\n        targetIndex = globe.getLayerById(layerTargetID).sequence;\n    }\n\n    var layerID = this._resolveLayerId(e.item.id);\n\n    globe.moveLayerToIndex(layerID, targetIndex);\n};\n\n/**\n * Checks layers range\n *\n * @method _inRangeUpdate\n * @param {Array} layersDisplayed - list of displayed layers id\n * @private\n */\nLayerSwitcher.prototype._inRangeUpdate = function (layersDisplayed) {\n    for (var layerKey in this._layers) {\n        var layer = this._layers[layerKey];\n        if (!layer) {\n            continue;\n        }\n        // Check if layer is displayed.\n        var layerDiv;\n        var bInRange = layersDisplayed.indexOf(layer.id) >= 0;\n        if (bInRange && !layer.inRange) {\n            layer.inRange = true;\n            layerDiv = document.getElementById(this._addUID(\"GPlayerSwitcher_ID_\" + layer.id));\n            layerDiv.classList.remove(\"outOfRange\");\n        } else if (!bInRange && layer.inRange) {\n            layer.inRange = false;\n            layerDiv = document.getElementById(this._addUID(\"GPlayerSwitcher_ID_\" + layer.id));\n            layerDiv.classList.add(\"outOfRange\");\n        }\n    }\n};\n\n/**\n * Update the layer list container\n *\n * @method _updateLayerListContainer\n * @private\n */\nLayerSwitcher.prototype._updateLayerListContainer = function () {\n    if (this._layerListContainer) {\n        var globe = this.getGlobe();\n\n        // empty the previous container\n        while (this._layerListContainer.firstChild) {\n            this._layerListContainer.removeChild(this._layerListContainer.firstChild);\n        }\n        // reorders layers according to the layer stack (globe.getLayers returns an reverse ordenered array)..\n        var layers = globe.getColorLayers();\n        var orderedLayers = layers.sort(function (a, b) {\n            return b.sequence - a.sequence;\n        });\n        // ... and adds the correct div to the different layers, in the zindex decreasing order\n        for (var j = 0; j < orderedLayers.length; j++) {\n            if (!this._layers[orderedLayers[j].id]) {\n                continue;\n            }\n            // retrieves the div of the layer, stored in the _layers array\n            var layerDiv = this._layers[orderedLayers[j].id].div;\n            this._layerListContainer.appendChild(layerDiv);\n        }\n    } else {\n        logger.error(\"[Itowns.control.LayerSwitcher] _updateLayerListContainer : layer list container not found to update layers order ?!\");\n    }\n};\n\n// ################################################################### //\n// ############################ Utils ################################ //\n// ################################################################### //\n\n/**\n * Gets layer informations : title, description, quicklookurl, legends, metadata\n *\n * @private\n * @memberof LayerSwitcher\n * @method _getLayerInfo\n * @param {Object} layer - the layer object\n * @returns {Object} layerInfo - layer informations\n */\nLayerSwitcher.prototype._getLayerInfo = function (layer) {\n    var layerInfo = {};\n    if (layer) {\n        layerInfo._title = layer.title || null;\n        layerInfo._description = layer.description || null;\n        layerInfo._quicklookUrl = layer.quicklookUrl || null;\n        layerInfo._metadata = layer.metadata || null;\n        layerInfo._legends = layer.legends || null;\n    }\n    return layerInfo;\n};\n\n/**\n * Gets layer id from div id\n *\n * @method _resolveLayerId\n * @param {String} divId - HTML div id\n * @returns {String} layer id\n * @private\n */\nLayerSwitcher.prototype._resolveLayerId = function (divId) {\n    var divName = _SelectorID2.default.name(divId); // ex GPvisibilityPicto_ID_26\n    return divName.substring(divName.indexOf(\"_ID_\") + 4); // ex. 26\n};\n\nexports.default = LayerSwitcher;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL0xheWVyU3dpdGNoZXIuanM/MTJmNiJdLCJuYW1lcyI6WyJsb2dnZXIiLCJMb2dnZXIiLCJnZXRMb2dnZXIiLCJMYXllclN3aXRjaGVyIiwibHNPcHRpb25zIiwib3B0aW9ucyIsImxheWVycyIsIlR5cGVFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiX2luaXRpYWxpemUiLCJjb250YWluZXIiLCJfaW5pdENvbnRhaW5lciIsIl9hZGRlZExheWVyQ29uZiIsInRhcmdldERpdiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0YXJnZXQiLCJXaWRnZXQiLCJjYWxsIiwibmFtZSIsImVsZW1lbnQiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJVdGlscyIsImFzc2lnbiIsIkxheWVyU3dpdGNoZXJET00iLCJjb25zdHJ1Y3RvciIsInNldEdsb2JlIiwiZ2xvYmUiLCJzZWxmIiwiaSIsIl9pbml0TGF5ZXJzIiwibGVuZ3RoIiwibGF5ZXIiLCJpZCIsImdldExheWVyQnlJZCIsImRpc3BsYXllZCIsImNvbmYiLCJjb25maWciLCJsYXllck9wdGlvbnMiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwibGVnZW5kcyIsIm1ldGFkYXRhIiwicXVpY2tsb29rVXJsIiwiaXByIiwib3BhY2l0eSIsInZpc2liaWxpdHkiLCJfbGF5ZXJzIiwiX2FkZEdsb2JlTGF5ZXJzIiwiX2NhbGxiYWNrcyIsIm9uT3BhY2l0eUxheWVyQ2FsbEJhY2siLCJlIiwiX3VwZGF0ZUxheWVyT3BhY2l0eSIsIm5ldyIsIm9uVmlzaWJpbGl0eUxheWVyQ2FsbEJhY2siLCJfdXBkYXRlTGF5ZXJWaXNpYmlsaXR5IiwidmlzaWJsZSIsIm9uQ2hhbmdlZFZpZXdDYWxsQmFjayIsIl9pblJhbmdlVXBkYXRlIiwiY29sb3JMYXllcnNJZCIsImxpc3RlbiIsIkdsb2JlVmlld0V4dGVuZGVkIiwiRVZFTlRTIiwiUFJFX1JFTkRFUiIsInByZVJlbmRlckV2ZW50RmV0Y2hDb2xvckxheWVyc0Rpc3BsYXllZCIsIm9uQWRkZWRMYXllckNhbGxCYWNrIiwibGF5ZXJJZCIsIl9sYXllckRpc3BsYXllZEluTGF5ZXJTd2l0Y2hlciIsImdldEdsb2JlIiwidHlwZSIsImxheWVyQ29uZiIsIl9nZXRMYXllckNvbmYiLCJhZGRMYXllciIsIkxBWUVSX0FEREVEIiwib25SZW1vdmVkTGF5ZXJDYWxsQmFjayIsInJlbW92ZUxheWVyIiwiTEFZRVJfUkVNT1ZFRCIsIm9uSW5kZXhMYXllckNhbGxCYWNrIiwiYXJyYXlzRXF1YWxzIiwiYTEiLCJhMiIsInNlcXVlbmNlIiwicHJldmlvdXMiLCJfdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyIiwiTEFZRVJTX09SREVSX0NIQU5HRUQiLCJnZXRDb2xvckxheWVycyIsImlpIiwiYWRkTGF5ZXJMaXN0ZW5lciIsIk9QQUNJVFlfUFJPUEVSVFlfQ0hBTkdFRCIsIlZJU0lCTEVfUFJPUEVSVFlfQ0hBTkdFRCIsIl9nbG9iZSIsImZvcmdldCIsImoiLCJyZW1vdmVMYXllckxpc3RlbmVyIiwiX2VsZW1lbnQiLCJoYXNDaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJsYXN0Q2hpbGQiLCJwYXJlbnROb2RlIiwiZXJyb3IiLCJMYXllckluR2xvYmUiLCJsYXllckluZm9zIiwiX2dldExheWVySW5mbyIsIl90aXRsZSIsIl9kZXNjcmlwdGlvbiIsIl9sZWdlbmRzIiwiX21ldGFkYXRhIiwiX3F1aWNrbG9va1VybCIsImF0dHJpYnV0aW9uIiwiZGl2IiwiX2NyZWF0ZUxheWVyRGl2IiwicHJvcCIsImhhc093blByb3BlcnR5IiwibmFtZURpdiIsIl9hZGRVSUQiLCJpbm5lckhUTUwiLCJpbmZvZGl2IiwiYWR2YW5jZWRUb29scyIsImFwcGVuZENoaWxkIiwiX2NyZWF0ZUFkdmFuY2VkVG9vbEluZm9ybWF0aW9uRWxlbWVudCIsImNsYXNzTmFtZSIsImxheWVyTGlzdCIsImxheWVyRGl2Iiwic2V0Q29sbGFwc2VkIiwiY29sbGFwc2VkIiwidW5kZWZpbmVkIiwiaXNDb2xsYXBzZWQiLCJnZXRDb2xsYXBzZWQiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiY2hlY2tlZCIsIl91aWQiLCJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJfbGF5ZXJMaXN0Q29udGFpbmVyIiwiX29wdGlvbnMiLCJfY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQiLCJpbnB1dCIsIl9jcmVhdGVNYWluTGF5ZXJzU2hvd0VsZW1lbnQiLCJkaXZMIiwiX2NyZWF0ZU1haW5MYXllcnNFbGVtZW50IiwiX2NyZWF0ZURyYWdnYWJsZUVsZW1lbnQiLCJwaWN0byIsIl9jcmVhdGVNYWluUGljdG9FbGVtZW50IiwiZGl2SSIsIl9jcmVhdGVNYWluSW5mb0VsZW1lbnQiLCJlbGVtZW50TGF5ZXJzTGlzdCIsImNoaWxkTm9kZXMiLCJnZXRFbGVtZW50Iiwib3JkZXJlZExheWVycyIsInNvcnQiLCJhIiwiYiIsImZvckVhY2giLCJsc0xheWVyQ29uZiIsImlzTGVnZW5kcyIsImlzTWV0YWRhdGEiLCJpc1F1aWNrbG9va1VybCIsImRpc3BsYXlJbmZvcm1hdGlvbkVsZW1lbnQiLCJfY3JlYXRlQ29udGFpbmVyTGF5ZXJFbGVtZW50IiwiaW5SYW5nZSIsImNsYXNzTGlzdCIsImFkZCIsIl9vbkNoYW5nZUxheWVyT3BhY2l0eSIsImxheWVySUQiLCJfcmVzb2x2ZUxheWVySWQiLCJvcGFjaXR5VmFsdWUiLCJ2YWx1ZSIsIm9wYWNpdHlJZCIsInNldExheWVyT3BhY2l0eSIsImxheWVyT3BhY2l0eUlucHV0IiwiTWF0aCIsInJvdW5kIiwibGF5ZXJPcGFjaXR5U3BhbiIsIl9vblZpc2liaWxpdHlMYXllckNsaWNrIiwic2V0TGF5ZXJWaXNpYmlsaXR5IiwibGF5ZXJWaXNpYmlsaXR5SW5wdXQiLCJfb25PcGVuTGF5ZXJJbmZvQ2xpY2siLCJwYW5lbCIsImluZm8iLCJkaXZJZCIsInJlbW92ZSIsIm9iaiIsImluZm9MYXllciIsIl9jcmVhdGVDb250YWluZXJMYXllckluZm9FbGVtZW50IiwiX29uRHJvcExheWVyQ2xpY2siLCJfb25EcmFnQW5kRHJvcExheWVyQ2xpY2siLCJuZXdJbmRleCIsIm9sZEluZGV4IiwidGFyZ2V0SW5kZXgiLCJsYXllclRhcmdldElEIiwiZnJvbSIsIml0ZW0iLCJtb3ZlTGF5ZXJUb0luZGV4IiwibGF5ZXJzRGlzcGxheWVkIiwibGF5ZXJLZXkiLCJiSW5SYW5nZSIsImluZGV4T2YiLCJmaXJzdENoaWxkIiwibGF5ZXJJbmZvIiwiZGl2TmFtZSIsInN1YnN0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUlBLFNBQVNDLDBCQUFPQyxTQUFQLENBQWlCLGVBQWpCLENBQWI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQSxTQUFTQyxhQUFULENBQXdCQyxTQUF4QixFQUFtQztBQUMvQkEsZ0JBQVlBLGFBQWEsRUFBekI7QUFDQSxRQUFJQyxVQUFVRCxVQUFVQyxPQUFWLElBQXFCLEVBQW5DO0FBQ0EsUUFBSUMsU0FBU0YsVUFBVUUsTUFBVixJQUFvQixFQUFqQzs7QUFFQSxRQUFJLEVBQUUsZ0JBQWdCSCxhQUFsQixDQUFKLEVBQXNDO0FBQ2xDLGNBQU0sSUFBSUksU0FBSixDQUFjLHlCQUFkLENBQU47QUFDSDs7QUFFRCxRQUFJRCxVQUFVLENBQUNFLE1BQU1DLE9BQU4sQ0FBY0gsTUFBZCxDQUFmLEVBQXNDO0FBQ2xDLGNBQU0sSUFBSUksS0FBSixDQUFVLDhDQUFWLENBQU47QUFDSDs7QUFFRCxRQUFJTCxXQUFXLFFBQU9BLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbEMsRUFBNEM7QUFDeEMsY0FBTSxJQUFJSyxLQUFKLENBQVUsZ0RBQVYsQ0FBTjtBQUNIOztBQUVELFNBQUtDLFdBQUwsQ0FBaUJOLE9BQWpCLEVBQTBCQyxNQUExQjs7QUFFQSxRQUFJTSxZQUFZLEtBQUtD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Q0FBcUNJLFFBQXJDO0FBQ0g7QUFDSixLQXJCRCxNQXFCTztBQUNIOUgsZUFBT3VHLEtBQVAsQ0FBYSxxSEFBYjtBQUNIO0FBQ0osQ0F6QkQ7O0FBMkJBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0FwRyxjQUFjb0IsU0FBZCxDQUF3Qm1GLGFBQXhCLEdBQXdDLFVBQVV0RSxLQUFWLEVBQWlCO0FBQ3JELFFBQUlzSyxZQUFZLEVBQWhCO0FBQ0EsUUFBSXRLLEtBQUosRUFBVztBQUNQc0ssa0JBQVUvRixNQUFWLEdBQW1CdkUsTUFBTU8sS0FBTixJQUFlLElBQWxDO0FBQ0ErSixrQkFBVTlGLFlBQVYsR0FBeUJ4RSxNQUFNUSxXQUFOLElBQXFCLElBQTlDO0FBQ0E4SixrQkFBVTNGLGFBQVYsR0FBMEIzRSxNQUFNVyxZQUFOLElBQXNCLElBQWhEO0FBQ0EySixrQkFBVTVGLFNBQVYsR0FBc0IxRSxNQUFNVSxRQUFOLElBQWtCLElBQXhDO0FBQ0E0SixrQkFBVTdGLFFBQVYsR0FBcUJ6RSxNQUFNUyxPQUFOLElBQWlCLElBQXRDO0FBQ0g7QUFDRCxXQUFPNkosU0FBUDtBQUNILENBVkQ7O0FBWUE7Ozs7Ozs7O0FBUUF2TSxjQUFjb0IsU0FBZCxDQUF3QmlKLGVBQXhCLEdBQTBDLFVBQVVlLEtBQVYsRUFBaUI7QUFDdkQsUUFBSW9CLFVBQVVwRSxxQkFBV2xILElBQVgsQ0FBZ0JrSyxLQUFoQixDQUFkLENBRHVELENBQ2pCO0FBQ3RDLFdBQU9vQixRQUFRQyxTQUFSLENBQWtCRCxRQUFRSCxPQUFSLENBQWdCLE1BQWhCLElBQTBCLENBQTVDLENBQVAsQ0FGdUQsQ0FFQTtBQUMxRCxDQUhEOztrQkFLZXJNLGEiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR2xvYmVWaWV3RXh0ZW5kZWQgZnJvbSBcIi4uL0dsb2JlVmlld0V4dGVuZGVkXCI7XG5pbXBvcnQgTG9nZ2VyIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHMvTG9nZ2VyQnlEZWZhdWx0XCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlsc1wiO1xuaW1wb3J0IFNlbGVjdG9ySUQgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9TZWxlY3RvcklEXCI7XG5pbXBvcnQgTGF5ZXJTd2l0Y2hlckRPTSBmcm9tIFwiLi4vLi4vQ29tbW9uL0NvbnRyb2xzL0xheWVyU3dpdGNoZXJET01cIjtcbmltcG9ydCBXaWRnZXQgZnJvbSBcIi4vV2lkZ2V0XCI7XG5cbnZhciBsb2dnZXIgPSBMb2dnZXIuZ2V0TG9nZ2VyKFwiTGF5ZXJTd2l0Y2hlclwiKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250cm9sIHRvIG1hbmFnZSBnbG9iZSBsYXllcnMgOiB0aGVpciBvcmRlciwgdmlzaWJpbGl0eSBhbmQgb3BhY2l0eSwgYW5kIGRpc3BsYXkgdGhlaXIgaW5mb3JtYXRpb25zICh0aXRsZSwgZGVzY3JpcHRpb24sIGxlZ2VuZHMsIG1ldGFkYXRhLi4uKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge2l0b3ducy5jb250cm9sLldpZGdldH1cbiAqIEBhbGlhcyBpdG93bnMuY29udHJvbC5MYXllclN3aXRjaGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbHNPcHRpb25zIC0gY29udHJvbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbbHNPcHRpb25zLmxheWVyc10gLSBsaXN0IG9mIGxheWVycyB0byBiZSBjb25maWd1cmVkLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW4gb2JqZWN0LCB3aXRoIGZvbGxvd2luZyBwcm9wZXJ0aWVzIDpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbHNPcHRpb25zLmxheWVycy5pZF0gLSBvbC5sYXllci5MYXllciBsYXllciB0byBiZSBjb25maWd1cmVkICh0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIGdsb2JlKVxuICogQHBhcmFtIHtPYmplY3R9IFtsc09wdGlvbnMubGF5ZXJzLmNvbmZpZ10gLSBjdXN0b20gY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGxheWVyIGluZm9ybWF0aW9uICh0aXRsZSwgZGVzY3JpcHRpb24sIGxlZ2VuZHMsIG1ldGFkYXRhLCBxdWlja2xvb2sgdXJsKSwgd2l0aCBmb2xsb3dpbmcgcHJvcGVydGllcyA6XG4gKiBAcGFyYW0ge1N0cmluZ30gW2xzT3B0aW9ucy5sYXllcnMuY29uZmlnLnRpdGxlXSAtIGxheWVyIGFsaWFzLCB0byBiZSBkaXNwbGF5ZWQgaW4gd2lkZ2V0IGxheWVyIGxpc3QuIEUuZy4gOiBcIkNhcnRlcyBJR05cIlxuICogQHBhcmFtIHtTdHJpbmd9IFtsc09wdGlvbnMubGF5ZXJzLmNvbmZpZy5kZXNjcmlwdGlvbl0gLSBsYXllciBkZXNjcmlwdGlvbiwgdG8gYmUgZGlzcGxheWVkIG9uIHRpdGxlIGhvdmVyLCBvciBpbiBsYXllciBpbmZvcm1hdGlvbiBwYW5lbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbHNPcHRpb25zLmxheWVycy5jb25maWcucXVpY2tsb29rVXJsXSAtIGxpbmsgdG8gYSBxdWljayBsb29rIGltYWdlIGZvciB0aGlzIGxheWVyLlxuICogQHBhcmFtIHtBcnJheX0gW2xzT3B0aW9ucy5sYXllcnMuY29uZmlnLmxlZ2VuZHNdIC0gYXJyYXkgb2YgbGF5ZXIgbGVnZW5kcy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuIG9iamVjdCwgd2l0aCBmb2xsb3dpbmcgcHJvcGVydGllcyA6XG4gKiAgICAgIC0gdXJsIChTdHJpbmcsIG1hbmRhdG9yeSkgOiBsaW5rIHRvIGEgbGVnZW5kXG4gKiAgICAgIC0gbWluU2NhbGVEZW5vbWluYXRvciAoTnVtYmVyLCBvcHRpb25hbCkgOiBtaW4gc2NhbGUgZGVub21pbmF0b3IgZm9yIGxlZ2VuZCB2YWxpZGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtsc09wdGlvbnMubGF5ZXJzLmNvbmZpZy5tZXRhZGF0YV0gLSBhcnJheSBvZiBsYXllciBtZXRhZGF0YS4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuIG9iamVjdCwgd2l0aCBwcm9wZXJ0eSB1cmwgKFN0cmluZywgbWFuZGF0b3J5KSA6IGxpbmsgdG8gYSBtZXRhZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IFtsc09wdGlvbnMub3B0aW9uc10gLSBJdG93bnMuY29udHJvbC5Db250cm9sIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xzT3B0aW9ucy5vcHRpb25zLmNvbGxhcHNlZCA9IHRydWVdIC0gU3BlY2lmeSBpZiB3aWRnZXQgaGFzIHRvIGJlIGNvbGxhcHNlZCAodHJ1ZSkgb3Igbm90IChmYWxzZSkgb24gZ2xvYmUgbG9hZGluZy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGF5ZXJTd2l0Y2hlciA9IG5ldyBpdG93bnMuY29udHJvbC5MYXllclN3aXRjaGVyKHtcbiAqICBsYXllcnMgOiBbXG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlkIDogXCJteUxheWVyXCIsXG4gKiAgICAgICAgICBjb25maWcgOiB7XG4gKiAgICAgICAgICAgICAgdGl0bGUgOiBcInRlc3QgbGF5ZXIgbmFtZSAxXCIsXG4gKiAgICAgICAgICAgICAgZGVzY3JpcHRpb24gOiBcInRlc3QgbGF5ZXIgZGVzYyAxXCIsXG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqICBdLFxuICogIG9wdGlvbnMgOiB7XG4gKiAgICAgIGNvbGxhcHNlZCA6IGZhbHNlXG4gKiAgfVxuICogKSk7XG4gKi9cbmZ1bmN0aW9uIExheWVyU3dpdGNoZXIgKGxzT3B0aW9ucykge1xuICAgIGxzT3B0aW9ucyA9IGxzT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGxzT3B0aW9ucy5vcHRpb25zIHx8IHt9O1xuICAgIHZhciBsYXllcnMgPSBsc09wdGlvbnMubGF5ZXJzIHx8IFtdO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExheWVyU3dpdGNoZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFUlJPUiBDTEFTU19DT05TVFJVQ1RPUlwiKTtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXJzICYmICFBcnJheS5pc0FycmF5KGxheWVycykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1IgV1JPTkdfVFlQRSA6IGxheWVycyBzaG91bGQgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1IgV1JPTkdfVFlQRSA6IG9wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKG9wdGlvbnMsIGxheWVycyk7XG5cbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5faW5pdENvbnRhaW5lcihvcHRpb25zKTtcbiAgICAvLyBwcm9wZXJ0eSB0byBzYXZlIGxheWVycyBjb25mIGFkZGVkIGFmdGVyIHRoZSBMUyBpcyBpbml0aWFsaXplZFxuICAgIHRoaXMuX2FkZGVkTGF5ZXJDb25mID0ge307XG4gICAgdmFyIHRhcmdldERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMudGFyZ2V0KSB8fCBudWxsO1xuXG4gICAgV2lkZ2V0LmNhbGwoXG4gICAgICAgIHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUgOiBcIkxheWVyU3dpdGNoZXJcIixcbiAgICAgICAgICAgIGVsZW1lbnQgOiBjb250YWluZXIsXG4gICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXREaXZcbiAgICAgICAgfVxuICAgICk7XG59XG5cbi8qXG4gKiBAbGVuZHMgbW9kdWxlOkxheWVyU3dpdGNoZXJcbiAqL1xuTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdpZGdldC5wcm90b3R5cGUsIHt9KTtcblxuLy8gcmV0cmlldmVzIG1ldGhvZHMgb2YgdGhlIGNvbW1vbiBjbGFzcyBMYXllclN3aXRjaGVyRE9NXG5VdGlscy5hc3NpZ24oTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUsIExheWVyU3dpdGNoZXJET00pO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIChhbGlhcylcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExheWVyU3dpdGNoZXI7XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzIChnZXR0ZXJzLCBzZXR0ZXJzKSAjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBCaW5kIGdsb2JlIHRvIGNvbnRyb2xcbiAqXG4gKiBAcGFyYW0ge0dsb2JlVmlld0V4dGVuZGVkfSBnbG9iZSAtIHRoZSBnbG9iZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5zZXRHbG9iZSA9IGZ1bmN0aW9uIChnbG9iZSkge1xuICAgIHZhciBsYXllcnM7XG4gICAgaWYgKGdsb2JlKSB7IC8vIGluIHRoZSBjYXNlIHRoZSBjb250cm9sIGlzIGFkZGVkIHRvIHRoZSBnbG9iZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gYWRkIG9wdGlvbnMgbGF5ZXJzIHRvIGxheWVybGlzdC5cbiAgICAgICAgLy8gKG9ubHkgdGhlIGxheWVycyBjb25maWd1cmF0ZWQgYnkgdGhlIHVzZXIgaW4gdGhlIG9wdGlvbnMgb2YgdGhlIGxheWVyU3dpdGNoZXIgKVxuICAgICAgICAvLyB0aGUgb3RoZXIgbGF5ZXJzIG9mIHRoZSBtYXAgd2lsbCBiZSBhZGRlZCBpbiB0aGUgc2V0R2xvYmUgbWV0aG9kXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5pdExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gcmV0cmlldmVzIHRoZSBsYXllci4uLlxuICAgICAgICAgICAgdmFyIGxheWVyID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRMYXllcnNbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICBsYXllciA9IGdsb2JlLmdldExheWVyQnlJZCh0aGlzLl9pbml0TGF5ZXJzW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxheWVyICYmIHRoaXMuX2luaXRMYXllcnNbaV0uZGlzcGxheWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4gYW5kIHRoZSBpbmZvcyBvZiB0aGUgY29uZmlndXJhdGlvbiBpZiB0aGV5IGV4aXN0ICh0aXRsZSwgZGVzY3JpcHRpb24sIGxlZ2VuZHMsIHF1aWNrbG9vaywgbWV0YWRhdGEpXG4gICAgICAgICAgICAgICAgdmFyIGNvbmYgPSB0aGlzLl9pbml0TGF5ZXJzW2ldLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA6IGNvbmYudGl0bGUgfHwgbGF5ZXIudGl0bGUgfHwgdGhpcy5faW5pdExheWVyc1tpXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gOiBjb25mLmRlc2NyaXB0aW9uIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZHMgOiBjb25mLmxlZ2VuZHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIDogY29uZi5tZXRhZGF0YSB8fCBbXSxcbiAgICAgICAgICAgICAgICAgICAgcXVpY2tsb29rVXJsIDogY29uZi5xdWlja2xvb2tVcmwgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25mLmlwciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBsYXllck9wdGlvbnMuaXByID0gY29uZi5pcHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZi5vcGFjaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyT3B0aW9ucy5vcGFjaXR5ID0gY29uZi5vcGFjaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmYudmlzaWJpbGl0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBsYXllck9wdGlvbnMudmlzaWJpbGl0eSA9IGNvbmYudmlzaWJpbGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZHMgdGhlIGxheWVyc1xuICAgICAgICB0aGlzLl9hZGRHbG9iZUxheWVycyhnbG9iZSk7XG5cbiAgICAgICAgLy8gYWRkaW5nIG9mIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25PcGFjaXR5TGF5ZXJDYWxsQmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVMYXllck9wYWNpdHkoZS50YXJnZXQuaWQsIGUubmV3Lm9wYWNpdHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vblZpc2liaWxpdHlMYXllckNhbGxCYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUxheWVyVmlzaWJpbGl0eShlLnRhcmdldC5pZCwgZS5uZXcudmlzaWJsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQXQgZXZlcnkgZ2xvYmUgbW92ZW1lbnQsIGxheWVyIHN3aXRjaGVyIG1heSBiZSB1cGRhdGVkLFxuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gbGF5ZXJzIG9uIGdsb2JlLCBhbmQgdGhlaXIgcmFuZ2UuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkNoYW5nZWRWaWV3Q2FsbEJhY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2VsZi5faW5SYW5nZVVwZGF0ZShlLmNvbG9yTGF5ZXJzSWQpO1xuICAgICAgICB9O1xuICAgICAgICBnbG9iZS5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLlBSRV9SRU5ERVIsIHRoaXMuX2NhbGxiYWNrcy5vbkNoYW5nZWRWaWV3Q2FsbEJhY2spO1xuICAgICAgICAvLyBwcmVyZW5kZXIgZXZlbnRzIHJldHVybnMgdmlzaWJsZSBsYXllcnNcbiAgICAgICAgZ2xvYmUucHJlUmVuZGVyRXZlbnRGZXRjaENvbG9yTGF5ZXJzRGlzcGxheWVkKCk7XG5cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQWRkZWRMYXllckNhbGxCYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGUubGF5ZXJJZDtcbiAgICAgICAgICAgIGlmIChzZWxmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9sYXllckRpc3BsYXllZEluTGF5ZXJTd2l0Y2hlcihpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBzZWxmLmdldEdsb2JlKCkuZ2V0TGF5ZXJCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gXCJlbGV2YXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSBzZWxmLl9nZXRMYXllckNvbmYoaWQpIHx8IHNlbGYuX2FkZGVkTGF5ZXJDb25mW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJDb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWRkTGF5ZXIobGF5ZXIsIGxheWVyQ29uZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRMYXllcihsYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBnbG9iZS5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkxBWUVSX0FEREVELCB0aGlzLl9jYWxsYmFja3Mub25BZGRlZExheWVyQ2FsbEJhY2spO1xuXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vblJlbW92ZWRMYXllckNhbGxCYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGUubGF5ZXJJZDtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBpbmRleCBtYXggYW5kIGRlbGV0ZSB0aGUgbGF5ZXIgZnJvbSB0aGUgbGF5ZXJzd2l0Y2hlclxuICAgICAgICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUxheWVyKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmUubGlzdGVuKEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5MQVlFUl9SRU1PVkVELCB0aGlzLl9jYWxsYmFja3Mub25SZW1vdmVkTGF5ZXJDYWxsQmFjayk7XG5cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uSW5kZXhMYXllckNhbGxCYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBhcnJheXNFcXVhbHMgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYTFbaV0gIT09IGEyW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoIWFycmF5c0VxdWFscyhlLm5ldy5zZXF1ZW5jZSwgZS5wcmV2aW91cy5zZXF1ZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVMYXllckxpc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmUubGlzdGVuKEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5MQVlFUlNfT1JERVJfQ0hBTkdFRCwgdGhpcy5fY2FsbGJhY2tzLm9uSW5kZXhMYXllckNhbGxCYWNrKTtcblxuICAgICAgICBsYXllcnMgPSBnbG9iZS5nZXRDb2xvckxheWVycygpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGF5ZXJzLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgICAgZ2xvYmUuYWRkTGF5ZXJMaXN0ZW5lcihsYXllcnNbaWldLCBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuT1BBQ0lUWV9QUk9QRVJUWV9DSEFOR0VELCB0aGlzLl9jYWxsYmFja3Mub25PcGFjaXR5TGF5ZXJDYWxsQmFjayk7XG4gICAgICAgICAgICBnbG9iZS5hZGRMYXllckxpc3RlbmVyKGxheWVyc1tpaV0sIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5WSVNJQkxFX1BST1BFUlRZX0NIQU5HRUQsIHRoaXMuX2NhbGxiYWNrcy5vblZpc2liaWxpdHlMYXllckNhbGxCYWNrKTtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUxheWVyVmlzaWJpbGl0eShsYXllcnNbaWldLmlkLCBsYXllcnNbaWldLnZpc2libGUpO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlTGF5ZXJPcGFjaXR5KGxheWVyc1tpaV0uaWQsIGxheWVyc1tpaV0ub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmVzIHRoZSBsaXN0ZW5lcnMgYXNzb2NpYXRlZCB0byB0aGUgZGVsZXRlZCBsYXllcnN3aXRjaGVyXG4gICAgICAgIHRoaXMuX2dsb2JlLmZvcmdldChHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuUFJFX1JFTkRFUiwgdGhpcy5fY2FsbGJhY2tzLm9uQ2hhbmdlZFZpZXdDYWxsQmFjayk7XG4gICAgICAgIHRoaXMuX2dsb2JlLmZvcmdldChHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTEFZRVJfQURERUQsIHRoaXMuX2NhbGxiYWNrcy5vbkFkZGVkTGF5ZXJDYWxsQmFjayk7XG4gICAgICAgIHRoaXMuX2dsb2JlLmZvcmdldChHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuTEFZRVJfUkVNT1ZFRCwgdGhpcy5fY2FsbGJhY2tzLm9uUmVtb3ZlZExheWVyQ2FsbEJhY2spO1xuICAgICAgICB0aGlzLl9nbG9iZS5mb3JnZXQoR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkxBWUVSU19PUkRFUl9DSEFOR0VELCB0aGlzLl9jYWxsYmFja3Mub25JbmRleExheWVyQ2FsbEJhY2spO1xuICAgICAgICBsYXllcnMgPSB0aGlzLl9nbG9iZS5nZXRDb2xvckxheWVycygpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVycy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmUucmVtb3ZlTGF5ZXJMaXN0ZW5lcihsYXllcnNbal0sIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5PUEFDSVRZX1BST1BFUlRZX0NIQU5HRUQsIHRoaXMuX2NhbGxiYWNrcy5vbk9wYWNpdHlMYXllckNhbGxCYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JlLnJlbW92ZUxheWVyTGlzdGVuZXIobGF5ZXJzW2pdLCBHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuVklTSUJMRV9QUk9QRVJUWV9DSEFOR0VELCB0aGlzLl9jYWxsYmFja3Mub25WaXNpYmlsaXR5TGF5ZXJDYWxsQmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVsZXRlcyB0aGUgbGF5ZXJTd2l0Y2hlciBET01cbiAgICAgICAgd2hpbGUgKHRoaXMuX2VsZW1lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gY2FsbHMgb3JpZ2luYWwgc2V0R2xvYmUgbWV0aG9kXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5zZXRHbG9iZS5jYWxsKHRoaXMsIGdsb2JlKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBsYXllciB0byBjb250cm9sICh3aGVuIGFkZGVkIHRvIGdsb2JlKSBvciBhZGQgbmV3IGxheWVyIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgLSBsYXllciB0byBhZGQgdG8gbGF5ZXIgc3dpdGNoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSAtIGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbGF5ZXIgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcudGl0bGVdIC0gbGF5ZXIgdGl0bGUgKGRlZmF1bHQgaXMgbGF5ZXIgaWRlbnRpZmllcilcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmRlc2NyaXB0aW9uXSAtIGxheWVyIGRlc2NyaXB0aW9uIChkZWZhdWx0IGlzIG51bGwpXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5sZWdlbmRzXSAtIGxheWVyIGxlZ2VuZHMgKGRlZmF1bHQgaXMgYW4gZW1wdHkgYXJyYXkpXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5tZXRhZGF0YV0gLSBsYXllciBtZXRhZGF0YSAoZGVmYXVsdCBpcyBhbiBlbXB0eSBhcnJheSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnF1aWNrbG9va1VybF0gLSBsYXllciBxdWlja2xvb2tVcmwgKGRlZmF1bHQgaXMgbnVsbClcbiAqIEBleGFtcGxlXG4gKiAgIGxheWVyU3dpdGNoZXIuYWRkTGF5ZXIoe1xuICogICAgICAgbGF5ZXIgOiBncFBhcmNlbHMsXG4gKiAgICAgICBjb25maWcgOiB7XG4gKiAgICAgICAgICAgdGl0bGUgOiBcIlBhcmNlbGxlcyBjYWRhc3RyYWxlc1wiLFxuICogICAgICAgICAgIGRlc2NyaXB0aW9uIDogXCJkZXNjcmlwdGlvbiBkZSBsYSBjb3VjaGVcIixcbiAqICAgICAgICAgICBxdWlja2xvb2tVcmwgOiBcImh0dHA6Ly9xdWlja2xvb2tVcmwuZnJcIlxuICogICAgICAgfVxuICogICB9KVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5hZGRMYXllciA9IGZ1bmN0aW9uIChsYXllciwgY29uZmlnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciBnbG9iZSA9IHRoaXMuZ2V0R2xvYmUoKTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTGF5ZXJTd2l0Y2hlcjphZGRMYXllciAtIG1pc3NpbmcgbGF5ZXIgcGFyYW1ldGVyXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkID0gbGF5ZXIuaWQ7XG4gICAgaWYgKGlkID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkxheWVyU3dpdGNoZXI6YWRkTGF5ZXIgLSBjb25maWd1cmF0aW9uIGNhbm5vdCBiZSBzZXQgZm9yIFwiICsgbGF5ZXIgKyBcIiBsYXllciAobGF5ZXIgaWQgbm90IGZvdW5kKVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN1YnNjcmlwdGlvbiB0byB0aGUgZXZlbnRzXG4gICAgZ2xvYmUuYWRkTGF5ZXJMaXN0ZW5lcihsYXllciwgR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLk9QQUNJVFlfUFJPUEVSVFlfQ0hBTkdFRCwgdGhpcy5fY2FsbGJhY2tzLm9uT3BhY2l0eUxheWVyQ2FsbEJhY2spO1xuICAgIGdsb2JlLmFkZExheWVyTGlzdGVuZXIobGF5ZXIsIEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5WSVNJQkxFX1BST1BFUlRZX0NIQU5HRUQsIHRoaXMuX2NhbGxiYWNrcy5vblZpc2liaWxpdHlMYXllckNhbGxCYWNrKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBsYXllciBpcyBpbiBnbG9iZSBsYXllcnNcbiAgICB2YXIgTGF5ZXJJbkdsb2JlID0gZ2xvYmUuZ2V0TGF5ZXJCeUlkKGlkKTtcblxuICAgIGlmICghTGF5ZXJJbkdsb2JlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkxheWVyU3dpdGNoZXI6YWRkTGF5ZXIgLSBjb25maWd1cmF0aW9uIGNhbm5vdCBiZSBzZXQgZm9yIFwiLCBsYXllciwgXCIgbGF5ZXIgKGxheWVyIGlzIG5vdCBpbiBnbG9iZSBsYXllcnMgKVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIGxheWVyIGlzIG5vdCBhbHJlYWR5IGluIGxheWVycyBsaXN0LCBhZGQgaXQgdG8gY29udHJvbCAobGF5ZXJzIGxpc3QgYW5kIGNvbnRhaW5lciBkaXYpXG4gICAgaWYgKCF0aGlzLl9sYXllcnNbaWRdKSB7XG4gICAgICAgIC8vIDEuIGFkZCBsYXllciB0byBsYXllcnMgbGlzdFxuICAgICAgICB2YXIgbGF5ZXJJbmZvcyA9IHRoaXMuX2dldExheWVySW5mbyhsYXllcikgfHwge307XG4gICAgICAgIHZhciBsYXllck9wdGlvbnMgPSB7XG4gICAgICAgICAgICB0aXRsZSA6IGNvbmZpZy50aXRsZSB8fCBsYXllckluZm9zLl90aXRsZSB8fCBpZCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uIDogY29uZmlnLmRlc2NyaXB0aW9uIHx8IGxheWVySW5mb3MuX2Rlc2NyaXB0aW9uIHx8IG51bGwsXG4gICAgICAgICAgICBsZWdlbmRzIDogY29uZmlnLmxlZ2VuZHMgfHwgbGF5ZXJJbmZvcy5fbGVnZW5kcyB8fCBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhIDogY29uZmlnLm1ldGFkYXRhIHx8IGxheWVySW5mb3MuX21ldGFkYXRhIHx8IFtdLFxuICAgICAgICAgICAgcXVpY2tsb29rVXJsIDogY29uZmlnLnF1aWNrbG9va1VybCB8fCBsYXllckluZm9zLl9xdWlja2xvb2tVcmwgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5pcHIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxheWVyT3B0aW9ucy5pcHIgPSBjb25maWcuaXByO1xuICAgICAgICAgICAgbGF5ZXIuYXR0cmlidXRpb24gPSBsYXllck9wdGlvbnMuaXByO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLm9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxheWVyT3B0aW9ucy5vcGFjaXR5ID0gY29uZmlnLm9wYWNpdHk7XG4gICAgICAgICAgICBsYXllci5vcGFjaXR5ID0gbGF5ZXJPcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudmlzaWJpbGl0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGF5ZXJPcHRpb25zLnZpc2liaWxpdHkgPSBjb25maWcudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIGxheWVyLnZpc2libGUgPSBsYXllck9wdGlvbnMudmlzaWJpbGl0eTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXJPcHRpb25zO1xuXG4gICAgICAgIC8vIGNyZWF0aW9uIG9mIHRoZSBkaXYgb2YgdGhlIGxheWVyIHdoaWNoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGxheWVyU3dpdGNoZXJcbiAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5kaXYgPSB0aGlzLl9jcmVhdGVMYXllckRpdihpZCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgLy8gdXNlciBtYXkgYWxzbyBhZGQgYSBuZXcgY29uZmlndXJhdGlvbiBmb3IgYW4gYWxyZWFkeSBhZGRlZCBsYXllclxuICAgIH0gZWxzZSBpZiAodGhpcy5fbGF5ZXJzW2lkXSAmJiBjb25maWcpIHtcbiAgICAgICAgLy8gYWRkIG5ldyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gbGF5ZXIgaW5mb3JtYXRpb25zXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXVtwcm9wXSA9IGNvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5pcHIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxheWVyLmF0dHJpYnV0aW9uID0gY29uZmlnLmlwcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5vcGFjaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsYXllci5vcGFjaXR5ID0gY29uZmlnLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudmlzaWJpbGl0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGF5ZXIudmlzaWJsZSA9IGNvbmZpZy52aXNpYmlsaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBuZXcgdGl0bGUgaW4gbGF5ZXIgZGl2XG4gICAgICAgIGlmIChjb25maWcudGl0bGUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BuYW1lX0lEX1wiICsgaWQpKTtcbiAgICAgICAgICAgIGlmIChuYW1lRGl2KSB7XG4gICAgICAgICAgICAgICAgbmFtZURpdi5pbm5lckhUTUwgPSBjb25maWcudGl0bGU7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgYSBham91dGVyP1xuICAgICAgICAgICAgICAgIC8vIG5hbWVEaXYudGl0bGUgPSBjb25maWcuZGVzY3JpcHRpb24gfHwgY29uZmlnLnRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBsYXllciBpbmZvIHBpY3RvIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgaW5mb2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQaW5mb19JRF9cIiArIGlkKSk7XG4gICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BpbmZvX0lEX1wiICsgaWQpKSAmJiBjb25maWcuZGVzY3JpcHRpb24gJiYgKGNvbmZpZy5sZWdlbmRzIHx8IGNvbmZpZy5tZXRhZGF0YSB8fCBjb25maWcucXVpY2tsb29rVXJsKSkge1xuICAgICAgICAgICAgdmFyIGFkdmFuY2VkVG9vbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUGFkdmFuY2VkVG9vbHNfSURfXCIgKyBpZCkpO1xuICAgICAgICAgICAgaWYgKGFkdmFuY2VkVG9vbHMpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlZFRvb2xzLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBZHZhbmNlZFRvb2xJbmZvcm1hdGlvbkVsZW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xvc2UgbGF5ZXIgaW5mbyBlbGVtZW50IGlmIG9wZW4sIHRvIHVwZGF0ZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgaWYgKGluZm9kaXYgJiYgaW5mb2Rpdi5jbGFzc05hbWUgPT09IFwiR1BsYXllckluZm9PcGVuZWRcIikge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BsYXllckluZm9QYW5lbFwiKSkuY2xhc3NOYW1lID0gXCJHUGxheWVySW5mb1BhbmVsQ2xvc2VkXCI7XG4gICAgICAgICAgICBpbmZvZGl2LmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9cIjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGxheWVyIGZyb20gY29udHJvbFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllcklkIC0gbGF5ZXIgdG8gcmVtb3ZlIHRvIGxheWVyIHN3aXRjaGVyXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKGxheWVySWQpIHtcbiAgICB2YXIgbGF5ZXJMaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BsYXllcnNMaXN0XCIpKTtcbiAgICAvLyBjbG9zZSBsYXllciBpbmZvIGVsZW1lbnQgaWYgb3Blbi5cbiAgICB2YXIgaW5mb2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQaW5mb19JRF9cIiArIGxheWVySWQpKTtcbiAgICBpZiAoaW5mb2RpdiAmJiBpbmZvZGl2LmNsYXNzTmFtZSA9PT0gXCJHUGxheWVySW5mb09wZW5lZFwiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJJbmZvUGFuZWxcIikpLmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9QYW5lbENsb3NlZFwiO1xuICAgICAgICBpbmZvZGl2LmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9cIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGxheWVyIGRpdlxuICAgIHZhciBsYXllckRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJTd2l0Y2hlcl9JRF9cIiArIGxheWVySWQpKTtcbiAgICBsYXllckxpc3QucmVtb3ZlQ2hpbGQobGF5ZXJEaXYpO1xuXG4gICAgLy8gcmVtb3ZlcyBsYXllciBvZiB0aGUgbGF5ZXIgbGlzdFxuICAgIGRlbGV0ZSB0aGlzLl9sYXllcnNbbGF5ZXJJZF07XG59O1xuXG4vKipcbiAqIENvbGxhcHNlIG9yIGRpc3BsYXkgY29udHJvbCBtYWluIGNvbnRhaW5lclxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sbGFwc2VkIC0gVHJ1ZSB0byBjb2xsYXBzZSBjb250cm9sLCBGYWxzZSB0byBkaXNwbGF5IGl0XG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLnNldENvbGxhcHNlZCA9IGZ1bmN0aW9uIChjb2xsYXBzZWQpIHtcbiAgICBpZiAoY29sbGFwc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiTGF5ZXJTd2l0Y2hlcjpzZXRDb2xsYXBzZWQgLSBtaXNzaW5nIGNvbGxhcHNlZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzQ29sbGFwc2VkID0gdGhpcy5nZXRDb2xsYXBzZWQoKTtcbiAgICBpZiAoKGNvbGxhcHNlZCAmJiBpc0NvbGxhcHNlZCkgfHwgKCFjb2xsYXBzZWQgJiYgIWlzQ29sbGFwc2VkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNpbXVsYXRlcyB0aGUgcGFuZWwgb3BlbmluZyBhZnRlciBhIGNsaWNrXG4gICAgaWYgKCFpc0NvbGxhcHNlZCkge1xuICAgICAgICB2YXIgbGF5ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGF5ZXJzW2ldLmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9cIjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb1BhbmVsXCIpKS5jbGFzc05hbWUgPSBcIkdQbGF5ZXJJbmZvUGFuZWxDbG9zZWRcIjtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BzaG93TGF5ZXJzTGlzdFwiKSkuY2hlY2tlZCA9ICFjb2xsYXBzZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3aWRnZXQgaXMgY29sbGFwc2VkIChtaW5pbWl6ZSksIGZhbHNlIG90aGVyd2lzZVxuICogQHJldHVybiB7Qm9vbGVhbn0gaXMgY29sbGFwc2VkXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLmdldENvbGxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQc2hvd0xheWVyc0xpc3RcIikpLmNoZWNrZWQ7XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCBjb21wb25lbnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBMYXllclN3aXRjaGVyIGNvbnRyb2wgKGNhbGxlZCBieSBjb25zdHJ1Y3RvcilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEl0b3ducy5jb250cm9sLkNvbnRyb2wgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIC0gbGlzdCBvZiBsYXllcnMgdG8gYmUgY29uZmlndXJlZC4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuIG9iamVjdCwgd2l0aCBmb2xsb3dpbmcgcHJvcGVydGllcyA6XG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBsYXllcnMpIHtcbiAgICAvLyBpZCBvZiB0aGUgY29udHJvbCA7IHVzZWQgdG8gc3VmZml4IHRoZSBDU1MgaWQgKGhhbmRsZXMgY2FzZXMgd2l0aCBzZXZlcmVsIGNvbnRyb2xzIG9uIHRoZSBzYW1lIHBhZ2UpXG4gICAgdGhpcy5fdWlkID0gU2VsZWN0b3JJRC5nZW5lcmF0ZSgpO1xuXG4gICAgLy8ge09iamVjdH0gY29udHJvbCBsYXllcnMgbGlzdC4gRWFjaCBrZXkgaXMgYSBsYXllciBpZCwgYW5kIGl0cyB2YWx1ZSBpcyBhbiBvYmplY3Qgb2YgbGF5ZXJzIG9wdGlvbnMgKGxheWVyLCBpZCwgb3BhY2l0eSwgdmlzaWJpbGl0eSwgdGl0bGUsIGRlc2NyaXB0aW9uLi4uKVxuICAgIHRoaXMuX2xheWVycyA9IHt9O1xuXG4gICAgLy8gZGl2IHdoaWNoIHdpbGwgY29udGFpbiB0aGUgZGl2cyBvZiB0aGUgbGlzdHNcbiAgICB0aGlzLl9sYXllckxpc3RDb250YWluZXIgPSBudWxsO1xuXG4gICAgLy8gY2FsbGJhY2tzXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG5cbiAgICAvLyBvcHRpb25zXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5faW5pdExheWVycyA9IGxheWVycztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGF5ZXIgY29uZmlndXJhdGlvbiBkZWZpbmVkIGF0IHdpZGdldCBpbml0aWFsaXphdGlvblxuICpcbiAqIEBtZXRob2QgX2dldExheWVyQ29uZlxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBsYXllciBpZFxuICogQHJldHVybiB7T2JqZWN0fSBsYXllckNvbmZpZyAtIGxheWVyIGNvbmZpZ3VyYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLl9nZXRMYXllckNvbmYgPSBmdW5jdGlvbiAobGF5ZXJJZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5pdExheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5faW5pdExheWVyc1tpXS5pZCA9PT0gbGF5ZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRMYXllcnNbaV0uY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgdGhlIGxheWVyIG11c3QgYmUgZGlzcGxheWVkIGluIHRoZSBsYXllclN3aXRjaGVyXG4gKlxuICogQG1ldGhvZCBfbGF5ZXJEaXNwbGF5ZWRJbkxheWVyU3dpdGNoZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGRpc3BsYXllZFxuICogQHByaXZhdGVcbiAqL1xuTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUuX2xheWVyRGlzcGxheWVkSW5MYXllclN3aXRjaGVyID0gZnVuY3Rpb24gKGxheWVySWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2luaXRMYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRMYXllcnNbaV0uaWQgPT09IGxheWVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMuX2luaXRMYXllcnNbaV0uZGlzcGxheWVkID09PSBcInVuZGVmaW5lZFwiIHx8IHRoaXMuX2luaXRMYXllcnNbaV0uZGlzcGxheWVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBjb250cm9sIG1haW4gY29udGFpbmVyXG4gKlxuICogQG1ldGhvZCBfaW5pdENvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb250cm9sIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXIgLSB3aWRnZXQgY29udGFpbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5faW5pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gY3JlYXRpb24gb2YgdGhlIG1haW4gY29udGFpbmVyXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50KCk7XG5cbiAgICAvLyBhZGRpbmcgaW4gdGhlIG1haW4gY29udGFpbmVyXG4gICAgdmFyIGlucHV0ID0gdGhpcy5fY3JlYXRlTWFpbkxheWVyc1Nob3dFbGVtZW50KCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgIC8vIGhhbmRsaW5nIG9mIHRoZSBcImNvbGxhcHNlZFwiIG1vZGVcbiAgICBpZiAoIW9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBcImNoZWNrZWRcIjtcbiAgICB9XG4gICAgLy8gYWRkcyB0aGUgbGF5ZXIgbGlzdCBpbiB0aGUgbWFpbiBjb250YWluZXJcbiAgICB2YXIgZGl2TCA9IHRoaXMuX2xheWVyTGlzdENvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZU1haW5MYXllcnNFbGVtZW50KCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdkwpO1xuXG4gICAgLy8gY3JlYXRlcyB0aGUgZHJhZ2dhYmxlIG1vZGVcbiAgICB0aGlzLl9jcmVhdGVEcmFnZ2FibGVFbGVtZW50KGRpdkwsIHRoaXMpO1xuXG4gICAgLy8gYWRkcyB0aGUgY29udHJvbCBwaWN0byBpbiB0aGUgbWFpbiBjb250YWluZXJcbiAgICB2YXIgcGljdG8gPSB0aGlzLl9jcmVhdGVNYWluUGljdG9FbGVtZW50KCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBpY3RvKTtcblxuICAgIC8vIGFkZHMgdGhlIGluZm8gcGFuZWwgaW4gdGhlIG1haW4gY29udGFpbmVyXG4gICAgdmFyIGRpdkkgPSB0aGlzLl9jcmVhdGVNYWluSW5mb0VsZW1lbnQoKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2SSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuLyoqXG4gKiBBZGRzIGNvbnRyb2wgbGF5ZXJzIHRvIGNvbnRyb2wgbWFpbiBjb250YWluZXJcbiAqXG4gKiBAbWV0aG9kIF9hZGRHbG9iZUxheWVyc1xuICogQHBhcmFtIHtPYmplY3R9IGdsb2JlIC0gdGhlIEl0b3ducy5HbG9iZVZpZXdFeHRlbmRlZCBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLl9hZGRHbG9iZUxheWVycyA9IGZ1bmN0aW9uIChnbG9iZSkge1xuICAgIC8vIFJldHJpZXZlcyB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgZGlmZmVyZW50IGxheWVyc1xuICAgIHZhciBlbGVtZW50TGF5ZXJzTGlzdDtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuZ2V0RWxlbWVudCgpLmNoaWxkTm9kZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0uaWQgPT09IHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJzTGlzdFwiKSkge1xuICAgICAgICAgICAgZWxlbWVudExheWVyc0xpc3QgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVvcmRlcnMgbGF5ZXJzIGFjY29yZGluZyB0byB0aGUgbGF5ZXIgc3RhY2sgKGdsb2JlLmdldExheWVycyByZXR1cm5zIGFuIHJldmVyc2Ugb3JkZW5lcmVkIGFycmF5KVxuICAgIHZhciBsYXllcnMgPSBnbG9iZS5nZXRDb2xvckxheWVycygpO1xuICAgIHZhciBvcmRlcmVkTGF5ZXJzID0gbGF5ZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuc2VxdWVuY2UgLSBhLnNlcXVlbmNlO1xuICAgIH0pO1xuXG4gICAgLy8gbG9vcCBvdmVyIGFsbCB0aGUgbGF5ZXJzIG9mIHRoZSBtYXAgaW4gb3JkZXIgdG8gYWRkIHRoZW0gdG8gdGhlIGNvbnRyb2wgbGF5ZXIgbGlzdCAoaWYgdGhleSBhcmUgbm90IGFscmVhZHkgYWRkZWQpXG4gICAgb3JkZXJlZExheWVycy5mb3JFYWNoKFxuICAgICAgICBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIGFkZHMgdGhlIG1hcCBsYXllcnMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIHZhciBpZDtcbiAgICAgICAgICAgIGlkID0gbGF5ZXIuaWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xheWVyRGlzcGxheWVkSW5MYXllclN3aXRjaGVyKGlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXllckNvbmYgPSB0aGlzLl9nZXRMYXllckNvbmYoaWQpIHx8IHRoaXMuX2FkZGVkTGF5ZXJDb25mW2lkXSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBsYXllckluZm9zID0gdGhpcy5fZ2V0TGF5ZXJJbmZvKGxheWVyKSB8fCB7fTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGF5ZXJzW2lkXSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsYXllciBpcyBub3QgeWV0IGluIHRoZSBsYXllciBsaXN0ICh0aGlzLl9sYXllcnMpLCB3ZSBhZGQgaXRcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA6IGxheWVyQ29uZi50aXRsZSB8fCBsYXllckluZm9zLl90aXRsZSB8fCBpZCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gOiBsYXllckNvbmYuZGVzY3JpcHRpb24gfHwgbGF5ZXJJbmZvcy5fZGVzY3JpcHRpb24gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kcyA6IGxheWVyQ29uZi5sZWdlbmRzIHx8IGxheWVySW5mb3MuX2xlZ2VuZHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIDogbGF5ZXJDb25mLm1ldGFkYXRhIHx8IGxheWVySW5mb3MuX21ldGFkYXRhIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBxdWlja2xvb2tVcmwgOiBsYXllckNvbmYucXVpY2tsb29rVXJsIHx8IGxheWVySW5mb3MuX3F1aWNrbG9va1VybCB8fCBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXJPcHRpb25zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbHNMYXllckNvbmYgPSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbHNMYXllckNvbmYuaXByICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLm9wdGlvbnMuYXR0cmlidXRpb24gPSBsc0xheWVyQ29uZi5pcHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbHNMYXllckNvbmYub3BhY2l0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5vcGFjaXR5ID0gbHNMYXllckNvbmYub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsc0xheWVyQ29uZi52aXNpYmlsaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnZpc2libGUgPSBsc0xheWVyQ29uZi52aXNpYmlsaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheWVyRGl2ID0gdGhpcy5fY3JlYXRlTGF5ZXJEaXYoaWQpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5kaXYgPSBsYXllckRpdjtcbiAgICAgICAgICAgIGVsZW1lbnRMYXllcnNMaXN0LmFwcGVuZENoaWxkKGxheWVyRGl2KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhpc1xuICAgICk7XG59O1xuXG4vKipcbiAqIGNyZWF0ZXMgbGF5ZXIgZGl2ICh0byBhcHBlbmQgdG8gY29udHJvbCBET00gZWxlbWVudCkuXG4gKlxuICogQG1ldGhvZCBfY3JlYXRlTGF5ZXJEaXZcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqIEByZXR1cm5zIHtET01FbGVtZW50fSBsYXllciBkaXZcbiAqIEBwcml2YXRlXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLl9jcmVhdGVMYXllckRpdiA9IGZ1bmN0aW9uIChsYXllcklkKSB7XG4gICAgdmFyIGxheWVyT3B0aW9ucyA9IHRoaXMuX2xheWVyc1tsYXllcklkXTtcbiAgICB2YXIgaXNMZWdlbmRzID0gbGF5ZXJPcHRpb25zLmxlZ2VuZHMgJiYgbGF5ZXJPcHRpb25zLmxlZ2VuZHMubGVuZ3RoICE9PSAwO1xuICAgIHZhciBpc01ldGFkYXRhID0gbGF5ZXJPcHRpb25zLm1ldGFkYXRhICYmIGxheWVyT3B0aW9ucy5tZXRhZGF0YS5sZW5ndGggIT09IDA7XG4gICAgdmFyIGlzUXVpY2tsb29rVXJsID0gbGF5ZXJPcHRpb25zLnF1aWNrbG9va1VybDtcbiAgICBpZiAoaXNMZWdlbmRzIHx8IGlzTWV0YWRhdGEgfHwgaXNRdWlja2xvb2tVcmwpIHtcbiAgICAgICAgbGF5ZXJPcHRpb25zLmRpc3BsYXlJbmZvcm1hdGlvbkVsZW1lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGFkZHMgYSBzcGVjaWZpYyBkaXYgaW4gdGhlIGNvbnRyb2wgZm9yIHRoZSBsYXllclxuICAgIGxheWVyT3B0aW9ucy5pZCA9IGxheWVySWQ7XG4gICAgdmFyIGxheWVyRGl2ID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyTGF5ZXJFbGVtZW50KGxheWVyT3B0aW9ucyk7XG5cbiAgICBpZiAoIWxheWVyT3B0aW9ucy5pblJhbmdlKSB7XG4gICAgICAgIGxheWVyRGl2LmNsYXNzTGlzdC5hZGQoXCJvdXRPZlJhbmdlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXllckRpdjtcbn07XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgRE9NIGV2ZW50cyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBDaGFuZ2VzIGxheWVyIG9wYWNpdHkgb24gbGF5ZXIgb3BhY2l0eSBwaWN0byBjbGlja1xuICpcbiAqIEBtZXRob2QgX29uQ2hhbmdlTGF5ZXJPcGFjaXR5XG4gKiBAcGFyYW0ge09iamVjdH0gZSAtIEhUTUwgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLl9vbkNoYW5nZUxheWVyT3BhY2l0eSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGdsb2JlID0gdGhpcy5nZXRHbG9iZSgpO1xuICAgIHZhciBsYXllcklEID0gdGhpcy5fcmVzb2x2ZUxheWVySWQoZS50YXJnZXQuaWQpO1xuXG4gICAgdmFyIG9wYWNpdHlWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgIHZhciBvcGFjaXR5SWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG9wYWNpdHlWYWx1ZV9JRF9cIiArIGxheWVySUQpKTtcbiAgICBvcGFjaXR5SWQuaW5uZXJIVE1MID0gb3BhY2l0eVZhbHVlICsgXCIlXCI7XG4gICAgZ2xvYmUuc2V0TGF5ZXJPcGFjaXR5KGxheWVySUQsIG9wYWNpdHlWYWx1ZSAvIDEwMCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgcGljdG8gb3BhY2l0eSB2YWx1ZSBvbiBsYXllciBvcGFjaXR5IGNoYW5nZVxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZUxheWVyT3BhY2l0eVxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBsYXllciBpZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9wYWNpdHkgLSBvcGFjaXR5IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5fdXBkYXRlTGF5ZXJPcGFjaXR5ID0gZnVuY3Rpb24gKGxheWVySWQsIG9wYWNpdHkpIHtcbiAgICBpZiAob3BhY2l0eSA+IDEpIHtcbiAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGlmIChvcGFjaXR5IDwgMCkge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJPcGFjaXR5SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUG9wYWNpdHlWYWx1ZURpdl9JRF9cIiArIGxheWVySWQpKTtcbiAgICBpZiAobGF5ZXJPcGFjaXR5SW5wdXQpIHtcbiAgICAgICAgbGF5ZXJPcGFjaXR5SW5wdXQudmFsdWUgPSBNYXRoLnJvdW5kKG9wYWNpdHkgKiAxMDApO1xuICAgIH1cblxuICAgIHZhciBsYXllck9wYWNpdHlTcGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BvcGFjaXR5VmFsdWVfSURfXCIgKyBsYXllcklkKSk7XG4gICAgaWYgKGxheWVyT3BhY2l0eVNwYW4pIHtcbiAgICAgICAgbGF5ZXJPcGFjaXR5U3Bhbi5pbm5lckhUTUwgPSBNYXRoLnJvdW5kKG9wYWNpdHkgKiAxMDApICsgXCIlXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIGxheWVyIHZpc2liaWxpdHkgb24gbGF5ZXIgdmlzaWJpbGl0eSBwaWN0byBjbGlja1xuICpcbiAqIEBtZXRob2QgX29uVmlzaWJpbGl0eUxheWVyQ2xpY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIC0gSFRNTCBldmVudFxuICogQHByaXZhdGVcbiAqL1xuTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUuX29uVmlzaWJpbGl0eUxheWVyQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBnbG9iZSA9IHRoaXMuZ2V0R2xvYmUoKTtcblxuICAgIHZhciBsYXllcklEID0gdGhpcy5fcmVzb2x2ZUxheWVySWQoZS50YXJnZXQuaWQpO1xuICAgIGdsb2JlLnNldExheWVyVmlzaWJpbGl0eShsYXllcklELCBlLnRhcmdldC5jaGVja2VkKTsgLy8gdXBkYXRlIHZpZXdlclxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHBpY3RvIHZpc2liaWxpdHkgb24gbGF5ZXIgdmlzaWJpbGl0eSBjaGFuZ2VcbiAqXG4gKiBAbWV0aG9kIF91cGRhdGVMYXllclZpc2liaWxpdHlcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllcklkIC0gbGF5ZXIgaWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJpbGl0eSAtIHZpc2libGUgaWYgdHJ1ZVxuICogQHByaXZhdGVcbiAqL1xuTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUuX3VwZGF0ZUxheWVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIChsYXllcklkLCB2aXNpYmlsaXR5KSB7XG4gICAgdmFyIGxheWVyVmlzaWJpbGl0eUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1B2aXNpYmlsaXR5X0lEX1wiICsgbGF5ZXJJZCkpO1xuICAgIGlmIChsYXllclZpc2liaWxpdHlJbnB1dCkge1xuICAgICAgICBsYXllclZpc2liaWxpdHlJbnB1dC5jaGVja2VkID0gdmlzaWJpbGl0eTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE9wZW5zIGxheWVyIGluZm9ybWF0aW9uIHBhbmVsIG9uIHBpY3RvIGNsaWNrXG4gKlxuICogQG1ldGhvZCBfb25PcGVuTGF5ZXJJbmZvQ2xpY2tcbiAqIEBwYXJhbSB7RXZlbnR9IGUgLSBNb3VzZUV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5fb25PcGVuTGF5ZXJJbmZvQ2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBsYXllcklEID0gdGhpcy5fcmVzb2x2ZUxheWVySWQoZS50YXJnZXQuaWQpO1xuXG4gICAgdmFyIGxheWVyT3B0aW9ucyA9IHRoaXMuX2xheWVyc1tsYXllcklEXTtcblxuICAgIHZhciBwYW5lbDtcbiAgICB2YXIgaW5mbztcblxuICAgIC8vIENsb3NlIGxheWVyIGluZm8gcGFuZWxcbiAgICB2YXIgZGl2SWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLnRhcmdldC5pZCk7XG4gICAgaWYgKGRpdklkLmNsYXNzTmFtZSA9PT0gXCJHUGxheWVySW5mb09wZW5lZFwiKSB7XG4gICAgICAgIGlmIChkaXZJZC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGl2SWQuY2xhc3NMaXN0LnJlbW92ZShcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgICAgICAgICAgZGl2SWQuY2xhc3NMaXN0LmFkZChcIkdQbGF5ZXJJbmZvXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb1BhbmVsXCIpKTtcbiAgICAgICAgaWYgKHBhbmVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYW5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiR1BwYW5lbFwiKTtcbiAgICAgICAgICAgIHBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoXCJHUGxheWVySW5mb1BhbmVsT3BlbmVkXCIpO1xuICAgICAgICAgICAgcGFuZWwuY2xhc3NMaXN0LmFkZChcIkdQbGF5ZXJJbmZvUGFuZWxDbG9zZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BsYXllckluZm9Db250ZW50XCIpKTtcbiAgICAgICAgcGFuZWwucmVtb3ZlQ2hpbGQoaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVyc1tpXS5jbGFzc05hbWUgPSBcIkdQbGF5ZXJJbmZvXCI7XG4gICAgfVxuXG4gICAgLy8gT3BlbiBsYXllciBpbmZvIHBhbmVsXG4gICAgaWYgKGRpdklkLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpdklkLmNsYXNzTGlzdC5yZW1vdmUoXCJHUGxheWVySW5mb1wiKTtcbiAgICAgICAgZGl2SWQuY2xhc3NMaXN0LmFkZChcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgIH1cblxuICAgIHBhbmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BsYXllckluZm9QYW5lbFwiKSk7XG4gICAgaWYgKHBhbmVsLmNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhbmVsLmNsYXNzTGlzdC5hZGQoXCJHUHBhbmVsXCIpO1xuICAgICAgICBwYW5lbC5jbGFzc0xpc3QucmVtb3ZlKFwiR1BsYXllckluZm9QYW5lbENsb3NlZFwiKTtcbiAgICAgICAgcGFuZWwuY2xhc3NMaXN0LmFkZChcIkdQbGF5ZXJJbmZvUGFuZWxPcGVuZWRcIik7XG4gICAgfVxuXG4gICAgaW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJJbmZvQ29udGVudFwiKSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgICAgcGFuZWwucmVtb3ZlQ2hpbGQoaW5mbyk7XG4gICAgfVxuXG4gICAgLy8gb24gcsOpY3Vww6hyZSBsZXMgaW5mb3MgYXNzb2Npw6llcyBhdSBsYXllciBwb3VyIG1ldHRyZSBkeW5hbWlxdWVtZW50IGxlIGNvbnRlbnUgZHUgcGFuZWwgZCdpbmZvcm1hdGlvbnNcbiAgICB2YXIgb2JqID0ge1xuICAgICAgICB0aXRsZSA6IGxheWVyT3B0aW9ucy50aXRsZSxcbiAgICAgICAgZGVzY3JpcHRpb24gOiBsYXllck9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgIHF1aWNrbG9va1VybCA6IGxheWVyT3B0aW9ucy5xdWlja2xvb2tVcmwsXG4gICAgICAgIG1ldGFkYXRhIDogbGF5ZXJPcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICBsZWdlbmRzIDogbGF5ZXJPcHRpb25zLmxlZ2VuZHNcbiAgICB9O1xuXG4gICAgdmFyIGluZm9MYXllciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lckxheWVySW5mb0VsZW1lbnQob2JqKTtcbiAgICBwYW5lbC5hcHBlbmRDaGlsZChpbmZvTGF5ZXIpO1xufTtcblxuLyoqXG4gKiByZW1vdmVzIGxheWVyIGZyb20gbGF5ZXIgc3dpdGNoZXIgYW5kIGdsb2JlIG9uIHBpY3RvIGNsaWNrXG4gKlxuICogQG1ldGhvZCBfb25Ecm9wTGF5ZXJDbGlja1xuICogQHBhcmFtIHtFdmVudH0gZSAtIE1vdXNlRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbkxheWVyU3dpdGNoZXIucHJvdG90eXBlLl9vbkRyb3BMYXllckNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ2xvYmUgPSB0aGlzLmdldEdsb2JlKCk7XG5cbiAgICB2YXIgbGF5ZXJJRCA9IHRoaXMuX3Jlc29sdmVMYXllcklkKGUudGFyZ2V0LmlkKTtcbiAgICAvLyByZW1vdmluZyB0aGUgbGF5ZXIgd2lsbCB0cmlnZ2VyIHRoZSBldmVudCBsaXN0ZW5lclxuICAgIC8vIHdoaWNoIHdpbGwgY2FsbCB0aGlzLnJlbW92ZUxheWVyIGFuZCBkZWxldGUgdGhlIGRpdlxuICAgIGdsb2JlLnJlbW92ZUxheWVyKGxheWVySUQpO1xuXG4gICAgdGhpcy5fdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyKCk7XG59O1xuXG4vKipcbiAqIGNoYW5nZXMgbGF5ZXJzIG9yZGVyIG9uIGRyYWcgYW5kIGRyb3BcbiAqXG4gKiBAbWV0aG9kIF9vbkRyb3BMYXllckNsaWNrXG4gKiBAcGFyYW0ge0V2ZW50fSBlIC0gSFRNTCBldmVudFxuICogQHByaXZhdGVcbiAqL1xuTGF5ZXJTd2l0Y2hlci5wcm90b3R5cGUuX29uRHJhZ0FuZERyb3BMYXllckNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZ2xvYmUgPSB0aGlzLmdldEdsb2JlKCk7XG5cbiAgICAvLyBIYW5kbGluZyBvZiB0aGUgaW5kZXhlcyA6IGdpdmVzIHRoZSBsaXR0bGUgaW5kZXhlcyAobG93ZXN0IGxheWVycykgdG8gdGhlIG5vbi12aXNpYmxlIGxheWVycyAoZGlzcGxheWVkOiBmYWxzZSlcbiAgICAvLyB3aGVuIHRoZSBpbmRleCBvZiBhIHZpc2libGUgbGF5ZXIgY2hhbmdlcy5cbiAgICAvLyBBbHdheXMgbW92ZXMgdGhlIG5vbi12aXNpYmxlIGxheWVycyB1bmRlciB0aGUgb3RoZXIgbGF5ZXJzICh0byBub3QgaGlkZSB0aGVtKVxuXG4gICAgaWYgKGUubmV3SW5kZXggLSBlLm9sZEluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBudWxsO1xuICAgIGlmICghZS5uZXdJbmRleCB8fCBlLm5ld0luZGV4ID09PSAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZ2xvYmUuZ2V0Q29sb3JMYXllcnMoKS5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXllclRhcmdldElEID0gdGhpcy5fcmVzb2x2ZUxheWVySWQoZS5mcm9tLmNoaWxkTm9kZXNbZS5uZXdJbmRleCArIChlLm5ld0luZGV4IC0gZS5vbGRJbmRleCA8IDAgPyAxIDogLTEpXS5pZCk7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZ2xvYmUuZ2V0TGF5ZXJCeUlkKGxheWVyVGFyZ2V0SUQpLnNlcXVlbmNlO1xuICAgIH1cblxuICAgIHZhciBsYXllcklEID0gdGhpcy5fcmVzb2x2ZUxheWVySWQoZS5pdGVtLmlkKTtcblxuICAgIGdsb2JlLm1vdmVMYXllclRvSW5kZXgobGF5ZXJJRCwgdGFyZ2V0SW5kZXgpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgbGF5ZXJzIHJhbmdlXG4gKlxuICogQG1ldGhvZCBfaW5SYW5nZVVwZGF0ZVxuICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzRGlzcGxheWVkIC0gbGlzdCBvZiBkaXNwbGF5ZWQgbGF5ZXJzIGlkXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5faW5SYW5nZVVwZGF0ZSA9IGZ1bmN0aW9uIChsYXllcnNEaXNwbGF5ZWQpIHtcbiAgICBmb3IgKHZhciBsYXllcktleSBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2xheWVyS2V5XTtcbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgbGF5ZXIgaXMgZGlzcGxheWVkLlxuICAgICAgICB2YXIgbGF5ZXJEaXY7XG4gICAgICAgIHZhciBiSW5SYW5nZSA9IGxheWVyc0Rpc3BsYXllZC5pbmRleE9mKGxheWVyLmlkKSA+PSAwO1xuICAgICAgICBpZiAoYkluUmFuZ2UgJiYgIWxheWVyLmluUmFuZ2UpIHtcbiAgICAgICAgICAgIGxheWVyLmluUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGF5ZXJEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9hZGRVSUQoXCJHUGxheWVyU3dpdGNoZXJfSURfXCIgKyBsYXllci5pZCkpO1xuICAgICAgICAgICAgbGF5ZXJEaXYuY2xhc3NMaXN0LnJlbW92ZShcIm91dE9mUmFuZ2VcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWJJblJhbmdlICYmIGxheWVyLmluUmFuZ2UpIHtcbiAgICAgICAgICAgIGxheWVyLmluUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGxheWVyRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BsYXllclN3aXRjaGVyX0lEX1wiICsgbGF5ZXIuaWQpKTtcbiAgICAgICAgICAgIGxheWVyRGl2LmNsYXNzTGlzdC5hZGQoXCJvdXRPZlJhbmdlXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGxheWVyIGxpc3QgY29udGFpbmVyXG4gKlxuICogQG1ldGhvZCBfdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5fdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9sYXllckxpc3RDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGdsb2JlID0gdGhpcy5nZXRHbG9iZSgpO1xuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBwcmV2aW91cyBjb250YWluZXJcbiAgICAgICAgd2hpbGUgKHRoaXMuX2xheWVyTGlzdENvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllckxpc3RDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fbGF5ZXJMaXN0Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlb3JkZXJzIGxheWVycyBhY2NvcmRpbmcgdG8gdGhlIGxheWVyIHN0YWNrIChnbG9iZS5nZXRMYXllcnMgcmV0dXJucyBhbiByZXZlcnNlIG9yZGVuZXJlZCBhcnJheSkuLlxuICAgICAgICB2YXIgbGF5ZXJzID0gZ2xvYmUuZ2V0Q29sb3JMYXllcnMoKTtcbiAgICAgICAgdmFyIG9yZGVyZWRMYXllcnMgPSBsYXllcnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIuc2VxdWVuY2UgLSBhLnNlcXVlbmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gLi4uIGFuZCBhZGRzIHRoZSBjb3JyZWN0IGRpdiB0byB0aGUgZGlmZmVyZW50IGxheWVycywgaW4gdGhlIHppbmRleCBkZWNyZWFzaW5nIG9yZGVyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3JkZXJlZExheWVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9sYXllcnNbb3JkZXJlZExheWVyc1tqXS5pZF0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHJpZXZlcyB0aGUgZGl2IG9mIHRoZSBsYXllciwgc3RvcmVkIGluIHRoZSBfbGF5ZXJzIGFycmF5XG4gICAgICAgICAgICB2YXIgbGF5ZXJEaXYgPSB0aGlzLl9sYXllcnNbb3JkZXJlZExheWVyc1tqXS5pZF0uZGl2O1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJMaXN0Q29udGFpbmVyLmFwcGVuZENoaWxkKGxheWVyRGl2KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIltJdG93bnMuY29udHJvbC5MYXllclN3aXRjaGVyXSBfdXBkYXRlTGF5ZXJMaXN0Q29udGFpbmVyIDogbGF5ZXIgbGlzdCBjb250YWluZXIgbm90IGZvdW5kIHRvIHVwZGF0ZSBsYXllcnMgb3JkZXIgPyFcIik7XG4gICAgfVxufTtcblxuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBVdGlscyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4vKipcbiAqIEdldHMgbGF5ZXIgaW5mb3JtYXRpb25zIDogdGl0bGUsIGRlc2NyaXB0aW9uLCBxdWlja2xvb2t1cmwsIGxlZ2VuZHMsIG1ldGFkYXRhXG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBMYXllclN3aXRjaGVyXG4gKiBAbWV0aG9kIF9nZXRMYXllckluZm9cbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIHRoZSBsYXllciBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGxheWVySW5mbyAtIGxheWVyIGluZm9ybWF0aW9uc1xuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5fZ2V0TGF5ZXJJbmZvID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgdmFyIGxheWVySW5mbyA9IHt9O1xuICAgIGlmIChsYXllcikge1xuICAgICAgICBsYXllckluZm8uX3RpdGxlID0gbGF5ZXIudGl0bGUgfHwgbnVsbDtcbiAgICAgICAgbGF5ZXJJbmZvLl9kZXNjcmlwdGlvbiA9IGxheWVyLmRlc2NyaXB0aW9uIHx8IG51bGw7XG4gICAgICAgIGxheWVySW5mby5fcXVpY2tsb29rVXJsID0gbGF5ZXIucXVpY2tsb29rVXJsIHx8IG51bGw7XG4gICAgICAgIGxheWVySW5mby5fbWV0YWRhdGEgPSBsYXllci5tZXRhZGF0YSB8fCBudWxsO1xuICAgICAgICBsYXllckluZm8uX2xlZ2VuZHMgPSBsYXllci5sZWdlbmRzIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsYXllckluZm87XG59O1xuXG4vKipcbiAqIEdldHMgbGF5ZXIgaWQgZnJvbSBkaXYgaWRcbiAqXG4gKiBAbWV0aG9kIF9yZXNvbHZlTGF5ZXJJZFxuICogQHBhcmFtIHtTdHJpbmd9IGRpdklkIC0gSFRNTCBkaXYgaWRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGxheWVyIGlkXG4gKiBAcHJpdmF0ZVxuICovXG5MYXllclN3aXRjaGVyLnByb3RvdHlwZS5fcmVzb2x2ZUxheWVySWQgPSBmdW5jdGlvbiAoZGl2SWQpIHtcbiAgICB2YXIgZGl2TmFtZSA9IFNlbGVjdG9ySUQubmFtZShkaXZJZCk7IC8vIGV4IEdQdmlzaWJpbGl0eVBpY3RvX0lEXzI2XG4gICAgcmV0dXJuIGRpdk5hbWUuc3Vic3RyaW5nKGRpdk5hbWUuaW5kZXhPZihcIl9JRF9cIikgKyA0KTsgLy8gZXguIDI2XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMYXllclN3aXRjaGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9Db250cm9scy9MYXllclN3aXRjaGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _sortable = __webpack_require__(22);\n\nvar _sortable2 = _interopRequireDefault(_sortable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar LayerSwitcherDOM = {\n\n    /**\n     * Creation du drag and drop\n     *\n     * @param {Object} elementDraggable - Element HTML (DOM) Container\n     * @param {Object} context - this\n     */\n    _createDraggableElement: function _createDraggableElement(elementDraggable, context) {\n        _sortable2.default.create(elementDraggable, {\n            handle: \".GPlayerName\",\n            draggable: \".draggable-layer\",\n            ghostClass: \"GPghostLayer\",\n            animation: 200,\n            // Call event function on drag and drop\n            onEnd: function onEnd(e) {\n                // FIXME pas terrrible, mais il faut bien passer ce contexte...\n                context._onDragAndDropLayerClick(e);\n            }\n        });\n    },\n\n    // ################################################################### //\n    // ######################### Main container ########################## //\n    // ################################################################### //\n\n    /**\n    * Add uuid to the tag ID\n    * @param {String} id - id selector\n    * @returns {String} uid - id selector with an unique id\n    */\n    _addUID: function _addUID(id) {\n        var uid = this._uid ? id + \"-\" + this._uid : id;\n        return uid;\n    },\n\n    /**\n     * Creation du container principal (DOM)\n     *\n     * @returns {DOMElement} container - layer switcher DOM element\n     */\n    _createMainContainerElement: function _createMainContainerElement() {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPlayerSwitcher\");\n        container.className = \"GPwidget\";\n        return container;\n    },\n\n    /**\n     * Creation du container principal d\"affichage des layers (DOM)\n     *\n     * @returns {DOMElement} input - element for minimizing/maximizing the layer switcher\n     */\n    _createMainLayersShowElement: function _createMainLayersShowElement() {\n        // <!-- Hidden checkbox for minimizing/maximizing -->\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPshowLayersList\");\n        input.type = \"checkbox\";\n        return input;\n    },\n\n    /**\n     * Creation du container principal des layers (DOM)\n     *\n     * @returns {DOMElement} container - layers list container\n     */\n    _createMainLayersElement: function _createMainLayersElement() {\n        // ajout de la liste des layers dans le container principal\n        // <div id=\"GPlayersList\" class=\"GPpanel\">\n        //   (...)\n        // </div>\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPlayersList\");\n        div.className = \"GPpanel\";\n        return div;\n    },\n\n    /**\n     * Creation du container du picto du controle (DOM)\n     *\n     * @returns {DOMElement} label\n     */\n    _createMainPictoElement: function _createMainPictoElement() {\n        var self = this;\n\n        // exemple :\n        // <!-- Label for minimizing/maximizing -->\n        // <label id=\"GPshowLayersListPicto\" class=\"GPshowAdvancedToolPicto\" for=\"GPshowLayersList\" title=\"Afficher/masquer le gestionnaire de couches\">\n        //    <span id=\"GPshowLayersListOpen\" class=\"GPshowAdvancedToolOpen\"></span><span id=\"GPshowLayersListClose\"></span>\n        // </label>\n\n        var label = document.createElement(\"label\");\n        label.id = this._addUID(\"GPshowLayersListPicto\");\n        label.className = \"GPshowAdvancedToolPicto\";\n        label.htmlFor = this._addUID(\"GPshowLayersList\");\n        label.title = \"Afficher/masquer le gestionnaire de couches\";\n\n        var spanOpen = document.createElement(\"span\");\n        spanOpen.id = this._addUID(\"GPshowLayersListOpen\");\n        spanOpen.className = \"GPshowAdvancedToolOpen\";\n        spanOpen.addEventListener(\"click\", function () {\n            if (document.getElementById(self._addUID(\"GPshowLayersList\")).checked) {\n                var layers = document.getElementsByClassName(\"GPlayerInfoOpened\");\n                for (var i = 0; i < layers.length; i++) {\n                    layers[i].className = \"GPlayerInfo\";\n                }\n                document.getElementById(self._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n            }\n        });\n\n        label.appendChild(spanOpen);\n\n        var spanClose = document.createElement(\"span\");\n        spanClose.addEventListener(\"click\", function () {\n            if (document.getElementById(self._addUID(\"GPshowLayersList\")).checked) {\n                var layers = document.getElementsByClassName(\"GPlayerInfoOpened\");\n                for (var i = 0; i < layers.length; i++) {\n                    layers[i].className = \"GPlayerInfo\";\n                }\n                document.getElementById(self._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n            }\n        });\n        spanClose.id = self._addUID(\"GPshowLayersListClose\");\n\n        label.appendChild(spanClose);\n\n        return label;\n    },\n\n    /**\n     * Creation du container du panneau d\"information (DOM)\n     *\n     * @returns {DOMElement} container\n     */\n    _createMainInfoElement: function _createMainInfoElement() {\n        // gestion du panneau d\"information dans le container principal\n        // <div id=\"GPlayerInfoPanel\" class=\"GPlayerInfoPanelClosed\">...</div>\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPlayerInfoPanel\");\n        div.className = \"GPpanel GPlayerInfoPanelClosed\";\n        return div;\n    },\n\n    // ################################################################### //\n    // ######################### Layer container ######################### //\n    // ################################################################### //\n\n    /**\n     * Creation du container du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     * @param {Object} obj.layer - couche (ol ou leaflet)\n     * @param {String} obj.id - identifiant de la couche (pour ol ou leaflet)\n     * @param {String} obj.title - nom de la couche à afficher dans le controle\n     * @param {String} obj.description - description de la couche à afficher\n     * @param {Boolean} obj.visibility - visibilité de la couche dans la carte (true or false)\n     * @param {Float} obj.opacity - opacité de la couche\n     *\n     * @returns {DOMElement} container\n     */\n    _createContainerLayerElement: function _createContainerLayerElement(obj) {\n        // exemple :\n        // <div id=\"GPlayerSwitcher_ID_Layer1\" class=\"GPlayerSwitcher_layer outOfRange\">\n        //     <!-- Basic toolbar : visibility / layer name\n        //     _createBasicToolElement\n        //           _createBasicToolVisibilityElement\n        //           _createBasicToolNameElement\n        //     -->\n        //     <!-- Hidden checkbox + label for showing advanced toolbar\n        //     _createAdvancedToolShowElement\n        //     -->\n        //     <!-- Advanced toolbar : layer info / opacity slider / opacity value / removal\n        //     _createAdvancedToolElement\n        //           _createAdvancedToolDeleteElement\n        //           _createAdvancedToolInformationElement\n        //           _createAdvancedToolOpacityElement\n        //     -->\n        // </div>\n\n        // <!-- Layer entry in layer list -->\n        // <!-- Every item is marked with layerID, which is defined at layer import -->\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPlayerSwitcher_ID_\" + obj.id);\n        container.className = \"GPlayerSwitcher_layer draggable-layer\";\n\n        // ajout des outils basiques (visibility / layer name)\n        container.appendChild(this._createBasicToolElement(obj));\n\n        // liste des outils avancés (layer info / opacity slider / opacity value / removal)\n        var array = this._createAdvancedToolShowElement(obj);\n        for (var i = 0; i < array.length; i++) {\n            container.appendChild(array[i]);\n        }\n\n        // ajout des outils avancés\n        container.appendChild(this._createAdvancedToolElement(obj));\n\n        return container;\n    },\n\n    // ################################################################### //\n    // ############################ Layer tool ########################### //\n    // ################################################################### //\n\n    /**\n     * Creation du container des outils basiques du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createBasicToolElement: function _createBasicToolElement(obj) {\n        // exemple :\n        // <div id=\"GPbasicTools_ID_1\" class=\"GPlayerBasicTools\">\n        //      <!-- _createBasicToolVisibilityElement -->\n        //      <!-- _createBasicToolNameElement -->\n        // </div>\n\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPbasicTools_ID_\" + obj.id);\n        div.className = \"GPlayerBasicTools\";\n\n        div.appendChild(this._createBasicToolNameElement(obj));\n\n        var array = this._createBasicToolVisibilityElement(obj);\n        for (var i = 0; i < array.length; i++) {\n            div.appendChild(array[i]);\n        }\n\n        return div;\n    },\n\n    /**\n     * Creation du nom du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createBasicToolNameElement: function _createBasicToolNameElement(obj) {\n        // exemple :\n        // <span id=\"GPname_ID_Layer1\" class=\"GPlayerName\" title=\"Quartiers prioritaires de la ville\">Quartiers prioritaires de la ville</span>\n        var span = document.createElement(\"span\");\n        span.id = this._addUID(\"GPname_ID_\" + obj.id);\n        span.className = \"GPlayerName\";\n        span.title = obj.description || obj.title;\n        span.innerHTML = obj.title;\n\n        return span;\n    },\n\n    /**\n     * Creation de l'icone de visibilité du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n      * @returns {DOMElement[]} array containing input and label elements\n     */\n    _createBasicToolVisibilityElement: function _createBasicToolVisibilityElement(obj) {\n        // exemple :\n        // <input type=\"checkbox\" id=\"GPvisibility_ID_Layer1\" checked=\"\">\n        // <label for=\"GPvisibility_ID_Layer1\" id=\"GPvisibilityPicto_ID_Layer1\" class=\"GPlayerVisibility\" title=\"Afficher/masquer la couche\"></label>\n\n        var list = [];\n\n        var checked = typeof obj.visibility !== \"undefined\" ? obj.visibility : true;\n        var id = this._addUID(\"GPvisibility_ID_\" + obj.id);\n\n        var input = document.createElement(\"input\");\n        input.id = id;\n        input.type = \"checkbox\";\n        input.checked = checked;\n\n        var label = document.createElement(\"label\");\n        label.htmlFor = id;\n        label.id = this._addUID(\"GPvisibilityPicto_ID_\" + obj.id);\n        label.className = \"GPlayerVisibility\";\n        label.title = \"Afficher/masquer la couche\";\n\n        // add event for visibility change\n        var context = this;\n        if (input.addEventListener) {\n            input.addEventListener(\"click\", function (e) {\n                context._onVisibilityLayerClick(e);\n            });\n        } else if (input.attachEvent) {\n            // internet explorer\n            input.attachEvent(\"onclick\", function (e) {\n                context._onVisibilityLayerClick(e);\n            });\n        }\n\n        list.push(input);\n        list.push(label);\n\n        return list;\n    },\n\n    /**\n     * Creation de l'affichage du menu des outils avancés du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement[]} array containing input and label elements\n     */\n    _createAdvancedToolShowElement: function _createAdvancedToolShowElement(obj) {\n        // <input type=\"checkbox\" id=\"GPshowAdvancedTools_ID_Layer1\">\n        // <label for=\"GPshowAdvancedTools_ID_Layer1\" id=\"GPshowAdvancedToolsPicto_ID_Layer1\" class=\"GPshowMoreOptions GPshowLayerAdvancedTools\" title=\"Plus d'outils\"></label>\n\n        var list = [];\n\n        var label = document.createElement(\"label\");\n        label.id = this._addUID(\"GPshowAdvancedToolsPicto_ID_\" + obj.id);\n        label.htmlFor = this._addUID(\"GPshowAdvancedTools_ID_\" + obj.id);\n        label.title = \"Plus d'outils\";\n        label.className = \"GPshowMoreOptions GPshowLayerAdvancedTools\";\n\n        var input = document.createElement(\"input\");\n        input.type = \"checkbox\";\n        input.id = this._addUID(\"GPshowAdvancedTools_ID_\" + obj.id);\n\n        list.push(input);\n        list.push(label);\n\n        return list;\n    },\n\n    /**\n     * Creation du container des outils avancés du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createAdvancedToolElement: function _createAdvancedToolElement(obj) {\n        // exemple :\n        // <div id=\"GPadvancedTools_ID_Layer1\" class=\"GPlayerAdvancedTools\">\n        //     <!-- _createAdvancedToolDeleteElement -->\n        //     <!-- _createAdvancedToolInformationElement -->\n        //     <!-- _createAdvancedToolOpacityElement -->\n        // </div>\n\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPadvancedTools_ID_\" + obj.id);\n        container.className = \"GPlayerAdvancedTools\";\n\n        container.appendChild(this._createAdvancedToolDeleteElement(obj));\n\n        // si on n'a de l'informations à afficher, on met en place ce composant\n        if (obj.title && obj.description) {\n            container.appendChild(this._createAdvancedToolInformationElement(obj));\n        }\n        if (obj.type !== \"feature\") {\n            var array = this._createAdvancedToolOpacityElement(obj);\n            for (var i = 0; i < array.length; i++) {\n                container.appendChild(array[i]);\n            }\n        }\n\n        return container;\n    },\n\n    /**\n     * Creation de l'icone de suppression du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createAdvancedToolDeleteElement: function _createAdvancedToolDeleteElement(obj) {\n        // exemple :\n        // <div id=\"GPremove_ID_Layer1\" class=\"GPlayerRemove\" title=\"Supprimer la couche\" onclick=\"GPdropLayer(this);\"></div>\n\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPremove_ID_\" + obj.id);\n        div.className = \"GPlayerRemove\";\n        div.title = \"Supprimer la couche\";\n        div.layerId = obj.id;\n\n        var context = this;\n        if (div.addEventListener) {\n            div.addEventListener(\"click\", function (e) {\n                context._onDropLayerClick(e);\n            });\n        } else if (div.attachEvent) {\n            // internet explorer\n            div.attachEvent(\"onclick\", function (e) {\n                context._onDropLayerClick(e);\n            });\n        }\n\n        return div;\n    },\n\n    /**\n     * Creation de l'icone d'information du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createAdvancedToolInformationElement: function _createAdvancedToolInformationElement(obj) {\n        // exemple :\n        // <div id=\"GPinfo_ID_Layer1\" class=\"GPlayerInfo\" title=\"Informations/légende\" onclick=\"GPopenLayerInfo(this);\"></div>\n\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPinfo_ID_\" + obj.id);\n        div.className = \"GPlayerInfo\";\n        div.title = \"Informations/légende\";\n        div.layerId = obj.id;\n        // add event on click\n        var context = this;\n        if (div.addEventListener) {\n            div.addEventListener(\"click\", function (e) {\n                context._onOpenLayerInfoClick(e);\n            });\n        } else if (div.attachEvent) {\n            // internet explorer\n            div.attachEvent(\"onclick\", function (e) {\n                context._onOpenLayerInfoClick(e);\n            });\n        }\n\n        return div;\n    },\n\n    /**\n     * Creation de l'icone de gestion de l'opacité du layer (DOM)\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement[]} array of two containers\n     */\n    _createAdvancedToolOpacityElement: function _createAdvancedToolOpacityElement(obj) {\n        // exemple :\n        // <div id=\"GPopacity_ID_Layer1\" class=\"GPlayerOpacity\" title=\"Opacité\">\n        //   <input id=\"GPopacityRange_ID_Layer1\" type=\"range\" value=\"100\" oninput=\"GPchangeLayerOpacity(this);\" onchange=\"GPchangeLayerOpacity(this);\">\n        // </div>\n        // <div class=\"GPlayerOpacityValue\" id=\"GPopacityValueDiv_ID_Layer1\">\n        //   <span id=\"GPopacityValue_ID_Layer1\">100</span>\n        //   %\n        // </div>\n\n        var list = [];\n\n        // curseur pour changer l'opacité\n        var divO = document.createElement(\"div\");\n        divO.id = this._addUID(\"GPopacity_ID_\" + obj.id);\n        divO.className = \"GPlayerOpacity\";\n        divO.title = \"Opacité\";\n\n        var opacity = typeof obj.opacity !== \"undefined\" ? obj.opacity : 1;\n        opacity = Math.round(opacity * 100);\n\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPopacityValueDiv_ID_\" + obj.id);\n        input.type = \"range\";\n        input.value = opacity;\n\n        // add event for opacity change\n        var context = this;\n        if (input.addEventListener) {\n            input.addEventListener(\"change\", function (e) {\n                context._onChangeLayerOpacity(e);\n            });\n        } else if (input.attachEvent) {\n            // internet explorer\n            input.attachEvent(\"onchange\", function (e) {\n                context._onChangeLayerOpacity(e);\n            });\n        }\n\n        if (input.addEventListener) {\n            input.addEventListener(\"input\", function (e) {\n                context._onChangeLayerOpacity(e);\n            });\n        } else if (input.attachEvent) {\n            // internet explorer\n            input.attachEvent(\"oninput\", function (e) {\n                context._onChangeLayerOpacity(e);\n            });\n        }\n\n        divO.appendChild(input);\n\n        // Valeur d'opacité\n        var divC = document.createElement(\"div\");\n        divC.id = this._addUID(\"GPopacityValueDiv_ID_\" + obj.id);\n        divC.className = \"GPlayerOpacityValue\";\n\n        var span = document.createElement(\"span\");\n        span.id = this._addUID(\"GPopacityValue_ID_\" + obj.id);\n        span.innerHTML = opacity + \"%\";\n\n        divC.appendChild(span);\n\n        list.push(divO);\n        list.push(divC);\n\n        return list;\n    },\n\n    // ################################################################### //\n    // ############################ Layer info ########################### //\n    // ################################################################### //\n\n    /**\n     * Creation du container du layer info (DOM)\n     *\n     * TODO GPlayerInfoPopup : ???\n     * TODO GPlayerInfoLink  : mettre en forme les échelles !\n     *\n     * @param {Object} obj - options de la couche à ajouter dans le layer switcher\n     *\n     * @returns {DOMElement} container\n     */\n    _createContainerLayerInfoElement: function _createContainerLayerInfoElement(obj) {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPlayerInfoContent\");\n\n        var title = document.createElement(\"div\");\n        title.id = this._addUID(\"GPlayerInfoTitle\");\n        title.innerHTML = obj.title;\n        container.appendChild(title);\n\n        if (obj.quicklookUrl) {\n            var quick = document.createElement(\"div\");\n            quick.id = this._addUID(\"GPlayerInfoQuicklook\");\n            quick.title = \"Afficher un aperçu de la couche\";\n            var refquick = document.createElement(\"a\");\n            refquick.href = obj.quicklookUrl;\n            refquick.appendChild(quick);\n            container.appendChild(refquick);\n        }\n\n        var close = document.createElement(\"div\");\n        close.id = this._addUID(\"GPlayerInfoClose\");\n        close.title = \"Fermer la fenêtre\";\n\n        var self = this;\n        /** Call event function on close click */\n        var onCloseClick = function onCloseClick() {\n            document.getElementById(self._addUID(\"GPlayerInfoPanel\")).className = \"GPlayerInfoPanelClosed\";\n            var layers = document.getElementsByClassName(\"GPlayerInfoOpened\");\n            for (var i = 0; i < layers.length; i++) {\n                layers[i].className = \"GPlayerInfo\";\n            }\n        };\n        if (close.addEventListener) {\n            close.addEventListener(\"click\", onCloseClick);\n        } else if (close.attachEvent) {\n            // internet explorer\n            close.attachEvent(\"onclick\", onCloseClick);\n        }\n        container.appendChild(close);\n\n        var desc = document.createElement(\"div\");\n        desc.id = this._addUID(\"GPlayerInfoDescription\");\n        desc.innerHTML = obj.description;\n        container.appendChild(desc);\n\n        if (obj.metadata) {\n            var mtd = document.createElement(\"div\");\n            mtd.id = this._addUID(\"GPlayerInfoMetadata\");\n\n            var mtdtitle = document.createElement(\"div\");\n            mtdtitle.className = \"GPlayerInfoSubtitle\";\n            mtdtitle.innerHTML = \"Métadonnées\";\n            mtd.appendChild(mtdtitle);\n\n            for (var i = 0; i < obj.metadata.length; i++) {\n                var urlmtd = obj.metadata[i].url;\n\n                var mtdlink = document.createElement(\"div\");\n                mtdlink.className = \"GPlayerInfoLink\";\n\n                var refmtd = document.createElement(\"a\");\n                refmtd.href = urlmtd;\n                refmtd.innerHTML = urlmtd;\n                mtdlink.appendChild(refmtd);\n                mtd.appendChild(mtdlink);\n            }\n\n            if (obj.metadata.length !== 0) {\n                container.appendChild(mtd);\n            }\n        }\n\n        if (obj.legends) {\n            var lgd = document.createElement(\"div\");\n            lgd.id = this._addUID(\"GPlayerInfoLegend\");\n\n            var lgdtitle = document.createElement(\"div\");\n            lgdtitle.className = \"GPlayerInfoSubtitle\";\n            lgdtitle.innerHTML = \"Légende\";\n            lgd.appendChild(lgdtitle);\n\n            var legends = {};\n            var maxScale = obj.maxScaleDenominator || 560000000;\n\n            // on crée un tableau temporaire pour ordonner les légendes selon le dénominateur d'échelle\n            for (var k = 0; k < obj.legends.length; k++) {\n                var minScale = obj.legends[k].minScaleDenominator;\n                if (minScale) {\n                    var s = minScale.toString();\n                    minScale = Math.round(parseInt(s.substring(0, 3), 10) / 10) * Math.pow(10, s.length - 2);\n                } else {\n                    minScale = 270;\n                }\n                legends[minScale] = obj.legends[k];\n            }\n\n            for (var scale in legends) {\n                if (legends.hasOwnProperty(scale)) {\n                    var urllgd = legends[scale].url;\n                    // on n'affiche pas les légendes pointant vers \"nolegend.jpg\"\n                    if (typeof urllgd === \"string\" && urllgd.toLowerCase().indexOf(\"nolegend.jpg\") === -1) {\n                        // TODO GPlayerInfoPopup\n                        var lgdlink = document.createElement(\"div\");\n                        lgdlink.className = \"GPlayerInfoLink\";\n\n                        maxScale = legends[scale].maxScaleDenominator || maxScale;\n\n                        var reflgd = document.createElement(\"a\");\n                        reflgd.href = urllgd;\n                        reflgd.innerHTML = \"Du 1/\" + scale + \" au 1/\" + maxScale;\n                        lgdlink.appendChild(reflgd);\n                        lgd.appendChild(lgdlink);\n                    } else {\n                        delete legends[scale];\n                    }\n                }\n            }\n\n            if (Object.keys(legends).length !== 0) {\n                container.appendChild(lgd);\n            }\n        }\n\n        return container;\n    }\n};\n\nexports.default = LayerSwitcherDOM;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL0xheWVyU3dpdGNoZXJET00uanM/ZThlNCJdLCJuYW1lcyI6WyJMYXllclN3aXRjaGVyRE9NIiwiX2NyZWF0ZURyYWdnYWJsZUVsZW1lbnQiLCJlbGVtZW50RHJhZ2dhYmxlIiwiY29udGV4dCIsIlNvcnRhYmxlIiwiY3JlYXRlIiwiaGFuZGxlIiwiZHJhZ2dhYmxlIiwiZ2hvc3RDbGFzcyIsImFuaW1hdGlvbiIsIm9uRW5kIiwiZSIsIl9vbkRyYWdBbmREcm9wTGF5ZXJDbGljayIsIl9hZGRVSUQiLCJpZCIsInVpZCIsIl91aWQiLCJfY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJfY3JlYXRlTWFpbkxheWVyc1Nob3dFbGVtZW50IiwiaW5wdXQiLCJ0eXBlIiwiX2NyZWF0ZU1haW5MYXllcnNFbGVtZW50IiwiZGl2IiwiX2NyZWF0ZU1haW5QaWN0b0VsZW1lbnQiLCJzZWxmIiwibGFiZWwiLCJodG1sRm9yIiwidGl0bGUiLCJzcGFuT3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRFbGVtZW50QnlJZCIsImNoZWNrZWQiLCJsYXllcnMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaSIsImxlbmd0aCIsImFwcGVuZENoaWxkIiwic3BhbkNsb3NlIiwiX2NyZWF0ZU1haW5JbmZvRWxlbWVudCIsIl9jcmVhdGVDb250YWluZXJMYXllckVsZW1lbnQiLCJvYmoiLCJfY3JlYXRlQmFzaWNUb29sRWxlbWVudCIsImFycmF5IiwiX2NyZWF0ZUFkdmFuY2VkVG9vbFNob3dFbGVtZW50IiwiX2NyZWF0ZUFkdmFuY2VkVG9vbEVsZW1lbnQiLCJfY3JlYXRlQmFzaWNUb29sTmFtZUVsZW1lbnQiLCJfY3JlYXRlQmFzaWNUb29sVmlzaWJpbGl0eUVsZW1lbnQiLCJzcGFuIiwiZGVzY3JpcHRpb24iLCJpbm5lckhUTUwiLCJsaXN0IiwidmlzaWJpbGl0eSIsIl9vblZpc2liaWxpdHlMYXllckNsaWNrIiwiYXR0YWNoRXZlbnQiLCJwdXNoIiwiX2NyZWF0ZUFkdmFuY2VkVG9vbERlbGV0ZUVsZW1lbnQiLCJfY3JlYXRlQWR2YW5jZWRUb29sSW5mb3JtYXRpb25FbGVtZW50IiwiX2NyZWF0ZUFkdmFuY2VkVG9vbE9wYWNpdHlFbGVtZW50IiwibGF5ZXJJZCIsIl9vbkRyb3BMYXllckNsaWNrIiwiX29uT3BlbkxheWVySW5mb0NsaWNrIiwiZGl2TyIsIm9wYWNpdHkiLCJNYXRoIiwicm91bmQiLCJ2YWx1ZSIsIl9vbkNoYW5nZUxheWVyT3BhY2l0eSIsImRpdkMiLCJfY3JlYXRlQ29udGFpbmVyTGF5ZXJJbmZvRWxlbWVudCIsInF1aWNrbG9va1VybCIsInF1aWNrIiwicmVmcXVpY2siLCJocmVmIiwiY2xvc2UiLCJvbkNsb3NlQ2xpY2siLCJkZXNjIiwibWV0YWRhdGEiLCJtdGQiLCJtdGR0aXRsZSIsInVybG10ZCIsInVybCIsIm10ZGxpbmsiLCJyZWZtdGQiLCJsZWdlbmRzIiwibGdkIiwibGdkdGl0bGUiLCJtYXhTY2FsZSIsIm1heFNjYWxlRGVub21pbmF0b3IiLCJrIiwibWluU2NhbGUiLCJtaW5TY2FsZURlbm9taW5hdG9yIiwicyIsInRvU3RyaW5nIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJwb3ciLCJzY2FsZSIsImhhc093blByb3BlcnR5IiwidXJsbGdkIiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwibGdkbGluayIsInJlZmxnZCIsIk9iamVjdCIsImtleXMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFFQSxJQUFJQSxtQkFBbUI7O0FBRW5COzs7Ozs7QUFNQUMsNkJBQTBCLGlDQUFVQyxnQkFBVixFQUE0QkMsT0FBNUIsRUFBcUM7QUFDM0RDLDJCQUFTQyxNQUFULENBQWdCSCxnQkFBaEIsRUFBa0M7QUFDOUJJLG9CQUFTLGNBRHFCO0FBRTlCQyx1QkFBWSxrQkFGa0I7QUFHOUJD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QUFzQmdELEdBQXRCO0FBQ0g7QUFDSjs7QUFFRCxlQUFPdEUsU0FBUDtBQUNIO0FBOXBCa0IsQ0FBdkI7O2tCQWlxQmVsQixnQiIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTb3J0YWJsZSBmcm9tIFwic29ydGFibGVcIjtcblxudmFyIExheWVyU3dpdGNoZXJET00gPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkdSBkcmFnIGFuZCBkcm9wXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudERyYWdnYWJsZSAtIEVsZW1lbnQgSFRNTCAoRE9NKSBDb250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIHRoaXNcbiAgICAgKi9cbiAgICBfY3JlYXRlRHJhZ2dhYmxlRWxlbWVudCA6IGZ1bmN0aW9uIChlbGVtZW50RHJhZ2dhYmxlLCBjb250ZXh0KSB7XG4gICAgICAgIFNvcnRhYmxlLmNyZWF0ZShlbGVtZW50RHJhZ2dhYmxlLCB7XG4gICAgICAgICAgICBoYW5kbGUgOiBcIi5HUGxheWVyTmFtZVwiLFxuICAgICAgICAgICAgZHJhZ2dhYmxlIDogXCIuZHJhZ2dhYmxlLWxheWVyXCIsXG4gICAgICAgICAgICBnaG9zdENsYXNzIDogXCJHUGdob3N0TGF5ZXJcIixcbiAgICAgICAgICAgIGFuaW1hdGlvbiA6IDIwMCxcbiAgICAgICAgICAgIC8vIENhbGwgZXZlbnQgZnVuY3Rpb24gb24gZHJhZyBhbmQgZHJvcFxuICAgICAgICAgICAgb25FbmQgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHBhcyB0ZXJycmlibGUsIG1haXMgaWwgZmF1dCBiaWVuIHBhc3NlciBjZSBjb250ZXh0ZS4uLlxuICAgICAgICAgICAgICAgIGNvbnRleHQuX29uRHJhZ0FuZERyb3BMYXllckNsaWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTWFpbiBjb250YWluZXIgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAqIEFkZCB1dWlkIHRvIHRoZSB0YWcgSURcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIGlkIHNlbGVjdG9yXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1aWQgLSBpZCBzZWxlY3RvciB3aXRoIGFuIHVuaXF1ZSBpZFxuICAgICovXG4gICAgX2FkZFVJRCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgdWlkID0gKHRoaXMuX3VpZCkgPyBpZCArIFwiLVwiICsgdGhpcy5fdWlkIDogaWQ7XG4gICAgICAgIHJldHVybiB1aWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIGR1IGNvbnRhaW5lciBwcmluY2lwYWwgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXIgLSBsYXllciBzd2l0Y2hlciBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJTd2l0Y2hlclwiKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1B3aWRnZXRcIjtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZHUgY29udGFpbmVyIHByaW5jaXBhbCBkXCJhZmZpY2hhZ2UgZGVzIGxheWVycyAoRE9NKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGlucHV0IC0gZWxlbWVudCBmb3IgbWluaW1pemluZy9tYXhpbWl6aW5nIHRoZSBsYXllciBzd2l0Y2hlclxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluTGF5ZXJzU2hvd0VsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIDwhLS0gSGlkZGVuIGNoZWNrYm94IGZvciBtaW5pbWl6aW5nL21heGltaXppbmcgLS0+XG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dMYXllcnNMaXN0XCIpO1xuICAgICAgICBpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIGR1IGNvbnRhaW5lciBwcmluY2lwYWwgZGVzIGxheWVycyAoRE9NKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGNvbnRhaW5lciAtIGxheWVycyBsaXN0IGNvbnRhaW5lclxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluTGF5ZXJzRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYWpvdXQgZGUgbGEgbGlzdGUgZGVzIGxheWVycyBkYW5zIGxlIGNvbnRhaW5lciBwcmluY2lwYWxcbiAgICAgICAgLy8gPGRpdiBpZD1cIkdQbGF5ZXJzTGlzdFwiIGNsYXNzPVwiR1BwYW5lbFwiPlxuICAgICAgICAvLyAgICguLi4pXG4gICAgICAgIC8vIDwvZGl2PlxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1BsYXllcnNMaXN0XCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUHBhbmVsXCI7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIGR1IGNvbnRhaW5lciBkdSBwaWN0byBkdSBjb250cm9sZSAoRE9NKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGxhYmVsXG4gICAgICovXG4gICAgX2NyZWF0ZU1haW5QaWN0b0VsZW1lbnQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBleGVtcGxlIDpcbiAgICAgICAgLy8gPCEtLSBMYWJlbCBmb3IgbWluaW1pemluZy9tYXhpbWl6aW5nIC0tPlxuICAgICAgICAvLyA8bGFiZWwgaWQ9XCJHUHNob3dMYXllcnNMaXN0UGljdG9cIiBjbGFzcz1cIkdQc2hvd0FkdmFuY2VkVG9vbFBpY3RvXCIgZm9yPVwiR1BzaG93TGF5ZXJzTGlzdFwiIHRpdGxlPVwiQWZmaWNoZXIvbWFzcXVlciBsZSBnZXN0aW9ubmFpcmUgZGUgY291Y2hlc1wiPlxuICAgICAgICAvLyAgICA8c3BhbiBpZD1cIkdQc2hvd0xheWVyc0xpc3RPcGVuXCIgY2xhc3M9XCJHUHNob3dBZHZhbmNlZFRvb2xPcGVuXCI+PC9zcGFuPjxzcGFuIGlkPVwiR1BzaG93TGF5ZXJzTGlzdENsb3NlXCI+PC9zcGFuPlxuICAgICAgICAvLyA8L2xhYmVsPlxuXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcbiAgICAgICAgbGFiZWwuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dMYXllcnNMaXN0UGljdG9cIik7XG4gICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9IFwiR1BzaG93QWR2YW5jZWRUb29sUGljdG9cIjtcbiAgICAgICAgbGFiZWwuaHRtbEZvciA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd0xheWVyc0xpc3RcIik7XG4gICAgICAgIGxhYmVsLnRpdGxlID0gXCJBZmZpY2hlci9tYXNxdWVyIGxlIGdlc3Rpb25uYWlyZSBkZSBjb3VjaGVzXCI7XG5cbiAgICAgICAgdmFyIHNwYW5PcGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93TGF5ZXJzTGlzdE9wZW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmNsYXNzTmFtZSA9IFwiR1BzaG93QWR2YW5jZWRUb29sT3BlblwiO1xuICAgICAgICBzcGFuT3Blbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQc2hvd0xheWVyc0xpc3RcIikpLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyc1tpXS5jbGFzc05hbWUgPSBcIkdQbGF5ZXJJbmZvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQbGF5ZXJJbmZvUGFuZWxcIikpLmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9QYW5lbENsb3NlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChzcGFuT3Blbik7XG5cbiAgICAgICAgdmFyIHNwYW5DbG9zZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuQ2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUHNob3dMYXllcnNMaXN0XCIpKS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJHUGxheWVySW5mb09wZW5lZFwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsYXllcnNbaV0uY2xhc3NOYW1lID0gXCJHUGxheWVySW5mb1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxmLl9hZGRVSUQoXCJHUGxheWVySW5mb1BhbmVsXCIpKS5jbGFzc05hbWUgPSBcIkdQbGF5ZXJJbmZvUGFuZWxDbG9zZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNwYW5DbG9zZS5pZCA9IHNlbGYuX2FkZFVJRChcIkdQc2hvd0xheWVyc0xpc3RDbG9zZVwiKTtcblxuICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChzcGFuQ2xvc2UpO1xuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZHUgY29udGFpbmVyIGR1IHBhbm5lYXUgZFwiaW5mb3JtYXRpb24gKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBfY3JlYXRlTWFpbkluZm9FbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBnZXN0aW9uIGR1IHBhbm5lYXUgZFwiaW5mb3JtYXRpb24gZGFucyBsZSBjb250YWluZXIgcHJpbmNpcGFsXG4gICAgICAgIC8vIDxkaXYgaWQ9XCJHUGxheWVySW5mb1BhbmVsXCIgY2xhc3M9XCJHUGxheWVySW5mb1BhbmVsQ2xvc2VkXCI+Li4uPC9kaXY+XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb1BhbmVsXCIpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUHBhbmVsIEdQbGF5ZXJJbmZvUGFuZWxDbG9zZWRcIjtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTGF5ZXIgY29udGFpbmVyICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkdSBjb250YWluZXIgZHUgbGF5ZXIgKERPTSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvcHRpb25zIGRlIGxhIGNvdWNoZSDDoCBham91dGVyIGRhbnMgbGUgbGF5ZXIgc3dpdGNoZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqLmxheWVyIC0gY291Y2hlIChvbCBvdSBsZWFmbGV0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmouaWQgLSBpZGVudGlmaWFudCBkZSBsYSBjb3VjaGUgKHBvdXIgb2wgb3UgbGVhZmxldClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqLnRpdGxlIC0gbm9tIGRlIGxhIGNvdWNoZSDDoCBhZmZpY2hlciBkYW5zIGxlIGNvbnRyb2xlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9iai5kZXNjcmlwdGlvbiAtIGRlc2NyaXB0aW9uIGRlIGxhIGNvdWNoZSDDoCBhZmZpY2hlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb2JqLnZpc2liaWxpdHkgLSB2aXNpYmlsaXTDqSBkZSBsYSBjb3VjaGUgZGFucyBsYSBjYXJ0ZSAodHJ1ZSBvciBmYWxzZSlcbiAgICAgKiBAcGFyYW0ge0Zsb2F0fSBvYmoub3BhY2l0eSAtIG9wYWNpdMOpIGRlIGxhIGNvdWNoZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIF9jcmVhdGVDb250YWluZXJMYXllckVsZW1lbnQgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIC8vIGV4ZW1wbGUgOlxuICAgICAgICAvLyA8ZGl2IGlkPVwiR1BsYXllclN3aXRjaGVyX0lEX0xheWVyMVwiIGNsYXNzPVwiR1BsYXllclN3aXRjaGVyX2xheWVyIG91dE9mUmFuZ2VcIj5cbiAgICAgICAgLy8gICAgIDwhLS0gQmFzaWMgdG9vbGJhciA6IHZpc2liaWxpdHkgLyBsYXllciBuYW1lXG4gICAgICAgIC8vICAgICBfY3JlYXRlQmFzaWNUb29sRWxlbWVudFxuICAgICAgICAvLyAgICAgICAgICAgX2NyZWF0ZUJhc2ljVG9vbFZpc2liaWxpdHlFbGVtZW50XG4gICAgICAgIC8vICAgICAgICAgICBfY3JlYXRlQmFzaWNUb29sTmFtZUVsZW1lbnRcbiAgICAgICAgLy8gICAgIC0tPlxuICAgICAgICAvLyAgICAgPCEtLSBIaWRkZW4gY2hlY2tib3ggKyBsYWJlbCBmb3Igc2hvd2luZyBhZHZhbmNlZCB0b29sYmFyXG4gICAgICAgIC8vICAgICBfY3JlYXRlQWR2YW5jZWRUb29sU2hvd0VsZW1lbnRcbiAgICAgICAgLy8gICAgIC0tPlxuICAgICAgICAvLyAgICAgPCEtLSBBZHZhbmNlZCB0b29sYmFyIDogbGF5ZXIgaW5mbyAvIG9wYWNpdHkgc2xpZGVyIC8gb3BhY2l0eSB2YWx1ZSAvIHJlbW92YWxcbiAgICAgICAgLy8gICAgIF9jcmVhdGVBZHZhbmNlZFRvb2xFbGVtZW50XG4gICAgICAgIC8vICAgICAgICAgICBfY3JlYXRlQWR2YW5jZWRUb29sRGVsZXRlRWxlbWVudFxuICAgICAgICAvLyAgICAgICAgICAgX2NyZWF0ZUFkdmFuY2VkVG9vbEluZm9ybWF0aW9uRWxlbWVudFxuICAgICAgICAvLyAgICAgICAgICAgX2NyZWF0ZUFkdmFuY2VkVG9vbE9wYWNpdHlFbGVtZW50XG4gICAgICAgIC8vICAgICAtLT5cbiAgICAgICAgLy8gPC9kaXY+XG5cbiAgICAgICAgLy8gPCEtLSBMYXllciBlbnRyeSBpbiBsYXllciBsaXN0IC0tPlxuICAgICAgICAvLyA8IS0tIEV2ZXJ5IGl0ZW0gaXMgbWFya2VkIHdpdGggbGF5ZXJJRCwgd2hpY2ggaXMgZGVmaW5lZCBhdCBsYXllciBpbXBvcnQgLS0+XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBjb250YWluZXIuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGxheWVyU3dpdGNoZXJfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJHUGxheWVyU3dpdGNoZXJfbGF5ZXIgZHJhZ2dhYmxlLWxheWVyXCI7XG5cbiAgICAgICAgLy8gYWpvdXQgZGVzIG91dGlscyBiYXNpcXVlcyAodmlzaWJpbGl0eSAvIGxheWVyIG5hbWUpXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVCYXNpY1Rvb2xFbGVtZW50KG9iaikpO1xuXG4gICAgICAgIC8vIGxpc3RlIGRlcyBvdXRpbHMgYXZhbmPDqXMgKGxheWVyIGluZm8gLyBvcGFjaXR5IHNsaWRlciAvIG9wYWNpdHkgdmFsdWUgLyByZW1vdmFsKVxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLl9jcmVhdGVBZHZhbmNlZFRvb2xTaG93RWxlbWVudChvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYXJyYXlbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWpvdXQgZGVzIG91dGlscyBhdmFuY8Opc1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlQWR2YW5jZWRUb29sRWxlbWVudChvYmopKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBMYXllciB0b29sICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIGR1IGNvbnRhaW5lciBkZXMgb3V0aWxzIGJhc2lxdWVzIGR1IGxheWVyIChET00pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb3B0aW9ucyBkZSBsYSBjb3VjaGUgw6AgYWpvdXRlciBkYW5zIGxlIGxheWVyIHN3aXRjaGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2ljVG9vbEVsZW1lbnQgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIC8vIGV4ZW1wbGUgOlxuICAgICAgICAvLyA8ZGl2IGlkPVwiR1BiYXNpY1Rvb2xzX0lEXzFcIiBjbGFzcz1cIkdQbGF5ZXJCYXNpY1Rvb2xzXCI+XG4gICAgICAgIC8vICAgICAgPCEtLSBfY3JlYXRlQmFzaWNUb29sVmlzaWJpbGl0eUVsZW1lbnQgLS0+XG4gICAgICAgIC8vICAgICAgPCEtLSBfY3JlYXRlQmFzaWNUb29sTmFtZUVsZW1lbnQgLS0+XG4gICAgICAgIC8vIDwvZGl2PlxuXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGJhc2ljVG9vbHNfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUGxheWVyQmFzaWNUb29sc1wiO1xuXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVCYXNpY1Rvb2xOYW1lRWxlbWVudChvYmopKTtcblxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLl9jcmVhdGVCYXNpY1Rvb2xWaXNpYmlsaXR5RWxlbWVudChvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoYXJyYXlbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZHUgbm9tIGR1IGxheWVyIChET00pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb3B0aW9ucyBkZSBsYSBjb3VjaGUgw6AgYWpvdXRlciBkYW5zIGxlIGxheWVyIHN3aXRjaGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2ljVG9vbE5hbWVFbGVtZW50IDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAvLyBleGVtcGxlIDpcbiAgICAgICAgLy8gPHNwYW4gaWQ9XCJHUG5hbWVfSURfTGF5ZXIxXCIgY2xhc3M9XCJHUGxheWVyTmFtZVwiIHRpdGxlPVwiUXVhcnRpZXJzIHByaW9yaXRhaXJlcyBkZSBsYSB2aWxsZVwiPlF1YXJ0aWVycyBwcmlvcml0YWlyZXMgZGUgbGEgdmlsbGU8L3NwYW4+XG4gICAgICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG5hbWVfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiR1BsYXllck5hbWVcIjtcbiAgICAgICAgc3Bhbi50aXRsZSA9IG9iai5kZXNjcmlwdGlvbiB8fCBvYmoudGl0bGU7XG4gICAgICAgIHNwYW4uaW5uZXJIVE1MID0gb2JqLnRpdGxlO1xuXG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkZSBsJ2ljb25lIGRlIHZpc2liaWxpdMOpIGR1IGxheWVyIChET00pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb3B0aW9ucyBkZSBsYSBjb3VjaGUgw6AgYWpvdXRlciBkYW5zIGxlIGxheWVyIHN3aXRjaGVyXG5cbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudFtdfSBhcnJheSBjb250YWluaW5nIGlucHV0IGFuZCBsYWJlbCBlbGVtZW50c1xuICAgICAqL1xuICAgIF9jcmVhdGVCYXNpY1Rvb2xWaXNpYmlsaXR5RWxlbWVudCA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgLy8gZXhlbXBsZSA6XG4gICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD1cIkdQdmlzaWJpbGl0eV9JRF9MYXllcjFcIiBjaGVja2VkPVwiXCI+XG4gICAgICAgIC8vIDxsYWJlbCBmb3I9XCJHUHZpc2liaWxpdHlfSURfTGF5ZXIxXCIgaWQ9XCJHUHZpc2liaWxpdHlQaWN0b19JRF9MYXllcjFcIiBjbGFzcz1cIkdQbGF5ZXJWaXNpYmlsaXR5XCIgdGl0bGU9XCJBZmZpY2hlci9tYXNxdWVyIGxhIGNvdWNoZVwiPjwvbGFiZWw+XG5cbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICB2YXIgY2hlY2tlZCA9ICh0eXBlb2Ygb2JqLnZpc2liaWxpdHkgIT09IFwidW5kZWZpbmVkXCIpID8gb2JqLnZpc2liaWxpdHkgOiB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLl9hZGRVSUQoXCJHUHZpc2liaWxpdHlfSURfXCIgKyBvYmouaWQpO1xuXG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQuaWQgPSBpZDtcbiAgICAgICAgaW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IGNoZWNrZWQ7XG5cbiAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICBsYWJlbC5odG1sRm9yID0gaWQ7XG4gICAgICAgIGxhYmVsLmlkID0gdGhpcy5fYWRkVUlEKFwiR1B2aXNpYmlsaXR5UGljdG9fSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcIkdQbGF5ZXJWaXNpYmlsaXR5XCI7XG4gICAgICAgIGxhYmVsLnRpdGxlID0gXCJBZmZpY2hlci9tYXNxdWVyIGxhIGNvdWNoZVwiO1xuXG4gICAgICAgIC8vIGFkZCBldmVudCBmb3IgdmlzaWJpbGl0eSBjaGFuZ2VcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAoaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fb25WaXNpYmlsaXR5TGF5ZXJDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpbnRlcm5ldCBleHBsb3JlclxuICAgICAgICAgICAgaW5wdXQuYXR0YWNoRXZlbnQoXG4gICAgICAgICAgICAgICAgXCJvbmNsaWNrXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fb25WaXNpYmlsaXR5TGF5ZXJDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGlucHV0KTtcbiAgICAgICAgbGlzdC5wdXNoKGxhYmVsKTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZGUgbCdhZmZpY2hhZ2UgZHUgbWVudSBkZXMgb3V0aWxzIGF2YW5jw6lzIGR1IGxheWVyIChET00pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb3B0aW9ucyBkZSBsYSBjb3VjaGUgw6AgYWpvdXRlciBkYW5zIGxlIGxheWVyIHN3aXRjaGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudFtdfSBhcnJheSBjb250YWluaW5nIGlucHV0IGFuZCBsYWJlbCBlbGVtZW50c1xuICAgICAqL1xuICAgIF9jcmVhdGVBZHZhbmNlZFRvb2xTaG93RWxlbWVudCA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiR1BzaG93QWR2YW5jZWRUb29sc19JRF9MYXllcjFcIj5cbiAgICAgICAgLy8gPGxhYmVsIGZvcj1cIkdQc2hvd0FkdmFuY2VkVG9vbHNfSURfTGF5ZXIxXCIgaWQ9XCJHUHNob3dBZHZhbmNlZFRvb2xzUGljdG9fSURfTGF5ZXIxXCIgY2xhc3M9XCJHUHNob3dNb3JlT3B0aW9ucyBHUHNob3dMYXllckFkdmFuY2VkVG9vbHNcIiB0aXRsZT1cIlBsdXMgZCdvdXRpbHNcIj48L2xhYmVsPlxuXG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgICBsYWJlbC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd0FkdmFuY2VkVG9vbHNQaWN0b19JRF9cIiArIG9iai5pZCk7XG4gICAgICAgIGxhYmVsLmh0bWxGb3IgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dBZHZhbmNlZFRvb2xzX0lEX1wiICsgb2JqLmlkKTtcbiAgICAgICAgbGFiZWwudGl0bGUgPSBcIlBsdXMgZCdvdXRpbHNcIjtcbiAgICAgICAgbGFiZWwuY2xhc3NOYW1lID0gXCJHUHNob3dNb3JlT3B0aW9ucyBHUHNob3dMYXllckFkdmFuY2VkVG9vbHNcIjtcblxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIGlucHV0LmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93QWR2YW5jZWRUb29sc19JRF9cIiArIG9iai5pZCk7XG5cbiAgICAgICAgbGlzdC5wdXNoKGlucHV0KTtcbiAgICAgICAgbGlzdC5wdXNoKGxhYmVsKTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZHUgY29udGFpbmVyIGRlcyBvdXRpbHMgYXZhbmPDqXMgZHUgbGF5ZXIgKERPTSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvcHRpb25zIGRlIGxhIGNvdWNoZSDDoCBham91dGVyIGRhbnMgbGUgbGF5ZXIgc3dpdGNoZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBfY3JlYXRlQWR2YW5jZWRUb29sRWxlbWVudCA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgLy8gZXhlbXBsZSA6XG4gICAgICAgIC8vIDxkaXYgaWQ9XCJHUGFkdmFuY2VkVG9vbHNfSURfTGF5ZXIxXCIgY2xhc3M9XCJHUGxheWVyQWR2YW5jZWRUb29sc1wiPlxuICAgICAgICAvLyAgICAgPCEtLSBfY3JlYXRlQWR2YW5jZWRUb29sRGVsZXRlRWxlbWVudCAtLT5cbiAgICAgICAgLy8gICAgIDwhLS0gX2NyZWF0ZUFkdmFuY2VkVG9vbEluZm9ybWF0aW9uRWxlbWVudCAtLT5cbiAgICAgICAgLy8gICAgIDwhLS0gX2NyZWF0ZUFkdmFuY2VkVG9vbE9wYWNpdHlFbGVtZW50IC0tPlxuICAgICAgICAvLyA8L2Rpdj5cblxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29udGFpbmVyLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BhZHZhbmNlZFRvb2xzX0lEX1wiICsgb2JqLmlkKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1BsYXllckFkdmFuY2VkVG9vbHNcIjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlQWR2YW5jZWRUb29sRGVsZXRlRWxlbWVudChvYmopKTtcblxuICAgICAgICAvLyBzaSBvbiBuJ2EgZGUgbCdpbmZvcm1hdGlvbnMgw6AgYWZmaWNoZXIsIG9uIG1ldCBlbiBwbGFjZSBjZSBjb21wb3NhbnRcbiAgICAgICAgaWYgKG9iai50aXRsZSAmJiBvYmouZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVBZHZhbmNlZFRvb2xJbmZvcm1hdGlvbkVsZW1lbnQob2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai50eXBlICE9PSBcImZlYXR1cmVcIikge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5fY3JlYXRlQWR2YW5jZWRUb29sT3BhY2l0eUVsZW1lbnQob2JqKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZGUgbCdpY29uZSBkZSBzdXBwcmVzc2lvbiBkdSBsYXllciAoRE9NKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9wdGlvbnMgZGUgbGEgY291Y2hlIMOgIGFqb3V0ZXIgZGFucyBsZSBsYXllciBzd2l0Y2hlclxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqL1xuICAgIF9jcmVhdGVBZHZhbmNlZFRvb2xEZWxldGVFbGVtZW50IDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAvLyBleGVtcGxlIDpcbiAgICAgICAgLy8gPGRpdiBpZD1cIkdQcmVtb3ZlX0lEX0xheWVyMVwiIGNsYXNzPVwiR1BsYXllclJlbW92ZVwiIHRpdGxlPVwiU3VwcHJpbWVyIGxhIGNvdWNoZVwiIG9uY2xpY2s9XCJHUGRyb3BMYXllcih0aGlzKTtcIj48L2Rpdj5cblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1ByZW1vdmVfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJHUGxheWVyUmVtb3ZlXCI7XG4gICAgICAgIGRpdi50aXRsZSA9IFwiU3VwcHJpbWVyIGxhIGNvdWNoZVwiO1xuICAgICAgICBkaXYubGF5ZXJJZCA9IG9iai5pZDtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChkaXYuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX29uRHJvcExheWVyQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXYuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmV0IGV4cGxvcmVyXG4gICAgICAgICAgICBkaXYuYXR0YWNoRXZlbnQoXG4gICAgICAgICAgICAgICAgXCJvbmNsaWNrXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fb25Ecm9wTGF5ZXJDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZGUgbCdpY29uZSBkJ2luZm9ybWF0aW9uIGR1IGxheWVyIChET00pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gb3B0aW9ucyBkZSBsYSBjb3VjaGUgw6AgYWpvdXRlciBkYW5zIGxlIGxheWVyIHN3aXRjaGVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgX2NyZWF0ZUFkdmFuY2VkVG9vbEluZm9ybWF0aW9uRWxlbWVudCA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgLy8gZXhlbXBsZSA6XG4gICAgICAgIC8vIDxkaXYgaWQ9XCJHUGluZm9fSURfTGF5ZXIxXCIgY2xhc3M9XCJHUGxheWVySW5mb1wiIHRpdGxlPVwiSW5mb3JtYXRpb25zL2zDqWdlbmRlXCIgb25jbGljaz1cIkdQb3BlbkxheWVySW5mbyh0aGlzKTtcIj48L2Rpdj5cblxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGl2LmlkID0gdGhpcy5fYWRkVUlEKFwiR1BpbmZvX0lEX1wiICsgb2JqLmlkKTtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9cIjtcbiAgICAgICAgZGl2LnRpdGxlID0gXCJJbmZvcm1hdGlvbnMvbMOpZ2VuZGVcIjtcbiAgICAgICAgZGl2LmxheWVySWQgPSBvYmouaWQ7XG4gICAgICAgIC8vIGFkZCBldmVudCBvbiBjbGlja1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChkaXYuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX29uT3BlbkxheWVySW5mb0NsaWNrKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpbnRlcm5ldCBleHBsb3JlclxuICAgICAgICAgICAgZGl2LmF0dGFjaEV2ZW50KFxuICAgICAgICAgICAgICAgIFwib25jbGlja1wiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX29uT3BlbkxheWVySW5mb0NsaWNrKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkZSBsJ2ljb25lIGRlIGdlc3Rpb24gZGUgbCdvcGFjaXTDqSBkdSBsYXllciAoRE9NKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9wdGlvbnMgZGUgbGEgY291Y2hlIMOgIGFqb3V0ZXIgZGFucyBsZSBsYXllciBzd2l0Y2hlclxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnRbXX0gYXJyYXkgb2YgdHdvIGNvbnRhaW5lcnNcbiAgICAgKi9cbiAgICBfY3JlYXRlQWR2YW5jZWRUb29sT3BhY2l0eUVsZW1lbnQgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIC8vIGV4ZW1wbGUgOlxuICAgICAgICAvLyA8ZGl2IGlkPVwiR1BvcGFjaXR5X0lEX0xheWVyMVwiIGNsYXNzPVwiR1BsYXllck9wYWNpdHlcIiB0aXRsZT1cIk9wYWNpdMOpXCI+XG4gICAgICAgIC8vICAgPGlucHV0IGlkPVwiR1BvcGFjaXR5UmFuZ2VfSURfTGF5ZXIxXCIgdHlwZT1cInJhbmdlXCIgdmFsdWU9XCIxMDBcIiBvbmlucHV0PVwiR1BjaGFuZ2VMYXllck9wYWNpdHkodGhpcyk7XCIgb25jaGFuZ2U9XCJHUGNoYW5nZUxheWVyT3BhY2l0eSh0aGlzKTtcIj5cbiAgICAgICAgLy8gPC9kaXY+XG4gICAgICAgIC8vIDxkaXYgY2xhc3M9XCJHUGxheWVyT3BhY2l0eVZhbHVlXCIgaWQ9XCJHUG9wYWNpdHlWYWx1ZURpdl9JRF9MYXllcjFcIj5cbiAgICAgICAgLy8gICA8c3BhbiBpZD1cIkdQb3BhY2l0eVZhbHVlX0lEX0xheWVyMVwiPjEwMDwvc3Bhbj5cbiAgICAgICAgLy8gICAlXG4gICAgICAgIC8vIDwvZGl2PlxuXG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgLy8gY3Vyc2V1ciBwb3VyIGNoYW5nZXIgbCdvcGFjaXTDqVxuICAgICAgICB2YXIgZGl2TyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdk8uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG9wYWNpdHlfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBkaXZPLmNsYXNzTmFtZSA9IFwiR1BsYXllck9wYWNpdHlcIjtcbiAgICAgICAgZGl2Ty50aXRsZSA9IFwiT3BhY2l0w6lcIjtcblxuICAgICAgICB2YXIgb3BhY2l0eSA9ICh0eXBlb2Ygb2JqLm9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpID8gb2JqLm9wYWNpdHkgOiAxO1xuICAgICAgICBvcGFjaXR5ID0gTWF0aC5yb3VuZChvcGFjaXR5ICogMTAwKTtcblxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGlucHV0LmlkID0gdGhpcy5fYWRkVUlEKFwiR1BvcGFjaXR5VmFsdWVEaXZfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBpbnB1dC50eXBlID0gXCJyYW5nZVwiO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IG9wYWNpdHk7XG5cbiAgICAgICAgLy8gYWRkIGV2ZW50IGZvciBvcGFjaXR5IGNoYW5nZVxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpbnB1dC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fb25DaGFuZ2VMYXllck9wYWNpdHkoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5hdHRhY2hFdmVudCkge1xuICAgICAgICAgICAgLy8gaW50ZXJuZXQgZXhwbG9yZXJcbiAgICAgICAgICAgIGlucHV0LmF0dGFjaEV2ZW50KFxuICAgICAgICAgICAgICAgIFwib25jaGFuZ2VcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9vbkNoYW5nZUxheWVyT3BhY2l0eShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX29uQ2hhbmdlTGF5ZXJPcGFjaXR5KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmV0IGV4cGxvcmVyXG4gICAgICAgICAgICBpbnB1dC5hdHRhY2hFdmVudChcbiAgICAgICAgICAgICAgICBcIm9uaW5wdXRcIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9vbkNoYW5nZUxheWVyT3BhY2l0eShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGl2Ty5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgICAgLy8gVmFsZXVyIGQnb3BhY2l0w6lcbiAgICAgICAgdmFyIGRpdkMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXZDLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BvcGFjaXR5VmFsdWVEaXZfSURfXCIgKyBvYmouaWQpO1xuICAgICAgICBkaXZDLmNsYXNzTmFtZSA9IFwiR1BsYXllck9wYWNpdHlWYWx1ZVwiO1xuXG4gICAgICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uaWQgPSB0aGlzLl9hZGRVSUQoXCJHUG9wYWNpdHlWYWx1ZV9JRF9cIiArIG9iai5pZCk7XG4gICAgICAgIHNwYW4uaW5uZXJIVE1MID0gb3BhY2l0eSArIFwiJVwiO1xuXG4gICAgICAgIGRpdkMuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cbiAgICAgICAgbGlzdC5wdXNoKGRpdk8pO1xuICAgICAgICBsaXN0LnB1c2goZGl2Qyk7XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfSxcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIExheWVyIGluZm8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRpb24gZHUgY29udGFpbmVyIGR1IGxheWVyIGluZm8gKERPTSlcbiAgICAgKlxuICAgICAqIFRPRE8gR1BsYXllckluZm9Qb3B1cCA6ID8/P1xuICAgICAqIFRPRE8gR1BsYXllckluZm9MaW5rICA6IG1ldHRyZSBlbiBmb3JtZSBsZXMgw6ljaGVsbGVzICFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvcHRpb25zIGRlIGxhIGNvdWNoZSDDoCBham91dGVyIGRhbnMgbGUgbGF5ZXIgc3dpdGNoZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXJcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29udGFpbmVyTGF5ZXJJbmZvRWxlbWVudCA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJJbmZvQ29udGVudFwiKTtcblxuICAgICAgICB2YXIgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aXRsZS5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJJbmZvVGl0bGVcIik7XG4gICAgICAgIHRpdGxlLmlubmVySFRNTCA9IG9iai50aXRsZTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlKTtcblxuICAgICAgICBpZiAob2JqLnF1aWNrbG9va1VybCkge1xuICAgICAgICAgICAgdmFyIHF1aWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHF1aWNrLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BsYXllckluZm9RdWlja2xvb2tcIik7XG4gICAgICAgICAgICBxdWljay50aXRsZSA9IFwiQWZmaWNoZXIgdW4gYXBlcsOndSBkZSBsYSBjb3VjaGVcIjtcbiAgICAgICAgICAgIHZhciByZWZxdWljayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgcmVmcXVpY2suaHJlZiA9IG9iai5xdWlja2xvb2tVcmw7XG4gICAgICAgICAgICByZWZxdWljay5hcHBlbmRDaGlsZChxdWljayk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmVmcXVpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsb3NlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY2xvc2UuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb0Nsb3NlXCIpO1xuICAgICAgICBjbG9zZS50aXRsZSA9IFwiRmVybWVyIGxhIGZlbsOqdHJlXCI7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvKiogQ2FsbCBldmVudCBmdW5jdGlvbiBvbiBjbG9zZSBjbGljayAqL1xuICAgICAgICB2YXIgb25DbG9zZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5fYWRkVUlEKFwiR1BsYXllckluZm9QYW5lbFwiKSkuY2xhc3NOYW1lID0gXCJHUGxheWVySW5mb1BhbmVsQ2xvc2VkXCI7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIkdQbGF5ZXJJbmZvT3BlbmVkXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXllcnNbaV0uY2xhc3NOYW1lID0gXCJHUGxheWVySW5mb1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgY2xvc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xvc2VDbGljayk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2UuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmV0IGV4cGxvcmVyXG4gICAgICAgICAgICBjbG9zZS5hdHRhY2hFdmVudChcIm9uY2xpY2tcIiwgb25DbG9zZUNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvc2UpO1xuXG4gICAgICAgIHZhciBkZXNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZGVzYy5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbGF5ZXJJbmZvRGVzY3JpcHRpb25cIik7XG4gICAgICAgIGRlc2MuaW5uZXJIVE1MID0gb2JqLmRlc2NyaXB0aW9uO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGVzYyk7XG5cbiAgICAgICAgaWYgKG9iai5tZXRhZGF0YSkge1xuICAgICAgICAgICAgdmFyIG10ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBtdGQuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb01ldGFkYXRhXCIpO1xuXG4gICAgICAgICAgICB2YXIgbXRkdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgbXRkdGl0bGUuY2xhc3NOYW1lID0gXCJHUGxheWVySW5mb1N1YnRpdGxlXCI7XG4gICAgICAgICAgICBtdGR0aXRsZS5pbm5lckhUTUwgPSBcIk3DqXRhZG9ubsOpZXNcIjtcbiAgICAgICAgICAgIG10ZC5hcHBlbmRDaGlsZChtdGR0aXRsZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm1ldGFkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVybG10ZCA9IG9iai5tZXRhZGF0YVtpXS51cmw7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXRkbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgbXRkbGluay5jbGFzc05hbWUgPSBcIkdQbGF5ZXJJbmZvTGlua1wiO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZm10ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgIHJlZm10ZC5ocmVmID0gdXJsbXRkO1xuICAgICAgICAgICAgICAgIHJlZm10ZC5pbm5lckhUTUwgPSB1cmxtdGQ7XG4gICAgICAgICAgICAgICAgbXRkbGluay5hcHBlbmRDaGlsZChyZWZtdGQpO1xuICAgICAgICAgICAgICAgIG10ZC5hcHBlbmRDaGlsZChtdGRsaW5rKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9iai5tZXRhZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobXRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmoubGVnZW5kcykge1xuICAgICAgICAgICAgdmFyIGxnZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBsZ2QuaWQgPSB0aGlzLl9hZGRVSUQoXCJHUGxheWVySW5mb0xlZ2VuZFwiKTtcblxuICAgICAgICAgICAgdmFyIGxnZHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGxnZHRpdGxlLmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9TdWJ0aXRsZVwiO1xuICAgICAgICAgICAgbGdkdGl0bGUuaW5uZXJIVE1MID0gXCJMw6lnZW5kZVwiO1xuICAgICAgICAgICAgbGdkLmFwcGVuZENoaWxkKGxnZHRpdGxlKTtcblxuICAgICAgICAgICAgdmFyIGxlZ2VuZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBtYXhTY2FsZSA9IG9iai5tYXhTY2FsZURlbm9taW5hdG9yIHx8IDU2MDAwMDAwMDtcblxuICAgICAgICAgICAgLy8gb24gY3LDqWUgdW4gdGFibGVhdSB0ZW1wb3JhaXJlIHBvdXIgb3Jkb25uZXIgbGVzIGzDqWdlbmRlcyBzZWxvbiBsZSBkw6lub21pbmF0ZXVyIGQnw6ljaGVsbGVcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2JqLmxlZ2VuZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluU2NhbGUgPSBvYmoubGVnZW5kc1trXS5taW5TY2FsZURlbm9taW5hdG9yO1xuICAgICAgICAgICAgICAgIGlmIChtaW5TY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IG1pblNjYWxlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIG1pblNjYWxlID0gTWF0aC5yb3VuZChwYXJzZUludChzLnN1YnN0cmluZygwLCAzKSwgMTApIC8gMTApICogTWF0aC5wb3coMTAsIHMubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluU2NhbGUgPSAyNzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZ2VuZHNbbWluU2NhbGVdID0gb2JqLmxlZ2VuZHNba107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYWxlIGluIGxlZ2VuZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kcy5oYXNPd25Qcm9wZXJ0eShzY2FsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybGxnZCA9IGxlZ2VuZHNbc2NhbGVdLnVybDtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gbidhZmZpY2hlIHBhcyBsZXMgbMOpZ2VuZGVzIHBvaW50YW50IHZlcnMgXCJub2xlZ2VuZC5qcGdcIlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVybGxnZCA9PT0gXCJzdHJpbmdcIiAmJiB1cmxsZ2QudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwibm9sZWdlbmQuanBnXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBHUGxheWVySW5mb1BvcHVwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGdkbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZ2RsaW5rLmNsYXNzTmFtZSA9IFwiR1BsYXllckluZm9MaW5rXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFNjYWxlID0gbGVnZW5kc1tzY2FsZV0ubWF4U2NhbGVEZW5vbWluYXRvciB8fCBtYXhTY2FsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZmxnZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGdkLmhyZWYgPSB1cmxsZ2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZ2QuaW5uZXJIVE1MID0gXCJEdSAxL1wiICsgc2NhbGUgKyBcIiBhdSAxL1wiICsgbWF4U2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZ2RsaW5rLmFwcGVuZENoaWxkKHJlZmxnZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZ2QuYXBwZW5kQ2hpbGQobGdkbGluayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGVnZW5kc1tzY2FsZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsZWdlbmRzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGdkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJTd2l0Y2hlckRPTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vQ29udHJvbHMvTGF5ZXJTd2l0Y2hlckRPTS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!\n * Sortable\n * @author\tRubaXa   <trash@rubaxa.org>\n * @license MIT\n */\n\n\n(function (factory) {\n\t\"use strict\";\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse if (typeof module != \"undefined\" && typeof module.exports != \"undefined\") {\n\t\tmodule.exports = factory();\n\t}\n\telse if (typeof Package !== \"undefined\") {\n\t\tSortable = factory();  // export for Meteor.js\n\t}\n\telse {\n\t\t/* jshint sub:true */\n\t\twindow[\"Sortable\"] = factory();\n\t}\n})(function () {\n\t\"use strict\";\n\n\tvar dragEl,\n\t\tparentEl,\n\t\tghostEl,\n\t\tcloneEl,\n\t\trootEl,\n\t\tnextEl,\n\n\t\tscrollEl,\n\t\tscrollParentEl,\n\n\t\tlastEl,\n\t\tlastCSS,\n\t\tlastParentCSS,\n\n\t\toldIndex,\n\t\tnewIndex,\n\n\t\tactiveGroup,\n\t\tautoScroll = {},\n\n\t\ttapEvt,\n\t\ttouchEvt,\n\n\t\tmoved,\n\n\t\t/** @const */\n\t\tRSPACE = /\\s+/g,\n\n\t\texpando = 'Sortable' + (new Date).getTime(),\n\n\t\twin = window,\n\t\tdocument = win.document,\n\t\tparseInt = win.parseInt,\n\n\t\tsupportDraggable = !!('draggable' in document.createElement('div')),\n\t\tsupportCssPointerEvents = (function (el) {\n\t\t\tel = document.createElement('x');\n\t\t\tel.style.cssText = 'pointer-events:auto';\n\t\t\treturn el.style.pointerEvents === 'auto';\n\t\t})(),\n\n\t\t_silent = false,\n\n\t\tabs = Math.abs,\n\t\tslice = [].slice,\n\n\t\ttouchDragOverListeners = [],\n\n\t\t_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {\n\t\t\t// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521\n\t\t\tif (rootEl && options.scroll) {\n\t\t\t\tvar el,\n\t\t\t\t\trect,\n\t\t\t\t\tsens = options.scrollSensitivity,\n\t\t\t\t\tspeed = options.scrollSpeed,\n\n\t\t\t\t\tx = evt.clientX,\n\t\t\t\t\ty = evt.clientY,\n\n\t\t\t\t\twinWidth = window.innerWidth,\n\t\t\t\t\twinHeight = window.innerHeight,\n\n\t\t\t\t\tvx,\n\t\t\t\t\tvy\n\t\t\t\t;\n\n\t\t\t\t// Delect scrollEl\n\t\t\t\tif (scrollParentEl !== rootEl) {\n\t\t\t\t\tscrollEl = options.scroll;\n\t\t\t\t\tscrollParentEl = rootEl;\n\n\t\t\t\t\tif (scrollEl === true) {\n\t\t\t\t\t\tscrollEl = rootEl;\n\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||\n\t\t\t\t\t\t\t\t(scrollEl.offsetHeight < scrollEl.scrollHeight)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\t\t} while (scrollEl = scrollEl.parentNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scrollEl) {\n\t\t\t\t\tel = scrollEl;\n\t\t\t\t\trect = scrollEl.getBoundingClientRect();\n\t\t\t\t\tvx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);\n\t\t\t\t\tvy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);\n\t\t\t\t}\n\n\n\t\t\t\tif (!(vx || vy)) {\n\t\t\t\t\tvx = (winWidth - x <= sens) - (x <= sens);\n\t\t\t\t\tvy = (winHeight - y <= sens) - (y <= sens);\n\n\t\t\t\t\t/* jshint expr:true */\n\t\t\t\t\t(vx || vy) && (el = win);\n\t\t\t\t}\n\n\n\t\t\t\tif (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {\n\t\t\t\t\tautoScroll.el = el;\n\t\t\t\t\tautoScroll.vx = vx;\n\t\t\t\t\tautoScroll.vy = vy;\n\n\t\t\t\t\tclearInterval(autoScroll.pid);\n\n\t\t\t\t\tif (el) {\n\t\t\t\t\t\tautoScroll.pid = setInterval(function () {\n\t\t\t\t\t\t\tif (el === win) {\n\t\t\t\t\t\t\t\twin.scrollTo(win.pageXOffset + vx * speed, win.pageYOffset + vy * speed);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvy && (el.scrollTop += vy * speed);\n\t\t\t\t\t\t\t\tvx && (el.scrollLeft += vx * speed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 24);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, 30),\n\n\t\t_prepareGroup = function (options) {\n\t\t\tvar group = options.group;\n\n\t\t\tif (!group || typeof group != 'object') {\n\t\t\t\tgroup = options.group = {name: group};\n\t\t\t}\n\n\t\t\t['pull', 'put'].forEach(function (key) {\n\t\t\t\tif (!(key in group)) {\n\t\t\t\t\tgroup[key] = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toptions.groups = ' ' + group.name + (group.put.join ? ' ' + group.put.join(' ') : '') + ' ';\n\t\t}\n\t;\n\n\n\n\t/**\n\t * @class  Sortable\n\t * @param  {HTMLElement}  el\n\t * @param  {Object}       [options]\n\t */\n\tfunction Sortable(el, options) {\n\t\tif (!(el && el.nodeType && el.nodeType === 1)) {\n\t\t\tthrow 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);\n\t\t}\n\n\t\tthis.el = el; // root element\n\t\tthis.options = options = _extend({}, options);\n\n\n\t\t// Export instance\n\t\tel[expando] = this;\n\n\n\t\t// Default options\n\t\tvar defaults = {\n\t\t\tgroup: Math.random(),\n\t\t\tsort: true,\n\t\t\tdisabled: false,\n\t\t\tstore: null,\n\t\t\thandle: null,\n\t\t\tscroll: true,\n\t\t\tscrollSensitivity: 30,\n\t\t\tscrollSpeed: 10,\n\t\t\tdraggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',\n\t\t\tghostClass: 'sortable-ghost',\n\t\t\tchosenClass: 'sortable-chosen',\n\t\t\tignore: 'a, img',\n\t\t\tfilter: null,\n\t\t\tanimation: 0,\n\t\t\tsetData: function (dataTransfer, dragEl) {\n\t\t\t\tdataTransfer.setData('Text', dragEl.textContent);\n\t\t\t},\n\t\t\tdropBubble: false,\n\t\t\tdragoverBubble: false,\n\t\t\tdataIdAttr: 'data-id',\n\t\t\tdelay: 0,\n\t\t\tforceFallback: false,\n\t\t\tfallbackClass: 'sortable-fallback',\n\t\t\tfallbackOnBody: false\n\t\t};\n\n\n\t\t// Set default options\n\t\tfor (var name in defaults) {\n\t\t\t!(name in options) && (options[name] = defaults[name]);\n\t\t}\n\n\t\t_prepareGroup(options);\n\n\t\t// Bind all private methods\n\t\tfor (var fn in this) {\n\t\t\tif (fn.charAt(0) === '_') {\n\t\t\t\tthis[fn] = this[fn].bind(this);\n\t\t\t}\n\t\t}\n\n\t\t// Setup drag mode\n\t\tthis.nativeDraggable = options.forceFallback ? false : supportDraggable;\n\n\t\t// Bind events\n\t\t_on(el, 'mousedown', this._onTapStart);\n\t\t_on(el, 'touchstart', this._onTapStart);\n\n\t\tif (this.nativeDraggable) {\n\t\t\t_on(el, 'dragover', this);\n\t\t\t_on(el, 'dragenter', this);\n\t\t}\n\n\t\ttouchDragOverListeners.push(this._onDragOver);\n\n\t\t// Restore sorting\n\t\toptions.store && this.sort(options.store.get(this));\n\t}\n\n\n\tSortable.prototype = /** @lends Sortable.prototype */ {\n\t\tconstructor: Sortable,\n\n\t\t_onTapStart: function (/** Event|TouchEvent */evt) {\n\t\t\tvar _this = this,\n\t\t\t\tel = this.el,\n\t\t\t\toptions = this.options,\n\t\t\t\ttype = evt.type,\n\t\t\t\ttouch = evt.touches && evt.touches[0],\n\t\t\t\ttarget = (touch || evt).target,\n\t\t\t\toriginalTarget = target,\n\t\t\t\tfilter = options.filter;\n\n\n\t\t\tif (type === 'mousedown' && evt.button !== 0 || options.disabled) {\n\t\t\t\treturn; // only left button or enabled\n\t\t\t}\n\n\t\t\ttarget = _closest(target, options.draggable, el);\n\n\t\t\tif (!target) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// get the index of the dragged element within its parent\n\t\t\toldIndex = _index(target);\n\n\t\t\t// Check filter\n\t\t\tif (typeof filter === 'function') {\n\t\t\t\tif (filter.call(this, evt, target, this)) {\n\t\t\t\t\t_dispatchEvent(_this, originalTarget, 'filter', target, el, oldIndex);\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (filter) {\n\t\t\t\tfilter = filter.split(',').some(function (criteria) {\n\t\t\t\t\tcriteria = _closest(originalTarget, criteria.trim(), el);\n\n\t\t\t\t\tif (criteria) {\n\t\t\t\t\t\t_dispatchEvent(_this, criteria, 'filter', target, el, oldIndex);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (filter) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\treturn; // cancel dnd\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (options.handle && !_closest(originalTarget, options.handle, el)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\t// Prepare `dragstart`\n\t\t\tthis._prepareDragStart(evt, touch, target);\n\t\t},\n\n\t\t_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target) {\n\t\t\tvar _this = this,\n\t\t\t\tel = _this.el,\n\t\t\t\toptions = _this.options,\n\t\t\t\townerDocument = el.ownerDocument,\n\t\t\t\tdragStartFn;\n\n\t\t\tif (target && !dragEl && (target.parentNode === el)) {\n\t\t\t\ttapEvt = evt;\n\n\t\t\t\trootEl = el;\n\t\t\t\tdragEl = target;\n\t\t\t\tparentEl = dragEl.parentNode;\n\t\t\t\tnextEl = dragEl.nextSibling;\n\t\t\t\tactiveGroup = options.group;\n\n\t\t\t\tdragStartFn = function () {\n\t\t\t\t\t// Delayed drag has been triggered\n\t\t\t\t\t// we can re-enable the events: touchmove/mousemove\n\t\t\t\t\t_this._disableDelayedDrag();\n\n\t\t\t\t\t// Make the element draggable\n\t\t\t\t\tdragEl.draggable = true;\n\n\t\t\t\t\t// Chosen item\n\t\t\t\t\t_toggleClass(dragEl, _this.options.chosenClass, true);\n\n\t\t\t\t\t// Bind the events: dragstart/dragend\n\t\t\t\t\t_this._triggerDragStart(touch);\n\t\t\t\t};\n\n\t\t\t\t// Disable \"draggable\"\n\t\t\t\toptions.ignore.split(',').forEach(function (criteria) {\n\t\t\t\t\t_find(dragEl, criteria.trim(), _disableDraggable);\n\t\t\t\t});\n\n\t\t\t\t_on(ownerDocument, 'mouseup', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchend', _this._onDrop);\n\t\t\t\t_on(ownerDocument, 'touchcancel', _this._onDrop);\n\n\t\t\t\tif (options.delay) {\n\t\t\t\t\t// If the user moves the pointer or let go the click or touch\n\t\t\t\t\t// before the delay has been reached:\n\t\t\t\t\t// disable the delayed drag\n\t\t\t\t\t_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchend', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);\n\t\t\t\t\t_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);\n\n\t\t\t\t\t_this._dragStartTimer = setTimeout(dragStartFn, options.delay);\n\t\t\t\t} else {\n\t\t\t\t\tdragStartFn();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_disableDelayedDrag: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\n\t\t\tclearTimeout(this._dragStartTimer);\n\t\t\t_off(ownerDocument, 'mouseup', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchend', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'mousemove', this._disableDelayedDrag);\n\t\t\t_off(ownerDocument, 'touchmove', this._disableDelayedDrag);\n\t\t},\n\n\t\t_triggerDragStart: function (/** Touch */touch) {\n\t\t\tif (touch) {\n\t\t\t\t// Touch device support\n\t\t\t\ttapEvt = {\n\t\t\t\t\ttarget: dragEl,\n\t\t\t\t\tclientX: touch.clientX,\n\t\t\t\t\tclientY: touch.clientY\n\t\t\t\t};\n\n\t\t\t\tthis._onDragStart(tapEvt, 'touch');\n\t\t\t}\n\t\t\telse if (!this.nativeDraggable) {\n\t\t\t\tthis._onDragStart(tapEvt, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_on(dragEl, 'dragend', this);\n\t\t\t\t_on(rootEl, 'dragstart', this._onDragStart);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (document.selection) {\n\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t} else {\n\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t}\n\t\t},\n\n\t\t_dragStarted: function () {\n\t\t\tif (rootEl && dragEl) {\n\t\t\t\t// Apply effect\n\t\t\t\t_toggleClass(dragEl, this.options.ghostClass, true);\n\n\t\t\t\tSortable.active = this;\n\n\t\t\t\t// Drag start event\n\t\t\t\t_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);\n\t\t\t}\n\t\t},\n\n\t\t_emulateDragOver: function () {\n\t\t\tif (touchEvt) {\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._lastX = touchEvt.clientX;\n\t\t\t\tthis._lastY = touchEvt.clientY;\n\n\t\t\t\tif (!supportCssPointerEvents) {\n\t\t\t\t\t_css(ghostEl, 'display', 'none');\n\t\t\t\t}\n\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),\n\t\t\t\t\tparent = target,\n\t\t\t\t\tgroupName = ' ' + this.options.group.name + '',\n\t\t\t\t\ti = touchDragOverListeners.length;\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (parent[expando] && parent[expando].options.groups.indexOf(groupName) > -1) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\ttouchDragOverListeners[i]({\n\t\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\n\t\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\n\t\t\t\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\t\t\t\trootEl: parent\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget = parent; // store last element\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\twhile (parent = parent.parentNode);\n\t\t\t\t}\n\n\t\t\t\tif (!supportCssPointerEvents) {\n\t\t\t\t\t_css(ghostEl, 'display', '');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t_onTouchMove: function (/**TouchEvent*/evt) {\n\t\t\tif (tapEvt) {\n\t\t\t\t// only set the status to dragging, when we are actually dragging\n\t\t\t\tif (!Sortable.active) {\n\t\t\t\t\tthis._dragStarted();\n\t\t\t\t}\n\n\t\t\t\t// as well as creating the ghost element on the document body\n\t\t\t\tthis._appendGhost();\n\n\t\t\t\tvar touch = evt.touches ? evt.touches[0] : evt,\n\t\t\t\t\tdx = touch.clientX - tapEvt.clientX,\n\t\t\t\t\tdy = touch.clientY - tapEvt.clientY,\n\t\t\t\t\ttranslate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\n\n\t\t\t\tmoved = true;\n\t\t\t\ttouchEvt = touch;\n\n\t\t\t\t_css(ghostEl, 'webkitTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'mozTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'msTransform', translate3d);\n\t\t\t\t_css(ghostEl, 'transform', translate3d);\n\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_appendGhost: function () {\n\t\t\tif (!ghostEl) {\n\t\t\t\tvar rect = dragEl.getBoundingClientRect(),\n\t\t\t\t\tcss = _css(dragEl),\n\t\t\t\t\toptions = this.options,\n\t\t\t\t\tghostRect;\n\n\t\t\t\tghostEl = dragEl.cloneNode(true);\n\n\t\t\t\t_toggleClass(ghostEl, options.ghostClass, false);\n\t\t\t\t_toggleClass(ghostEl, options.fallbackClass, true);\n\n\t\t\t\t_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));\n\t\t\t\t_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));\n\t\t\t\t_css(ghostEl, 'width', rect.width);\n\t\t\t\t_css(ghostEl, 'height', rect.height);\n\t\t\t\t_css(ghostEl, 'opacity', '0.8');\n\t\t\t\t_css(ghostEl, 'position', 'fixed');\n\t\t\t\t_css(ghostEl, 'zIndex', '100000');\n\t\t\t\t_css(ghostEl, 'pointerEvents', 'none');\n\n\t\t\t\toptions.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);\n\n\t\t\t\t// Fixing dimensions.\n\t\t\t\tghostRect = ghostEl.getBoundingClientRect();\n\t\t\t\t_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);\n\t\t\t\t_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);\n\t\t\t}\n\t\t},\n\n\t\t_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {\n\t\t\tvar dataTransfer = evt.dataTransfer,\n\t\t\t\toptions = this.options;\n\n\t\t\tthis._offUpEvents();\n\n\t\t\tif (activeGroup.pull == 'clone') {\n\t\t\t\tcloneEl = dragEl.cloneNode(true);\n\t\t\t\t_css(cloneEl, 'display', 'none');\n\t\t\t\trootEl.insertBefore(cloneEl, dragEl);\n\t\t\t}\n\n\t\t\tif (useFallback) {\n\n\t\t\t\tif (useFallback === 'touch') {\n\t\t\t\t\t// Bind touch events\n\t\t\t\t\t_on(document, 'touchmove', this._onTouchMove);\n\t\t\t\t\t_on(document, 'touchend', this._onDrop);\n\t\t\t\t\t_on(document, 'touchcancel', this._onDrop);\n\t\t\t\t} else {\n\t\t\t\t\t// Old brwoser\n\t\t\t\t\t_on(document, 'mousemove', this._onTouchMove);\n\t\t\t\t\t_on(document, 'mouseup', this._onDrop);\n\t\t\t\t}\n\n\t\t\t\tthis._loopId = setInterval(this._emulateDragOver, 50);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dataTransfer) {\n\t\t\t\t\tdataTransfer.effectAllowed = 'move';\n\t\t\t\t\toptions.setData && options.setData.call(this, dataTransfer, dragEl);\n\t\t\t\t}\n\n\t\t\t\t_on(document, 'drop', this);\n\t\t\t\tsetTimeout(this._dragStarted, 0);\n\t\t\t}\n\t\t},\n\n\t\t_onDragOver: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\ttarget,\n\t\t\t\tdragRect,\n\t\t\t\trevert,\n\t\t\t\toptions = this.options,\n\t\t\t\tgroup = options.group,\n\t\t\t\tgroupPut = group.put,\n\t\t\t\tisOwner = (activeGroup === group),\n\t\t\t\tcanSort = options.sort;\n\n\t\t\tif (evt.preventDefault !== void 0) {\n\t\t\t\tevt.preventDefault();\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation();\n\t\t\t}\n\n\t\t\tmoved = true;\n\n\t\t\tif (activeGroup && !options.disabled &&\n\t\t\t\t(isOwner\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\n\t\t\t\t\t: activeGroup.pull && groupPut && (\n\t\t\t\t\t\t(activeGroup.name === group.name) || // by Name\n\t\t\t\t\t\t(groupPut.indexOf && ~groupPut.indexOf(activeGroup.name)) // by Array\n\t\t\t\t\t)\n\t\t\t\t) &&\n\t\t\t\t(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback\n\t\t\t) {\n\t\t\t\t// Smart auto-scrolling\n\t\t\t\t_autoScroll(evt, options, this.el);\n\n\t\t\t\tif (_silent) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttarget = _closest(evt.target, options.draggable, el);\n\t\t\t\tdragRect = dragEl.getBoundingClientRect();\n\n\t\t\t\tif (revert) {\n\t\t\t\t\t_cloneHide(true);\n\n\t\t\t\t\tif (cloneEl || nextEl) {\n\t\t\t\t\t\trootEl.insertBefore(dragEl, cloneEl || nextEl);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!canSort) {\n\t\t\t\t\t\trootEl.appendChild(dragEl);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tif ((el.children.length === 0) || (el.children[0] === ghostEl) ||\n\t\t\t\t\t(el === evt.target) && (target = _ghostIsLast(el, evt))\n\t\t\t\t) {\n\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\tif (target.animated) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetRect = target.getBoundingClientRect();\n\t\t\t\t\t}\n\n\t\t\t\t\t_cloneHide(isOwner);\n\n\t\t\t\t\tif (_onMove(rootEl, el, dragEl, dragRect, target, targetRect) !== false) {\n\t\t\t\t\t\tif (!dragEl.contains(el)) {\n\t\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\t\tparentEl = el; // actualization\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._animate(dragRect, dragEl);\n\t\t\t\t\t\ttarget && this._animate(targetRect, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {\n\t\t\t\t\tif (lastEl !== target) {\n\t\t\t\t\t\tlastEl = target;\n\t\t\t\t\t\tlastCSS = _css(target);\n\t\t\t\t\t\tlastParentCSS = _css(target.parentNode);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar targetRect = target.getBoundingClientRect(),\n\t\t\t\t\t\twidth = targetRect.right - targetRect.left,\n\t\t\t\t\t\theight = targetRect.bottom - targetRect.top,\n\t\t\t\t\t\tfloating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display)\n\t\t\t\t\t\t\t|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),\n\t\t\t\t\t\tisWide = (target.offsetWidth > dragEl.offsetWidth),\n\t\t\t\t\t\tisLong = (target.offsetHeight > dragEl.offsetHeight),\n\t\t\t\t\t\thalfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,\n\t\t\t\t\t\tnextSibling = target.nextElementSibling,\n\t\t\t\t\t\tmoveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect),\n\t\t\t\t\t\tafter\n\t\t\t\t\t;\n\n\t\t\t\t\tif (moveVector !== false) {\n\t\t\t\t\t\t_silent = true;\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\n\n\t\t\t\t\t\t_cloneHide(isOwner);\n\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\n\t\t\t\t\t\t\tafter = (moveVector === 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (floating) {\n\t\t\t\t\t\t\tvar elTop = dragEl.offsetTop,\n\t\t\t\t\t\t\t\ttgTop = target.offsetTop;\n\n\t\t\t\t\t\t\tif (elTop === tgTop) {\n\t\t\t\t\t\t\t\tafter = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tafter = tgTop > elTop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tafter = (nextSibling !== dragEl) && !isLong || halfway && isLong;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dragEl.contains(el)) {\n\t\t\t\t\t\t\tif (after && !nextSibling) {\n\t\t\t\t\t\t\t\tel.appendChild(dragEl);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparentEl = dragEl.parentNode; // actualization\n\n\t\t\t\t\t\tthis._animate(dragRect, dragEl);\n\t\t\t\t\t\tthis._animate(targetRect, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_animate: function (prevRect, target) {\n\t\t\tvar ms = this.options.animation;\n\n\t\t\tif (ms) {\n\t\t\t\tvar currentRect = target.getBoundingClientRect();\n\n\t\t\t\t_css(target, 'transition', 'none');\n\t\t\t\t_css(target, 'transform', 'translate3d('\n\t\t\t\t\t+ (prevRect.left - currentRect.left) + 'px,'\n\t\t\t\t\t+ (prevRect.top - currentRect.top) + 'px,0)'\n\t\t\t\t);\n\n\t\t\t\ttarget.offsetWidth; // repaint\n\n\t\t\t\t_css(target, 'transition', 'all ' + ms + 'ms');\n\t\t\t\t_css(target, 'transform', 'translate3d(0,0,0)');\n\n\t\t\t\tclearTimeout(target.animated);\n\t\t\t\ttarget.animated = setTimeout(function () {\n\t\t\t\t\t_css(target, 'transition', '');\n\t\t\t\t\t_css(target, 'transform', '');\n\t\t\t\t\ttarget.animated = false;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t},\n\n\t\t_offUpEvents: function () {\n\t\t\tvar ownerDocument = this.el.ownerDocument;\n\n\t\t\t_off(document, 'touchmove', this._onTouchMove);\n\t\t\t_off(ownerDocument, 'mouseup', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchend', this._onDrop);\n\t\t\t_off(ownerDocument, 'touchcancel', this._onDrop);\n\t\t},\n\n\t\t_onDrop: function (/**Event*/evt) {\n\t\t\tvar el = this.el,\n\t\t\t\toptions = this.options;\n\n\t\t\tclearInterval(this._loopId);\n\t\t\tclearInterval(autoScroll.pid);\n\t\t\tclearTimeout(this._dragStartTimer);\n\n\t\t\t// Unbind events\n\t\t\t_off(document, 'mousemove', this._onTouchMove);\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(document, 'drop', this);\n\t\t\t\t_off(el, 'dragstart', this._onDragStart);\n\t\t\t}\n\n\t\t\tthis._offUpEvents();\n\n\t\t\tif (evt) {\n\t\t\t\tif (moved) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\n\t\t\t\t}\n\n\t\t\t\tghostEl && ghostEl.parentNode.removeChild(ghostEl);\n\n\t\t\t\tif (dragEl) {\n\t\t\t\t\tif (this.nativeDraggable) {\n\t\t\t\t\t\t_off(dragEl, 'dragend', this);\n\t\t\t\t\t}\n\n\t\t\t\t\t_disableDraggable(dragEl);\n\n\t\t\t\t\t// Remove class's\n\t\t\t\t\t_toggleClass(dragEl, this.options.ghostClass, false);\n\t\t\t\t\t_toggleClass(dragEl, this.options.chosenClass, false);\n\n\t\t\t\t\tif (rootEl !== parentEl) {\n\t\t\t\t\t\tnewIndex = _index(dragEl);\n\n\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t// drag from one list and drop into another\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t\t// Add event\n\t\t\t\t\t\t\t_dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t\t// Remove event\n\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Remove clone\n\t\t\t\t\t\tcloneEl && cloneEl.parentNode.removeChild(cloneEl);\n\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\n\n\t\t\t\t\t\t\tif (newIndex >= 0) {\n\t\t\t\t\t\t\t\t// drag & drop within the same list\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Sortable.active) {\n\t\t\t\t\t\tif (newIndex === null || newIndex === -1) {\n\t\t\t\t\t\t\tnewIndex = oldIndex;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);\n\n\t\t\t\t\t\t// Save sorting\n\t\t\t\t\t\tthis.save();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Nulling\n\t\t\t\trootEl =\n\t\t\t\tdragEl =\n\t\t\t\tparentEl =\n\t\t\t\tghostEl =\n\t\t\t\tnextEl =\n\t\t\t\tcloneEl =\n\n\t\t\t\tscrollEl =\n\t\t\t\tscrollParentEl =\n\n\t\t\t\ttapEvt =\n\t\t\t\ttouchEvt =\n\n\t\t\t\tmoved =\n\t\t\t\tnewIndex =\n\n\t\t\t\tlastEl =\n\t\t\t\tlastCSS =\n\n\t\t\t\tactiveGroup =\n\t\t\t\tSortable.active = null;\n\t\t\t}\n\t\t},\n\n\n\t\thandleEvent: function (/**Event*/evt) {\n\t\t\tvar type = evt.type;\n\n\t\t\tif (type === 'dragover' || type === 'dragenter') {\n\t\t\t\tif (dragEl) {\n\t\t\t\t\tthis._onDragOver(evt);\n\t\t\t\t\t_globalDragOver(evt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type === 'drop' || type === 'dragend') {\n\t\t\t\tthis._onDrop(evt);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Serializes the item into an array of string.\n\t\t * @returns {String[]}\n\t\t */\n\t\ttoArray: function () {\n\t\t\tvar order = [],\n\t\t\t\tel,\n\t\t\t\tchildren = this.el.children,\n\t\t\t\ti = 0,\n\t\t\t\tn = children.length,\n\t\t\t\toptions = this.options;\n\n\t\t\tfor (; i < n; i++) {\n\t\t\t\tel = children[i];\n\t\t\t\tif (_closest(el, options.draggable, this.el)) {\n\t\t\t\t\torder.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn order;\n\t\t},\n\n\n\t\t/**\n\t\t * Sorts the elements according to the array.\n\t\t * @param  {String[]}  order  order of the items\n\t\t */\n\t\tsort: function (order) {\n\t\t\tvar items = {}, rootEl = this.el;\n\n\t\t\tthis.toArray().forEach(function (id, i) {\n\t\t\t\tvar el = rootEl.children[i];\n\n\t\t\t\tif (_closest(el, this.options.draggable, rootEl)) {\n\t\t\t\t\titems[id] = el;\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\torder.forEach(function (id) {\n\t\t\t\tif (items[id]) {\n\t\t\t\t\trootEl.removeChild(items[id]);\n\t\t\t\t\trootEl.appendChild(items[id]);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * Save the current sorting\n\t\t */\n\t\tsave: function () {\n\t\t\tvar store = this.options.store;\n\t\t\tstore && store.set(this);\n\t\t},\n\n\n\t\t/**\n\t\t * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.\n\t\t * @param   {HTMLElement}  el\n\t\t * @param   {String}       [selector]  default: `options.draggable`\n\t\t * @returns {HTMLElement|null}\n\t\t */\n\t\tclosest: function (el, selector) {\n\t\t\treturn _closest(el, selector || this.options.draggable, this.el);\n\t\t},\n\n\n\t\t/**\n\t\t * Set/get option\n\t\t * @param   {string} name\n\t\t * @param   {*}      [value]\n\t\t * @returns {*}\n\t\t */\n\t\toption: function (name, value) {\n\t\t\tvar options = this.options;\n\n\t\t\tif (value === void 0) {\n\t\t\t\treturn options[name];\n\t\t\t} else {\n\t\t\t\toptions[name] = value;\n\n\t\t\t\tif (name === 'group') {\n\t\t\t\t\t_prepareGroup(options);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Destroy\n\t\t */\n\t\tdestroy: function () {\n\t\t\tvar el = this.el;\n\n\t\t\tel[expando] = null;\n\n\t\t\t_off(el, 'mousedown', this._onTapStart);\n\t\t\t_off(el, 'touchstart', this._onTapStart);\n\n\t\t\tif (this.nativeDraggable) {\n\t\t\t\t_off(el, 'dragover', this);\n\t\t\t\t_off(el, 'dragenter', this);\n\t\t\t}\n\n\t\t\t// Remove draggable attributes\n\t\t\tArray.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {\n\t\t\t\tel.removeAttribute('draggable');\n\t\t\t});\n\n\t\t\ttouchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);\n\n\t\t\tthis._onDrop();\n\n\t\t\tthis.el = el = null;\n\t\t}\n\t};\n\n\n\tfunction _cloneHide(state) {\n\t\tif (cloneEl && (cloneEl.state !== state)) {\n\t\t\t_css(cloneEl, 'display', state ? 'none' : '');\n\t\t\t!state && cloneEl.state && rootEl.insertBefore(cloneEl, dragEl);\n\t\t\tcloneEl.state = state;\n\t\t}\n\t}\n\n\n\tfunction _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {\n\t\tif (el) {\n\t\t\tctx = ctx || document;\n\t\t\tselector = selector.split('.');\n\n\t\t\tvar tag = selector.shift().toUpperCase(),\n\t\t\t\tre = new RegExp('\\\\s(' + selector.join('|') + ')(?=\\\\s)', 'g');\n\n\t\t\tdo {\n\t\t\t\tif (\n\t\t\t\t\t(tag === '>*' && el.parentNode === ctx) || (\n\t\t\t\t\t\t(tag === '' || el.nodeName.toUpperCase() == tag) &&\n\t\t\t\t\t\t(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn el;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (el !== ctx && (el = el.parentNode));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\tfunction _globalDragOver(/**Event*/evt) {\n\t\tif (evt.dataTransfer) {\n\t\t\tevt.dataTransfer.dropEffect = 'move';\n\t\t}\n\t\tevt.preventDefault();\n\t}\n\n\n\tfunction _on(el, event, fn) {\n\t\tel.addEventListener(event, fn, false);\n\t}\n\n\n\tfunction _off(el, event, fn) {\n\t\tel.removeEventListener(event, fn, false);\n\t}\n\n\n\tfunction _toggleClass(el, name, state) {\n\t\tif (el) {\n\t\t\tif (el.classList) {\n\t\t\t\tel.classList[state ? 'add' : 'remove'](name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar className = (' ' + el.className + ' ').replace(RSPACE, ' ').replace(' ' + name + ' ', ' ');\n\t\t\t\tel.className = (className + (state ? ' ' + name : '')).replace(RSPACE, ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction _css(el, prop, val) {\n\t\tvar style = el && el.style;\n\n\t\tif (style) {\n\t\t\tif (val === void 0) {\n\t\t\t\tif (document.defaultView && document.defaultView.getComputedStyle) {\n\t\t\t\t\tval = document.defaultView.getComputedStyle(el, '');\n\t\t\t\t}\n\t\t\t\telse if (el.currentStyle) {\n\t\t\t\t\tval = el.currentStyle;\n\t\t\t\t}\n\n\t\t\t\treturn prop === void 0 ? val : val[prop];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!(prop in style)) {\n\t\t\t\t\tprop = '-webkit-' + prop;\n\t\t\t\t}\n\n\t\t\t\tstyle[prop] = val + (typeof val === 'string' ? '' : 'px');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction _find(ctx, tagName, iterator) {\n\t\tif (ctx) {\n\t\t\tvar list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;\n\n\t\t\tif (iterator) {\n\t\t\t\tfor (; i < n; i++) {\n\t\t\t\t\titerator(list[i], i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\n\n\tfunction _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {\n\t\tvar evt = document.createEvent('Event'),\n\t\t\toptions = (sortable || rootEl[expando]).options,\n\t\t\tonName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);\n\n\t\tevt.initEvent(name, true, true);\n\n\t\tevt.to = rootEl;\n\t\tevt.from = fromEl || rootEl;\n\t\tevt.item = targetEl || rootEl;\n\t\tevt.clone = cloneEl;\n\n\t\tevt.oldIndex = startIndex;\n\t\tevt.newIndex = newIndex;\n\n\t\trootEl.dispatchEvent(evt);\n\n\t\tif (options[onName]) {\n\t\t\toptions[onName].call(sortable, evt);\n\t\t}\n\t}\n\n\n\tfunction _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect) {\n\t\tvar evt,\n\t\t\tsortable = fromEl[expando],\n\t\t\tonMoveFn = sortable.options.onMove,\n\t\t\tretVal;\n\n\t\tevt = document.createEvent('Event');\n\t\tevt.initEvent('move', true, true);\n\n\t\tevt.to = toEl;\n\t\tevt.from = fromEl;\n\t\tevt.dragged = dragEl;\n\t\tevt.draggedRect = dragRect;\n\t\tevt.related = targetEl || toEl;\n\t\tevt.relatedRect = targetRect || toEl.getBoundingClientRect();\n\n\t\tfromEl.dispatchEvent(evt);\n\n\t\tif (onMoveFn) {\n\t\t\tretVal = onMoveFn.call(sortable, evt);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\n\tfunction _disableDraggable(el) {\n\t\tel.draggable = false;\n\t}\n\n\n\tfunction _unsilent() {\n\t\t_silent = false;\n\t}\n\n\n\t/** @returns {HTMLElement|false} */\n\tfunction _ghostIsLast(el, evt) {\n\t\tvar lastEl = el.lastElementChild,\n\t\t\t\trect = lastEl.getBoundingClientRect();\n\n\t\treturn ((evt.clientY - (rect.top + rect.height) > 5) || (evt.clientX - (rect.right + rect.width) > 5)) && lastEl; // min delta\n\t}\n\n\n\t/**\n\t * Generate id\n\t * @param   {HTMLElement} el\n\t * @returns {String}\n\t * @private\n\t */\n\tfunction _generateId(el) {\n\t\tvar str = el.tagName + el.className + el.src + el.href + el.textContent,\n\t\t\ti = str.length,\n\t\t\tsum = 0;\n\n\t\twhile (i--) {\n\t\t\tsum += str.charCodeAt(i);\n\t\t}\n\n\t\treturn sum.toString(36);\n\t}\n\n\t/**\n\t * Returns the index of an element within its parent\n\t * @param  {HTMLElement} el\n\t * @return {number}\n\t */\n\tfunction _index(el) {\n\t\tvar index = 0;\n\n\t\tif (!el || !el.parentNode) {\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (el && (el = el.previousElementSibling)) {\n\t\t\tif (el.nodeName.toUpperCase() !== 'TEMPLATE') {\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfunction _throttle(callback, ms) {\n\t\tvar args, _this;\n\n\t\treturn function () {\n\t\t\tif (args === void 0) {\n\t\t\t\targs = arguments;\n\t\t\t\t_this = this;\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (args.length === 1) {\n\t\t\t\t\t\tcallback.call(_this, args[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.apply(_this, args);\n\t\t\t\t\t}\n\n\t\t\t\t\targs = void 0;\n\t\t\t\t}, ms);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction _extend(dst, src) {\n\t\tif (dst && src) {\n\t\t\tfor (var key in src) {\n\t\t\t\tif (src.hasOwnProperty(key)) {\n\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\n\n\t// Export utils\n\tSortable.utils = {\n\t\ton: _on,\n\t\toff: _off,\n\t\tcss: _css,\n\t\tfind: _find,\n\t\tis: function (el, selector) {\n\t\t\treturn !!_closest(el, selector, el);\n\t\t},\n\t\textend: _extend,\n\t\tthrottle: _throttle,\n\t\tclosest: _closest,\n\t\ttoggleClass: _toggleClass,\n\t\tindex: _index\n\t};\n\n\n\t/**\n\t * Create sortable instance\n\t * @param {HTMLElement}  el\n\t * @param {Object}      [options]\n\t */\n\tSortable.create = function (el, options) {\n\t\treturn new Sortable(el, options);\n\t};\n\n\n\t// Export\n\tSortable.version = '1.3.0';\n\treturn Sortable;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9Tb3J0YWJsZS5qcz8yZTg5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUEsZUFBZTtBQUNmLHFDQUFxQzs7O0FBR3JDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBLG1IQUFtSDtBQUNuSDs7O0FBR0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxuICogU29ydGFibGVcbiAqIEBhdXRob3JcdFJ1YmFYYSAgIDx0cmFzaEBydWJheGEub3JnPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBQYWNrYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0U29ydGFibGUgPSBmYWN0b3J5KCk7ICAvLyBleHBvcnQgZm9yIE1ldGVvci5qc1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8qIGpzaGludCBzdWI6dHJ1ZSAqL1xuXHRcdHdpbmRvd1tcIlNvcnRhYmxlXCJdID0gZmFjdG9yeSgpO1xuXHR9XG59KShmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBkcmFnRWwsXG5cdFx0cGFyZW50RWwsXG5cdFx0Z2hvc3RFbCxcblx0XHRjbG9uZUVsLFxuXHRcdHJvb3RFbCxcblx0XHRuZXh0RWwsXG5cblx0XHRzY3JvbGxFbCxcblx0XHRzY3JvbGxQYXJlbnRFbCxcblxuXHRcdGxhc3RFbCxcblx0XHRsYXN0Q1NTLFxuXHRcdGxhc3RQYXJlbnRDU1MsXG5cblx0XHRvbGRJbmRleCxcblx0XHRuZXdJbmRleCxcblxuXHRcdGFjdGl2ZUdyb3VwLFxuXHRcdGF1dG9TY3JvbGwgPSB7fSxcblxuXHRcdHRhcEV2dCxcblx0XHR0b3VjaEV2dCxcblxuXHRcdG1vdmVkLFxuXG5cdFx0LyoqIEBjb25zdCAqL1xuXHRcdFJTUEFDRSA9IC9cXHMrL2csXG5cblx0XHRleHBhbmRvID0gJ1NvcnRhYmxlJyArIChuZXcgRGF0ZSkuZ2V0VGltZSgpLFxuXG5cdFx0d2luID0gd2luZG93LFxuXHRcdGRvY3VtZW50ID0gd2luLmRvY3VtZW50LFxuXHRcdHBhcnNlSW50ID0gd2luLnBhcnNlSW50LFxuXG5cdFx0c3VwcG9ydERyYWdnYWJsZSA9ICEhKCdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSxcblx0XHRzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyA9IChmdW5jdGlvbiAoZWwpIHtcblx0XHRcdGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgneCcpO1xuXHRcdFx0ZWwuc3R5bGUuY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czphdXRvJztcblx0XHRcdHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XG5cdFx0fSkoKSxcblxuXHRcdF9zaWxlbnQgPSBmYWxzZSxcblxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNsaWNlID0gW10uc2xpY2UsXG5cblx0XHR0b3VjaERyYWdPdmVyTGlzdGVuZXJzID0gW10sXG5cblx0XHRfYXV0b1Njcm9sbCA9IF90aHJvdHRsZShmdW5jdGlvbiAoLyoqRXZlbnQqL2V2dCwgLyoqT2JqZWN0Ki9vcHRpb25zLCAvKipIVE1MRWxlbWVudCovcm9vdEVsKSB7XG5cdFx0XHQvLyBCdWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUwNTUyMVxuXHRcdFx0aWYgKHJvb3RFbCAmJiBvcHRpb25zLnNjcm9sbCkge1xuXHRcdFx0XHR2YXIgZWwsXG5cdFx0XHRcdFx0cmVjdCxcblx0XHRcdFx0XHRzZW5zID0gb3B0aW9ucy5zY3JvbGxTZW5zaXRpdml0eSxcblx0XHRcdFx0XHRzcGVlZCA9IG9wdGlvbnMuc2Nyb2xsU3BlZWQsXG5cblx0XHRcdFx0XHR4ID0gZXZ0LmNsaWVudFgsXG5cdFx0XHRcdFx0eSA9IGV2dC5jbGllbnRZLFxuXG5cdFx0XHRcdFx0d2luV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCxcblx0XHRcdFx0XHR3aW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQsXG5cblx0XHRcdFx0XHR2eCxcblx0XHRcdFx0XHR2eVxuXHRcdFx0XHQ7XG5cblx0XHRcdFx0Ly8gRGVsZWN0IHNjcm9sbEVsXG5cdFx0XHRcdGlmIChzY3JvbGxQYXJlbnRFbCAhPT0gcm9vdEVsKSB7XG5cdFx0XHRcdFx0c2Nyb2xsRWwgPSBvcHRpb25zLnNjcm9sbDtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnRFbCA9IHJvb3RFbDtcblxuXHRcdFx0XHRcdGlmIChzY3JvbGxFbCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0c2Nyb2xsRWwgPSByb290RWw7XG5cblx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0aWYgKChzY3JvbGxFbC5vZmZzZXRXaWR0aCA8IHNjcm9sbEVsLnNjcm9sbFdpZHRoKSB8fFxuXHRcdFx0XHRcdFx0XHRcdChzY3JvbGxFbC5vZmZzZXRIZWlnaHQgPCBzY3JvbGxFbC5zY3JvbGxIZWlnaHQpXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8qIGpzaGludCBib3NzOnRydWUgKi9cblx0XHRcdFx0XHRcdH0gd2hpbGUgKHNjcm9sbEVsID0gc2Nyb2xsRWwucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNjcm9sbEVsKSB7XG5cdFx0XHRcdFx0ZWwgPSBzY3JvbGxFbDtcblx0XHRcdFx0XHRyZWN0ID0gc2Nyb2xsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdFx0dnggPSAoYWJzKHJlY3QucmlnaHQgLSB4KSA8PSBzZW5zKSAtIChhYnMocmVjdC5sZWZ0IC0geCkgPD0gc2Vucyk7XG5cdFx0XHRcdFx0dnkgPSAoYWJzKHJlY3QuYm90dG9tIC0geSkgPD0gc2VucykgLSAoYWJzKHJlY3QudG9wIC0geSkgPD0gc2Vucyk7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmICghKHZ4IHx8IHZ5KSkge1xuXHRcdFx0XHRcdHZ4ID0gKHdpbldpZHRoIC0geCA8PSBzZW5zKSAtICh4IDw9IHNlbnMpO1xuXHRcdFx0XHRcdHZ5ID0gKHdpbkhlaWdodCAtIHkgPD0gc2VucykgLSAoeSA8PSBzZW5zKTtcblxuXHRcdFx0XHRcdC8qIGpzaGludCBleHByOnRydWUgKi9cblx0XHRcdFx0XHQodnggfHwgdnkpICYmIChlbCA9IHdpbik7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChhdXRvU2Nyb2xsLnZ4ICE9PSB2eCB8fCBhdXRvU2Nyb2xsLnZ5ICE9PSB2eSB8fCBhdXRvU2Nyb2xsLmVsICE9PSBlbCkge1xuXHRcdFx0XHRcdGF1dG9TY3JvbGwuZWwgPSBlbDtcblx0XHRcdFx0XHRhdXRvU2Nyb2xsLnZ4ID0gdng7XG5cdFx0XHRcdFx0YXV0b1Njcm9sbC52eSA9IHZ5O1xuXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChhdXRvU2Nyb2xsLnBpZCk7XG5cblx0XHRcdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0XHRcdGF1dG9TY3JvbGwucGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZWwgPT09IHdpbikge1xuXHRcdFx0XHRcdFx0XHRcdHdpbi5zY3JvbGxUbyh3aW4ucGFnZVhPZmZzZXQgKyB2eCAqIHNwZWVkLCB3aW4ucGFnZVlPZmZzZXQgKyB2eSAqIHNwZWVkKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2eSAmJiAoZWwuc2Nyb2xsVG9wICs9IHZ5ICogc3BlZWQpO1xuXHRcdFx0XHRcdFx0XHRcdHZ4ICYmIChlbC5zY3JvbGxMZWZ0ICs9IHZ4ICogc3BlZWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCAyNCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwgMzApLFxuXG5cdFx0X3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuXG5cdFx0XHRpZiAoIWdyb3VwIHx8IHR5cGVvZiBncm91cCAhPSAnb2JqZWN0Jykge1xuXHRcdFx0XHRncm91cCA9IG9wdGlvbnMuZ3JvdXAgPSB7bmFtZTogZ3JvdXB9O1xuXHRcdFx0fVxuXG5cdFx0XHRbJ3B1bGwnLCAncHV0J10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmICghKGtleSBpbiBncm91cCkpIHtcblx0XHRcdFx0XHRncm91cFtrZXldID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG9wdGlvbnMuZ3JvdXBzID0gJyAnICsgZ3JvdXAubmFtZSArIChncm91cC5wdXQuam9pbiA/ICcgJyArIGdyb3VwLnB1dC5qb2luKCcgJykgOiAnJykgKyAnICc7XG5cdFx0fVxuXHQ7XG5cblxuXG5cdC8qKlxuXHQgKiBAY2xhc3MgIFNvcnRhYmxlXG5cdCAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcblx0ICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cblx0ICovXG5cdGZ1bmN0aW9uIFNvcnRhYmxlKGVsLCBvcHRpb25zKSB7XG5cdFx0aWYgKCEoZWwgJiYgZWwubm9kZVR5cGUgJiYgZWwubm9kZVR5cGUgPT09IDEpKSB7XG5cdFx0XHR0aHJvdyAnU29ydGFibGU6IGBlbGAgbXVzdCBiZSBIVE1MRWxlbWVudCwgYW5kIG5vdCAnICsge30udG9TdHJpbmcuY2FsbChlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbCA9IGVsOyAvLyByb290IGVsZW1lbnRcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gX2V4dGVuZCh7fSwgb3B0aW9ucyk7XG5cblxuXHRcdC8vIEV4cG9ydCBpbnN0YW5jZVxuXHRcdGVsW2V4cGFuZG9dID0gdGhpcztcblxuXG5cdFx0Ly8gRGVmYXVsdCBvcHRpb25zXG5cdFx0dmFyIGRlZmF1bHRzID0ge1xuXHRcdFx0Z3JvdXA6IE1hdGgucmFuZG9tKCksXG5cdFx0XHRzb3J0OiB0cnVlLFxuXHRcdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXHRcdFx0c3RvcmU6IG51bGwsXG5cdFx0XHRoYW5kbGU6IG51bGwsXG5cdFx0XHRzY3JvbGw6IHRydWUsXG5cdFx0XHRzY3JvbGxTZW5zaXRpdml0eTogMzAsXG5cdFx0XHRzY3JvbGxTcGVlZDogMTAsXG5cdFx0XHRkcmFnZ2FibGU6IC9bdW9dbC9pLnRlc3QoZWwubm9kZU5hbWUpID8gJ2xpJyA6ICc+KicsXG5cdFx0XHRnaG9zdENsYXNzOiAnc29ydGFibGUtZ2hvc3QnLFxuXHRcdFx0Y2hvc2VuQ2xhc3M6ICdzb3J0YWJsZS1jaG9zZW4nLFxuXHRcdFx0aWdub3JlOiAnYSwgaW1nJyxcblx0XHRcdGZpbHRlcjogbnVsbCxcblx0XHRcdGFuaW1hdGlvbjogMCxcblx0XHRcdHNldERhdGE6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuXHRcdFx0XHRkYXRhVHJhbnNmZXIuc2V0RGF0YSgnVGV4dCcsIGRyYWdFbC50ZXh0Q29udGVudCk7XG5cdFx0XHR9LFxuXHRcdFx0ZHJvcEJ1YmJsZTogZmFsc2UsXG5cdFx0XHRkcmFnb3ZlckJ1YmJsZTogZmFsc2UsXG5cdFx0XHRkYXRhSWRBdHRyOiAnZGF0YS1pZCcsXG5cdFx0XHRkZWxheTogMCxcblx0XHRcdGZvcmNlRmFsbGJhY2s6IGZhbHNlLFxuXHRcdFx0ZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcblx0XHRcdGZhbGxiYWNrT25Cb2R5OiBmYWxzZVxuXHRcdH07XG5cblxuXHRcdC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHRmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG5cdFx0XHQhKG5hbWUgaW4gb3B0aW9ucykgJiYgKG9wdGlvbnNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXSk7XG5cdFx0fVxuXG5cdFx0X3ByZXBhcmVHcm91cChvcHRpb25zKTtcblxuXHRcdC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuXHRcdGZvciAodmFyIGZuIGluIHRoaXMpIHtcblx0XHRcdGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJykge1xuXHRcdFx0XHR0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgZHJhZyBtb2RlXG5cdFx0dGhpcy5uYXRpdmVEcmFnZ2FibGUgPSBvcHRpb25zLmZvcmNlRmFsbGJhY2sgPyBmYWxzZSA6IHN1cHBvcnREcmFnZ2FibGU7XG5cblx0XHQvLyBCaW5kIGV2ZW50c1xuXHRcdF9vbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuXHRcdF9vbihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuXHRcdGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuXHRcdFx0X29uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcblx0XHRcdF9vbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuXHRcdH1cblxuXHRcdHRvdWNoRHJhZ092ZXJMaXN0ZW5lcnMucHVzaCh0aGlzLl9vbkRyYWdPdmVyKTtcblxuXHRcdC8vIFJlc3RvcmUgc29ydGluZ1xuXHRcdG9wdGlvbnMuc3RvcmUgJiYgdGhpcy5zb3J0KG9wdGlvbnMuc3RvcmUuZ2V0KHRoaXMpKTtcblx0fVxuXG5cblx0U29ydGFibGUucHJvdG90eXBlID0gLyoqIEBsZW5kcyBTb3J0YWJsZS5wcm90b3R5cGUgKi8ge1xuXHRcdGNvbnN0cnVjdG9yOiBTb3J0YWJsZSxcblxuXHRcdF9vblRhcFN0YXJ0OiBmdW5jdGlvbiAoLyoqIEV2ZW50fFRvdWNoRXZlbnQgKi9ldnQpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXMsXG5cdFx0XHRcdGVsID0gdGhpcy5lbCxcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdFx0dHlwZSA9IGV2dC50eXBlLFxuXHRcdFx0XHR0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdLFxuXHRcdFx0XHR0YXJnZXQgPSAodG91Y2ggfHwgZXZ0KS50YXJnZXQsXG5cdFx0XHRcdG9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0LFxuXHRcdFx0XHRmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblxuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZ0LmJ1dHRvbiAhPT0gMCB8fCBvcHRpb25zLmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybjsgLy8gb25seSBsZWZ0IGJ1dHRvbiBvciBlbmFibGVkXG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldCA9IF9jbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsKTtcblxuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aGluIGl0cyBwYXJlbnRcblx0XHRcdG9sZEluZGV4ID0gX2luZGV4KHRhcmdldCk7XG5cblx0XHRcdC8vIENoZWNrIGZpbHRlclxuXHRcdFx0aWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xuXHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KF90aGlzLCBvcmlnaW5hbFRhcmdldCwgJ2ZpbHRlcicsIHRhcmdldCwgZWwsIG9sZEluZGV4KTtcblx0XHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm47IC8vIGNhbmNlbCBkbmRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZmlsdGVyKSB7XG5cdFx0XHRcdGZpbHRlciA9IGZpbHRlci5zcGxpdCgnLCcpLnNvbWUoZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG5cdFx0XHRcdFx0Y3JpdGVyaWEgPSBfY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgY3JpdGVyaWEudHJpbSgpLCBlbCk7XG5cblx0XHRcdFx0XHRpZiAoY3JpdGVyaWEpIHtcblx0XHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KF90aGlzLCBjcml0ZXJpYSwgJ2ZpbHRlcicsIHRhcmdldCwgZWwsIG9sZEluZGV4KTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGZpbHRlcikge1xuXHRcdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybjsgLy8gY2FuY2VsIGRuZFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKG9wdGlvbnMuaGFuZGxlICYmICFfY2xvc2VzdChvcmlnaW5hbFRhcmdldCwgb3B0aW9ucy5oYW5kbGUsIGVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gUHJlcGFyZSBgZHJhZ3N0YXJ0YFxuXHRcdFx0dGhpcy5fcHJlcGFyZURyYWdTdGFydChldnQsIHRvdWNoLCB0YXJnZXQpO1xuXHRcdH0sXG5cblx0XHRfcHJlcGFyZURyYWdTdGFydDogZnVuY3Rpb24gKC8qKiBFdmVudCAqL2V2dCwgLyoqIFRvdWNoICovdG91Y2gsIC8qKiBIVE1MRWxlbWVudCAqL3RhcmdldCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcyxcblx0XHRcdFx0ZWwgPSBfdGhpcy5lbCxcblx0XHRcdFx0b3B0aW9ucyA9IF90aGlzLm9wdGlvbnMsXG5cdFx0XHRcdG93bmVyRG9jdW1lbnQgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRkcmFnU3RhcnRGbjtcblxuXHRcdFx0aWYgKHRhcmdldCAmJiAhZHJhZ0VsICYmICh0YXJnZXQucGFyZW50Tm9kZSA9PT0gZWwpKSB7XG5cdFx0XHRcdHRhcEV2dCA9IGV2dDtcblxuXHRcdFx0XHRyb290RWwgPSBlbDtcblx0XHRcdFx0ZHJhZ0VsID0gdGFyZ2V0O1xuXHRcdFx0XHRwYXJlbnRFbCA9IGRyYWdFbC5wYXJlbnROb2RlO1xuXHRcdFx0XHRuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG5cdFx0XHRcdGFjdGl2ZUdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuXHRcdFx0XHRkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG5cdFx0XHRcdFx0Ly8gd2UgY2FuIHJlLWVuYWJsZSB0aGUgZXZlbnRzOiB0b3VjaG1vdmUvbW91c2Vtb3ZlXG5cdFx0XHRcdFx0X3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSB0aGUgZWxlbWVudCBkcmFnZ2FibGVcblx0XHRcdFx0XHRkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdC8vIENob3NlbiBpdGVtXG5cdFx0XHRcdFx0X3RvZ2dsZUNsYXNzKGRyYWdFbCwgX3RoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvLyBCaW5kIHRoZSBldmVudHM6IGRyYWdzdGFydC9kcmFnZW5kXG5cdFx0XHRcdFx0X3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQodG91Y2gpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIERpc2FibGUgXCJkcmFnZ2FibGVcIlxuXHRcdFx0XHRvcHRpb25zLmlnbm9yZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG5cdFx0XHRcdFx0X2ZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X29uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG5cdFx0XHRcdF9vbihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCBfdGhpcy5fb25Ecm9wKTtcblx0XHRcdFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xuXG5cdFx0XHRcdGlmIChvcHRpb25zLmRlbGF5KSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuXHRcdFx0XHRcdC8vIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGJlZW4gcmVhY2hlZDpcblx0XHRcdFx0XHQvLyBkaXNhYmxlIHRoZSBkZWxheWVkIGRyYWdcblx0XHRcdFx0XHRfb24ob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcblx0XHRcdFx0XHRfb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG5cdFx0XHRcdFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuXHRcdFx0XHRcdF9vbihvd25lckRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG5cdFx0XHRcdFx0X29uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcblxuXHRcdFx0XHRcdF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRyYWdTdGFydEZuKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9kcmFnU3RhcnRUaW1lcik7XG5cdFx0XHRfb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcblx0XHRcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcblx0XHRcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcblx0XHRcdF9vZmYob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG5cdFx0XHRfb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuXHRcdH0sXG5cblx0XHRfdHJpZ2dlckRyYWdTdGFydDogZnVuY3Rpb24gKC8qKiBUb3VjaCAqL3RvdWNoKSB7XG5cdFx0XHRpZiAodG91Y2gpIHtcblx0XHRcdFx0Ly8gVG91Y2ggZGV2aWNlIHN1cHBvcnRcblx0XHRcdFx0dGFwRXZ0ID0ge1xuXHRcdFx0XHRcdHRhcmdldDogZHJhZ0VsLFxuXHRcdFx0XHRcdGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG5cdFx0XHRcdFx0Y2xpZW50WTogdG91Y2guY2xpZW50WVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuX29uRHJhZ1N0YXJ0KHRhcEV2dCwgJ3RvdWNoJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICghdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcblx0XHRcdFx0dGhpcy5fb25EcmFnU3RhcnQodGFwRXZ0LCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfb24oZHJhZ0VsLCAnZHJhZ2VuZCcsIHRoaXMpO1xuXHRcdFx0XHRfb24ocm9vdEVsLCAnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2RyYWdTdGFydGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuXHRcdFx0XHQvLyBBcHBseSBlZmZlY3Rcblx0XHRcdFx0X3RvZ2dsZUNsYXNzKGRyYWdFbCwgdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuXG5cdFx0XHRcdFNvcnRhYmxlLmFjdGl2ZSA9IHRoaXM7XG5cblx0XHRcdFx0Ly8gRHJhZyBzdGFydCBldmVudFxuXHRcdFx0XHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdzdGFydCcsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0b3VjaEV2dCkge1xuXHRcdFx0XHRpZiAodGhpcy5fbGFzdFggPT09IHRvdWNoRXZ0LmNsaWVudFggJiYgdGhpcy5fbGFzdFkgPT09IHRvdWNoRXZ0LmNsaWVudFkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XG5cdFx0XHRcdHRoaXMuX2xhc3RZID0gdG91Y2hFdnQuY2xpZW50WTtcblxuXHRcdFx0XHRpZiAoIXN1cHBvcnRDc3NQb2ludGVyRXZlbnRzKSB7XG5cdFx0XHRcdFx0X2NzcyhnaG9zdEVsLCAnZGlzcGxheScsICdub25lJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKSxcblx0XHRcdFx0XHRwYXJlbnQgPSB0YXJnZXQsXG5cdFx0XHRcdFx0Z3JvdXBOYW1lID0gJyAnICsgdGhpcy5vcHRpb25zLmdyb3VwLm5hbWUgKyAnJyxcblx0XHRcdFx0XHRpID0gdG91Y2hEcmFnT3Zlckxpc3RlbmVycy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdGlmIChwYXJlbnRbZXhwYW5kb10gJiYgcGFyZW50W2V4cGFuZG9dLm9wdGlvbnMuZ3JvdXBzLmluZGV4T2YoZ3JvdXBOYW1lKSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0XHRcdFx0XHR0b3VjaERyYWdPdmVyTGlzdGVuZXJzW2ldKHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsaWVudFg6IHRvdWNoRXZ0LmNsaWVudFgsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGllbnRZOiB0b3VjaEV2dC5jbGllbnRZLFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0OiB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdFx0XHRyb290RWw6IHBhcmVudFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhcmdldCA9IHBhcmVudDsgLy8gc3RvcmUgbGFzdCBlbGVtZW50XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8qIGpzaGludCBib3NzOnRydWUgKi9cblx0XHRcdFx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cykge1xuXHRcdFx0XHRcdF9jc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHRfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uICgvKipUb3VjaEV2ZW50Ki9ldnQpIHtcblx0XHRcdGlmICh0YXBFdnQpIHtcblx0XHRcdFx0Ly8gb25seSBzZXQgdGhlIHN0YXR1cyB0byBkcmFnZ2luZywgd2hlbiB3ZSBhcmUgYWN0dWFsbHkgZHJhZ2dpbmdcblx0XHRcdFx0aWYgKCFTb3J0YWJsZS5hY3RpdmUpIHtcblx0XHRcdFx0XHR0aGlzLl9kcmFnU3RhcnRlZCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYXMgd2VsbCBhcyBjcmVhdGluZyB0aGUgZ2hvc3QgZWxlbWVudCBvbiB0aGUgZG9jdW1lbnQgYm9keVxuXHRcdFx0XHR0aGlzLl9hcHBlbmRHaG9zdCgpO1xuXG5cdFx0XHRcdHZhciB0b3VjaCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQsXG5cdFx0XHRcdFx0ZHggPSB0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFgsXG5cdFx0XHRcdFx0ZHkgPSB0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFksXG5cdFx0XHRcdFx0dHJhbnNsYXRlM2QgPSBldnQudG91Y2hlcyA/ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsJyArIGR5ICsgJ3B4LDApJyA6ICd0cmFuc2xhdGUoJyArIGR4ICsgJ3B4LCcgKyBkeSArICdweCknO1xuXG5cdFx0XHRcdG1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0dG91Y2hFdnQgPSB0b3VjaDtcblxuXHRcdFx0XHRfY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XG5cdFx0XHRcdF9jc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCB0cmFuc2xhdGUzZCk7XG5cdFx0XHRcdF9jc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZTNkKTtcblxuXHRcdFx0XHRldnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2FwcGVuZEdob3N0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIWdob3N0RWwpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBkcmFnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdFx0XHRcdFx0Y3NzID0gX2NzcyhkcmFnRWwpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdFx0Z2hvc3RSZWN0O1xuXG5cdFx0XHRcdGdob3N0RWwgPSBkcmFnRWwuY2xvbmVOb2RlKHRydWUpO1xuXG5cdFx0XHRcdF90b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcblx0XHRcdFx0X3RvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG5cblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAndG9wJywgcmVjdC50b3AgLSBwYXJzZUludChjc3MubWFyZ2luVG9wLCAxMCkpO1xuXHRcdFx0XHRfY3NzKGdob3N0RWwsICdsZWZ0JywgcmVjdC5sZWZ0IC0gcGFyc2VJbnQoY3NzLm1hcmdpbkxlZnQsIDEwKSk7XG5cdFx0XHRcdF9jc3MoZ2hvc3RFbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG5cdFx0XHRcdF9jc3MoZ2hvc3RFbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAnb3BhY2l0eScsICcwLjgnKTtcblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAncG9zaXRpb24nLCAnZml4ZWQnKTtcblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAnekluZGV4JywgJzEwMDAwMCcpO1xuXHRcdFx0XHRfY3NzKGdob3N0RWwsICdwb2ludGVyRXZlbnRzJywgJ25vbmUnKTtcblxuXHRcdFx0XHRvcHRpb25zLmZhbGxiYWNrT25Cb2R5ICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZ2hvc3RFbCkgfHwgcm9vdEVsLmFwcGVuZENoaWxkKGdob3N0RWwpO1xuXG5cdFx0XHRcdC8vIEZpeGluZyBkaW1lbnNpb25zLlxuXHRcdFx0XHRnaG9zdFJlY3QgPSBnaG9zdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRfY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGggKiAyIC0gZ2hvc3RSZWN0LndpZHRoKTtcblx0XHRcdFx0X2NzcyhnaG9zdEVsLCAnaGVpZ2h0JywgcmVjdC5oZWlnaHQgKiAyIC0gZ2hvc3RSZWN0LmhlaWdodCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9vbkRyYWdTdGFydDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQsIC8qKmJvb2xlYW4qL3VzZUZhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZGF0YVRyYW5zZmVyID0gZXZ0LmRhdGFUcmFuc2Zlcixcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0dGhpcy5fb2ZmVXBFdmVudHMoKTtcblxuXHRcdFx0aWYgKGFjdGl2ZUdyb3VwLnB1bGwgPT0gJ2Nsb25lJykge1xuXHRcdFx0XHRjbG9uZUVsID0gZHJhZ0VsLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0X2NzcyhjbG9uZUVsLCAnZGlzcGxheScsICdub25lJyk7XG5cdFx0XHRcdHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmVFbCwgZHJhZ0VsKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHVzZUZhbGxiYWNrKSB7XG5cblx0XHRcdFx0aWYgKHVzZUZhbGxiYWNrID09PSAndG91Y2gnKSB7XG5cdFx0XHRcdFx0Ly8gQmluZCB0b3VjaCBldmVudHNcblx0XHRcdFx0XHRfb24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0XHRcdFx0X29uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuXHRcdFx0XHRcdF9vbihkb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBPbGQgYnJ3b3NlclxuXHRcdFx0XHRcdF9vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcblx0XHRcdFx0XHRfb24oZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2xvb3BJZCA9IHNldEludGVydmFsKHRoaXMuX2VtdWxhdGVEcmFnT3ZlciwgNTApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChkYXRhVHJhbnNmZXIpIHtcblx0XHRcdFx0XHRkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcblx0XHRcdFx0XHRvcHRpb25zLnNldERhdGEgJiYgb3B0aW9ucy5zZXREYXRhLmNhbGwodGhpcywgZGF0YVRyYW5zZmVyLCBkcmFnRWwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X29uKGRvY3VtZW50LCAnZHJvcCcsIHRoaXMpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KHRoaXMuX2RyYWdTdGFydGVkLCAwKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X29uRHJhZ092ZXI6IGZ1bmN0aW9uICgvKipFdmVudCovZXZ0KSB7XG5cdFx0XHR2YXIgZWwgPSB0aGlzLmVsLFxuXHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdGRyYWdSZWN0LFxuXHRcdFx0XHRyZXZlcnQsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRcdGdyb3VwID0gb3B0aW9ucy5ncm91cCxcblx0XHRcdFx0Z3JvdXBQdXQgPSBncm91cC5wdXQsXG5cdFx0XHRcdGlzT3duZXIgPSAoYWN0aXZlR3JvdXAgPT09IGdyb3VwKSxcblx0XHRcdFx0Y2FuU29ydCA9IG9wdGlvbnMuc29ydDtcblxuXHRcdFx0aWYgKGV2dC5wcmV2ZW50RGVmYXVsdCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHQhb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdG1vdmVkID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGFjdGl2ZUdyb3VwICYmICFvcHRpb25zLmRpc2FibGVkICYmXG5cdFx0XHRcdChpc093bmVyXG5cdFx0XHRcdFx0PyBjYW5Tb3J0IHx8IChyZXZlcnQgPSAhcm9vdEVsLmNvbnRhaW5zKGRyYWdFbCkpIC8vIFJldmVydGluZyBpdGVtIGludG8gdGhlIG9yaWdpbmFsIGxpc3Rcblx0XHRcdFx0XHQ6IGFjdGl2ZUdyb3VwLnB1bGwgJiYgZ3JvdXBQdXQgJiYgKFxuXHRcdFx0XHRcdFx0KGFjdGl2ZUdyb3VwLm5hbWUgPT09IGdyb3VwLm5hbWUpIHx8IC8vIGJ5IE5hbWVcblx0XHRcdFx0XHRcdChncm91cFB1dC5pbmRleE9mICYmIH5ncm91cFB1dC5pbmRleE9mKGFjdGl2ZUdyb3VwLm5hbWUpKSAvLyBieSBBcnJheVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KSAmJlxuXHRcdFx0XHQoZXZ0LnJvb3RFbCA9PT0gdm9pZCAwIHx8IGV2dC5yb290RWwgPT09IHRoaXMuZWwpIC8vIHRvdWNoIGZhbGxiYWNrXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gU21hcnQgYXV0by1zY3JvbGxpbmdcblx0XHRcdFx0X2F1dG9TY3JvbGwoZXZ0LCBvcHRpb25zLCB0aGlzLmVsKTtcblxuXHRcdFx0XHRpZiAoX3NpbGVudCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldCA9IF9jbG9zZXN0KGV2dC50YXJnZXQsIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCk7XG5cdFx0XHRcdGRyYWdSZWN0ID0gZHJhZ0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdGlmIChyZXZlcnQpIHtcblx0XHRcdFx0XHRfY2xvbmVIaWRlKHRydWUpO1xuXG5cdFx0XHRcdFx0aWYgKGNsb25lRWwgfHwgbmV4dEVsKSB7XG5cdFx0XHRcdFx0XHRyb290RWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgY2xvbmVFbCB8fCBuZXh0RWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICghY2FuU29ydCkge1xuXHRcdFx0XHRcdFx0cm9vdEVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoKGVsLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgfHwgKGVsLmNoaWxkcmVuWzBdID09PSBnaG9zdEVsKSB8fFxuXHRcdFx0XHRcdChlbCA9PT0gZXZ0LnRhcmdldCkgJiYgKHRhcmdldCA9IF9naG9zdElzTGFzdChlbCwgZXZ0KSlcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmFuaW1hdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfY2xvbmVIaWRlKGlzT3duZXIpO1xuXG5cdFx0XHRcdFx0aWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGlmICghZHJhZ0VsLmNvbnRhaW5zKGVsKSkge1xuXHRcdFx0XHRcdFx0XHRlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuXHRcdFx0XHRcdFx0XHRwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGUoZHJhZ1JlY3QsIGRyYWdFbCk7XG5cdFx0XHRcdFx0XHR0YXJnZXQgJiYgdGhpcy5fYW5pbWF0ZSh0YXJnZXRSZWN0LCB0YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0YXJnZXQgJiYgIXRhcmdldC5hbmltYXRlZCAmJiB0YXJnZXQgIT09IGRyYWdFbCAmJiAodGFyZ2V0LnBhcmVudE5vZGVbZXhwYW5kb10gIT09IHZvaWQgMCkpIHtcblx0XHRcdFx0XHRpZiAobGFzdEVsICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0XHRcdGxhc3RFbCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdGxhc3RDU1MgPSBfY3NzKHRhcmdldCk7XG5cdFx0XHRcdFx0XHRsYXN0UGFyZW50Q1NTID0gX2Nzcyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHR2YXIgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcblx0XHRcdFx0XHRcdHdpZHRoID0gdGFyZ2V0UmVjdC5yaWdodCAtIHRhcmdldFJlY3QubGVmdCxcblx0XHRcdFx0XHRcdGhlaWdodCA9IHRhcmdldFJlY3QuYm90dG9tIC0gdGFyZ2V0UmVjdC50b3AsXG5cdFx0XHRcdFx0XHRmbG9hdGluZyA9IC9sZWZ0fHJpZ2h0fGlubGluZS8udGVzdChsYXN0Q1NTLmNzc0Zsb2F0ICsgbGFzdENTUy5kaXNwbGF5KVxuXHRcdFx0XHRcdFx0XHR8fCAobGFzdFBhcmVudENTUy5kaXNwbGF5ID09ICdmbGV4JyAmJiBsYXN0UGFyZW50Q1NTWydmbGV4LWRpcmVjdGlvbiddLmluZGV4T2YoJ3JvdycpID09PSAwKSxcblx0XHRcdFx0XHRcdGlzV2lkZSA9ICh0YXJnZXQub2Zmc2V0V2lkdGggPiBkcmFnRWwub2Zmc2V0V2lkdGgpLFxuXHRcdFx0XHRcdFx0aXNMb25nID0gKHRhcmdldC5vZmZzZXRIZWlnaHQgPiBkcmFnRWwub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdGhhbGZ3YXkgPSAoZmxvYXRpbmcgPyAoZXZ0LmNsaWVudFggLSB0YXJnZXRSZWN0LmxlZnQpIC8gd2lkdGggOiAoZXZ0LmNsaWVudFkgLSB0YXJnZXRSZWN0LnRvcCkgLyBoZWlnaHQpID4gMC41LFxuXHRcdFx0XHRcdFx0bmV4dFNpYmxpbmcgPSB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLFxuXHRcdFx0XHRcdFx0bW92ZVZlY3RvciA9IF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0KSxcblx0XHRcdFx0XHRcdGFmdGVyXG5cdFx0XHRcdFx0O1xuXG5cdFx0XHRcdFx0aWYgKG1vdmVWZWN0b3IgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRfc2lsZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XG5cblx0XHRcdFx0XHRcdF9jbG9uZUhpZGUoaXNPd25lcik7XG5cblx0XHRcdFx0XHRcdGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGFmdGVyID0gKG1vdmVWZWN0b3IgPT09IDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoZmxvYXRpbmcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVsVG9wID0gZHJhZ0VsLm9mZnNldFRvcCxcblx0XHRcdFx0XHRcdFx0XHR0Z1RvcCA9IHRhcmdldC5vZmZzZXRUb3A7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGVsVG9wID09PSB0Z1RvcCkge1xuXHRcdFx0XHRcdFx0XHRcdGFmdGVyID0gKHRhcmdldC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09PSBkcmFnRWwpICYmICFpc1dpZGUgfHwgaGFsZndheSAmJiBpc1dpZGU7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0YWZ0ZXIgPSB0Z1RvcCA+IGVsVG9wO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhZnRlciA9IChuZXh0U2libGluZyAhPT0gZHJhZ0VsKSAmJiAhaXNMb25nIHx8IGhhbGZ3YXkgJiYgaXNMb25nO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIWRyYWdFbC5jb250YWlucyhlbCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFmdGVyICYmICFuZXh0U2libGluZykge1xuXHRcdFx0XHRcdFx0XHRcdGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgYWZ0ZXIgPyBuZXh0U2libGluZyA6IHRhcmdldCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuXG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRlKGRyYWdSZWN0LCBkcmFnRWwpO1xuXHRcdFx0XHRcdFx0dGhpcy5fYW5pbWF0ZSh0YXJnZXRSZWN0LCB0YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYW5pbWF0ZTogZnVuY3Rpb24gKHByZXZSZWN0LCB0YXJnZXQpIHtcblx0XHRcdHZhciBtcyA9IHRoaXMub3B0aW9ucy5hbmltYXRpb247XG5cblx0XHRcdGlmIChtcykge1xuXHRcdFx0XHR2YXIgY3VycmVudFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0X2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJ25vbmUnKTtcblx0XHRcdFx0X2Nzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJ1xuXHRcdFx0XHRcdCsgKHByZXZSZWN0LmxlZnQgLSBjdXJyZW50UmVjdC5sZWZ0KSArICdweCwnXG5cdFx0XHRcdFx0KyAocHJldlJlY3QudG9wIC0gY3VycmVudFJlY3QudG9wKSArICdweCwwKSdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0YXJnZXQub2Zmc2V0V2lkdGg7IC8vIHJlcGFpbnRcblxuXHRcdFx0XHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnYWxsICcgKyBtcyArICdtcycpO1xuXHRcdFx0XHRfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUzZCgwLDAsMCknKTtcblxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcblx0XHRcdFx0dGFyZ2V0LmFuaW1hdGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0X2Nzcyh0YXJnZXQsICd0cmFuc2l0aW9uJywgJycpO1xuXHRcdFx0XHRcdF9jc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuXHRcdFx0XHRcdHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR9LCBtcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9vZmZVcEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmVsLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdF9vZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG5cdFx0XHRfb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Ecm9wKTtcblx0XHRcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ecm9wKTtcblx0XHRcdF9vZmYob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25Ecm9wKTtcblx0XHR9LFxuXG5cdFx0X29uRHJvcDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpIHtcblx0XHRcdHZhciBlbCA9IHRoaXMuZWwsXG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcblx0XHRcdGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbC5waWQpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2RyYWdTdGFydFRpbWVyKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGV2ZW50c1xuXHRcdFx0X29mZihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcblxuXHRcdFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdF9vZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG5cdFx0XHRcdF9vZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX29mZlVwRXZlbnRzKCk7XG5cblx0XHRcdGlmIChldnQpIHtcblx0XHRcdFx0aWYgKG1vdmVkKSB7XG5cdFx0XHRcdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0IW9wdGlvbnMuZHJvcEJ1YmJsZSAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnaG9zdEVsICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcblxuXHRcdFx0XHRpZiAoZHJhZ0VsKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdFx0XHRfb2ZmKGRyYWdFbCwgJ2RyYWdlbmQnLCB0aGlzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZGlzYWJsZURyYWdnYWJsZShkcmFnRWwpO1xuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGNsYXNzJ3Ncblx0XHRcdFx0XHRfdG9nZ2xlQ2xhc3MoZHJhZ0VsLCB0aGlzLm9wdGlvbnMuZ2hvc3RDbGFzcywgZmFsc2UpO1xuXHRcdFx0XHRcdF90b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuXG5cdFx0XHRcdFx0aWYgKHJvb3RFbCAhPT0gcGFyZW50RWwpIHtcblx0XHRcdFx0XHRcdG5ld0luZGV4ID0gX2luZGV4KGRyYWdFbCk7XG5cblx0XHRcdFx0XHRcdGlmIChuZXdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGRyYWcgZnJvbSBvbmUgbGlzdCBhbmQgZHJvcCBpbnRvIGFub3RoZXJcblx0XHRcdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQobnVsbCwgcGFyZW50RWwsICdzb3J0JywgZHJhZ0VsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XG5cdFx0XHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ3NvcnQnLCBkcmFnRWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBZGQgZXZlbnRcblx0XHRcdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQobnVsbCwgcGFyZW50RWwsICdhZGQnLCBkcmFnRWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZXZlbnRcblx0XHRcdFx0XHRcdFx0X2Rpc3BhdGNoRXZlbnQodGhpcywgcm9vdEVsLCAncmVtb3ZlJywgZHJhZ0VsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGNsb25lXG5cdFx0XHRcdFx0XHRjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcblxuXHRcdFx0XHRcdFx0aWYgKGRyYWdFbC5uZXh0U2libGluZyAhPT0gbmV4dEVsKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXHRcdFx0XHRcdFx0XHRuZXdJbmRleCA9IF9pbmRleChkcmFnRWwpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChuZXdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZHJhZyAmIGRyb3Agd2l0aGluIHRoZSBzYW1lIGxpc3Rcblx0XHRcdFx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICd1cGRhdGUnLCBkcmFnRWwsIHJvb3RFbCwgb2xkSW5kZXgsIG5ld0luZGV4KTtcblx0XHRcdFx0XHRcdFx0XHRfZGlzcGF0Y2hFdmVudCh0aGlzLCByb290RWwsICdzb3J0JywgZHJhZ0VsLCByb290RWwsIG9sZEluZGV4LCBuZXdJbmRleCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoU29ydGFibGUuYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRpZiAobmV3SW5kZXggPT09IG51bGwgfHwgbmV3SW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdG5ld0luZGV4ID0gb2xkSW5kZXg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9kaXNwYXRjaEV2ZW50KHRoaXMsIHJvb3RFbCwgJ2VuZCcsIGRyYWdFbCwgcm9vdEVsLCBvbGRJbmRleCwgbmV3SW5kZXgpO1xuXG5cdFx0XHRcdFx0XHQvLyBTYXZlIHNvcnRpbmdcblx0XHRcdFx0XHRcdHRoaXMuc2F2ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE51bGxpbmdcblx0XHRcdFx0cm9vdEVsID1cblx0XHRcdFx0ZHJhZ0VsID1cblx0XHRcdFx0cGFyZW50RWwgPVxuXHRcdFx0XHRnaG9zdEVsID1cblx0XHRcdFx0bmV4dEVsID1cblx0XHRcdFx0Y2xvbmVFbCA9XG5cblx0XHRcdFx0c2Nyb2xsRWwgPVxuXHRcdFx0XHRzY3JvbGxQYXJlbnRFbCA9XG5cblx0XHRcdFx0dGFwRXZ0ID1cblx0XHRcdFx0dG91Y2hFdnQgPVxuXG5cdFx0XHRcdG1vdmVkID1cblx0XHRcdFx0bmV3SW5kZXggPVxuXG5cdFx0XHRcdGxhc3RFbCA9XG5cdFx0XHRcdGxhc3RDU1MgPVxuXG5cdFx0XHRcdGFjdGl2ZUdyb3VwID1cblx0XHRcdFx0U29ydGFibGUuYWN0aXZlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cblx0XHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKC8qKkV2ZW50Ki9ldnQpIHtcblx0XHRcdHZhciB0eXBlID0gZXZ0LnR5cGU7XG5cblx0XHRcdGlmICh0eXBlID09PSAnZHJhZ292ZXInIHx8IHR5cGUgPT09ICdkcmFnZW50ZXInKSB7XG5cdFx0XHRcdGlmIChkcmFnRWwpIHtcblx0XHRcdFx0XHR0aGlzLl9vbkRyYWdPdmVyKGV2dCk7XG5cdFx0XHRcdFx0X2dsb2JhbERyYWdPdmVyKGV2dCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGUgPT09ICdkcm9wJyB8fCB0eXBlID09PSAnZHJhZ2VuZCcpIHtcblx0XHRcdFx0dGhpcy5fb25Ecm9wKGV2dCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU2VyaWFsaXplcyB0aGUgaXRlbSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZy5cblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nW119XG5cdFx0ICovXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9yZGVyID0gW10sXG5cdFx0XHRcdGVsLFxuXHRcdFx0XHRjaGlsZHJlbiA9IHRoaXMuZWwuY2hpbGRyZW4sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRuID0gY2hpbGRyZW4ubGVuZ3RoLFxuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0XHRmb3IgKDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRlbCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoX2Nsb3Nlc3QoZWwsIG9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsKSkge1xuXHRcdFx0XHRcdG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3JkZXI7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU29ydHMgdGhlIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGUgYXJyYXkuXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nW119ICBvcmRlciAgb3JkZXIgb2YgdGhlIGl0ZW1zXG5cdFx0ICovXG5cdFx0c29ydDogZnVuY3Rpb24gKG9yZGVyKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSB7fSwgcm9vdEVsID0gdGhpcy5lbDtcblxuXHRcdFx0dGhpcy50b0FycmF5KCkuZm9yRWFjaChmdW5jdGlvbiAoaWQsIGkpIHtcblx0XHRcdFx0dmFyIGVsID0gcm9vdEVsLmNoaWxkcmVuW2ldO1xuXG5cdFx0XHRcdGlmIChfY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsKSkge1xuXHRcdFx0XHRcdGl0ZW1zW2lkXSA9IGVsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0b3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0aWYgKGl0ZW1zW2lkXSkge1xuXHRcdFx0XHRcdHJvb3RFbC5yZW1vdmVDaGlsZChpdGVtc1tpZF0pO1xuXHRcdFx0XHRcdHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cblx0XHQvKipcblx0XHQgKiBTYXZlIHRoZSBjdXJyZW50IHNvcnRpbmdcblx0XHQgKi9cblx0XHRzYXZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc3RvcmUgPSB0aGlzLm9wdGlvbnMuc3RvcmU7XG5cdFx0XHRzdG9yZSAmJiBzdG9yZS5zZXQodGhpcyk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0LCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3RvciBieSB0ZXN0aW5nIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgdHJhdmVyc2luZyB1cCB0aHJvdWdoIGl0cyBhbmNlc3RvcnMgaW4gdGhlIERPTSB0cmVlLlxuXHRcdCAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gIGVsXG5cdFx0ICogQHBhcmFtICAge1N0cmluZ30gICAgICAgW3NlbGVjdG9yXSAgZGVmYXVsdDogYG9wdGlvbnMuZHJhZ2dhYmxlYFxuXHRcdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxudWxsfVxuXHRcdCAqL1xuXHRcdGNsb3Nlc3Q6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcblx0XHRcdHJldHVybiBfY2xvc2VzdChlbCwgc2VsZWN0b3IgfHwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCk7XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogU2V0L2dldCBvcHRpb25cblx0XHQgKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXG5cdFx0ICogQHBhcmFtICAgeyp9ICAgICAgW3ZhbHVlXVxuXHRcdCAqIEByZXR1cm5zIHsqfVxuXHRcdCAqL1xuXHRcdG9wdGlvbjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHRcdFx0aWYgKHZhbHVlID09PSB2b2lkIDApIHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnNbbmFtZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zW25hbWVdID0gdmFsdWU7XG5cblx0XHRcdFx0aWYgKG5hbWUgPT09ICdncm91cCcpIHtcblx0XHRcdFx0XHRfcHJlcGFyZUdyb3VwKG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogRGVzdHJveVxuXHRcdCAqL1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBlbCA9IHRoaXMuZWw7XG5cblx0XHRcdGVsW2V4cGFuZG9dID0gbnVsbDtcblxuXHRcdFx0X29mZihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuXHRcdFx0X29mZihlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRhcFN0YXJ0KTtcblxuXHRcdFx0aWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG5cdFx0XHRcdF9vZmYoZWwsICdkcmFnb3ZlcicsIHRoaXMpO1xuXHRcdFx0XHRfb2ZmKGVsLCAnZHJhZ2VudGVyJywgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkcmFnZ2FibGUgYXR0cmlidXRlc1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2FibGUnKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0b3VjaERyYWdPdmVyTGlzdGVuZXJzLnNwbGljZSh0b3VjaERyYWdPdmVyTGlzdGVuZXJzLmluZGV4T2YodGhpcy5fb25EcmFnT3ZlciksIDEpO1xuXG5cdFx0XHR0aGlzLl9vbkRyb3AoKTtcblxuXHRcdFx0dGhpcy5lbCA9IGVsID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblxuXHRmdW5jdGlvbiBfY2xvbmVIaWRlKHN0YXRlKSB7XG5cdFx0aWYgKGNsb25lRWwgJiYgKGNsb25lRWwuc3RhdGUgIT09IHN0YXRlKSkge1xuXHRcdFx0X2NzcyhjbG9uZUVsLCAnZGlzcGxheScsIHN0YXRlID8gJ25vbmUnIDogJycpO1xuXHRcdFx0IXN0YXRlICYmIGNsb25lRWwuc3RhdGUgJiYgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuXHRcdFx0Y2xvbmVFbC5zdGF0ZSA9IHN0YXRlO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gX2Nsb3Nlc3QoLyoqSFRNTEVsZW1lbnQqL2VsLCAvKipTdHJpbmcqL3NlbGVjdG9yLCAvKipIVE1MRWxlbWVudCovY3R4KSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG5cblx0XHRcdHZhciB0YWcgPSBzZWxlY3Rvci5zaGlmdCgpLnRvVXBwZXJDYXNlKCksXG5cdFx0XHRcdHJlID0gbmV3IFJlZ0V4cCgnXFxcXHMoJyArIHNlbGVjdG9yLmpvaW4oJ3wnKSArICcpKD89XFxcXHMpJywgJ2cnKTtcblxuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KHRhZyA9PT0gJz4qJyAmJiBlbC5wYXJlbnROb2RlID09PSBjdHgpIHx8IChcblx0XHRcdFx0XHRcdCh0YWcgPT09ICcnIHx8IGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gdGFnKSAmJlxuXHRcdFx0XHRcdFx0KCFzZWxlY3Rvci5sZW5ndGggfHwgKCgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLm1hdGNoKHJlKSB8fCBbXSkubGVuZ3RoID09IHNlbGVjdG9yLmxlbmd0aClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiBlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGVsICE9PSBjdHggJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBfZ2xvYmFsRHJhZ092ZXIoLyoqRXZlbnQqL2V2dCkge1xuXHRcdGlmIChldnQuZGF0YVRyYW5zZmVyKSB7XG5cdFx0XHRldnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG5cdFx0fVxuXHRcdGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBfb24oZWwsIGV2ZW50LCBmbikge1xuXHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9vZmYoZWwsIGV2ZW50LCBmbikge1xuXHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBmYWxzZSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF90b2dnbGVDbGFzcyhlbCwgbmFtZSwgc3RhdGUpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGlmIChlbC5jbGFzc0xpc3QpIHtcblx0XHRcdFx0ZWwuY2xhc3NMaXN0W3N0YXRlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUlNQQUNFLCAnICcpLnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblx0XHRcdFx0ZWwuY2xhc3NOYW1lID0gKGNsYXNzTmFtZSArIChzdGF0ZSA/ICcgJyArIG5hbWUgOiAnJykpLnJlcGxhY2UoUlNQQUNFLCAnICcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gX2NzcyhlbCwgcHJvcCwgdmFsKSB7XG5cdFx0dmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG5cblx0XHRpZiAoc3R5bGUpIHtcblx0XHRcdGlmICh2YWwgPT09IHZvaWQgMCkge1xuXHRcdFx0XHRpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0XHRcdHZhbCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcblx0XHRcdFx0XHR2YWwgPSBlbC5jdXJyZW50U3R5bGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcHJvcCA9PT0gdm9pZCAwID8gdmFsIDogdmFsW3Byb3BdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICghKHByb3AgaW4gc3R5bGUpKSB7XG5cdFx0XHRcdFx0cHJvcCA9ICctd2Via2l0LScgKyBwcm9wO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gX2ZpbmQoY3R4LCB0YWdOYW1lLCBpdGVyYXRvcikge1xuXHRcdGlmIChjdHgpIHtcblx0XHRcdHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLCBpID0gMCwgbiA9IGxpc3QubGVuZ3RoO1xuXG5cdFx0XHRpZiAoaXRlcmF0b3IpIHtcblx0XHRcdFx0Zm9yICg7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0XHRpdGVyYXRvcihsaXN0W2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cblx0XHRyZXR1cm4gW107XG5cdH1cblxuXG5cblx0ZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQoc29ydGFibGUsIHJvb3RFbCwgbmFtZSwgdGFyZ2V0RWwsIGZyb21FbCwgc3RhcnRJbmRleCwgbmV3SW5kZXgpIHtcblx0XHR2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JyksXG5cdFx0XHRvcHRpb25zID0gKHNvcnRhYmxlIHx8IHJvb3RFbFtleHBhbmRvXSkub3B0aW9ucyxcblx0XHRcdG9uTmFtZSA9ICdvbicgKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG5cblx0XHRldnQuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuXG5cdFx0ZXZ0LnRvID0gcm9vdEVsO1xuXHRcdGV2dC5mcm9tID0gZnJvbUVsIHx8IHJvb3RFbDtcblx0XHRldnQuaXRlbSA9IHRhcmdldEVsIHx8IHJvb3RFbDtcblx0XHRldnQuY2xvbmUgPSBjbG9uZUVsO1xuXG5cdFx0ZXZ0Lm9sZEluZGV4ID0gc3RhcnRJbmRleDtcblx0XHRldnQubmV3SW5kZXggPSBuZXdJbmRleDtcblxuXHRcdHJvb3RFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cblx0XHRpZiAob3B0aW9uc1tvbk5hbWVdKSB7XG5cdFx0XHRvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9vbk1vdmUoZnJvbUVsLCB0b0VsLCBkcmFnRWwsIGRyYWdSZWN0LCB0YXJnZXRFbCwgdGFyZ2V0UmVjdCkge1xuXHRcdHZhciBldnQsXG5cdFx0XHRzb3J0YWJsZSA9IGZyb21FbFtleHBhbmRvXSxcblx0XHRcdG9uTW92ZUZuID0gc29ydGFibGUub3B0aW9ucy5vbk1vdmUsXG5cdFx0XHRyZXRWYWw7XG5cblx0XHRldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcblx0XHRldnQuaW5pdEV2ZW50KCdtb3ZlJywgdHJ1ZSwgdHJ1ZSk7XG5cblx0XHRldnQudG8gPSB0b0VsO1xuXHRcdGV2dC5mcm9tID0gZnJvbUVsO1xuXHRcdGV2dC5kcmFnZ2VkID0gZHJhZ0VsO1xuXHRcdGV2dC5kcmFnZ2VkUmVjdCA9IGRyYWdSZWN0O1xuXHRcdGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcblx0XHRldnQucmVsYXRlZFJlY3QgPSB0YXJnZXRSZWN0IHx8IHRvRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRmcm9tRWwuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0aWYgKG9uTW92ZUZuKSB7XG5cdFx0XHRyZXRWYWwgPSBvbk1vdmVGbi5jYWxsKHNvcnRhYmxlLCBldnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXRWYWw7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG5cdFx0ZWwuZHJhZ2dhYmxlID0gZmFsc2U7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIF91bnNpbGVudCgpIHtcblx0XHRfc2lsZW50ID0gZmFsc2U7XG5cdH1cblxuXG5cdC8qKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8ZmFsc2V9ICovXG5cdGZ1bmN0aW9uIF9naG9zdElzTGFzdChlbCwgZXZ0KSB7XG5cdFx0dmFyIGxhc3RFbCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQsXG5cdFx0XHRcdHJlY3QgPSBsYXN0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRyZXR1cm4gKChldnQuY2xpZW50WSAtIChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0KSA+IDUpIHx8IChldnQuY2xpZW50WCAtIChyZWN0LnJpZ2h0ICsgcmVjdC53aWR0aCkgPiA1KSkgJiYgbGFzdEVsOyAvLyBtaW4gZGVsdGFcblx0fVxuXG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGlkXG5cdCAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcblx0ICogQHJldHVybnMge1N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIF9nZW5lcmF0ZUlkKGVsKSB7XG5cdFx0dmFyIHN0ciA9IGVsLnRhZ05hbWUgKyBlbC5jbGFzc05hbWUgKyBlbC5zcmMgKyBlbC5ocmVmICsgZWwudGV4dENvbnRlbnQsXG5cdFx0XHRpID0gc3RyLmxlbmd0aCxcblx0XHRcdHN1bSA9IDA7XG5cblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRzdW0gKz0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN1bS50b1N0cmluZygzNik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgYW4gZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuXHQgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gX2luZGV4KGVsKSB7XG5cdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdGlmICghZWwgfHwgIWVsLnBhcmVudE5vZGUpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cblx0XHR3aGlsZSAoZWwgJiYgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykpIHtcblx0XHRcdGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnKSB7XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gX3Rocm90dGxlKGNhbGxiYWNrLCBtcykge1xuXHRcdHZhciBhcmdzLCBfdGhpcztcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoYXJncyA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdF90aGlzID0gdGhpcztcblxuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoX3RoaXMsIGFyZ3NbMF0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YXJncyA9IHZvaWQgMDtcblx0XHRcdFx0fSwgbXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBfZXh0ZW5kKGRzdCwgc3JjKSB7XG5cdFx0aWYgKGRzdCAmJiBzcmMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBzcmMpIHtcblx0XHRcdFx0aWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0ZHN0W2tleV0gPSBzcmNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkc3Q7XG5cdH1cblxuXG5cdC8vIEV4cG9ydCB1dGlsc1xuXHRTb3J0YWJsZS51dGlscyA9IHtcblx0XHRvbjogX29uLFxuXHRcdG9mZjogX29mZixcblx0XHRjc3M6IF9jc3MsXG5cdFx0ZmluZDogX2ZpbmQsXG5cdFx0aXM6IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcblx0XHRcdHJldHVybiAhIV9jbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwpO1xuXHRcdH0sXG5cdFx0ZXh0ZW5kOiBfZXh0ZW5kLFxuXHRcdHRocm90dGxlOiBfdGhyb3R0bGUsXG5cdFx0Y2xvc2VzdDogX2Nsb3Nlc3QsXG5cdFx0dG9nZ2xlQ2xhc3M6IF90b2dnbGVDbGFzcyxcblx0XHRpbmRleDogX2luZGV4XG5cdH07XG5cblxuXHQvKipcblx0ICogQ3JlYXRlIHNvcnRhYmxlIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICBlbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gICAgICBbb3B0aW9uc11cblx0ICovXG5cdFNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuXHRcdHJldHVybiBuZXcgU29ydGFibGUoZWwsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0Ly8gRXhwb3J0XG5cdFNvcnRhYmxlLnZlcnNpb24gPSAnMS4zLjAnO1xuXHRyZXR1cm4gU29ydGFibGU7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NvcnRhYmxlanMvU29ydGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _SelectorID = __webpack_require__(3);\n\nvar _SelectorID2 = _interopRequireDefault(_SelectorID);\n\nvar _LayerUtils = __webpack_require__(7);\n\nvar _LayerUtils2 = _interopRequireDefault(_LayerUtils);\n\nvar _AttributionDOM = __webpack_require__(24);\n\nvar _AttributionDOM2 = _interopRequireDefault(_AttributionDOM);\n\nvar _Widget = __webpack_require__(4);\n\nvar _Widget2 = _interopRequireDefault(_Widget);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"Attributions\");\n\n/**\n * @classdesc\n * Control to manage layers attributions\n *\n * @constructor\n * @alias itowns.control.Attributions\n * @extends {itowns.control.Widget}\n * @param {Object} aOptions - control options\n * @param {Object} [aOptions.options] - Itowns.control.Control options\n * @param {Boolean} [aOptions.options.collapsed = false] - Specify if the control has to be opened or not.\n * @example\n * var attribution = new itowns.control.Attritbution({\n *  options : {\n *      collapsed: true\n *  }\n * ));\n */\nfunction Attributions(aOptions) {\n    aOptions = aOptions || {};\n    var options = aOptions.options || {};\n\n    if (!(this instanceof Attributions)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    if (options && (typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        throw new Error(\"ERROR WRONG_TYPE : options should be an object\");\n    }\n\n    this._initialize(options);\n\n    var container = this._initContainer(options);\n    var targetDiv = document.getElementById(options.target) || null;\n\n    _Widget2.default.call(this, {\n        name: \"Attributions\",\n        element: container,\n        target: targetDiv\n    });\n}\n\n/*\n * @lends module:Attributions\n */\nAttributions.prototype = Object.create(_Widget2.default.prototype, {});\n\n// retrieves methods of the common class AttributionDOM\n_Utils2.default.assign(Attributions.prototype, _AttributionDOM2.default);\n\n/**\n * Constructor (alias)\n *\n * @private\n */\nAttributions.prototype.constructor = Attributions;\n\n// ################################################################### //\n// ############## public methods (getters, setters) ################## //\n// ################################################################### //\n\n/**\n * Bind globe to control\n *\n * @param {GlobeViewExtended} globe - the globe\n */\nAttributions.prototype.setGlobe = function (globe) {\n    // info : this function is called after a globe.addWidget() or a globe.removeWidget()\n\n    if (globe) {\n        // In the case of the adding of a control to the globe\n        var self = this;\n\n        // Adding of the listeners\n\n        // At every globe movement, attributions may be updated,\n        // according to layers on globe, and their visibility.\n        this._callbacks.onPreRenderCallBack = function (e) {\n            var allLayers = e.colorLayersId.concat(e.elevationLayersId);\n\n            self._inRangeUpdate(allLayers, e.extent);\n        };\n\n        globe.listen(_GlobeViewExtended2.default.EVENTS.PRE_RENDER, this._callbacks.onPreRenderCallBack);\n        globe.preRenderEventFetchViewExtent();\n        globe.preRenderEventFetchLayersDisplayed();\n    } else {\n        // delete listener\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.PRE_RENDER, this._callbacks.onPreRenderCallBack);\n\n        // delete DOM\n        while (this._element.hasChildNodes()) {\n            this._element.removeChild(this._element.lastChild);\n        }\n        this._element.parentNode.removeChild(this._element);\n    }\n\n    // call original setGlobe method\n    _Widget2.default.prototype.setGlobe.call(this, globe);\n};\n\n/**\n * Collapse or display control main container\n *\n * @param {Boolean} collapsed - True to collapse control, False to display it\n */\nAttributions.prototype.setCollapsed = function (collapsed) {\n    if (collapsed === undefined) {\n        logger.error(\"Attributions:setCollapsed - missing collapsed parameter\");\n        return;\n    }\n    var isCollapsed = this.getCollapsed();\n    if (collapsed && isCollapsed || !collapsed && !isCollapsed) {\n        return;\n    }\n\n    document.getElementById(this._addUID(\"GPshowAttributionsList\")).checked = !collapsed;\n};\n\n/**\n * Returns true if widget is collapsed (minimize), false otherwise\n *\n * @return {Boolean} collapsed\n */\nAttributions.prototype.getCollapsed = function () {\n    return !document.getElementById(this._addUID(\"GPshowAttributionsList\")).checked;\n};\n\n// ################################################################### //\n// ##################### init component ############################## //\n// ################################################################### //\n\n/**\n * Initialize Attributions control (called by constructor)\n *\n * @param {Object} options - Itowns.control.Control options\n * @private\n */\nAttributions.prototype._initialize = function (options) {\n    // id of the widget : usefull to suffix the CSS ids (to handle cases with several widgets on the same page)\n    this._uid = _SelectorID2.default.generate();\n\n    // div which will contain the list divs.\n    this._AttributionContainer = null;\n\n    // callbacks\n    this._callbacks = {};\n\n    // options\n    this._options = options;\n};\n\n/**\n * Creates control main container\n *\n * @method _initContainer\n * @param {Object} options - control options\n * @returns {DOMElement} container - widget container\n * @private\n */\nAttributions.prototype._initContainer = function (options) {\n    var container = this._createMainContainerElement();\n\n    // adds in the main container the layer display selector\n    var inputShow = this._createMainAttributionsShowElement();\n    container.appendChild(inputShow);\n\n    // handles the \"collapsed\" mode\n    if (!options.collapsed) {\n        inputShow.checked = \"checked\";\n    }\n    // adds the layer list in the main container\n    var divA = this._attributionListContainer = this._createMainAttributionsListContainer();\n    var ulA = this._createAttributionsList();\n    divA.appendChild(ulA);\n    container.appendChild(divA);\n\n    // adds the widget picto in the main container\n    var picto = this._createMainPictoElement(options.collapsed);\n    container.appendChild(picto);\n\n    return container;\n};\n\n/**\n * Checks layers range\n *\n * @method _inRangeUpdate\n * @param {Array} layersDisplayed - Id of the layers diplayed on screen\n * @param {Object} extent - The globe view extent\n * @private\n */\n\nAttributions.prototype._inRangeUpdate = function (layersDisplayed, extent) {\n    var globe = this.getGlobe();\n\n    var scaleDenominator = 1 / globe.getScale();\n\n    var attributions = new Map();\n\n    for (var h = 0; h < layersDisplayed.length; h++) {\n        var layer = globe.getLayerById(layersDisplayed[h]);\n\n        // FIXME itowns bug : itowns should only returns visible layers\n        if (!layer.visible) {\n            continue;\n        }\n\n        var ori = layer.options.originators;\n\n        if (ori) {\n            for (var j = 0; j < ori.length; j++) {\n                // if the attribution is already added, we skip to not add it several times\n                if (attributions.has(ori[j].name)) {\n                    continue;\n                };\n                // if no constraints are associated to the originator, we just add the attribution\n                if (!ori[j].constraints) {\n                    // adds the attribution in the Map() called 'attributions'\n                    attributions.set(ori[j].name, ori[j]);\n                    continue;\n                }\n                // if the minScaleDenominator exists\n                if (ori[j].constraints[0].minScaleDenominator) {\n                    // if min/maxScaleDenominator are equals, we display the attribution corresponding to the zoom level associated to the scale denominator\n                    if (ori[j].constraints[0].minScaleDenominator === ori[j].constraints[0].maxScaleDenominator) {\n                        // retrieves the zoom level\n                        var attributionZoomLevel = _LayerUtils2.default.getZoomLevelFromScaleDenominator(ori[j].constraints[0].minScaleDenominator);\n                        // selects the scaledenominators around the corresponding zoom level\n                        var maxAttributionScaleDenominator = (this._resolutionsWGS84[attributionZoomLevel] + this._resolutionsWGS84[attributionZoomLevel - 1]) / (0.00028 * 2);\n                        var minAttributionScaleDenominator = (this._resolutionsWGS84[attributionZoomLevel] + this._resolutionsWGS84[attributionZoomLevel + 1]) / (0.00028 * 2);\n                        if (!(maxAttributionScaleDenominator > scaleDenominator && scaleDenominator > minAttributionScaleDenominator)) {\n                            continue;\n                        }\n                        // either, we check we are located between the minScaleDenominator and the maxScaleDenominator\n                    } else if (!(ori[j].constraints[0].minScaleDenominator < scaleDenominator && scaleDenominator < ori[j].constraints[0].maxScaleDenominator)) {\n                        continue;\n                    }\n                }\n                // checks if 'bbox\" exists\n                if (ori[j].constraints[0].bbox) {\n                    // checks we are into the bbox limits\n                    if (ori[j].constraints[0].bbox.left < extent.west() && ori[j].constraints[0].bbox.right > extent.east() && ori[j].constraints[0].bbox.top > extent.north() && ori[j].constraints[0].bbox.bottom < extent.south()) {\n                        // adds the attribution in the Map() called 'attributions'\n                        attributions.set(ori[j].name, ori[j]);\n                    }\n                    // if 'bbox' attribute doesn't exist\n                } else if (!ori[j].constraints[0].bbox) {\n                    attributions.set(ori[j].name, ori[j]);\n                }\n            }\n        }\n    }\n    this._updateAttributionListContainer(attributions);\n};\n\n// ################################################################### //\n// ######################### DOM events ############################## //\n// ################################################################### //\n\n/**\n * Updates the layer list container\n *\n * @method _updateAttributionListContainer\n * @param {Map} attributions - map of attributions\n * @private\n */\nAttributions.prototype._updateAttributionListContainer = function (attributions) {\n    var element = document.getElementById(this._addUID(\"GPAttributionsList\"));\n    document.getElementById(this._addUID(\"GPAttributionsList\")).parentNode.removeChild(element);\n\n    var ul = this._createAttributionsList();\n    attributions.forEach(function (a) {\n        var li = document.createElement(\"li\");\n        var link = document.createElement(\"a\");\n        link.href = a.url;\n        link.innerHTML = a.name + \"&nbsp\";\n        link.target = \"_blank\";\n        li.id = a.name.replace(/\\s/g, \"\");\n        li.appendChild(link);\n        ul.appendChild(li);\n    });\n    this._attributionListContainer.appendChild(ul);\n};\n\nAttributions.prototype._resolutionsWGS84 = {\n    0: 156543.033928041,\n    1: 78271.51696402048,\n    2: 39135.758482010235,\n    3: 19567.87924100512,\n    4: 9783.93962050256,\n    5: 4891.96981025128,\n    6: 2445.98490512564,\n    7: 1222.99245256282,\n    8: 611.49622628141,\n    9: 305.7481131407048,\n    10: 152.8740565703525,\n    11: 76.43702828517624,\n    12: 38.21851414258813,\n    13: 19.10925707129406,\n    14: 9.554628535647032,\n    15: 4.777314267823516,\n    16: 2.388657133911758,\n    17: 1.194328566955879,\n    18: 0.5971642834779395,\n    19: 0.2985821417389697,\n    20: 0.1492910708694849,\n    21: 0.0746455354347424\n};\n\nexports.default = Attributions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL0F0dHJpYnV0aW9ucy5qcz9lMjE5Il0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkF0dHJpYnV0aW9ucyIsImFPcHRpb25zIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsIkVycm9yIiwiX2luaXRpYWxpemUiLCJjb250YWluZXIiLCJfaW5pdENvbnRhaW5lciIsInRhcmdldERpdiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0YXJnZXQiLCJXaWRnZXQiLCJjYWxsIiwibmFtZSIsImVsZW1lbnQiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJVdGlscyIsImFzc2lnbiIsIkF0dHJpYnV0aW9uRE9NIiwiY29uc3RydWN0b3IiLCJzZXRHbG9iZSIsImdsb2JlIiwic2VsZiIsIl9jYWxsYmFja3MiLCJvblByZVJlbmRlckNhbGxCYWNrIiwiZSIsImFsbExheWVycyIsImNvbG9yTGF5ZXJzSWQiLCJjb25jYXQiLCJlbGV2YXRpb25MYXllcnNJZCIsIl9pblJhbmdlVXBkYXRlIiwiZXh0ZW50IiwibGlzdGVuIiwiR2xvYmVWaWV3RXh0ZW5kZWQiLCJFVkVOVFMiLCJQUkVfUkVOREVSIiwicHJlUmVuZGVyRXZlbnRGZXRjaFZpZXdFeHRlbnQiLCJwcmVSZW5kZXJFdmVudEZldGNoTGF5ZXJzRGlzcGxheWVkIiwiX2dsb2JlIiwiZm9yZ2V0IiwiX2VsZW1lbnQiLCJoYXNDaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJsYXN0Q2hpbGQiLCJwYXJlbnROb2RlIiwic2V0Q29sbGFwc2VkIiwiY29sbGFwc2VkIiwidW5kZWZpbmVkIiwiZXJyb3IiLCJpc0NvbGxhcHNlZCIsImdldENvbGxhcHNlZCIsIl9hZGRVSUQiLCJjaGVja2VkIiwiX3VpZCIsIlNlbGVjdG9ySUQiLCJnZW5lcmF0ZSIsIl9BdHRyaWJ1dGlvbkNvbnRhaW5lciIsIl9vcHRpb25zIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IiwiaW5wdXRTaG93IiwiX2NyZWF0ZU1haW5BdHRyaWJ1dGlvbnNTaG93RWxlbWVudCIsImFwcGVuZENoaWxkIiwiZGl2QSIsIl9hdHRyaWJ1dGlvbkxpc3RDb250YWluZXIiLCJfY3JlYXRlTWFpbkF0dHJpYnV0aW9uc0xpc3RDb250YWluZXIiLCJ1bEEiLCJfY3JlYXRlQXR0cmlidXRpb25zTGlzdCIsInBpY3RvIiwiX2NyZWF0ZU1haW5QaWN0b0VsZW1lbnQiLCJsYXllcnNEaXNwbGF5ZWQiLCJnZXRHbG9iZSIsInNjYWxlRGVub21pbmF0b3IiLCJnZXRTY2FsZSIsImF0dHJpYnV0aW9ucyIsIk1hcCIsImgiLCJsZW5ndGgiLCJsYXllciIsImdldExheWVyQnlJZCIsInZpc2libGUiLCJvcmkiLCJvcmlnaW5hdG9ycyIsImoiLCJoYXMiLCJjb25zdHJhaW50cyIsInNldCIsIm1pblNjYWxlRGVub21pbmF0b3IiLCJtYXhTY2FsZURlbm9taW5hdG9yIiwiYXR0cmlidXRpb25ab29tTGV2ZWwiLCJMYXllclV0aWxzIiwiZ2V0Wm9vbUxldmVsRnJvbVNjYWxlRGVub21pbmF0b3IiLCJtYXhBdHRyaWJ1dGlvblNjYWxlRGVub21pbmF0b3IiLCJfcmVzb2x1dGlvbnNXR1M4NCIsIm1pbkF0dHJpYnV0aW9uU2NhbGVEZW5vbWluYXRvciIsImJib3giLCJsZWZ0Iiwid2VzdCIsInJpZ2h0IiwiZWFzdCIsInRvcCIsIm5vcnRoIiwiYm90dG9tIiwic291dGgiLCJfdXBkYXRlQXR0cmlidXRpb25MaXN0Q29udGFpbmVyIiwidWwiLCJmb3JFYWNoIiwiYSIsImxpIiwiY3JlYXRlRWxlbWVudCIsImxpbmsiLCJocmVmIiwidXJsIiwiaW5uZXJIVE1MIiwiaWQiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJQSxTQUFTQywwQkFBT0MsU0FBUCxD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QXJCa0M7QUFzQnZDLFFBQUs7QUF0QmtDLENBQTNDOztrQkF5QmUvRixZIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdsb2JlVmlld0V4dGVuZGVkIGZyb20gXCIuLi9HbG9iZVZpZXdFeHRlbmRlZFwiO1xuaW1wb3J0IExvZ2dlciBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL0xvZ2dlckJ5RGVmYXVsdFwiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHNcIjtcbmltcG9ydCBTZWxlY3RvcklEIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHMvU2VsZWN0b3JJRFwiO1xuaW1wb3J0IExheWVyVXRpbHMgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9MYXllclV0aWxzXCI7XG5pbXBvcnQgQXR0cmlidXRpb25ET00gZnJvbSBcIi4uLy4uL0NvbW1vbi9Db250cm9scy9BdHRyaWJ1dGlvbkRPTVwiO1xuaW1wb3J0IFdpZGdldCBmcm9tIFwiLi9XaWRnZXRcIjtcblxudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJBdHRyaWJ1dGlvbnNcIik7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udHJvbCB0byBtYW5hZ2UgbGF5ZXJzIGF0dHJpYnV0aW9uc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIGl0b3ducy5jb250cm9sLkF0dHJpYnV0aW9uc1xuICogQGV4dGVuZHMge2l0b3ducy5jb250cm9sLldpZGdldH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBhT3B0aW9ucyAtIGNvbnRyb2wgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFthT3B0aW9ucy5vcHRpb25zXSAtIEl0b3ducy5jb250cm9sLkNvbnRyb2wgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbYU9wdGlvbnMub3B0aW9ucy5jb2xsYXBzZWQgPSBmYWxzZV0gLSBTcGVjaWZ5IGlmIHRoZSBjb250cm9sIGhhcyB0byBiZSBvcGVuZWQgb3Igbm90LlxuICogQGV4YW1wbGVcbiAqIHZhciBhdHRyaWJ1dGlvbiA9IG5ldyBpdG93bnMuY29udHJvbC5BdHRyaXRidXRpb24oe1xuICogIG9wdGlvbnMgOiB7XG4gKiAgICAgIGNvbGxhcHNlZDogdHJ1ZVxuICogIH1cbiAqICkpO1xuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbnMgKGFPcHRpb25zKSB7XG4gICAgYU9wdGlvbnMgPSBhT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IGFPcHRpb25zLm9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXR0cmlidXRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRVJST1IgQ0xBU1NfQ09OU1RSVUNUT1JcIik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1IgV1JPTkdfVFlQRSA6IG9wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKG9wdGlvbnMpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2luaXRDb250YWluZXIob3B0aW9ucyk7XG4gICAgdmFyIHRhcmdldERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMudGFyZ2V0KSB8fCBudWxsO1xuXG4gICAgV2lkZ2V0LmNhbGwoXG4gICAgICAgIHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUgOiBcIkF0dHJpYnV0aW9uc1wiLFxuICAgICAgICAgICAgZWxlbWVudCA6IGNvbnRhaW5lcixcbiAgICAgICAgICAgIHRhcmdldCA6IHRhcmdldERpdlxuICAgICAgICB9XG4gICAgKTtcbn1cblxuLypcbiAqIEBsZW5kcyBtb2R1bGU6QXR0cmlidXRpb25zXG4gKi9cbkF0dHJpYnV0aW9ucy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdpZGdldC5wcm90b3R5cGUsIHt9KTtcblxuLy8gcmV0cmlldmVzIG1ldGhvZHMgb2YgdGhlIGNvbW1vbiBjbGFzcyBBdHRyaWJ1dGlvbkRPTVxuVXRpbHMuYXNzaWduKEF0dHJpYnV0aW9ucy5wcm90b3R5cGUsIEF0dHJpYnV0aW9uRE9NKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciAoYWxpYXMpXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQXR0cmlidXRpb25zLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF0dHJpYnV0aW9ucztcblxuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMgcHVibGljIG1ldGhvZHMgKGdldHRlcnMsIHNldHRlcnMpICMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuXG4vKipcbiAqIEJpbmQgZ2xvYmUgdG8gY29udHJvbFxuICpcbiAqIEBwYXJhbSB7R2xvYmVWaWV3RXh0ZW5kZWR9IGdsb2JlIC0gdGhlIGdsb2JlXG4gKi9cbkF0dHJpYnV0aW9ucy5wcm90b3R5cGUuc2V0R2xvYmUgPSBmdW5jdGlvbiAoZ2xvYmUpIHtcbiAgICAvLyBpbmZvIDogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgYSBnbG9iZS5hZGRXaWRnZXQoKSBvciBhIGdsb2JlLnJlbW92ZVdpZGdldCgpXG5cbiAgICBpZiAoZ2xvYmUpIHsgLy8gSW4gdGhlIGNhc2Ugb2YgdGhlIGFkZGluZyBvZiBhIGNvbnRyb2wgdG8gdGhlIGdsb2JlXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBBZGRpbmcgb2YgdGhlIGxpc3RlbmVyc1xuXG4gICAgICAgIC8vIEF0IGV2ZXJ5IGdsb2JlIG1vdmVtZW50LCBhdHRyaWJ1dGlvbnMgbWF5IGJlIHVwZGF0ZWQsXG4gICAgICAgIC8vIGFjY29yZGluZyB0byBsYXllcnMgb24gZ2xvYmUsIGFuZCB0aGVpciB2aXNpYmlsaXR5LlxuICAgICAgICB0aGlzLl9jYWxsYmFja3Mub25QcmVSZW5kZXJDYWxsQmFjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgYWxsTGF5ZXJzID0gZS5jb2xvckxheWVyc0lkLmNvbmNhdChlLmVsZXZhdGlvbkxheWVyc0lkKTtcblxuICAgICAgICAgICAgc2VsZi5faW5SYW5nZVVwZGF0ZShhbGxMYXllcnMsIGUuZXh0ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICBnbG9iZS5saXN0ZW4oR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLlBSRV9SRU5ERVIsIHRoaXMuX2NhbGxiYWNrcy5vblByZVJlbmRlckNhbGxCYWNrKTtcbiAgICAgICAgZ2xvYmUucHJlUmVuZGVyRXZlbnRGZXRjaFZpZXdFeHRlbnQoKTtcbiAgICAgICAgZ2xvYmUucHJlUmVuZGVyRXZlbnRGZXRjaExheWVyc0Rpc3BsYXllZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlbGV0ZSBsaXN0ZW5lclxuICAgICAgICB0aGlzLl9nbG9iZS5mb3JnZXQoR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLlBSRV9SRU5ERVIsIHRoaXMuX2NhbGxiYWNrcy5vblByZVJlbmRlckNhbGxCYWNrKTtcblxuICAgICAgICAvLyBkZWxldGUgRE9NXG4gICAgICAgIHdoaWxlICh0aGlzLl9lbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9lbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIGNhbGwgb3JpZ2luYWwgc2V0R2xvYmUgbWV0aG9kXG4gICAgV2lkZ2V0LnByb3RvdHlwZS5zZXRHbG9iZS5jYWxsKHRoaXMsIGdsb2JlKTtcbn07XG5cbi8qKlxuICogQ29sbGFwc2Ugb3IgZGlzcGxheSBjb250cm9sIG1haW4gY29udGFpbmVyXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xsYXBzZWQgLSBUcnVlIHRvIGNvbGxhcHNlIGNvbnRyb2wsIEZhbHNlIHRvIGRpc3BsYXkgaXRcbiAqL1xuQXR0cmlidXRpb25zLnByb3RvdHlwZS5zZXRDb2xsYXBzZWQgPSBmdW5jdGlvbiAoY29sbGFwc2VkKSB7XG4gICAgaWYgKGNvbGxhcHNlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkF0dHJpYnV0aW9uczpzZXRDb2xsYXBzZWQgLSBtaXNzaW5nIGNvbGxhcHNlZCBwYXJhbWV0ZXJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGlzQ29sbGFwc2VkID0gdGhpcy5nZXRDb2xsYXBzZWQoKTtcbiAgICBpZiAoKGNvbGxhcHNlZCAmJiBpc0NvbGxhcHNlZCkgfHwgKCFjb2xsYXBzZWQgJiYgIWlzQ29sbGFwc2VkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BzaG93QXR0cmlidXRpb25zTGlzdFwiKSkuY2hlY2tlZCA9ICFjb2xsYXBzZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB3aWRnZXQgaXMgY29sbGFwc2VkIChtaW5pbWl6ZSksIGZhbHNlIG90aGVyd2lzZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGNvbGxhcHNlZFxuICovXG5BdHRyaWJ1dGlvbnMucHJvdG90eXBlLmdldENvbGxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQc2hvd0F0dHJpYnV0aW9uc0xpc3RcIikpLmNoZWNrZWQ7XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCBjb21wb25lbnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBBdHRyaWJ1dGlvbnMgY29udHJvbCAoY2FsbGVkIGJ5IGNvbnN0cnVjdG9yKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSXRvd25zLmNvbnRyb2wuQ29udHJvbCBvcHRpb25zXG4gKiBAcHJpdmF0ZVxuICovXG5BdHRyaWJ1dGlvbnMucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBpZCBvZiB0aGUgd2lkZ2V0IDogdXNlZnVsbCB0byBzdWZmaXggdGhlIENTUyBpZHMgKHRvIGhhbmRsZSBjYXNlcyB3aXRoIHNldmVyYWwgd2lkZ2V0cyBvbiB0aGUgc2FtZSBwYWdlKVxuICAgIHRoaXMuX3VpZCA9IFNlbGVjdG9ySUQuZ2VuZXJhdGUoKTtcblxuICAgIC8vIGRpdiB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIGxpc3QgZGl2cy5cbiAgICB0aGlzLl9BdHRyaWJ1dGlvbkNvbnRhaW5lciA9IG51bGw7XG5cbiAgICAvLyBjYWxsYmFja3NcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcblxuICAgIC8vIG9wdGlvbnNcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBjb250cm9sIG1haW4gY29udGFpbmVyXG4gKlxuICogQG1ldGhvZCBfaW5pdENvbnRhaW5lclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb250cm9sIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXIgLSB3aWRnZXQgY29udGFpbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5BdHRyaWJ1dGlvbnMucHJvdG90eXBlLl9pbml0Q29udGFpbmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQoKTtcblxuICAgIC8vIGFkZHMgaW4gdGhlIG1haW4gY29udGFpbmVyIHRoZSBsYXllciBkaXNwbGF5IHNlbGVjdG9yXG4gICAgdmFyIGlucHV0U2hvdyA9IHRoaXMuX2NyZWF0ZU1haW5BdHRyaWJ1dGlvbnNTaG93RWxlbWVudCgpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dFNob3cpO1xuXG4gICAgLy8gaGFuZGxlcyB0aGUgXCJjb2xsYXBzZWRcIiBtb2RlXG4gICAgaWYgKCFvcHRpb25zLmNvbGxhcHNlZCkge1xuICAgICAgICBpbnB1dFNob3cuY2hlY2tlZCA9IFwiY2hlY2tlZFwiO1xuICAgIH1cbiAgICAvLyBhZGRzIHRoZSBsYXllciBsaXN0IGluIHRoZSBtYWluIGNvbnRhaW5lclxuICAgIHZhciBkaXZBID0gdGhpcy5fYXR0cmlidXRpb25MaXN0Q29udGFpbmVyID0gdGhpcy5fY3JlYXRlTWFpbkF0dHJpYnV0aW9uc0xpc3RDb250YWluZXIoKTtcbiAgICB2YXIgdWxBID0gdGhpcy5fY3JlYXRlQXR0cmlidXRpb25zTGlzdCgpO1xuICAgIGRpdkEuYXBwZW5kQ2hpbGQodWxBKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2QSk7XG5cbiAgICAvLyBhZGRzIHRoZSB3aWRnZXQgcGljdG8gaW4gdGhlIG1haW4gY29udGFpbmVyXG4gICAgdmFyIHBpY3RvID0gdGhpcy5fY3JlYXRlTWFpblBpY3RvRWxlbWVudChvcHRpb25zLmNvbGxhcHNlZCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBpY3RvKTtcblxuICAgIHJldHVybiBjb250YWluZXI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBsYXllcnMgcmFuZ2VcbiAqXG4gKiBAbWV0aG9kIF9pblJhbmdlVXBkYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBsYXllcnNEaXNwbGF5ZWQgLSBJZCBvZiB0aGUgbGF5ZXJzIGRpcGxheWVkIG9uIHNjcmVlblxuICogQHBhcmFtIHtPYmplY3R9IGV4dGVudCAtIFRoZSBnbG9iZSB2aWV3IGV4dGVudFxuICogQHByaXZhdGVcbiAqL1xuXG5BdHRyaWJ1dGlvbnMucHJvdG90eXBlLl9pblJhbmdlVXBkYXRlID0gZnVuY3Rpb24gKGxheWVyc0Rpc3BsYXllZCwgZXh0ZW50KSB7XG4gICAgdmFyIGdsb2JlID0gdGhpcy5nZXRHbG9iZSgpO1xuXG4gICAgdmFyIHNjYWxlRGVub21pbmF0b3IgPSAxIC8gZ2xvYmUuZ2V0U2NhbGUoKTtcblxuICAgIHZhciBhdHRyaWJ1dGlvbnMgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKHZhciBoID0gMDsgaCA8IGxheWVyc0Rpc3BsYXllZC5sZW5ndGg7IGgrKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBnbG9iZS5nZXRMYXllckJ5SWQobGF5ZXJzRGlzcGxheWVkW2hdKTtcblxuICAgICAgICAvLyBGSVhNRSBpdG93bnMgYnVnIDogaXRvd25zIHNob3VsZCBvbmx5IHJldHVybnMgdmlzaWJsZSBsYXllcnNcbiAgICAgICAgaWYgKCFsYXllci52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmkgPSBsYXllci5vcHRpb25zLm9yaWdpbmF0b3JzO1xuXG4gICAgICAgIGlmIChvcmkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3JpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGF0dHJpYnV0aW9uIGlzIGFscmVhZHkgYWRkZWQsIHdlIHNraXAgdG8gbm90IGFkZCBpdCBzZXZlcmFsIHRpbWVzXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0aW9ucy5oYXMob3JpW2pdLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gY29uc3RyYWludHMgYXJlIGFzc29jaWF0ZWQgdG8gdGhlIG9yaWdpbmF0b3IsIHdlIGp1c3QgYWRkIHRoZSBhdHRyaWJ1dGlvblxuICAgICAgICAgICAgICAgIGlmICghb3JpW2pdLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgdGhlIGF0dHJpYnV0aW9uIGluIHRoZSBNYXAoKSBjYWxsZWQgJ2F0dHJpYnV0aW9ucydcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zLnNldChvcmlbal0ubmFtZSwgb3JpW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBtaW5TY2FsZURlbm9taW5hdG9yIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChvcmlbal0uY29uc3RyYWludHNbMF0ubWluU2NhbGVEZW5vbWluYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtaW4vbWF4U2NhbGVEZW5vbWluYXRvciBhcmUgZXF1YWxzLCB3ZSBkaXNwbGF5IHRoZSBhdHRyaWJ1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSB6b29tIGxldmVsIGFzc29jaWF0ZWQgdG8gdGhlIHNjYWxlIGRlbm9taW5hdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlbal0uY29uc3RyYWludHNbMF0ubWluU2NhbGVEZW5vbWluYXRvciA9PT0gb3JpW2pdLmNvbnN0cmFpbnRzWzBdLm1heFNjYWxlRGVub21pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlcyB0aGUgem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0aW9uWm9vbUxldmVsID0gTGF5ZXJVdGlscy5nZXRab29tTGV2ZWxGcm9tU2NhbGVEZW5vbWluYXRvcihvcmlbal0uY29uc3RyYWludHNbMF0ubWluU2NhbGVEZW5vbWluYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RzIHRoZSBzY2FsZWRlbm9taW5hdG9ycyBhcm91bmQgdGhlIGNvcnJlc3BvbmRpbmcgem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heEF0dHJpYnV0aW9uU2NhbGVEZW5vbWluYXRvciA9ICh0aGlzLl9yZXNvbHV0aW9uc1dHUzg0W2F0dHJpYnV0aW9uWm9vbUxldmVsXSArIHRoaXMuX3Jlc29sdXRpb25zV0dTODRbYXR0cmlidXRpb25ab29tTGV2ZWwgLSAxXSkgLyAoMC4wMDAyOCAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkF0dHJpYnV0aW9uU2NhbGVEZW5vbWluYXRvciA9ICh0aGlzLl9yZXNvbHV0aW9uc1dHUzg0W2F0dHJpYnV0aW9uWm9vbUxldmVsXSArIHRoaXMuX3Jlc29sdXRpb25zV0dTODRbYXR0cmlidXRpb25ab29tTGV2ZWwgKyAxXSkgLyAoMC4wMDAyOCAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWF4QXR0cmlidXRpb25TY2FsZURlbm9taW5hdG9yID4gc2NhbGVEZW5vbWluYXRvciAmJiBzY2FsZURlbm9taW5hdG9yID4gbWluQXR0cmlidXRpb25TY2FsZURlbm9taW5hdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIsIHdlIGNoZWNrIHdlIGFyZSBsb2NhdGVkIGJldHdlZW4gdGhlIG1pblNjYWxlRGVub21pbmF0b3IgYW5kIHRoZSBtYXhTY2FsZURlbm9taW5hdG9yXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIShvcmlbal0uY29uc3RyYWludHNbMF0ubWluU2NhbGVEZW5vbWluYXRvciA8IHNjYWxlRGVub21pbmF0b3IgJiYgc2NhbGVEZW5vbWluYXRvciA8IG9yaVtqXS5jb25zdHJhaW50c1swXS5tYXhTY2FsZURlbm9taW5hdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmICdiYm94XCIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKG9yaVtqXS5jb25zdHJhaW50c1swXS5iYm94KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB3ZSBhcmUgaW50byB0aGUgYmJveCBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaVtqXS5jb25zdHJhaW50c1swXS5iYm94LmxlZnQgPCBleHRlbnQud2VzdCgpICYmIG9yaVtqXS5jb25zdHJhaW50c1swXS5iYm94LnJpZ2h0ID4gZXh0ZW50LmVhc3QoKSAmJiBvcmlbal0uY29uc3RyYWludHNbMF0uYmJveC50b3AgPiBleHRlbnQubm9ydGgoKSAmJiBvcmlbal0uY29uc3RyYWludHNbMF0uYmJveC5ib3R0b20gPCBleHRlbnQuc291dGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyB0aGUgYXR0cmlidXRpb24gaW4gdGhlIE1hcCgpIGNhbGxlZCAnYXR0cmlidXRpb25zJ1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zLnNldChvcmlbal0ubmFtZSwgb3JpW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAnYmJveCcgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFvcmlbal0uY29uc3RyYWludHNbMF0uYmJveCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGlvbnMuc2V0KG9yaVtqXS5uYW1lLCBvcmlbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGlvbkxpc3RDb250YWluZXIoYXR0cmlidXRpb25zKTtcbn07XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgRE9NIGV2ZW50cyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBsYXllciBsaXN0IGNvbnRhaW5lclxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZUF0dHJpYnV0aW9uTGlzdENvbnRhaW5lclxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0aW9ucyAtIG1hcCBvZiBhdHRyaWJ1dGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbkF0dHJpYnV0aW9ucy5wcm90b3R5cGUuX3VwZGF0ZUF0dHJpYnV0aW9uTGlzdENvbnRhaW5lciA9IGZ1bmN0aW9uIChhdHRyaWJ1dGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2FkZFVJRChcIkdQQXR0cmlidXRpb25zTGlzdFwiKSk7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5fYWRkVUlEKFwiR1BBdHRyaWJ1dGlvbnNMaXN0XCIpKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXG4gICAgdmFyIHVsID0gdGhpcy5fY3JlYXRlQXR0cmlidXRpb25zTGlzdCgpO1xuICAgIGF0dHJpYnV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgbGluay5ocmVmID0gYS51cmw7XG4gICAgICAgIGxpbmsuaW5uZXJIVE1MID0gYS5uYW1lICsgXCImbmJzcFwiO1xuICAgICAgICBsaW5rLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgICAgIGxpLmlkID0gYS5uYW1lLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICB9KTtcbiAgICB0aGlzLl9hdHRyaWJ1dGlvbkxpc3RDb250YWluZXIuYXBwZW5kQ2hpbGQodWwpO1xufTtcblxuQXR0cmlidXRpb25zLnByb3RvdHlwZS5fcmVzb2x1dGlvbnNXR1M4NCA9IHtcbiAgICAwIDogMTU2NTQzLjAzMzkyODA0MSxcbiAgICAxIDogNzgyNzEuNTE2OTY0MDIwNDgsXG4gICAgMiA6IDM5MTM1Ljc1ODQ4MjAxMDIzNSxcbiAgICAzIDogMTk1NjcuODc5MjQxMDA1MTIsXG4gICAgNCA6IDk3ODMuOTM5NjIwNTAyNTYsXG4gICAgNSA6IDQ4OTEuOTY5ODEwMjUxMjgsXG4gICAgNiA6IDI0NDUuOTg0OTA1MTI1NjQsXG4gICAgNyA6IDEyMjIuOTkyNDUyNTYyODIsXG4gICAgOCA6IDYxMS40OTYyMjYyODE0MSxcbiAgICA5IDogMzA1Ljc0ODExMzE0MDcwNDgsXG4gICAgMTAgOiAxNTIuODc0MDU2NTcwMzUyNSxcbiAgICAxMSA6IDc2LjQzNzAyODI4NTE3NjI0LFxuICAgIDEyIDogMzguMjE4NTE0MTQyNTg4MTMsXG4gICAgMTMgOiAxOS4xMDkyNTcwNzEyOTQwNixcbiAgICAxNCA6IDkuNTU0NjI4NTM1NjQ3MDMyLFxuICAgIDE1IDogNC43NzczMTQyNjc4MjM1MTYsXG4gICAgMTYgOiAyLjM4ODY1NzEzMzkxMTc1OCxcbiAgICAxNyA6IDEuMTk0MzI4NTY2OTU1ODc5LFxuICAgIDE4IDogMC41OTcxNjQyODM0Nzc5Mzk1LFxuICAgIDE5IDogMC4yOTg1ODIxNDE3Mzg5Njk3LFxuICAgIDIwIDogMC4xNDkyOTEwNzA4Njk0ODQ5LFxuICAgIDIxIDogMC4wNzQ2NDU1MzU0MzQ3NDI0XG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGlvbnM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSXRvd25zL0NvbnRyb2xzL0F0dHJpYnV0aW9ucy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar AttributionDOM = {\n\n    // ################################################################### //\n    // ######################### Main container ########################## //\n    // ################################################################### //\n\n    /**\n    * Add uuid to the tag ID\n    * @param {String} id - id selector\n    * @returns {String} uid - id selector with an unique id\n    */\n    _addUID: function _addUID(id) {\n        var uid = this._uid ? id + \"-\" + this._uid : id;\n        return uid;\n    },\n\n    /**\n     * Creation du container principal (DOM)\n     *\n     * @returns {DOMElement} div DOM\n     */\n    _createMainContainerElement: function _createMainContainerElement() {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPAttribution\");\n        container.className = \"GPwidget\";\n\n        return container;\n    },\n\n    /**\n     * Creation du selecteur (caché) pour l'affichage/masquage des attributions (DOM)\n     *\n     * @returns {DOMElement} checkbox DOM\n     */\n    _createMainAttributionsShowElement: function _createMainAttributionsShowElement() {\n        var input = document.createElement(\"input\");\n        input.id = this._addUID(\"GPshowAttributionsList\");\n        input.type = \"checkbox\";\n        return input;\n    },\n\n    /**\n     * Création de l'élément liste des attributions (DOM)\n     *\n     * @returns {DOMElement} liste DOM\n     */\n    _createAttributionsList: function _createAttributionsList() {\n        var ul = document.createElement(\"ul\");\n        ul.id = this._addUID(\"GPAttributionsList\");\n        return ul;\n    },\n\n    /**\n     * Création du conteneur principal des attributions (DOM)\n     *\n     * @returns {DOMElement} div DOM\n     */\n    _createMainAttributionsListContainer: function _createMainAttributionsListContainer() {\n        var div = document.createElement(\"div\");\n        div.id = this._addUID(\"GPAttributionsListContainer\");\n\n        return div;\n    },\n\n    /**\n     * Création du container du picto du controle (DOM)\n     * @param {Boolean} collapsed - collapsed\n     * @returns {DOMElement} label DOM\n     */\n    _createMainPictoElement: function _createMainPictoElement(collapsed) {\n        var self = this;\n\n        var label = document.createElement(\"label\");\n        label.id = this._addUID(\"GPshowAttributionsListPicto\");\n        label.className = \"GPshowAdvancedToolPicto\";\n        label.htmlFor = this._addUID(\"GPshowAttributionsList\");\n        label.title = \"Afficher/masquer les attributions\";\n\n        var spanOpen = document.createElement(\"span\");\n        spanOpen.id = this._addUID(\"GPshowAttributionsListOpenClose\");\n        spanOpen.className = \"GPshowAdvancedToolOpen\";\n        spanOpen.innerHTML = collapsed ? \"i\" : \"»\";\n        spanOpen.addEventListener(\"click\", function () {\n            spanOpen.innerHTML = document.getElementById(self._addUID(\"GPshowAttributionsList\")).checked ? \"i\" : \"»\";\n        });\n\n        label.appendChild(spanOpen);\n\n        return label;\n    }\n\n};\n\nexports.default = AttributionDOM;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL0F0dHJpYnV0aW9uRE9NLmpzPzA1NTgiXSwibmFtZXMiOlsiQXR0cmlidXRpb25ET00iLCJfYWRkVUlEIiwiaWQiLCJ1aWQiLCJfdWlkIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiX2NyZWF0ZU1haW5BdHRyaWJ1dGlvbnNTaG93RWxlbWVudCIsImlucHV0IiwidHlwZSIsIl9jcmVhdGVBdHRyaWJ1dGlvbnNMaXN0IiwidWwiLCJfY3JlYXRlTWFpbkF0dHJpYnV0aW9uc0xpc3RDb250YWluZXIiLCJkaXYiLCJfY3JlYXRlTWFpblBpY3RvRWxlbWVudCIsImNvbGxhcHNlZCIsInNlbGYiLCJsYWJlbCIsImh0bWxGb3IiLCJ0aXRsZSIsInNwYW5PcGVuIiwiaW5uZXJIVE1MIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldEVsZW1lbnRCeUlkIiwiY2hlY2tlZCIsImFwcGVuZENoaWxkIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUlBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBQyxhQUFVLGlCQUFVQyxFQUFWLEVBQWM7QUFDcEIsWUFBSUMsTUFBTyxLQUFLQyxJQUFOLEdBQWNGLEtBQUssR0FBTCxHQUFXLEtBQUtFLElBQTlCLEdBQXFDRixFQUEvQztBQUNBLGVBQU9DLEdBQVA7QUFDSCxLQWRnQjs7QUFnQmpCOzs7OztBQUtBRSxpQ0FBOEIsdUNBQVk7QUFDdEMsWUFBSUMsWUFBWUMsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFoQjtBQUNBRixrQkFBVUosRUFBVixHQUFlLEtBQUtELE9BQUwsQ0FBYSxlQUFiLENBQWY7QUFDQUssa0JBQVVHLFNBQVYsR0FBc0IsVUFBdEI7O0FBRUEsZUFBT0gsU0FBUDtBQUNILEtBM0JnQjs7QUE2QmpCOzs7OztBQUtBSSx3Q0FBcUMsOENBQVk7QUFDN0MsWUFBSUMsUUFBUUosU0FBU0MsYUFBVCxDQUF1QixPQUF2QixDQUFaO0FBQ0FHLGNBQU1ULEVBQU4sR0FBVyxLQUFLRCxPQUFMLENBQWEsd0JBQWIsQ0FBWDtBQUNBVSxjQUFNQyxJQUFOLEdBQWEsVUFBYjtBQUNBLGVBQU9ELEtBQVA7QUFDSCxLQXZDZ0I7O0FBeUNqQjs7Ozs7QUFLQUUsNkJBQTBCLG1DQUFZO0FBQ2xDLFlBQUlDLEtBQUtQLFNBQVNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBVDtBQUNBTSxXQUFHWixFQUFILEdBQVEsS0FBS0QsT0FBTCxDQUFhLG9CQUFiLENBQVI7QUFDQSxlQUFPYSxFQUFQO0FBQ0gsS0FsRGdCOztBQW9EakI7Ozs7O0FBS0FDLDBDQUF1QyxnREFBWTtBQUMvQyxZQUFJQyxNQUFNVCxTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQVY7QUFDQVEsWUFBSWQsRUFBSixHQUFTLEtBQUtELE9BQUwsQ0FBYSw2QkFBYixDQUFUOztBQUVBLGVBQU9lLEdBQVA7QUFDSCxLQTlEZ0I7O0FBZ0VqQjs7Ozs7QUFLQUMsNkJBQTBCLGlDQUFVQyxTQUFWLEVBQXFCO0FBQzNDLFlBQUlDLE9BQU8sSUFBWDs7QUFFQSxZQUFJQyxRQUFRYixTQUFTQyxhQUFULENBQXVCLE9BQXZCLENBQVo7QUFDQVksY0FBTWxCLEVBQU4sR0FBVyxLQUFLRCxPQUFMLENBQWEsNkJBQWIsQ0FBWDtBQUNBbUIsY0FBTVgsU0FBTixHQUFrQix5QkFBbEI7QUFDQVcsY0FBTUMsT0FBTixHQUFnQixLQUFLcEIsT0FBTCxDQUFhLHdCQUFiLENBQWhCO0FBQ0FtQixjQUFNRSxLQUFOLEdBQWMsbUNBQWQ7O0FBRUEsWUFBSUMsV0FBV2hCLFNBQVNDLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBZjtBQUNBZSxpQkFBU3JCLEVBQVQsR0FBYyxLQUFLRCxPQUFMLENBQWEsaUNBQWIsQ0FBZDtBQUNBc0IsaUJBQVNkLFNBQVQsR0FBcUIsd0JBQXJCO0FBQ0FjLGlCQUFTQyxTQUFULEdBQXFCTixZQUFZLEdBQVosR0FBa0IsR0FBdkM7QUFDQUssaUJBQVNFLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DLFlBQVk7QUFDM0NGLHFCQUFTQyxTQUFULEdBQXNCakIsU0FBU21CLGNBQVQsQ0FBd0JQLEtBQUtsQixPQUFMLENBQWEsd0JBQWIsQ0FBeEIsRUFBZ0UwQixPQUFqRSxHQUE0RSxHQUE1RSxHQUFrRixHQUF2RztBQUNILFNBRkQ7O0FBSUFQLGNBQU1RLFdBQU4sQ0FBa0JMLFFBQWxCOztBQUVBLGVBQU9ILEtBQVA7QUFDSDs7QUF6RmdCLENBQXJCOztrQkE2RmVwQixjIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEF0dHJpYnV0aW9uRE9NID0ge1xuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAvL1xuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgTWFpbiBjb250YWluZXIgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbiAgICAvKipcbiAgICAqIEFkZCB1dWlkIHRvIHRoZSB0YWcgSURcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIGlkIHNlbGVjdG9yXG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1aWQgLSBpZCBzZWxlY3RvciB3aXRoIGFuIHVuaXF1ZSBpZFxuICAgICovXG4gICAgX2FkZFVJRCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgdWlkID0gKHRoaXMuX3VpZCkgPyBpZCArIFwiLVwiICsgdGhpcy5fdWlkIDogaWQ7XG4gICAgICAgIHJldHVybiB1aWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0aW9uIGR1IGNvbnRhaW5lciBwcmluY2lwYWwgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBkaXYgRE9NXG4gICAgICovXG4gICAgX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29udGFpbmVyLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BBdHRyaWJ1dGlvblwiKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1B3aWRnZXRcIjtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBkdSBzZWxlY3RldXIgKGNhY2jDqSkgcG91ciBsJ2FmZmljaGFnZS9tYXNxdWFnZSBkZXMgYXR0cmlidXRpb25zIChET00pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY2hlY2tib3ggRE9NXG4gICAgICovXG4gICAgX2NyZWF0ZU1haW5BdHRyaWJ1dGlvbnNTaG93RWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBpbnB1dC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQc2hvd0F0dHJpYnV0aW9uc0xpc3RcIik7XG4gICAgICAgIGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3LDqWF0aW9uIGRlIGwnw6lsw6ltZW50IGxpc3RlIGRlcyBhdHRyaWJ1dGlvbnMgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBsaXN0ZSBET01cbiAgICAgKi9cbiAgICBfY3JlYXRlQXR0cmlidXRpb25zTGlzdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IHRoaXMuX2FkZFVJRChcIkdQQXR0cmlidXRpb25zTGlzdFwiKTtcbiAgICAgICAgcmV0dXJuIHVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcsOpYXRpb24gZHUgY29udGVuZXVyIHByaW5jaXBhbCBkZXMgYXR0cmlidXRpb25zIChET00pXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gZGl2IERPTVxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluQXR0cmlidXRpb25zTGlzdENvbnRhaW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IHRoaXMuX2FkZFVJRChcIkdQQXR0cmlidXRpb25zTGlzdENvbnRhaW5lclwiKTtcblxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcsOpYXRpb24gZHUgY29udGFpbmVyIGR1IHBpY3RvIGR1IGNvbnRyb2xlIChET00pXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb2xsYXBzZWQgLSBjb2xsYXBzZWRcbiAgICAgKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gbGFiZWwgRE9NXG4gICAgICovXG4gICAgX2NyZWF0ZU1haW5QaWN0b0VsZW1lbnQgOiBmdW5jdGlvbiAoY29sbGFwc2VkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG4gICAgICAgIGxhYmVsLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93QXR0cmlidXRpb25zTGlzdFBpY3RvXCIpO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBcIkdQc2hvd0FkdmFuY2VkVG9vbFBpY3RvXCI7XG4gICAgICAgIGxhYmVsLmh0bWxGb3IgPSB0aGlzLl9hZGRVSUQoXCJHUHNob3dBdHRyaWJ1dGlvbnNMaXN0XCIpO1xuICAgICAgICBsYWJlbC50aXRsZSA9IFwiQWZmaWNoZXIvbWFzcXVlciBsZXMgYXR0cmlidXRpb25zXCI7XG5cbiAgICAgICAgdmFyIHNwYW5PcGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW5PcGVuLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzaG93QXR0cmlidXRpb25zTGlzdE9wZW5DbG9zZVwiKTtcbiAgICAgICAgc3Bhbk9wZW4uY2xhc3NOYW1lID0gXCJHUHNob3dBZHZhbmNlZFRvb2xPcGVuXCI7XG4gICAgICAgIHNwYW5PcGVuLmlubmVySFRNTCA9IGNvbGxhcHNlZCA/IFwiaVwiIDogXCLCu1wiO1xuICAgICAgICBzcGFuT3Blbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3Bhbk9wZW4uaW5uZXJIVE1MID0gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuX2FkZFVJRChcIkdQc2hvd0F0dHJpYnV0aW9uc0xpc3RcIikpLmNoZWNrZWQpID8gXCJpXCIgOiBcIsK7XCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHNwYW5PcGVuKTtcblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGlvbkRPTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vQ29udHJvbHMvQXR0cmlidXRpb25ET00uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _SelectorID = __webpack_require__(3);\n\nvar _SelectorID2 = _interopRequireDefault(_SelectorID);\n\nvar _ScaleDOM = __webpack_require__(26);\n\nvar _ScaleDOM2 = _interopRequireDefault(_ScaleDOM);\n\nvar _Widget = __webpack_require__(4);\n\nvar _Widget2 = _interopRequireDefault(_Widget);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @classdesc\n * Control to display the scalebar with itowns\n *\n * @constructor\n * @alias itowns.control.Scale\n * @extends {itowns.control.Widget}\n * @alias itowns.control.Scale\n * @param {Object} options - widget options\n * @param {String}  options.target - HTML target element id\n * @param {String}  options.position - \"absolute\" or \"relative\"\n * @example\n * var scale = new itowns.control.Scale();\n *\n */\nfunction Scale(options) {\n    if (!(this instanceof Scale)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    if ((typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        throw new Error(\"ERROR WRONG_TYPE : options should be an object\");\n    }\n\n    this._initialize();\n\n    var container = this._initContainer();\n    var vDiv = document.getElementById(\"viewerDiv\");\n\n    // by default, add the control on the viwerDiv\n    var targetDiv = document.getElementById(options.target) || vDiv;\n\n    _Widget2.default.call(this, {\n        name: \"GraphicScale\",\n        element: container,\n        target: targetDiv,\n        position: options.position\n    });\n}\n\n/*\n * @lends module:Scale\n */\nScale.prototype = Object.create(_Widget2.default.prototype, {});\n\n// retrieves methods of the common class ScaleDOM\n_Utils2.default.assign(Scale.prototype, _ScaleDOM2.default);\n\n/**\n * Constructor (alias)\n *\n * @private\n */\nScale.prototype.constructor = Scale;\n\n// ################################################################### //\n// ############## public methods (getters, setters) ################## //\n// ################################################################### //\n\n/**\n * Bind globe to control\n *\n * @param {GlobeViewExtended} globe - the globe\n */\nScale.prototype.setGlobe = function (globe) {\n    // info : this function is called after a globe.addWidget() or a globe.removeWidget()\n\n    if (globe) {\n        // In the case of the adding of a control to the globe\n        var self = this;\n        /**\n         * Definition of the scaleControl callback :\n         * when the view is changing, we recalculate the graphic scale\n         */\n        this._callbacks.onChangedViewCallback = function () {\n            var value = globe.pixelsToMeters(200);\n            value = Math.floor(value);\n            var digit = Math.pow(10, value.toString().length - 1);\n            value = Math.round(value / digit) * digit;\n            var pix = globe.metersToPixels(value);\n            var unit = \"m\";\n            if (value >= 1000) {\n                value /= 1000;\n                unit = \"km\";\n            }\n            self.getElement().innerHTML = value + \" \" + unit;\n            self.getElement().style.width = pix + \"px\";\n        };\n        // Ajout des listeners\n        // initialization\n        if (globe.isInitialized()) {\n            this._callbacks.onChangedViewCallback();\n        } else {\n            globe.listen(_GlobeViewExtended2.default.EVENTS.GLOBE_INITIALIZED, this._callbacks.onChangedViewCallback);\n        }\n\n        // At every globe range movement, scale bar may be updated,\n        globe.listen(_GlobeViewExtended2.default.EVENTS.RANGE_CHANGED, this._callbacks.onChangedViewCallback);\n    } else if (globe == null) {\n        // we remove the listeners linked to the scalecontrol which has been deleted\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.GLOBE_INITIALIZED, this._callbacks.onChangedViewCallback);\n        this._globe.forget(_GlobeViewExtended2.default.EVENTS.RANGE_CHANGED, this._callbacks.onChangedViewCallback);\n\n        // if globe == null we remove the scale control\n        // delete the scaleControl DOM\n        while (this.getElement().hasChildNodes()) {\n            this.getElement().removeChild(this.getElement().lastChild);\n        }\n        this.getElement().parentNode.removeChild(this.getElement());\n    }\n\n    // call original setGlobe method\n    _Widget2.default.prototype.setGlobe.call(this, globe);\n};\n\n// ################################################################### //\n// ##################### init component ############################## //\n// ################################################################### //\n\n/**\n * Initialize Scale control (called by constructor)\n *\n * @private\n */\nScale.prototype._initialize = function () {\n    // id of the widget : usefull to suffix the CSS ids (to handle cases with several widgets on the same page)\n    this._uid = _SelectorID2.default.generate();\n\n    // div which will contain the list divs.\n    this._ScaleContainer = null;\n\n    // callbacks\n    this._callbacks = {};\n};\n\n/**\n * Create control main container\n *\n * @method _initContainer\n * @returns {DOMElement} container - widget container\n * @private\n */\nScale.prototype._initContainer = function () {\n    var container = this._createMainContainerElement();\n\n    return container;\n};\n\nexports.default = Scale;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL1NjYWxlLmpzP2JkODUiXSwibmFtZXMiOlsiU2NhbGUiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiRXJyb3IiLCJfaW5pdGlhbGl6ZSIsImNvbnRhaW5lciIsIl9pbml0Q29udGFpbmVyIiwidkRpdiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0YXJnZXREaXYiLCJ0YXJnZXQiLCJXaWRnZXQiLCJjYWxsIiwibmFtZSIsImVsZW1lbnQiLCJwb3NpdGlvbiIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsIlV0aWxzIiwiYXNzaWduIiwiU2NhbGVET00iLCJjb25zdHJ1Y3RvciIsInNldEdsb2JlIiwiZ2xvYmUiLCJzZWxmIiwiX2NhbGxiYWNrcyIsIm9uQ2hhbmdlZFZpZXdDYWxsYmFjayIsInZhbHVlIiwicGl4ZWxzVG9NZXRlcnMiLCJNYXRoIiwiZmxvb3IiLCJkaWdpdCIsInBvdyIsInRvU3RyaW5nIiwibGVuZ3RoIiwicm91bmQiLCJwaXgiLCJtZXRlcnNUb1BpeGVscyIsInVuaXQiLCJnZXRFbGVtZW50IiwiaW5uZXJIVE1MIiwic3R5bGUiLCJ3aWR0aCIsImlzSW5pdGlhbGl6ZWQiLCJsaXN0ZW4iLCJHbG9iZVZpZXdFeHRlbmRlZCIsIkVWRU5UUyIsIkdMT0JFX0lOSVRJQUxJWkVEIiwiUkFOR0VfQ0hBTkdFRCIsIl9nbG9iZSIsImZvcmdldCIsImhhc0NoaWxkTm9kZXMiLCJyZW1vdmVDaGlsZCIsImxhc3RDaGlsZCIsInBhcmVudE5vZGUiLCJfdWlkIiwiU2VsZWN0b3JJRCIsImdlbmVyYXRlIiwiX1NjYWxlQ29udGFpbmVyIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxTQUFTQSxLQUFULENBQWdCQyxP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QyxNQUFsQixDQUF5QkUsYUFBNUMsRUFBMkQsS0FBS3ZCLFVBQUwsQ0FBZ0JDLHFCQUEzRTs7QUFFQTtBQUNBO0FBQ0EsZUFBTyxLQUFLYSxVQUFMLEdBQWtCWSxhQUFsQixFQUFQLEVBQTBDO0FBQ3RDLGlCQUFLWixVQUFMLEdBQWtCYSxXQUFsQixDQUE4QixLQUFLYixVQUFMLEdBQWtCYyxTQUFoRDtBQUNIO0FBQ0QsYUFBS2QsVUFBTCxHQUFrQmUsVUFBbEIsQ0FBNkJGLFdBQTdCLENBQXlDLEtBQUtiLFVBQUwsRUFBekM7QUFDSDs7QUFFRDtBQUNBN0IscUJBQU9LLFNBQVAsQ0FBaUJPLFFBQWpCLENBQTBCWCxJQUExQixDQUErQixJQUEvQixFQUFxQ1ksS0FBckM7QUFDSCxDQWhERDs7QUFrREE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBekIsTUFBTWlCLFNBQU4sQ0FBZ0JiLFdBQWhCLEdBQThCLFlBQVk7QUFDdEM7QUFDQSxTQUFLcUQsSUFBTCxHQUFZQyxxQkFBV0MsUUFBWCxFQUFaOztBQUVBO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QixJQUF2Qjs7QUFFQTtBQUNBLFNBQUtqQyxVQUFMLEdBQWtCLEVBQWxCO0FBQ0gsQ0FURDs7QUFXQTs7Ozs7OztBQU9BM0IsTUFBTWlCLFNBQU4sQ0FBZ0JYLGNBQWhCLEdBQWlDLFlBQVk7QUFDekMsUUFBSUQsWUFBWSxLQUFLd0QsMkJBQUwsRUFBaEI7O0FBRUEsV0FBT3hELFNBQVA7QUFDSCxDQUpEOztrQkFNZUwsSyIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHbG9iZVZpZXdFeHRlbmRlZCBmcm9tIFwiLi4vR2xvYmVWaWV3RXh0ZW5kZWRcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzXCI7XG5pbXBvcnQgU2VsZWN0b3JJRCBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL1NlbGVjdG9ySURcIjtcbmltcG9ydCBTY2FsZURPTSBmcm9tIFwiLi4vLi4vQ29tbW9uL0NvbnRyb2xzL1NjYWxlRE9NXCI7XG5pbXBvcnQgV2lkZ2V0IGZyb20gXCIuL1dpZGdldFwiO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRyb2wgdG8gZGlzcGxheSB0aGUgc2NhbGViYXIgd2l0aCBpdG93bnNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBpdG93bnMuY29udHJvbC5TY2FsZVxuICogQGV4dGVuZHMge2l0b3ducy5jb250cm9sLldpZGdldH1cbiAqIEBhbGlhcyBpdG93bnMuY29udHJvbC5TY2FsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3aWRnZXQgb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9ICBvcHRpb25zLnRhcmdldCAtIEhUTUwgdGFyZ2V0IGVsZW1lbnQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSAgb3B0aW9ucy5wb3NpdGlvbiAtIFwiYWJzb2x1dGVcIiBvciBcInJlbGF0aXZlXCJcbiAqIEBleGFtcGxlXG4gKiB2YXIgc2NhbGUgPSBuZXcgaXRvd25zLmNvbnRyb2wuU2NhbGUoKTtcbiAqXG4gKi9cbmZ1bmN0aW9uIFNjYWxlIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjYWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRVJST1IgQ0xBU1NfQ09OU1RSVUNUT1JcIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFdST05HX1RZUEUgOiBvcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3RcIik7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2luaXRDb250YWluZXIoKTtcbiAgICB2YXIgdkRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlld2VyRGl2XCIpO1xuXG4gICAgLy8gYnkgZGVmYXVsdCwgYWRkIHRoZSBjb250cm9sIG9uIHRoZSB2aXdlckRpdlxuICAgIHZhciB0YXJnZXREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLnRhcmdldCkgfHwgdkRpdjtcblxuICAgIFdpZGdldC5jYWxsKFxuICAgICAgICB0aGlzLCB7XG4gICAgICAgICAgICBuYW1lIDogXCJHcmFwaGljU2NhbGVcIixcbiAgICAgICAgICAgIGVsZW1lbnQgOiBjb250YWluZXIsXG4gICAgICAgICAgICB0YXJnZXQgOiB0YXJnZXREaXYsXG4gICAgICAgICAgICBwb3NpdGlvbiA6IG9wdGlvbnMucG9zaXRpb25cbiAgICAgICAgfVxuICAgICk7XG59XG5cbi8qXG4gKiBAbGVuZHMgbW9kdWxlOlNjYWxlXG4gKi9cblNjYWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2lkZ2V0LnByb3RvdHlwZSwge30pO1xuXG4vLyByZXRyaWV2ZXMgbWV0aG9kcyBvZiB0aGUgY29tbW9uIGNsYXNzIFNjYWxlRE9NXG5VdGlscy5hc3NpZ24oU2NhbGUucHJvdG90eXBlLCBTY2FsZURPTSk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgKGFsaWFzKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cblNjYWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjYWxlO1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyBwdWJsaWMgbWV0aG9kcyAoZ2V0dGVycywgc2V0dGVycykgIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogQmluZCBnbG9iZSB0byBjb250cm9sXG4gKlxuICogQHBhcmFtIHtHbG9iZVZpZXdFeHRlbmRlZH0gZ2xvYmUgLSB0aGUgZ2xvYmVcbiAqL1xuU2NhbGUucHJvdG90eXBlLnNldEdsb2JlID0gZnVuY3Rpb24gKGdsb2JlKSB7XG4gICAgLy8gaW5mbyA6IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGEgZ2xvYmUuYWRkV2lkZ2V0KCkgb3IgYSBnbG9iZS5yZW1vdmVXaWRnZXQoKVxuXG4gICAgaWYgKGdsb2JlKSB7IC8vIEluIHRoZSBjYXNlIG9mIHRoZSBhZGRpbmcgb2YgYSBjb250cm9sIHRvIHRoZSBnbG9iZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbml0aW9uIG9mIHRoZSBzY2FsZUNvbnRyb2wgY2FsbGJhY2sgOlxuICAgICAgICAgKiB3aGVuIHRoZSB2aWV3IGlzIGNoYW5naW5nLCB3ZSByZWNhbGN1bGF0ZSB0aGUgZ3JhcGhpYyBzY2FsZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLm9uQ2hhbmdlZFZpZXdDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdsb2JlLnBpeGVsc1RvTWV0ZXJzKDIwMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gTWF0aC5wb3coMTAsIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyBkaWdpdCkgKiBkaWdpdDtcbiAgICAgICAgICAgIHZhciBwaXggPSBnbG9iZS5tZXRlcnNUb1BpeGVscyh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IFwibVwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IDEwMDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAvPSAxMDAwO1xuICAgICAgICAgICAgICAgIHVuaXQgPSBcImttXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmdldEVsZW1lbnQoKS5pbm5lckhUTUwgPSB2YWx1ZSArIFwiIFwiICsgdW5pdDtcbiAgICAgICAgICAgIHNlbGYuZ2V0RWxlbWVudCgpLnN0eWxlLndpZHRoID0gcGl4ICsgXCJweFwiO1xuICAgICAgICB9O1xuICAgICAgICAvLyBBam91dCBkZXMgbGlzdGVuZXJzXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmIChnbG9iZS5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5vbkNoYW5nZWRWaWV3Q2FsbGJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JlLmxpc3RlbihHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuR0xPQkVfSU5JVElBTElaRUQsIHRoaXMuX2NhbGxiYWNrcy5vbkNoYW5nZWRWaWV3Q2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXQgZXZlcnkgZ2xvYmUgcmFuZ2UgbW92ZW1lbnQsIHNjYWxlIGJhciBtYXkgYmUgdXBkYXRlZCxcbiAgICAgICAgZ2xvYmUubGlzdGVuKEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5SQU5HRV9DSEFOR0VELCB0aGlzLl9jYWxsYmFja3Mub25DaGFuZ2VkVmlld0NhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JlID09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgbGlua2VkIHRvIHRoZSBzY2FsZWNvbnRyb2wgd2hpY2ggaGFzIGJlZW4gZGVsZXRlZFxuICAgICAgICB0aGlzLl9nbG9iZS5mb3JnZXQoR2xvYmVWaWV3RXh0ZW5kZWQuRVZFTlRTLkdMT0JFX0lOSVRJQUxJWkVELCB0aGlzLl9jYWxsYmFja3Mub25DaGFuZ2VkVmlld0NhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fZ2xvYmUuZm9yZ2V0KEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5SQU5HRV9DSEFOR0VELCB0aGlzLl9jYWxsYmFja3Mub25DaGFuZ2VkVmlld0NhbGxiYWNrKTtcblxuICAgICAgICAvLyBpZiBnbG9iZSA9PSBudWxsIHdlIHJlbW92ZSB0aGUgc2NhbGUgY29udHJvbFxuICAgICAgICAvLyBkZWxldGUgdGhlIHNjYWxlQ29udHJvbCBET01cbiAgICAgICAgd2hpbGUgKHRoaXMuZ2V0RWxlbWVudCgpLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkucmVtb3ZlQ2hpbGQodGhpcy5nZXRFbGVtZW50KCkubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ2V0RWxlbWVudCgpKTtcbiAgICB9XG5cbiAgICAvLyBjYWxsIG9yaWdpbmFsIHNldEdsb2JlIG1ldGhvZFxuICAgIFdpZGdldC5wcm90b3R5cGUuc2V0R2xvYmUuY2FsbCh0aGlzLCBnbG9iZSk7XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCBjb21wb25lbnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBTY2FsZSBjb250cm9sIChjYWxsZWQgYnkgY29uc3RydWN0b3IpXG4gKlxuICogQHByaXZhdGVcbiAqL1xuU2NhbGUucHJvdG90eXBlLl9pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlkIG9mIHRoZSB3aWRnZXQgOiB1c2VmdWxsIHRvIHN1ZmZpeCB0aGUgQ1NTIGlkcyAodG8gaGFuZGxlIGNhc2VzIHdpdGggc2V2ZXJhbCB3aWRnZXRzIG9uIHRoZSBzYW1lIHBhZ2UpXG4gICAgdGhpcy5fdWlkID0gU2VsZWN0b3JJRC5nZW5lcmF0ZSgpO1xuXG4gICAgLy8gZGl2IHdoaWNoIHdpbGwgY29udGFpbiB0aGUgbGlzdCBkaXZzLlxuICAgIHRoaXMuX1NjYWxlQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIGNhbGxiYWNrc1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgY29udHJvbCBtYWluIGNvbnRhaW5lclxuICpcbiAqIEBtZXRob2QgX2luaXRDb250YWluZXJcbiAqIEByZXR1cm5zIHtET01FbGVtZW50fSBjb250YWluZXIgLSB3aWRnZXQgY29udGFpbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5TY2FsZS5wcm90b3R5cGUuX2luaXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50KCk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2NhbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSXRvd25zL0NvbnRyb2xzL1NjYWxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar ScaleDOM = {\n\n    /**\n    * Add uuid to the tag ID\n    * @param {String} id - id selector\n    * @returns {String} uid - id selector with an unique id\n    */\n    _addUID: function _addUID(id) {\n        var uid = this._uid ? id + \"-\" + this._uid : id;\n        return uid;\n    },\n\n    /**\n     * Main container (DOM)\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMainContainerElement: function _createMainContainerElement() {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPscaleContainer\");\n        container.className = \"GPwidget\";\n        return container;\n    }\n};\n\nexports.default = ScaleDOM;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL1NjYWxlRE9NLmpzPzY1OWIiXSwibmFtZXMiOlsiU2NhbGVET00iLCJfYWRkVUlEIiwiaWQiLCJ1aWQiLCJfdWlkIiwiX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLElBQUlBLFdBQVc7O0FBRVg7Ozs7O0FBS0FDLGFBQVUsaUJBQVVDLEVBQVYsRUFBYztBQUNwQixZQUFJQyxNQUFPLEtBQUtDLElBQU4sR0FBY0YsS0FBSyxHQUFMLEdBQVcsS0FBS0UsSUFBOUIsR0FBcUNGLEVBQS9DO0FBQ0EsZUFBT0MsR0FBUDtBQUNILEtBVlU7O0FBWVg7Ozs7O0FBS0FFLGlDQUE4Qix1Q0FBWTtBQUN0QyxZQUFJQyxZQUFZQyxTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0FBQ0FGLGtCQUFVSixFQUFWLEdBQWUsS0FBS0QsT0FBTCxDQUFhLGtCQUFiLENBQWY7QUFDQUssa0JBQVVHLFNBQVYsR0FBc0IsVUFBdEI7QUFDQSxlQUFPSCxTQUFQO0FBQ0g7QUF0QlUsQ0FBZjs7a0JBeUJlTixRIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFNjYWxlRE9NID0ge1xuXG4gICAgLyoqXG4gICAgKiBBZGQgdXVpZCB0byB0aGUgdGFnIElEXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBpZCBzZWxlY3RvclxuICAgICogQHJldHVybnMge1N0cmluZ30gdWlkIC0gaWQgc2VsZWN0b3Igd2l0aCBhbiB1bmlxdWUgaWRcbiAgICAqL1xuICAgIF9hZGRVSUQgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHVpZCA9ICh0aGlzLl91aWQpID8gaWQgKyBcIi1cIiArIHRoaXMuX3VpZCA6IGlkO1xuICAgICAgICByZXR1cm4gdWlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWluIGNvbnRhaW5lciAoRE9NKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0RPTUVsZW1lbnR9IERPTSBlbGVtZW50XG4gICAgICovXG4gICAgX2NyZWF0ZU1haW5Db250YWluZXJFbGVtZW50IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgY29udGFpbmVyLmlkID0gdGhpcy5fYWRkVUlEKFwiR1BzY2FsZUNvbnRhaW5lclwiKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiR1B3aWRnZXRcIjtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTY2FsZURPTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vQ29udHJvbHMvU2NhbGVET00uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _GlobeViewExtended = __webpack_require__(2);\n\nvar _GlobeViewExtended2 = _interopRequireDefault(_GlobeViewExtended);\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _SelectorID = __webpack_require__(3);\n\nvar _SelectorID2 = _interopRequireDefault(_SelectorID);\n\nvar _MiniGlobeDOM = __webpack_require__(28);\n\nvar _MiniGlobeDOM2 = _interopRequireDefault(_MiniGlobeDOM);\n\nvar _Widget = __webpack_require__(4);\n\nvar _Widget2 = _interopRequireDefault(_Widget);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @classdesc\n * Control to display the MiniGlobe with itowns\n *\n * @constructor\n * @extends {itowns.control.Widget}\n * @alias itowns.control.MiniGlobe\n * @param {Object} [options] - control options\n * @param {Object} [options.layer] - custom itowns layer to display on the mini globe\n * @example\n * var miniglobe = new itowns.control.MiniGlobe();\n *\n */\nfunction MiniGlobe(options) {\n    options = options || {};\n\n    if (!(this instanceof MiniGlobe)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    if (options && (typeof options === \"undefined\" ? \"undefined\" : _typeof(options)) !== \"object\") {\n        throw new Error(\"ERROR WRONG_TYPE : options should be an object\");\n    }\n\n    this._initialize();\n\n    var container = this._initContainer();\n    var vDiv = document.getElementById(\"viewerDiv\");\n    this._options = options;\n\n    // by default, adds the control on the viewerDiv\n    var targetDiv = document.getElementById(options.target) || vDiv;\n\n    _Widget2.default.call(this, {\n        name: \"Overview\",\n        element: container,\n        target: targetDiv,\n        position: options.position\n    });\n}\n\n/*\n * @lends module:MiniGlobe\n */\nMiniGlobe.prototype = Object.create(_Widget2.default.prototype, {});\n\n// retrieves methods of the common class MiniGlobeDOM\n_Utils2.default.assign(MiniGlobe.prototype, _MiniGlobeDOM2.default);\n\n/**\n * Constructor (alias)\n *\n * @private\n */\nMiniGlobe.prototype.constructor = MiniGlobe;\n\n// ################################################################### //\n// ############## public methods (getters, setters) ################## //\n// ################################################################### //\n\n/**\n * Bind globe to control\n *\n * @param {GlobeViewExtended} globe - the globe\n */\nMiniGlobe.prototype.setGlobe = function (globe) {\n    // info : this function is called after a globe.addWidget() or a globe.removeWidget()\n\n    if (globe) {\n        // In the case of the adding of a control to the globe\n        var minDistance = 6650000;\n        var maxDistance = 30000000;\n        var positionOnGlobe = globe.getCenter();\n        var miniView = new _GlobeViewExtended2.default(this._element, positionOnGlobe, {\n            // `limit globe' subdivision level:\n            // we're don't need a precise globe model\n            // since the mini globe will always be seen from a far point of view (see minDistance above)\n            maxSubdivisionLevel: 6,\n            // Don't instance default controls since miniview's camera will be synced\n            // on the main view's one (see globeView.onAfterRender)\n            noControls: true,\n            position: \"absolute\"\n        });\n\n        miniView.setBackground();\n\n        var updateMiniGlobeHandler = function updateMiniGlobeHandler() {\n            // clamp distance camera from globe\n            var range = globe.getRange();\n            var distance = Math.min(Math.max(range * 1.5, minDistance), maxDistance);\n            // Update target miniview's camera\n            miniView.setCameraPosition(globe.moveTarget(), distance);\n            miniView.lookAt(globe.moveTarget());\n            miniView.notifyChange();\n        };\n        globe.listen(_GlobeViewExtended2.default.EVENTS.AFTER_RENDER, updateMiniGlobeHandler);\n        if (globe.isInitialized()) {\n            updateMiniGlobeHandler();\n        } else {\n            globe.listen(_GlobeViewExtended2.default.EVENTS.GLOBE_INITIALIZED, updateMiniGlobeHandler);\n        }\n\n        /**\n         * Add one imagery layer to the miniview (by default, the ortho)\n         */\n        var miniGlobeLayer = this._options.layer || this._baseLayer;\n        miniView.addLayer(miniGlobeLayer);\n        // save as property of the control the globe created for the overview\n        this._globeObj = miniView;\n    } else if (globe == null) {\n        // if globe == null we remove the overview control\n        // we delete the overview control DOM\n        while (this.getElement().hasChildNodes()) {\n            this.getElement().removeChild(this.getElement().lastChild);\n        }\n        this.getElement().parentNode.removeChild(this.getElement());\n    }\n\n    // call original setGlobe method\n    _Widget2.default.prototype.setGlobe.call(this, globe);\n};\n\n// ################################################################### //\n// ##################### init component ############################## //\n// ################################################################### //\n\n/**\n * Initialize MiniGlobe control (called by constructor)\n *\n * @private\n */\nMiniGlobe.prototype._initialize = function () {\n    // id of the widget : usefull to suffix the CSS ids (to handle cases with several widgets on the same page)\n    this._uid = _SelectorID2.default.generate();\n\n    // div which will contain the list divs.\n    this._MiniGlobeContainer = null;\n\n    // callbacks\n    this._callbacks = {};\n};\n\n/**\n * Creates control main container\n *\n * @method _initContainer\n * @returns {DOMElement} container - widget container\n * @private\n */\nMiniGlobe.prototype._initContainer = function () {\n    var container = this._createMainContainerElement();\n\n    return container;\n};\n\nMiniGlobe.prototype._baseLayer = {\n    type: \"color\",\n    protocol: \"wmts\",\n    id: \"Maps\",\n    url: \"https://wxs.ign.fr/an7nvfzojv5wa96dsga5nk8w/geoportail/wmts\",\n    updateStrategy: {\n        type: \"0\",\n        options: {}\n    },\n    networkOptions: {\n        crossOrigin: \"omit\"\n    },\n    options: {\n        name: \"GEOGRAPHICALGRIDSYSTEMS.MAPS\",\n        mimetype: \"image/jpeg\",\n        tileMatrixSet: \"PM\",\n        tileMatrixSetLimits: {\n            0: {\n                minTileRow: \"0\",\n                maxTileRow: \"0\",\n                minTileCol: \"0\",\n                maxTileCol: \"1\"\n            },\n            1: {\n                minTileRow: \"0\",\n                maxTileRow: \"1\",\n                minTileCol: \"0\",\n                maxTileCol: \"2\"\n            },\n            2: {\n                minTileRow: \"0\",\n                maxTileRow: \"2\",\n                minTileCol: \"0\",\n                maxTileCol: \"4\"\n            },\n            3: {\n                minTileRow: \"0\",\n                maxTileRow: \"5\",\n                minTileCol: \"0\",\n                maxTileCol: \"8\"\n            },\n            4: {\n                minTileRow: \"1\",\n                maxTileRow: \"11\",\n                minTileCol: \"0\",\n                maxTileCol: \"16\"\n            },\n            5: {\n                minTileRow: \"3\",\n                maxTileRow: \"22\",\n                minTileCol: \"0\",\n                maxTileCol: \"32\"\n            },\n            6: {\n                minTileRow: \"7\",\n                maxTileRow: \"45\",\n                minTileCol: \"0\",\n                maxTileCol: \"64\"\n            },\n            7: {\n                minTileRow: \"42\",\n                maxTileRow: \"97\",\n                minTileCol: \"0\",\n                maxTileCol: \"115\"\n            },\n            8: {\n                minTileRow: \"84\",\n                maxTileRow: \"195\",\n                minTileCol: \"1\",\n                maxTileCol: \"247\"\n            },\n            9: {\n                minTileRow: \"170\",\n                maxTileRow: \"390\",\n                minTileCol: \"2\",\n                maxTileCol: \"495\"\n            },\n            10: {\n                minTileRow: \"340\",\n                maxTileRow: \"780\",\n                minTileCol: \"5\",\n                maxTileCol: \"990\"\n            },\n            11: {\n                minTileRow: \"681\",\n                maxTileRow: \"1544\",\n                minTileCol: \"10\",\n                maxTileCol: \"1981\"\n            },\n            12: {\n                minTileRow: \"1363\",\n                maxTileRow: \"3088\",\n                minTileCol: \"20\",\n                maxTileCol: \"3962\"\n            },\n            13: {\n                minTileRow: \"2726\",\n                maxTileRow: \"6177\",\n                minTileCol: \"40\",\n                maxTileCol: \"7924\"\n            },\n            14: {\n                minTileRow: \"5452\",\n                maxTileRow: \"12355\",\n                minTileCol: \"81\",\n                maxTileCol: \"15847\"\n            },\n            15: {\n                minTileRow: \"10944\",\n                maxTileRow: \"21176\",\n                minTileCol: \"163\",\n                maxTileCol: \"31695\"\n            },\n            16: {\n                minTileRow: \"21889\",\n                maxTileRow: \"42353\",\n                minTileCol: \"326\",\n                maxTileCol: \"63382\"\n            },\n            17: {\n                minTileRow: \"43776\",\n                maxTileRow: \"73526\",\n                minTileCol: \"42528\",\n                maxTileCol: \"85869\"\n            },\n            18: {\n                minTileRow: \"87557\",\n                maxTileRow: \"147052\",\n                minTileCol: \"85058\",\n                maxTileCol: \"171738\"\n            }\n        }\n    }\n};\n\nexports.default = MiniGlobe;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NvbnRyb2xzL01pbmlHbG9iZS5qcz9kMWM0Il0sIm5hbWVzIjpbIk1pbmlHbG9iZSIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJFcnJvciIsIl9pbml0aWFsaXplIiwiY29udGFpbmVyIiwiX2luaXRDb250YWluZXIiLCJ2RGl2IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIl9vcHRpb25zIiwidGFyZ2V0RGl2IiwidGFyZ2V0IiwiV2lkZ2V0IiwiY2FsbCIsIm5hbWUiLCJlbGVtZW50IiwicG9zaXRpb24iLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJVdGlscyIsImFzc2lnbiIsIk1pbmlHbG9iZURPTSIsImNvbnN0cnVjdG9yIiwic2V0R2xvYmUiLCJnbG9iZSIsIm1pbkRpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJwb3NpdGlvbk9uR2xvYmUiLCJnZXRDZW50ZXIiLCJtaW5pVmlldyIsIkdsb2JlVmlld0V4dGVuZGVkIiwiX2VsZW1lbnQiLCJtYXhTdWJkaXZpc2lvbkxldmVsIiwibm9Db250cm9scyIsInNldEJhY2tncm91bmQiLCJ1cGRhdGVNaW5pR2xvYmVIYW5kbGVyIiwicmFuZ2UiLCJnZXRSYW5nZSIsImRpc3RhbmNlIiwiTWF0aCIsIm1pbiIsIm1heCIsInNldENhbWVyYVBvc2l0aW9uIiwibW92ZVRhcmdldCIsImxvb2tBdCIsIm5vdGlmeUNoYW5nZSIsImxpc3RlbiIsIkVWRU5UUyIsIkFGVEVSX1JFTkRFUiIsImlzSW5pdGlhbGl6ZWQiLCJHTE9CRV9JTklUSUFMSVpFRCIsIm1pbmlHbG9iZUxheWVyIiwibGF5ZXIiLCJfYmFzZUxheWVyIiwiYWRkTGF5ZXIiLCJfZ2xvYmVPYmoiLCJnZXRFbGVtZW50IiwiaGFzQ2hpbGROb2RlcyIsInJlbW92ZUNoaWxkIiwibGFzdENoaWxkIiwicGFyZW50Tm9kZSIsIl91aWQiLCJTZWxlY3RvcklEIiwiZ2VuZXJhdGUiLCJfTWluaUdsb2JlQ29udGFpbmVyIiwiX2NhbGxiYWNrcyIsIl9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCIsInR5cGUiLCJwcm90b2NvbCIsImlkIiwidXJsIiwidXBkYXRlU3RyYXRlZ3kiLCJuZXR3b3JrT3B0aW9ucyIsImNyb3NzT3JpZ2luIiwibWltZXR5cGUiLCJ0aWxlTWF0cml4U2V0IiwidGlsZU1hdHJpeFNldExpbWl0cyIsIm1pblRpbGVSb3ciLCJtYXhUaWxlUm93IiwibWluVGlsZUNvbCIsIm1heFRpbGVDb2wiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTQSxTQUFULENBQW9CQyxPQUFwQixFQUE2QjtBQUN6QkEsY0FBVUEsV0FBVyxFQUFyQjs7QUFFQSxRQUFJLEVBQUUsZ0JBQWdCRCxTQUFsQixDQUFKLEVBQWtDO0FBQzlCLGNBQU0sSUFBSUUsU0FBSixDQUFjLHlCQUFkLENBQU47QUFDSDs7QUFFRCxRQUFJRCxXQUFXLFFBQU9BLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBbEMsRUFBNEM7QUFDeEMsY0FBTSxJQUFJRSxLQUFKLENBQVUsZ0RBQVYsQ0FBTjtBQUNIOztBQUVELFNBQUtDLFdBQUw7O0FBRUEsUUFBSUMsWUFBWSxLQUFLQyxjQUFMLEVBQWhCO0FBQ0EsUUFBSUMsT0FBT0MsU0FBU0MsY0FBVCxDQUF3QixXQUF4QixDQUFYO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQlQsT0FBaEI7O0FBRUE7QUFDQSxRQUFJVSxZQUFZSCxTQUFTQyxjQUFULENBQXdCUixRQUFRVyxNQUFoQyxLQUEyQ0wsSUFBM0Q7O0FBRUFNLHFCQUFPQyxJQUFQLENBQ0ksSUFESixFQUNVO0FBQ0ZDLGNBQU8sVUFETDtBQUVGQyxpQkFBVVgsU0FGUjtBQUdGTyxnQkFBU0QsU0FIUDtBQUlGTSxrQkFBV2hCLFFBQVFnQjtBQUpqQixLQURWO0FBUUg7O0FBRUQ7OztBQUdBakIsVUFBVWtCLFNBQVYsR0FB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QkFBYSxPQUZaO0FBR0RDLDRCQUFhLE9BSFo7QUFJREMsNEJBQWE7QUFKWixhQXZHYTtBQTZHbEIsZ0JBQUs7QUFDREgsNEJBQWEsT0FEWjtBQUVEQyw0QkFBYSxRQUZaO0FBR0RDLDRCQUFhLE9BSFo7QUFJREMsNEJBQWE7QUFKWjtBQTdHYTtBQUpoQjtBQVptQixDQUFqQzs7a0JBdUllbEYsUyIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHbG9iZVZpZXdFeHRlbmRlZCBmcm9tIFwiLi4vR2xvYmVWaWV3RXh0ZW5kZWRcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzXCI7XG5pbXBvcnQgU2VsZWN0b3JJRCBmcm9tIFwiLi4vLi4vQ29tbW9uL1V0aWxzL1NlbGVjdG9ySURcIjtcbmltcG9ydCBNaW5pR2xvYmVET00gZnJvbSBcIi4uLy4uL0NvbW1vbi9Db250cm9scy9NaW5pR2xvYmVET01cIjtcbmltcG9ydCBXaWRnZXQgZnJvbSBcIi4vV2lkZ2V0XCI7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ29udHJvbCB0byBkaXNwbGF5IHRoZSBNaW5pR2xvYmUgd2l0aCBpdG93bnNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtpdG93bnMuY29udHJvbC5XaWRnZXR9XG4gKiBAYWxpYXMgaXRvd25zLmNvbnRyb2wuTWluaUdsb2JlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gY29udHJvbCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGF5ZXJdIC0gY3VzdG9tIGl0b3ducyBsYXllciB0byBkaXNwbGF5IG9uIHRoZSBtaW5pIGdsb2JlXG4gKiBAZXhhbXBsZVxuICogdmFyIG1pbmlnbG9iZSA9IG5ldyBpdG93bnMuY29udHJvbC5NaW5pR2xvYmUoKTtcbiAqXG4gKi9cbmZ1bmN0aW9uIE1pbmlHbG9iZSAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmlHbG9iZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVSUk9SIENMQVNTX0NPTlNUUlVDVE9SXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFdST05HX1RZUEUgOiBvcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3RcIik7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2luaXRDb250YWluZXIoKTtcbiAgICB2YXIgdkRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmlld2VyRGl2XCIpO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gYnkgZGVmYXVsdCwgYWRkcyB0aGUgY29udHJvbCBvbiB0aGUgdmlld2VyRGl2XG4gICAgdmFyIHRhcmdldERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMudGFyZ2V0KSB8fCB2RGl2O1xuXG4gICAgV2lkZ2V0LmNhbGwoXG4gICAgICAgIHRoaXMsIHtcbiAgICAgICAgICAgIG5hbWUgOiBcIk92ZXJ2aWV3XCIsXG4gICAgICAgICAgICBlbGVtZW50IDogY29udGFpbmVyLFxuICAgICAgICAgICAgdGFyZ2V0IDogdGFyZ2V0RGl2LFxuICAgICAgICAgICAgcG9zaXRpb24gOiBvcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH1cbiAgICApO1xufVxuXG4vKlxuICogQGxlbmRzIG1vZHVsZTpNaW5pR2xvYmVcbiAqL1xuTWluaUdsb2JlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV2lkZ2V0LnByb3RvdHlwZSwge30pO1xuXG4vLyByZXRyaWV2ZXMgbWV0aG9kcyBvZiB0aGUgY29tbW9uIGNsYXNzIE1pbmlHbG9iZURPTVxuVXRpbHMuYXNzaWduKE1pbmlHbG9iZS5wcm90b3R5cGUsIE1pbmlHbG9iZURPTSk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgKGFsaWFzKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1pbmlHbG9iZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaW5pR2xvYmU7XG5cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzIChnZXR0ZXJzLCBzZXR0ZXJzKSAjIyMjIyMjIyMjIyMjIyMjIyMgLy9cbi8vICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgLy9cblxuLyoqXG4gKiBCaW5kIGdsb2JlIHRvIGNvbnRyb2xcbiAqXG4gKiBAcGFyYW0ge0dsb2JlVmlld0V4dGVuZGVkfSBnbG9iZSAtIHRoZSBnbG9iZVxuICovXG5NaW5pR2xvYmUucHJvdG90eXBlLnNldEdsb2JlID0gZnVuY3Rpb24gKGdsb2JlKSB7XG4gICAgLy8gaW5mbyA6IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGEgZ2xvYmUuYWRkV2lkZ2V0KCkgb3IgYSBnbG9iZS5yZW1vdmVXaWRnZXQoKVxuXG4gICAgaWYgKGdsb2JlKSB7IC8vIEluIHRoZSBjYXNlIG9mIHRoZSBhZGRpbmcgb2YgYSBjb250cm9sIHRvIHRoZSBnbG9iZVxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSA2NjUwMDAwO1xuICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSAzMDAwMDAwMDtcbiAgICAgICAgdmFyIHBvc2l0aW9uT25HbG9iZSA9IGdsb2JlLmdldENlbnRlcigpO1xuICAgICAgICB2YXIgbWluaVZpZXcgPSBuZXcgR2xvYmVWaWV3RXh0ZW5kZWQodGhpcy5fZWxlbWVudCwgcG9zaXRpb25Pbkdsb2JlLCB7XG4gICAgICAgICAgICAvLyBgbGltaXQgZ2xvYmUnIHN1YmRpdmlzaW9uIGxldmVsOlxuICAgICAgICAgICAgLy8gd2UncmUgZG9uJ3QgbmVlZCBhIHByZWNpc2UgZ2xvYmUgbW9kZWxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBtaW5pIGdsb2JlIHdpbGwgYWx3YXlzIGJlIHNlZW4gZnJvbSBhIGZhciBwb2ludCBvZiB2aWV3IChzZWUgbWluRGlzdGFuY2UgYWJvdmUpXG4gICAgICAgICAgICBtYXhTdWJkaXZpc2lvbkxldmVsIDogNixcbiAgICAgICAgICAgIC8vIERvbid0IGluc3RhbmNlIGRlZmF1bHQgY29udHJvbHMgc2luY2UgbWluaXZpZXcncyBjYW1lcmEgd2lsbCBiZSBzeW5jZWRcbiAgICAgICAgICAgIC8vIG9uIHRoZSBtYWluIHZpZXcncyBvbmUgKHNlZSBnbG9iZVZpZXcub25BZnRlclJlbmRlcilcbiAgICAgICAgICAgIG5vQ29udHJvbHMgOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb24gOiBcImFic29sdXRlXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWluaVZpZXcuc2V0QmFja2dyb3VuZCgpO1xuXG4gICAgICAgIHZhciB1cGRhdGVNaW5pR2xvYmVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2xhbXAgZGlzdGFuY2UgY2FtZXJhIGZyb20gZ2xvYmVcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGdsb2JlLmdldFJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1pbihNYXRoLm1heChyYW5nZSAqIDEuNSwgbWluRGlzdGFuY2UpLCBtYXhEaXN0YW5jZSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGFyZ2V0IG1pbml2aWV3J3MgY2FtZXJhXG4gICAgICAgICAgICBtaW5pVmlldy5zZXRDYW1lcmFQb3NpdGlvbihnbG9iZS5tb3ZlVGFyZ2V0KCksIGRpc3RhbmNlKTtcbiAgICAgICAgICAgIG1pbmlWaWV3Lmxvb2tBdChnbG9iZS5tb3ZlVGFyZ2V0KCkpO1xuICAgICAgICAgICAgbWluaVZpZXcubm90aWZ5Q2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGdsb2JlLmxpc3RlbihHbG9iZVZpZXdFeHRlbmRlZC5FVkVOVFMuQUZURVJfUkVOREVSLCB1cGRhdGVNaW5pR2xvYmVIYW5kbGVyKTtcbiAgICAgICAgaWYgKGdsb2JlLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgdXBkYXRlTWluaUdsb2JlSGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmUubGlzdGVuKEdsb2JlVmlld0V4dGVuZGVkLkVWRU5UUy5HTE9CRV9JTklUSUFMSVpFRCwgdXBkYXRlTWluaUdsb2JlSGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIG9uZSBpbWFnZXJ5IGxheWVyIHRvIHRoZSBtaW5pdmlldyAoYnkgZGVmYXVsdCwgdGhlIG9ydGhvKVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1pbmlHbG9iZUxheWVyID0gdGhpcy5fb3B0aW9ucy5sYXllciB8fCB0aGlzLl9iYXNlTGF5ZXI7XG4gICAgICAgIG1pbmlWaWV3LmFkZExheWVyKG1pbmlHbG9iZUxheWVyKTtcbiAgICAgICAgLy8gc2F2ZSBhcyBwcm9wZXJ0eSBvZiB0aGUgY29udHJvbCB0aGUgZ2xvYmUgY3JlYXRlZCBmb3IgdGhlIG92ZXJ2aWV3XG4gICAgICAgIHRoaXMuX2dsb2JlT2JqID0gbWluaVZpZXc7XG4gICAgfSBlbHNlIGlmIChnbG9iZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIGlmIGdsb2JlID09IG51bGwgd2UgcmVtb3ZlIHRoZSBvdmVydmlldyBjb250cm9sXG4gICAgICAgIC8vIHdlIGRlbGV0ZSB0aGUgb3ZlcnZpZXcgY29udHJvbCBET01cbiAgICAgICAgd2hpbGUgKHRoaXMuZ2V0RWxlbWVudCgpLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRFbGVtZW50KCkucmVtb3ZlQ2hpbGQodGhpcy5nZXRFbGVtZW50KCkubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEVsZW1lbnQoKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ2V0RWxlbWVudCgpKTtcbiAgICB9XG5cbiAgICAvLyBjYWxsIG9yaWdpbmFsIHNldEdsb2JlIG1ldGhvZFxuICAgIFdpZGdldC5wcm90b3R5cGUuc2V0R2xvYmUuY2FsbCh0aGlzLCBnbG9iZSk7XG59O1xuXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMgaW5pdCBjb21wb25lbnQgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG4vLyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIC8vXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBNaW5pR2xvYmUgY29udHJvbCAoY2FsbGVkIGJ5IGNvbnN0cnVjdG9yKVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1pbmlHbG9iZS5wcm90b3R5cGUuX2luaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaWQgb2YgdGhlIHdpZGdldCA6IHVzZWZ1bGwgdG8gc3VmZml4IHRoZSBDU1MgaWRzICh0byBoYW5kbGUgY2FzZXMgd2l0aCBzZXZlcmFsIHdpZGdldHMgb24gdGhlIHNhbWUgcGFnZSlcbiAgICB0aGlzLl91aWQgPSBTZWxlY3RvcklELmdlbmVyYXRlKCk7XG5cbiAgICAvLyBkaXYgd2hpY2ggd2lsbCBjb250YWluIHRoZSBsaXN0IGRpdnMuXG4gICAgdGhpcy5fTWluaUdsb2JlQ29udGFpbmVyID0gbnVsbDtcblxuICAgIC8vIGNhbGxiYWNrc1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGNvbnRyb2wgbWFpbiBjb250YWluZXJcbiAqXG4gKiBAbWV0aG9kIF9pbml0Q29udGFpbmVyXG4gKiBAcmV0dXJucyB7RE9NRWxlbWVudH0gY29udGFpbmVyIC0gd2lkZ2V0IGNvbnRhaW5lclxuICogQHByaXZhdGVcbiAqL1xuTWluaUdsb2JlLnByb3RvdHlwZS5faW5pdENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQoKTtcblxuICAgIHJldHVybiBjb250YWluZXI7XG59O1xuXG5NaW5pR2xvYmUucHJvdG90eXBlLl9iYXNlTGF5ZXIgPSB7XG4gICAgdHlwZSA6IFwiY29sb3JcIixcbiAgICBwcm90b2NvbCA6IFwid210c1wiLFxuICAgIGlkIDogXCJNYXBzXCIsXG4gICAgdXJsIDogXCJodHRwczovL3d4cy5pZ24uZnIvYW43bnZmem9qdjV3YTk2ZHNnYTVuazh3L2dlb3BvcnRhaWwvd210c1wiLFxuICAgIHVwZGF0ZVN0cmF0ZWd5IDoge1xuICAgICAgICB0eXBlIDogXCIwXCIsXG4gICAgICAgIG9wdGlvbnMgOiB7fVxuICAgIH0sXG4gICAgbmV0d29ya09wdGlvbnMgOiB7XG4gICAgICAgIGNyb3NzT3JpZ2luIDogXCJvbWl0XCJcbiAgICB9LFxuICAgIG9wdGlvbnMgOiB7XG4gICAgICAgIG5hbWUgOiBcIkdFT0dSQVBISUNBTEdSSURTWVNURU1TLk1BUFNcIixcbiAgICAgICAgbWltZXR5cGUgOiBcImltYWdlL2pwZWdcIixcbiAgICAgICAgdGlsZU1hdHJpeFNldCA6IFwiUE1cIixcbiAgICAgICAgdGlsZU1hdHJpeFNldExpbWl0cyA6IHtcbiAgICAgICAgICAgIDAgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjBcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiMVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMSA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCIwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMVwiLFxuICAgICAgICAgICAgICAgIG1pblRpbGVDb2wgOiBcIjBcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCIyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyIDoge1xuICAgICAgICAgICAgICAgIG1pblRpbGVSb3cgOiBcIjBcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlUm93IDogXCIyXCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDMgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjVcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiOFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNCA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCIxXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMTFcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiMTZcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDUgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiM1wiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjIyXCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjMyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA2IDoge1xuICAgICAgICAgICAgICAgIG1pblRpbGVSb3cgOiBcIjdcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlUm93IDogXCI0NVwiLFxuICAgICAgICAgICAgICAgIG1pblRpbGVDb2wgOiBcIjBcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCI2NFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNyA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCI0MlwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjk3XCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjExNVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOCA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCI4NFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjE5NVwiLFxuICAgICAgICAgICAgICAgIG1pblRpbGVDb2wgOiBcIjFcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCIyNDdcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDkgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiMTcwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMzkwXCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiMlwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjQ5NVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTAgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiMzQwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiNzgwXCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiNVwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjk5MFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTEgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiNjgxXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMTU0NFwiLFxuICAgICAgICAgICAgICAgIG1pblRpbGVDb2wgOiBcIjEwXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiMTk4MVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTIgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiMTM2M1wiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjMwODhcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCIyMFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjM5NjJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDEzIDoge1xuICAgICAgICAgICAgICAgIG1pblRpbGVSb3cgOiBcIjI3MjZcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlUm93IDogXCI2MTc3XCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiNDBcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCI3OTI0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxNCA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCI1NDUyXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMTIzNTVcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCI4MVwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVDb2wgOiBcIjE1ODQ3XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxNSA6IHtcbiAgICAgICAgICAgICAgICBtaW5UaWxlUm93IDogXCIxMDk0NFwiLFxuICAgICAgICAgICAgICAgIG1heFRpbGVSb3cgOiBcIjIxMTc2XCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiMTYzXCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiMzE2OTVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDE2IDoge1xuICAgICAgICAgICAgICAgIG1pblRpbGVSb3cgOiBcIjIxODg5XCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiNDIzNTNcIixcbiAgICAgICAgICAgICAgICBtaW5UaWxlQ29sIDogXCIzMjZcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCI2MzM4MlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTcgOiB7XG4gICAgICAgICAgICAgICAgbWluVGlsZVJvdyA6IFwiNDM3NzZcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlUm93IDogXCI3MzUyNlwiLFxuICAgICAgICAgICAgICAgIG1pblRpbGVDb2wgOiBcIjQyNTI4XCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZUNvbCA6IFwiODU4NjlcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDE4IDoge1xuICAgICAgICAgICAgICAgIG1pblRpbGVSb3cgOiBcIjg3NTU3XCIsXG4gICAgICAgICAgICAgICAgbWF4VGlsZVJvdyA6IFwiMTQ3MDUyXCIsXG4gICAgICAgICAgICAgICAgbWluVGlsZUNvbCA6IFwiODUwNThcIixcbiAgICAgICAgICAgICAgICBtYXhUaWxlQ29sIDogXCIxNzE3MzhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTWluaUdsb2JlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9Db250cm9scy9NaW5pR2xvYmUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar MiniGlobeDOM = {\n\n    /**\n    * Add uuid to the tag ID\n    * @param {String} id - id selector\n    * @returns {String} uid - id selector with an unique id\n    */\n    _addUID: function _addUID(id) {\n        var uid = this._uid ? id + \"-\" + this._uid : id;\n        return uid;\n    },\n\n    /**\n     * Main container (DOM)\n     *\n     * @returns {DOMElement} DOM element\n     */\n    _createMainContainerElement: function _createMainContainerElement() {\n        var container = document.createElement(\"div\");\n        container.id = this._addUID(\"GPminiglobeContainer\");\n        container.className = \"GPwidget\";\n        return container;\n    }\n};\n\nexports.default = MiniGlobeDOM;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL0NvbnRyb2xzL01pbmlHbG9iZURPTS5qcz82ZGUxIl0sIm5hbWVzIjpbIk1pbmlHbG9iZURPTSIsIl9hZGRVSUQiLCJpZCIsInVpZCIsIl91aWQiLCJfY3JlYXRlTWFpbkNvbnRhaW5lckVsZW1lbnQiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsZUFBZTs7QUFFZjs7Ozs7QUFLQUMsYUFBVSxpQkFBVUMsRUFBVixFQUFjO0FBQ3BCLFlBQUlDLE1BQU8sS0FBS0MsSUFBTixHQUFjRixLQUFLLEdBQUwsR0FBVyxLQUFLRSxJQUE5QixHQUFxQ0YsRUFBL0M7QUFDQSxlQUFPQyxHQUFQO0FBQ0gsS0FWYzs7QUFZZjs7Ozs7QUFLQUUsaUNBQThCLHVDQUFZO0FBQ3RDLFlBQUlDLFlBQVlDLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQUYsa0JBQVVKLEVBQVYsR0FBZSxLQUFLRCxPQUFMLENBQWEsc0JBQWIsQ0FBZjtBQUNBSyxrQkFBVUcsU0FBVixHQUFzQixVQUF0QjtBQUNBLGVBQU9ILFNBQVA7QUFDSDtBQXRCYyxDQUFuQjs7a0JBeUJlTixZIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIE1pbmlHbG9iZURPTSA9IHtcblxuICAgIC8qKlxuICAgICogQWRkIHV1aWQgdG8gdGhlIHRhZyBJRFxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gaWQgc2VsZWN0b3JcbiAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHVpZCAtIGlkIHNlbGVjdG9yIHdpdGggYW4gdW5pcXVlIGlkXG4gICAgKi9cbiAgICBfYWRkVUlEIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciB1aWQgPSAodGhpcy5fdWlkKSA/IGlkICsgXCItXCIgKyB0aGlzLl91aWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIHVpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFpbiBjb250YWluZXIgKERPTSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtET01FbGVtZW50fSBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9jcmVhdGVNYWluQ29udGFpbmVyRWxlbWVudCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGNvbnRhaW5lci5pZCA9IHRoaXMuX2FkZFVJRChcIkdQbWluaWdsb2JlQ29udGFpbmVyXCIpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJHUHdpZGdldFwiO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1pbmlHbG9iZURPTTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vQ29udHJvbHMvTWluaUdsb2JlRE9NLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Config = __webpack_require__(5);\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"wmtsLayer\");\n\n/**\n * @classdesc\n * Geoportal WMTS source creation\n *\n * @constructor\n * @alias itowns.layer.GeoportalWMTS\n * @param {Object} options            - options for function call.\n * @param {String} options.layer      - Layer name (e.g. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)\n * @param {String} [options.apiKey]   - Access key to Geoportal platform\n * @param {Object} [options.itownsParams] - other options for itowns.GlobeView.addLayer function (see {@link http://www.itowns-project.org/itowns/API_Doc/GlobeView.html#addLayer GlobeView.addLayer})\n * @example\n * var geoportalWMTS = new itowns.layer.GeoportalWMTS({\n *      layer  : \"ORTHOIMAGERY.ORTHOPHOTOS\"\n * });\n */\n/* globals self */\nfunction LayerWMTS(options) {\n    if (!(this instanceof LayerWMTS)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    // check layer params\n    if (!options.layer) {\n        throw new Error(\"ERROR PARAM_MISSING : layer\");\n    }\n    if (typeof options.layer !== \"string\") {\n        throw new Error(\"ERROR WRONG TYPE : layer\");\n    }\n\n    // par defaut\n    if (typeof options.ssl === \"undefined\") {\n        options.ssl = false;\n    }\n\n    // Check if configuration is loaded\n    if (!_Config2.default.isConfigLoaded()) {\n        throw new Error(\"ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html\");\n    }\n\n    var layerId = _Config2.default.getLayerId(options.layer, \"WMTS\");\n\n    if (layerId && _Config2.default.configuration.getLayerConf(layerId)) {\n        var wmtsParams = _Config2.default.getLayerParams(options.layer, \"WMTS\", options.apiKey);\n\n        // gestion de mixContent dans l'url du service...\n        var ctx = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : null;\n        var protocol = ctx ? ctx.location && ctx.location.protocol && ctx.location.protocol.indexOf(\"https:\") === 0 ? \"https://\" : \"http://\" : options.ssl ? \"https://\" : \"http://\";\n\n        this.type = \"color\";\n        this.protocol = \"wmts\";\n        this.id = layerId;\n        this.url = wmtsParams.url.replace(/(http|https):\\/\\//, protocol);\n        this.updateStrategy = {\n            type: 0,\n            options: {}\n        };\n        this.networkOptions = {\n            crossOrigin: \"omit\"\n        };\n        this.projection = wmtsParams.projection;\n        this.options = {\n            originators: wmtsParams.originators,\n            name: options.layer,\n            mimetype: wmtsParams.format,\n            tileMatrixSet: wmtsParams.TMSLink,\n            extent: {\n                west: wmtsParams.extent.left,\n                east: wmtsParams.extent.right,\n                south: wmtsParams.extent.bottom,\n                north: wmtsParams.extent.top\n            },\n            tileMatrixSetLimits: wmtsParams.tileMatrices\n        };\n\n        // récupération des autres paramètres passés par l'utilisateur\n        _Utils2.default.mergeParams(this, options.itownsParams);\n\n        // add legends and metadata (to be added to LayerSwitcher control)\n        this.legends = wmtsParams.legends;\n        this.metadata = wmtsParams.metadata;\n        this.description = wmtsParams.description;\n        this.title = wmtsParams.title;\n        this.quicklookUrl = wmtsParams.quicklookUrl;\n    } else {\n        // If layer is not in Gp.Config\n        logger.error(\"ERROR layer id (layer name: \" + options.layer + \" / service: WMTS ) was not found !?\");\n    }\n}\n\n/*\n * Constructor (alias)\n */\nLayerWMTS.prototype.constructor = LayerWMTS;\n\nexports.default = LayerWMTS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0xheWVyL0xheWVyV01UUy5qcz80ZWVjIl0sIm5hbWVzIjpbImxvZ2dlciIsIkxvZ2dlciIsImdldExvZ2dlciIsIkxheWVyV01UUyIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJsYXllciIsIkVycm9yIiwic3NsIiwiQ29uZmlnIiwiaXNDb25maWdMb2FkZWQiLCJsYXllcklkIiwiZ2V0TGF5ZXJJZCIsImNvbmZpZ3VyYXRpb24iLCJnZXRMYXllckNvbmYiLCJ3bXRzUGFyYW1zIiwiZ2V0TGF5ZXJQYXJhbXMiLCJhcGlLZXkiLCJjdHgiLCJ3aW5kb3ciLCJzZWxmIiwicHJvdG9jb2wiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJ0eXBlIiwiaWQiLCJ1cmwiLCJyZXBsYWNlIiwidXBkYXRlU3RyYXRlZ3kiLCJuZXR3b3JrT3B0aW9ucyIsImNyb3NzT3JpZ2luIiwicHJvamVjdGlvbiIsIm9yaWdpbmF0b3JzIiwibmFtZSIsIm1pbWV0eXBlIiwiZm9ybWF0IiwidGlsZU1hdHJpeFNldCIsIlRNU0xpbmsiLCJleHRlbnQiLCJ3ZXN0IiwibGVmdCIsImVhc3QiLCJyaWdodCIsInNvdXRoIiwiYm90dG9tIiwibm9ydGgiLCJ0b3AiLCJ0aWxlTWF0cml4U2V0TGltaXRzIiwidGlsZU1hdHJpY2VzIiwiVXRpbHMiLCJtZXJnZVBhcmFtcyIsIml0b3duc1BhcmFtcyIsImxlZ2VuZHMiLCJtZXRhZGF0YSIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJxdWlja2xvb2tVcmwiLCJlcnJvciIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUlBLFNBQVNDLDBCQUFPQyxTQUFQLENBQWlCLFdBQWpCLENBQWI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFQQTtBQXVCQSxTQUFTQyxTQUFULENBQW9CQyxPQUFwQixFQUE2QjtBQUN6QixRQUFJLEVB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YUFBS0MsWUFBTCxHQUFvQnpDLFdBQVd5QyxZQUEvQjtBQUNILEtBNUNELE1BNENPO0FBQ0g7QUFDQXhELGVBQU95RCxLQUFQLENBQWEsaUNBQWlDckQsUUFBUUUsS0FBekMsR0FBaUQscUNBQTlEO0FBQ0g7QUFDSjs7QUFFRDs7O0FBR0FILFVBQVV1RCxTQUFWLENBQW9CQyxXQUFwQixHQUFrQ3hELFNBQWxDOztrQkFFZUEsUyIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgc2VsZiAqL1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHNcIjtcbmltcG9ydCBDb25maWcgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Db25maWdcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJ3bXRzTGF5ZXJcIik7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogR2VvcG9ydGFsIFdNVFMgc291cmNlIGNyZWF0aW9uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgaXRvd25zLmxheWVyLkdlb3BvcnRhbFdNVFNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgLSBvcHRpb25zIGZvciBmdW5jdGlvbiBjYWxsLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubGF5ZXIgICAgICAtIExheWVyIG5hbWUgKGUuZy4gXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3NsXSAgICAgLSBpZiBzZXQgdHJ1ZSwgZW5mb3JjZSBwcm90b2NvbCBodHRwcyAob25seSBmb3Igbm9kZWpzKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFwaUtleV0gICAtIEFjY2VzcyBrZXkgdG8gR2VvcG9ydGFsIHBsYXRmb3JtXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaXRvd25zUGFyYW1zXSAtIG90aGVyIG9wdGlvbnMgZm9yIGl0b3ducy5HbG9iZVZpZXcuYWRkTGF5ZXIgZnVuY3Rpb24gKHNlZSB7QGxpbmsgaHR0cDovL3d3dy5pdG93bnMtcHJvamVjdC5vcmcvaXRvd25zL0FQSV9Eb2MvR2xvYmVWaWV3Lmh0bWwjYWRkTGF5ZXIgR2xvYmVWaWV3LmFkZExheWVyfSlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvcG9ydGFsV01UUyA9IG5ldyBpdG93bnMubGF5ZXIuR2VvcG9ydGFsV01UUyh7XG4gKiAgICAgIGxheWVyICA6IFwiT1JUSE9JTUFHRVJZLk9SVEhPUEhPVE9TXCJcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBMYXllcldNVFMgKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGF5ZXJXTVRTKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRVJST1IgQ0xBU1NfQ09OU1RSVUNUT1JcIik7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgbGF5ZXIgcGFyYW1zXG4gICAgaWYgKCFvcHRpb25zLmxheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFBBUkFNX01JU1NJTkcgOiBsYXllclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxheWVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFdST05HIFRZUEUgOiBsYXllclwiKTtcbiAgICB9XG5cbiAgICAvLyBwYXIgZGVmYXV0XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNzbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zLnNzbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbmZpZ3VyYXRpb24gaXMgbG9hZGVkXG4gICAgaWYgKCFDb25maWcuaXNDb25maWdMb2FkZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUiA6IGNvbnRyYWN0IGtleSBjb25maWd1cmF0aW9uIGhhcyB0byBiZSBsb2FkZWQgdG8gbG9hZCBHZW9wb3J0YWwgbGF5ZXJzLiBTZWUgaHR0cDovL2lnbmYuZ2l0aHViLmlvL2V2b2x1dGlvbi1hcGlnZW9wb3J0YWlsL29sMy9vbDMtYXV0b2NvbmYuaHRtbFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJJZCA9IENvbmZpZy5nZXRMYXllcklkKG9wdGlvbnMubGF5ZXIsIFwiV01UU1wiKTtcblxuICAgIGlmIChsYXllcklkICYmIENvbmZpZy5jb25maWd1cmF0aW9uLmdldExheWVyQ29uZihsYXllcklkKSkge1xuICAgICAgICB2YXIgd210c1BhcmFtcyA9IENvbmZpZy5nZXRMYXllclBhcmFtcyhvcHRpb25zLmxheWVyLCBcIldNVFNcIiwgb3B0aW9ucy5hcGlLZXkpO1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGUgbWl4Q29udGVudCBkYW5zIGwndXJsIGR1IHNlcnZpY2UuLi5cbiAgICAgICAgdmFyIGN0eCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsO1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSAoY3R4KVxuICAgICAgICAgICAgPyAoY3R4LmxvY2F0aW9uICYmIGN0eC5sb2NhdGlvbi5wcm90b2NvbCAmJiBjdHgubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSA9PT0gMCA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiKVxuICAgICAgICAgICAgOiAob3B0aW9ucy5zc2wgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIik7XG5cbiAgICAgICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gXCJ3bXRzXCI7XG4gICAgICAgIHRoaXMuaWQgPSBsYXllcklkO1xuICAgICAgICB0aGlzLnVybCA9IHdtdHNQYXJhbXMudXJsLnJlcGxhY2UoLyhodHRwfGh0dHBzKTpcXC9cXC8vLCBwcm90b2NvbCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RyYXRlZ3kgPSB7XG4gICAgICAgICAgICB0eXBlIDogMCxcbiAgICAgICAgICAgIG9wdGlvbnMgOiB7fVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5ldHdvcmtPcHRpb25zID0ge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gOiBcIm9taXRcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSB3bXRzUGFyYW1zLnByb2plY3Rpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmF0b3JzIDogd210c1BhcmFtcy5vcmlnaW5hdG9ycyxcbiAgICAgICAgICAgIG5hbWUgOiBvcHRpb25zLmxheWVyLFxuICAgICAgICAgICAgbWltZXR5cGUgOiB3bXRzUGFyYW1zLmZvcm1hdCxcbiAgICAgICAgICAgIHRpbGVNYXRyaXhTZXQgOiB3bXRzUGFyYW1zLlRNU0xpbmssXG4gICAgICAgICAgICBleHRlbnQgOiB7XG4gICAgICAgICAgICAgICAgd2VzdCA6IHdtdHNQYXJhbXMuZXh0ZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgZWFzdCA6IHdtdHNQYXJhbXMuZXh0ZW50LnJpZ2h0LFxuICAgICAgICAgICAgICAgIHNvdXRoIDogd210c1BhcmFtcy5leHRlbnQuYm90dG9tLFxuICAgICAgICAgICAgICAgIG5vcnRoIDogd210c1BhcmFtcy5leHRlbnQudG9wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGlsZU1hdHJpeFNldExpbWl0cyA6IHdtdHNQYXJhbXMudGlsZU1hdHJpY2VzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGVzIGF1dHJlcyBwYXJhbcOodHJlcyBwYXNzw6lzIHBhciBsJ3V0aWxpc2F0ZXVyXG4gICAgICAgIFV0aWxzLm1lcmdlUGFyYW1zKHRoaXMsIG9wdGlvbnMuaXRvd25zUGFyYW1zKTtcblxuICAgICAgICAvLyBhZGQgbGVnZW5kcyBhbmQgbWV0YWRhdGEgKHRvIGJlIGFkZGVkIHRvIExheWVyU3dpdGNoZXIgY29udHJvbClcbiAgICAgICAgdGhpcy5sZWdlbmRzID0gd210c1BhcmFtcy5sZWdlbmRzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gd210c1BhcmFtcy5tZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IHdtdHNQYXJhbXMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudGl0bGUgPSB3bXRzUGFyYW1zLnRpdGxlO1xuICAgICAgICB0aGlzLnF1aWNrbG9va1VybCA9IHdtdHNQYXJhbXMucXVpY2tsb29rVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGxheWVyIGlzIG5vdCBpbiBHcC5Db25maWdcbiAgICAgICAgbG9nZ2VyLmVycm9yKFwiRVJST1IgbGF5ZXIgaWQgKGxheWVyIG5hbWU6IFwiICsgb3B0aW9ucy5sYXllciArIFwiIC8gc2VydmljZTogV01UUyApIHdhcyBub3QgZm91bmQgIT9cIik7XG4gICAgfVxufVxuXG4vKlxuICogQ29uc3RydWN0b3IgKGFsaWFzKVxuICovXG5MYXllcldNVFMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXJXTVRTO1xuXG5leHBvcnQgZGVmYXVsdCBMYXllcldNVFM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSXRvd25zL0xheWVyL0xheWVyV01UUy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Config = __webpack_require__(5);\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"wmsLayer\");\n\n/**\n * @classdesc\n * Geoportal WMTS source creation\n *\n * @constructor\n * @alias itowns.layer.GeoportalWMS\n * @param {Object} options            - options for function call.\n * @param {String} options.layer      - Layer name (e.g. \"ORTHOIMAGERY.ORTHOPHOTOS\")\n * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)\n * @param {String} [options.apiKey]   - Access key to Geoportal platform\n * @param {Object} [options.itownsParams] - other options for itowns.GlobeView.addLayer function (see {@link http://www.itowns-project.org/itowns/API_Doc/GlobeView.html#addLayer GlobeView.addLayer})\n * @example\n * var geoportalWMS = new itowns.layer.GeoportalWMS({\n *      layer  : \"ORTHOIMAGERY.ORTHOPHOTOS\"\n * });\n */\n/* globals self */\nfunction LayerWMS(options) {\n    if (!(this instanceof LayerWMS)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    // check layer params\n    if (!options.layer) {\n        throw new Error(\"ERROR PARAM_MISSING : layer\");\n    }\n    if (typeof options.layer !== \"string\") {\n        throw new Error(\"ERROR WRONG TYPE : layer\");\n    }\n\n    // par defaut\n    if (typeof options.ssl === \"undefined\") {\n        options.ssl = false;\n    }\n\n    // Check if configuration is loaded\n    if (!_Config2.default.isConfigLoaded()) {\n        throw new Error(\"ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html\");\n    }\n\n    var layerId = _Config2.default.getLayerId(options.layer, \"WMS\");\n\n    if (layerId && _Config2.default.configuration.getLayerConf(layerId)) {\n        var wmsParams = _Config2.default.getLayerParams(options.layer, \"WMS\", options.apiKey);\n\n        // gestion de mixContent dans l'url du service...\n        var ctx = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : null;\n        var protocol = ctx ? ctx.location && ctx.location.protocol && ctx.location.protocol.indexOf(\"https:\") === 0 ? \"https://\" : \"http://\" : options.ssl ? \"https://\" : \"http://\";\n\n        this.type = \"color\";\n        this.protocol = \"wms\";\n        this.version = wmsParams.version;\n        this.id = layerId;\n        this.name = options.layer;\n        this.url = wmsParams.url.replace(/(http|https):\\/\\//, protocol);\n        this.updateStrategy = {\n            type: 0,\n            options: {}\n        };\n        this.heightMapWidth = 256;\n        this.waterMask = false;\n        this.networkOptions = {\n            crossOrigin: \"omit\"\n        };\n        this.projection = wmsParams.projection;\n        this.options = {\n            originators: wmsParams.originators,\n            mimetype: wmsParams.format,\n            extent: {\n                west: wmsParams.extent.left,\n                east: wmsParams.extent.right,\n                south: wmsParams.extent.bottom,\n                north: wmsParams.extent.top\n            }\n        };\n\n        // récupération des autres paramètres passés par l'utilisateur\n        _Utils2.default.mergeParams(this, options.itownsParams);\n\n        // add legends and metadata (to be added to LayerSwitcher control)\n        this.legends = wmsParams.legends;\n        this.metadata = wmsParams.metadata;\n        this.description = wmsParams.description;\n        this.title = wmsParams.title;\n        this.quicklookUrl = wmsParams.quicklookUrl;\n    } else {\n        // If layer is not in Gp.Config\n        logger.error(\"ERROR layer id (layer name: \" + options.layer + \" / service: WMS ) was not found !?\");\n    }\n}\n\n/*\n * Constructor (alias)\n */\nLayerWMS.prototype.constructor = LayerWMS;\n\nexports.default = LayerWMS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0xheWVyL0xheWVyV01TLmpzPzBlOGUiXSwibmFtZXMiOlsibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiTGF5ZXJXTVMiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwibGF5ZXIiLCJFcnJvciIsInNzbCIsIkNvbmZpZyIsImlzQ29uZmlnTG9hZGVkIiwibGF5ZXJJZCIsImdldExheWVySWQiLCJjb25maWd1cmF0aW9uIiwiZ2V0TGF5ZXJDb25mIiwid21zUGFyYW1zIiwiZ2V0TGF5ZXJQYXJhbXMiLCJhcGlLZXkiLCJjdHgiLCJ3aW5kb3ciLCJzZWxmIiwicHJvdG9jb2wiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJ0eXBlIiwidmVyc2lvbiIsImlkIiwibmFtZSIsInVybCIsInJlcGxhY2UiLCJ1cGRhdGVTdHJhdGVneSIsImhlaWdodE1hcFdpZHRoIiwid2F0ZXJNYXNrIiwibmV0d29ya09wdGlvbnMiLCJjcm9zc09yaWdpbiIsInByb2plY3Rpb24iLCJvcmlnaW5hdG9ycyIsIm1pbWV0eXBlIiwiZm9ybWF0IiwiZXh0ZW50Iiwid2VzdCIsImxlZnQiLCJlYXN0IiwicmlnaHQiLCJzb3V0aCIsImJvdHRvbSIsIm5vcnRoIiwidG9wIiwiVXRpbHMiLCJtZXJnZVBhcmFtcyIsIml0b3duc1BhcmFtcyIsImxlZ2VuZHMiLCJtZXRhZGF0YSIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJxdWlja2xvb2tVcmwiLCJlcnJvciIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUlBLFNBQVNDLDBCQUFPQyxTQUFQLENBQWlCLFVBQWpCLENBQWI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFQQTtBQXVCQSxTQUFTQyxRQUFULENBQW1CQyxPQUFuQixFQUE0QjtBQUN4QixRQUFJLEVBQUUsZ0JBQWdCRCxRQUFsQixDQUFKLEVBQWlD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VUFBVXVDLEtBQXZCO0FBQ0EsYUFBS0MsWUFBTCxHQUFvQnhDLFVBQVV3QyxZQUE5QjtBQUNILEtBN0NELE1BNkNPO0FBQ0g7QUFDQXZELGVBQU93RCxLQUFQLENBQWEsaUNBQWlDcEQsUUFBUUUsS0FBekMsR0FBaUQsb0NBQTlEO0FBQ0g7QUFDSjs7QUFFRDs7O0FBR0FILFNBQVNzRCxTQUFULENBQW1CQyxXQUFuQixHQUFpQ3ZELFFBQWpDOztrQkFFZUEsUSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgc2VsZiAqL1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHNcIjtcbmltcG9ydCBDb25maWcgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Db25maWdcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJ3bXNMYXllclwiKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBHZW9wb3J0YWwgV01UUyBzb3VyY2UgY3JlYXRpb25cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhbGlhcyBpdG93bnMubGF5ZXIuR2VvcG9ydGFsV01TXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgIC0gb3B0aW9ucyBmb3IgZnVuY3Rpb24gY2FsbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmxheWVyICAgICAgLSBMYXllciBuYW1lIChlLmcuIFwiT1JUSE9JTUFHRVJZLk9SVEhPUEhPVE9TXCIpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNzbF0gICAgIC0gaWYgc2V0IHRydWUsIGVuZm9yY2UgcHJvdG9jb2wgaHR0cHMgKG9ubHkgZm9yIG5vZGVqcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hcGlLZXldICAgLSBBY2Nlc3Mga2V5IHRvIEdlb3BvcnRhbCBwbGF0Zm9ybVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLml0b3duc1BhcmFtc10gLSBvdGhlciBvcHRpb25zIGZvciBpdG93bnMuR2xvYmVWaWV3LmFkZExheWVyIGZ1bmN0aW9uIChzZWUge0BsaW5rIGh0dHA6Ly93d3cuaXRvd25zLXByb2plY3Qub3JnL2l0b3ducy9BUElfRG9jL0dsb2JlVmlldy5odG1sI2FkZExheWVyIEdsb2JlVmlldy5hZGRMYXllcn0pXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb3BvcnRhbFdNUyA9IG5ldyBpdG93bnMubGF5ZXIuR2VvcG9ydGFsV01TKHtcbiAqICAgICAgbGF5ZXIgIDogXCJPUlRIT0lNQUdFUlkuT1JUSE9QSE9UT1NcIlxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIExheWVyV01TIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExheWVyV01TKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRVJST1IgQ0xBU1NfQ09OU1RSVUNUT1JcIik7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgbGF5ZXIgcGFyYW1zXG4gICAgaWYgKCFvcHRpb25zLmxheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFBBUkFNX01JU1NJTkcgOiBsYXllclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxheWVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVSUk9SIFdST05HIFRZUEUgOiBsYXllclwiKTtcbiAgICB9XG5cbiAgICAvLyBwYXIgZGVmYXV0XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNzbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zLnNzbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbmZpZ3VyYXRpb24gaXMgbG9hZGVkXG4gICAgaWYgKCFDb25maWcuaXNDb25maWdMb2FkZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUiA6IGNvbnRyYWN0IGtleSBjb25maWd1cmF0aW9uIGhhcyB0byBiZSBsb2FkZWQgdG8gbG9hZCBHZW9wb3J0YWwgbGF5ZXJzLiBTZWUgaHR0cDovL2lnbmYuZ2l0aHViLmlvL2V2b2x1dGlvbi1hcGlnZW9wb3J0YWlsL29sMy9vbDMtYXV0b2NvbmYuaHRtbFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJJZCA9IENvbmZpZy5nZXRMYXllcklkKG9wdGlvbnMubGF5ZXIsIFwiV01TXCIpO1xuXG4gICAgaWYgKGxheWVySWQgJiYgQ29uZmlnLmNvbmZpZ3VyYXRpb24uZ2V0TGF5ZXJDb25mKGxheWVySWQpKSB7XG4gICAgICAgIHZhciB3bXNQYXJhbXMgPSBDb25maWcuZ2V0TGF5ZXJQYXJhbXMob3B0aW9ucy5sYXllciwgXCJXTVNcIiwgb3B0aW9ucy5hcGlLZXkpO1xuXG4gICAgICAgIC8vIGdlc3Rpb24gZGUgbWl4Q29udGVudCBkYW5zIGwndXJsIGR1IHNlcnZpY2UuLi5cbiAgICAgICAgdmFyIGN0eCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsO1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSAoY3R4KVxuICAgICAgICAgICAgPyAoY3R4LmxvY2F0aW9uICYmIGN0eC5sb2NhdGlvbi5wcm90b2NvbCAmJiBjdHgubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZihcImh0dHBzOlwiKSA9PT0gMCA/IFwiaHR0cHM6Ly9cIiA6IFwiaHR0cDovL1wiKVxuICAgICAgICAgICAgOiAob3B0aW9ucy5zc2wgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIik7XG5cbiAgICAgICAgdGhpcy50eXBlID0gXCJjb2xvclwiO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gXCJ3bXNcIjtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gd21zUGFyYW1zLnZlcnNpb247XG4gICAgICAgIHRoaXMuaWQgPSBsYXllcklkO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLmxheWVyO1xuICAgICAgICB0aGlzLnVybCA9IHdtc1BhcmFtcy51cmwucmVwbGFjZSgvKGh0dHB8aHR0cHMpOlxcL1xcLy8sIHByb3RvY29sKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJhdGVneSA9IHtcbiAgICAgICAgICAgIHR5cGUgOiAwLFxuICAgICAgICAgICAgb3B0aW9ucyA6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwV2lkdGggPSAyNTY7XG4gICAgICAgIHRoaXMud2F0ZXJNYXNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgICAgICBjcm9zc09yaWdpbiA6IFwib21pdFwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IHdtc1BhcmFtcy5wcm9qZWN0aW9uO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBvcmlnaW5hdG9ycyA6IHdtc1BhcmFtcy5vcmlnaW5hdG9ycyxcbiAgICAgICAgICAgIG1pbWV0eXBlIDogd21zUGFyYW1zLmZvcm1hdCxcbiAgICAgICAgICAgIGV4dGVudCA6IHtcbiAgICAgICAgICAgICAgICB3ZXN0IDogd21zUGFyYW1zLmV4dGVudC5sZWZ0LFxuICAgICAgICAgICAgICAgIGVhc3QgOiB3bXNQYXJhbXMuZXh0ZW50LnJpZ2h0LFxuICAgICAgICAgICAgICAgIHNvdXRoIDogd21zUGFyYW1zLmV4dGVudC5ib3R0b20sXG4gICAgICAgICAgICAgICAgbm9ydGggOiB3bXNQYXJhbXMuZXh0ZW50LnRvcFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHLDqWN1cMOpcmF0aW9uIGRlcyBhdXRyZXMgcGFyYW3DqHRyZXMgcGFzc8OpcyBwYXIgbCd1dGlsaXNhdGV1clxuICAgICAgICBVdGlscy5tZXJnZVBhcmFtcyh0aGlzLCBvcHRpb25zLml0b3duc1BhcmFtcyk7XG5cbiAgICAgICAgLy8gYWRkIGxlZ2VuZHMgYW5kIG1ldGFkYXRhICh0byBiZSBhZGRlZCB0byBMYXllclN3aXRjaGVyIGNvbnRyb2wpXG4gICAgICAgIHRoaXMubGVnZW5kcyA9IHdtc1BhcmFtcy5sZWdlbmRzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gd21zUGFyYW1zLm1ldGFkYXRhO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gd21zUGFyYW1zLmRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnRpdGxlID0gd21zUGFyYW1zLnRpdGxlO1xuICAgICAgICB0aGlzLnF1aWNrbG9va1VybCA9IHdtc1BhcmFtcy5xdWlja2xvb2tVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbGF5ZXIgaXMgbm90IGluIEdwLkNvbmZpZ1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJFUlJPUiBsYXllciBpZCAobGF5ZXIgbmFtZTogXCIgKyBvcHRpb25zLmxheWVyICsgXCIgLyBzZXJ2aWNlOiBXTVMgKSB3YXMgbm90IGZvdW5kICE/XCIpO1xuICAgIH1cbn1cblxuLypcbiAqIENvbnN0cnVjdG9yIChhbGlhcylcbiAqL1xuTGF5ZXJXTVMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXJXTVM7XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyV01TO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9MYXllci9MYXllcldNUy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Utils = __webpack_require__(1);\n\nvar _Utils2 = _interopRequireDefault(_Utils);\n\nvar _Config = __webpack_require__(5);\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _LoggerByDefault = __webpack_require__(0);\n\nvar _LoggerByDefault2 = _interopRequireDefault(_LoggerByDefault);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar logger = _LoggerByDefault2.default.getLogger(\"elevationLayer\");\n\n/**\n * @classdesc\n * Geoportal elevation source creation\n *\n * @constructor\n * @alias itowns.layer.GeoportalElevation\n * @param {Object} options            - options for function call.\n * @param {String} options.layer      - Elevation layer name (e.g. \"ELEVATION.ELEVATIONGRIDCOVERAGE\")\n * @param {Boolean} [options.ssl]     - if set true, enforce protocol https (only for nodejs)\n * @param {String} [options.apiKey]   - Access key to Geoportal platform\n * @param {Object} [options.itownsParams] - options to overload default geoportal layer options for itowns.GlobeView.addLayer function (see {@link http://www.itowns-project.org/itowns/API_Doc/GlobeView.html#addLayer GlobeView.addLayer})\n * @example\n * var geoportalElevation = new itowns.layer.GeoportalElevation({\n *      layer  : \"ELEVATION.ELEVATIONGRIDCOVERAGE\"\n * });\n */\n/* globals self */\nfunction LayerElevation(options) {\n    if (!(this instanceof LayerElevation)) {\n        throw new TypeError(\"ERROR CLASS_CONSTRUCTOR\");\n    }\n\n    // check layer params\n    if (!options.layer) {\n        throw new Error(\"ERROR PARAM_MISSING : layer\");\n    }\n    if (typeof options.layer !== \"string\") {\n        throw new Error(\"ERROR WRONG TYPE : layer\");\n    }\n\n    // par defaut\n    if (typeof options.ssl === \"undefined\") {\n        options.ssl = false;\n    }\n\n    // Check if configuration is loaded\n    if (!_Config2.default.isConfigLoaded()) {\n        throw new Error(\"ERROR : contract key configuration has to be loaded to load Geoportal layers. See http://ignf.github.io/evolution-apigeoportail/ol3/ol3-autoconf.html\");\n    }\n\n    var layerId = _Config2.default.getLayerId(options.layer, \"WMTS\");\n\n    if (layerId && _Config2.default.configuration.getLayerConf(layerId)) {\n        var wmtsParams = _Config2.default.getLayerParams(options.layer, \"WMTS\", options.apiKey);\n\n        // gestion de mixContent dans l'url du service...\n        var ctx = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : null;\n        var protocol = ctx ? ctx.location && ctx.location.protocol && ctx.location.protocol.indexOf(\"https:\") === 0 ? \"https://\" : \"http://\" : options.ssl ? \"https://\" : \"http://\";\n\n        this.type = \"elevation\";\n        this.protocol = \"wmts\";\n        this.id = layerId;\n        this.url = wmtsParams.url.replace(/(http|https):\\/\\//, protocol);\n        this.noDataValue = -99999;\n        this.updateStrategy = {\n            type: 1,\n            options: {\n                groups: [3, 7, 11, 14]\n            }\n        };\n        this.networkOptions = {\n            crossOrigin: \"omit\"\n        };\n        this.projection = wmtsParams.projection;\n        this.options = {\n            originators: wmtsParams.originators,\n            name: options.layer,\n            mimetype: \"image/x-bil;bits=32\",\n            tileMatrixSet: wmtsParams.TMSLink,\n            extent: {\n                west: wmtsParams.extent.left,\n                east: wmtsParams.extent.right,\n                south: wmtsParams.extent.bottom,\n                north: wmtsParams.extent.top\n            },\n            tileMatrixSetLimits: wmtsParams.tileMatrices\n        };\n\n        // récupération des autres paramètres passés par l'utilisateur\n        _Utils2.default.mergeParams(this, options.itownsParams);\n\n        // add legends and metadata (to be added to LayerSwitcher control)\n        this.legends = wmtsParams.legends;\n        this.metadata = wmtsParams.metadata;\n        this.description = wmtsParams.description;\n        this.title = wmtsParams.title;\n        this.quicklookUrl = wmtsParams.quicklookUrl;\n    } else {\n        // If layer is not in Gp.Config\n        logger.log(\"[source WMTS] ERROR : \" + options.layer + \" cannot be found in Geoportal Configuration. Make sure that this resource is included in your contract key.\");\n    }\n}\n\n/*\n * Constructor (alias)\n */\nLayerElevation.prototype.constructor = LayerElevation;\n\nexports.default = LayerElevation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0xheWVyL0xheWVyRWxldmF0aW9uLmpzP2Q0MTMiXSwibmFtZXMiOlsibG9nZ2VyIiwiTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiTGF5ZXJFbGV2YXRpb24iLCJvcHRpb25zIiwiVHlwZUVycm9yIiwibGF5ZXIiLCJFcnJvciIsInNzbCIsIkNvbmZpZyIsImlzQ29uZmlnTG9hZGVkIiwibGF5ZXJJZCIsImdldExheWVySWQiLCJjb25maWd1cmF0aW9uIiwiZ2V0TGF5ZXJDb25mIiwid210c1BhcmFtcyIsImdldExheWVyUGFyYW1zIiwiYXBpS2V5IiwiY3R4Iiwid2luZG93Iiwic2VsZiIsInByb3RvY29sIiwibG9jYXRpb24iLCJpbmRleE9mIiwidHlwZSIsImlkIiwidXJsIiwicmVwbGFjZSIsIm5vRGF0YVZhbHVlIiwidXBkYXRlU3RyYXRlZ3kiLCJncm91cHMiLCJuZXR3b3JrT3B0aW9ucyIsImNyb3NzT3JpZ2luIiwicHJvamVjdGlvbiIsIm9yaWdpbmF0b3JzIiwibmFtZSIsIm1pbWV0eXBlIiwidGlsZU1hdHJpeFNldCIsIlRNU0xpbmsiLCJleHRlbnQiLCJ3ZXN0IiwibGVmdCIsImVhc3QiLCJyaWdodCIsInNvdXRoIiwiYm90dG9tIiwibm9ydGgiLCJ0b3AiLCJ0aWxlTWF0cml4U2V0TGltaXRzIiwidGlsZU1hdHJpY2VzIiwiVXRpbHMiLCJtZXJnZVBhcmFtcyIsIml0b3duc1BhcmFtcyIsImxlZ2VuZHMiLCJtZXRhZGF0YSIsImRlc2NyaXB0aW9uIiwidGl0bGUiLCJxdWlja2xvb2tVcmwiLCJsb2ciLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJQSxTQUFTQywwQkFBT0MsU0FBUCxDQUFpQixnQkFBakIsQ0FBYjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQVBBO0FBdUJBLFNBQVNDLGNBQVQsQ0FBeUJDLE9B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LFFBQUwsR0FBZ0J2QyxXQUFXdUMsUUFBM0I7QUFDQSxhQUFLQyxXQUFMLEdBQW1CeEMsV0FBV3dDLFdBQTlCO0FBQ0EsYUFBS0MsS0FBTCxHQUFhekMsV0FBV3lDLEtBQXhCO0FBQ0EsYUFBS0MsWUFBTCxHQUFvQjFDLFdBQVcwQyxZQUEvQjtBQUNILEtBL0NELE1BK0NPO0FBQ0g7QUFDQXpELGVBQU8wRCxHQUFQLENBQVcsMkJBQTJCdEQsUUFBUUUsS0FBbkMsR0FBMkMsNkdBQXREO0FBQ0g7QUFDSjs7QUFFRDs7O0FBR0FILGVBQWV3RCxTQUFmLENBQXlCQyxXQUF6QixHQUF1Q3pELGNBQXZDOztrQkFFZUEsYyIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgc2VsZiAqL1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi9Db21tb24vVXRpbHNcIjtcbmltcG9ydCBDb25maWcgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Db25maWdcIjtcbmltcG9ydCBMb2dnZXIgZnJvbSBcIi4uLy4uL0NvbW1vbi9VdGlscy9Mb2dnZXJCeURlZmF1bHRcIjtcblxudmFyIGxvZ2dlciA9IExvZ2dlci5nZXRMb2dnZXIoXCJlbGV2YXRpb25MYXllclwiKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBHZW9wb3J0YWwgZWxldmF0aW9uIHNvdXJjZSBjcmVhdGlvblxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIGl0b3ducy5sYXllci5HZW9wb3J0YWxFbGV2YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgLSBvcHRpb25zIGZvciBmdW5jdGlvbiBjYWxsLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubGF5ZXIgICAgICAtIEVsZXZhdGlvbiBsYXllciBuYW1lIChlLmcuIFwiRUxFVkFUSU9OLkVMRVZBVElPTkdSSURDT1ZFUkFHRVwiKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zc2xdICAgICAtIGlmIHNldCB0cnVlLCBlbmZvcmNlIHByb3RvY29sIGh0dHBzIChvbmx5IGZvciBub2RlanMpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXBpS2V5XSAgIC0gQWNjZXNzIGtleSB0byBHZW9wb3J0YWwgcGxhdGZvcm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pdG93bnNQYXJhbXNdIC0gb3B0aW9ucyB0byBvdmVybG9hZCBkZWZhdWx0IGdlb3BvcnRhbCBsYXllciBvcHRpb25zIGZvciBpdG93bnMuR2xvYmVWaWV3LmFkZExheWVyIGZ1bmN0aW9uIChzZWUge0BsaW5rIGh0dHA6Ly93d3cuaXRvd25zLXByb2plY3Qub3JnL2l0b3ducy9BUElfRG9jL0dsb2JlVmlldy5odG1sI2FkZExheWVyIEdsb2JlVmlldy5hZGRMYXllcn0pXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb3BvcnRhbEVsZXZhdGlvbiA9IG5ldyBpdG93bnMubGF5ZXIuR2VvcG9ydGFsRWxldmF0aW9uKHtcbiAqICAgICAgbGF5ZXIgIDogXCJFTEVWQVRJT04uRUxFVkFUSU9OR1JJRENPVkVSQUdFXCJcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBMYXllckVsZXZhdGlvbiAob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMYXllckVsZXZhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkVSUk9SIENMQVNTX0NPTlNUUlVDVE9SXCIpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGxheWVyIHBhcmFtc1xuICAgIGlmICghb3B0aW9ucy5sYXllcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUiBQQVJBTV9NSVNTSU5HIDogbGF5ZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sYXllciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFUlJPUiBXUk9ORyBUWVBFIDogbGF5ZXJcIik7XG4gICAgfVxuXG4gICAgLy8gcGFyIGRlZmF1dFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zc2wgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zc2wgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjb25maWd1cmF0aW9uIGlzIGxvYWRlZFxuICAgIGlmICghQ29uZmlnLmlzQ29uZmlnTG9hZGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRVJST1IgOiBjb250cmFjdCBrZXkgY29uZmlndXJhdGlvbiBoYXMgdG8gYmUgbG9hZGVkIHRvIGxvYWQgR2VvcG9ydGFsIGxheWVycy4gU2VlIGh0dHA6Ly9pZ25mLmdpdGh1Yi5pby9ldm9sdXRpb24tYXBpZ2VvcG9ydGFpbC9vbDMvb2wzLWF1dG9jb25mLmh0bWxcIik7XG4gICAgfVxuXG4gICAgdmFyIGxheWVySWQgPSBDb25maWcuZ2V0TGF5ZXJJZChvcHRpb25zLmxheWVyLCBcIldNVFNcIik7XG5cbiAgICBpZiAobGF5ZXJJZCAmJiBDb25maWcuY29uZmlndXJhdGlvbi5nZXRMYXllckNvbmYobGF5ZXJJZCkpIHtcbiAgICAgICAgdmFyIHdtdHNQYXJhbXMgPSBDb25maWcuZ2V0TGF5ZXJQYXJhbXMob3B0aW9ucy5sYXllciwgXCJXTVRTXCIsIG9wdGlvbnMuYXBpS2V5KTtcblxuICAgICAgICAvLyBnZXN0aW9uIGRlIG1peENvbnRlbnQgZGFucyBsJ3VybCBkdSBzZXJ2aWNlLi4uXG4gICAgICAgIHZhciBjdHggPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogbnVsbDtcbiAgICAgICAgdmFyIHByb3RvY29sID0gKGN0eClcbiAgICAgICAgICAgID8gKGN0eC5sb2NhdGlvbiAmJiBjdHgubG9jYXRpb24ucHJvdG9jb2wgJiYgY3R4LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwczpcIikgPT09IDAgPyBcImh0dHBzOi8vXCIgOiBcImh0dHA6Ly9cIilcbiAgICAgICAgICAgIDogKG9wdGlvbnMuc3NsID8gXCJodHRwczovL1wiIDogXCJodHRwOi8vXCIpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZWxldmF0aW9uXCI7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBcIndtdHNcIjtcbiAgICAgICAgdGhpcy5pZCA9IGxheWVySWQ7XG4gICAgICAgIHRoaXMudXJsID0gd210c1BhcmFtcy51cmwucmVwbGFjZSgvKGh0dHB8aHR0cHMpOlxcL1xcLy8sIHByb3RvY29sKTtcbiAgICAgICAgdGhpcy5ub0RhdGFWYWx1ZSA9IC05OTk5OTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHJhdGVneSA9IHtcbiAgICAgICAgICAgIHR5cGUgOiAxLFxuICAgICAgICAgICAgb3B0aW9ucyA6IHtcbiAgICAgICAgICAgICAgICBncm91cHMgOiBbMywgNywgMTEsIDE0XVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5ldHdvcmtPcHRpb25zID0ge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW4gOiBcIm9taXRcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSB3bXRzUGFyYW1zLnByb2plY3Rpb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmF0b3JzIDogd210c1BhcmFtcy5vcmlnaW5hdG9ycyxcbiAgICAgICAgICAgIG5hbWUgOiBvcHRpb25zLmxheWVyLFxuICAgICAgICAgICAgbWltZXR5cGUgOiBcImltYWdlL3gtYmlsO2JpdHM9MzJcIixcbiAgICAgICAgICAgIHRpbGVNYXRyaXhTZXQgOiB3bXRzUGFyYW1zLlRNU0xpbmssXG4gICAgICAgICAgICBleHRlbnQgOiB7XG4gICAgICAgICAgICAgICAgd2VzdCA6IHdtdHNQYXJhbXMuZXh0ZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgZWFzdCA6IHdtdHNQYXJhbXMuZXh0ZW50LnJpZ2h0LFxuICAgICAgICAgICAgICAgIHNvdXRoIDogd210c1BhcmFtcy5leHRlbnQuYm90dG9tLFxuICAgICAgICAgICAgICAgIG5vcnRoIDogd210c1BhcmFtcy5leHRlbnQudG9wXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGlsZU1hdHJpeFNldExpbWl0cyA6IHdtdHNQYXJhbXMudGlsZU1hdHJpY2VzXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcsOpY3Vww6lyYXRpb24gZGVzIGF1dHJlcyBwYXJhbcOodHJlcyBwYXNzw6lzIHBhciBsJ3V0aWxpc2F0ZXVyXG4gICAgICAgIFV0aWxzLm1lcmdlUGFyYW1zKHRoaXMsIG9wdGlvbnMuaXRvd25zUGFyYW1zKTtcblxuICAgICAgICAvLyBhZGQgbGVnZW5kcyBhbmQgbWV0YWRhdGEgKHRvIGJlIGFkZGVkIHRvIExheWVyU3dpdGNoZXIgY29udHJvbClcbiAgICAgICAgdGhpcy5sZWdlbmRzID0gd210c1BhcmFtcy5sZWdlbmRzO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gd210c1BhcmFtcy5tZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IHdtdHNQYXJhbXMuZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudGl0bGUgPSB3bXRzUGFyYW1zLnRpdGxlO1xuICAgICAgICB0aGlzLnF1aWNrbG9va1VybCA9IHdtdHNQYXJhbXMucXVpY2tsb29rVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGxheWVyIGlzIG5vdCBpbiBHcC5Db25maWdcbiAgICAgICAgbG9nZ2VyLmxvZyhcIltzb3VyY2UgV01UU10gRVJST1IgOiBcIiArIG9wdGlvbnMubGF5ZXIgKyBcIiBjYW5ub3QgYmUgZm91bmQgaW4gR2VvcG9ydGFsIENvbmZpZ3VyYXRpb24uIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcmVzb3VyY2UgaXMgaW5jbHVkZWQgaW4geW91ciBjb250cmFjdCBrZXkuXCIpO1xuICAgIH1cbn1cblxuLypcbiAqIENvbnN0cnVjdG9yIChhbGlhcylcbiAqL1xuTGF5ZXJFbGV2YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXJFbGV2YXRpb247XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyRWxldmF0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9MYXllci9MYXllckVsZXZhdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(33);\n\n__webpack_require__(34);\n\n__webpack_require__(35);\n\n__webpack_require__(36);\n\n__webpack_require__(37);\n\n__webpack_require__(38);\n\n__webpack_require__(39);\n\n__webpack_require__(40);\n\n__webpack_require__(41);\n\n__webpack_require__(42);\n\n__webpack_require__(43);\n\n__webpack_require__(44);\n\n__webpack_require__(45);\n\n__webpack_require__(46);\n\n__webpack_require__(47);\n\n__webpack_require__(48);\n\n__webpack_require__(49);\n\n__webpack_require__(50);\n\n__webpack_require__(51);\n\n__webpack_require__(52);\n\n__webpack_require__(53);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSXRvd25zL0NTUy5qcz85ODE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0EiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuLi8uLi9yZXMvQ29tbW9uL0dQZHJhd2luZy5jc3NcIjtcbmltcG9ydCBcIi4uLy4uL3Jlcy9Db21tb24vR1Bpc29jaHJvbi5jc3NcIjtcbmltcG9ydCBcIi4uLy4uL3Jlcy9Db21tb24vR1BtZWFzdXJlQXppbXV0aC5jc3NcIjtcbmltcG9ydCBcIi4uLy4uL3Jlcy9Db21tb24vR1ByZXZlcnNlR2VvY29kaW5nLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUGVsZXZhdGlvblBhdGguY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvQ29tbW9uL0dQbGF5ZXJTd2l0Y2hlci5jc3NcIjtcbmltcG9ydCBcIi4uLy4uL3Jlcy9Db21tb24vR1BtZWFzdXJlTGVuZ3RoLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUHJvdXRlLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUGdlbmVyYWxXaWRnZXQuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvQ29tbW9uL0dQbG9jYXRpb24uY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvQ29tbW9uL0dQbWVhc3VyZVRvb2xUaXAuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvQ29tbW9uL0dQc2VhcmNoRW5naW5lLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUGdldEZlYXR1cmVJbmZvLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUG1lYXN1cmVBcmVhLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0NvbW1vbi9HUG1vdXNlUG9zaXRpb24uY3NzXCI7XG5cbmltcG9ydCBcIi4uLy4uL3Jlcy9JdG93bnMvR1BnZW5lcmFsV2lkZ2V0SXRvd25zLmNzc1wiO1xuXG5pbXBvcnQgXCIuLi8uLi9yZXMvSXRvd25zL0NvbnRyb2xzL0F0dHJpYnV0aW9uL0dQYXR0cmlidXRpb25JdG93bnMuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvSXRvd25zL0NvbnRyb2xzL0xheWVyU3dpdGNoZXIvR1BsYXllclN3aXRjaGVySXRvd25zLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0l0b3ducy9Db250cm9scy9NaW5pR2xvYmUvR1BtaW5pR2xvYmVJdG93bnMuY3NzXCI7XG5pbXBvcnQgXCIuLi8uLi9yZXMvSXRvd25zL0NvbnRyb2xzL01vdXNlUG9zaXRpb24vR1Btb3VzZVBvc2l0aW9uSXRvd25zLmNzc1wiO1xuaW1wb3J0IFwiLi4vLi4vcmVzL0l0b3ducy9Db250cm9scy9TY2FsZS9HUHNjYWxlSXRvd25zLmNzc1wiO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0l0b3ducy9DU1MuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQZHJhd2luZy5jc3M/NDU4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQZHJhd2luZy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQaXNvY2hyb24uY3NzP2NmNDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUGlzb2Nocm9uLmNzc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbWVhc3VyZUF6aW11dGguY3NzPzkyMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUG1lYXN1cmVBemltdXRoLmNzc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQcmV2ZXJzZUdlb2NvZGluZy5jc3M/MDNmMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQcmV2ZXJzZUdlb2NvZGluZy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQZWxldmF0aW9uUGF0aC5jc3M/YzRiZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQZWxldmF0aW9uUGF0aC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbGF5ZXJTd2l0Y2hlci5jc3M/NDVhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQbGF5ZXJTd2l0Y2hlci5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbWVhc3VyZUxlbmd0aC5jc3M/N2MzOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQbWVhc3VyZUxlbmd0aC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQcm91dGUuY3NzP2NhZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUHJvdXRlLmNzc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQZ2VuZXJhbFdpZGdldC5jc3M/YjBkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQZ2VuZXJhbFdpZGdldC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbG9jYXRpb24uY3NzPzE5ZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUGxvY2F0aW9uLmNzc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbWVhc3VyZVRvb2xUaXAuY3NzPzllY2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUG1lYXN1cmVUb29sVGlwLmNzc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQc2VhcmNoRW5naW5lLmNzcz8yMjUxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlcy9Db21tb24vR1BzZWFyY2hFbmdpbmUuY3NzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQZ2V0RmVhdHVyZUluZm8uY3NzP2YzMzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUGdldEZlYXR1cmVJbmZvLmNzc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbWVhc3VyZUFyZWEuY3NzPzUxM2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0NvbW1vbi9HUG1lYXN1cmVBcmVhLmNzc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvQ29tbW9uL0dQbW91c2VQb3NpdGlvbi5jc3M/ZTUzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvQ29tbW9uL0dQbW91c2VQb3NpdGlvbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n");

/***/ }),
/* 48 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0dQZ2VuZXJhbFdpZGdldEl0b3ducy5jc3M/NWY3MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvSXRvd25zL0dQZ2VuZXJhbFdpZGdldEl0b3ducy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0NvbnRyb2xzL0F0dHJpYnV0aW9uL0dQYXR0cmlidXRpb25JdG93bnMuY3NzPzRlYjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0l0b3ducy9Db250cm9scy9BdHRyaWJ1dGlvbi9HUGF0dHJpYnV0aW9uSXRvd25zLmNzc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0NvbnRyb2xzL0xheWVyU3dpdGNoZXIvR1BsYXllclN3aXRjaGVySXRvd25zLmNzcz8wMjQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlcy9JdG93bnMvQ29udHJvbHMvTGF5ZXJTd2l0Y2hlci9HUGxheWVyU3dpdGNoZXJJdG93bnMuY3NzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50\n");

/***/ }),
/* 51 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0NvbnRyb2xzL01pbmlHbG9iZS9HUG1pbmlHbG9iZUl0b3ducy5jc3M/OTk3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXMvSXRvd25zL0NvbnRyb2xzL01pbmlHbG9iZS9HUG1pbmlHbG9iZUl0b3ducy5jc3Ncbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n");

/***/ }),
/* 52 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0NvbnRyb2xzL01vdXNlUG9zaXRpb24vR1Btb3VzZVBvc2l0aW9uSXRvd25zLmNzcz8yNWEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlcy9JdG93bnMvQ29udHJvbHMvTW91c2VQb3NpdGlvbi9HUG1vdXNlUG9zaXRpb25JdG93bnMuY3NzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52\n");

/***/ }),
/* 53 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXMvSXRvd25zL0NvbnRyb2xzL1NjYWxlL0dQc2NhbGVJdG93bnMuY3NzP2Q4MTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzL0l0b3ducy9Db250cm9scy9TY2FsZS9HUHNjYWxlSXRvd25zLmNzc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53\n");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _gp = __webpack_require__(6);\n\nvar _gp2 = _interopRequireDefault(_gp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(function () {\n    var scripts = document.getElementsByTagName(\"script\");\n\n    var key = scripts[scripts.length - 1].getAttribute(\"data-key\");\n    // in case of several keys\n    if (key) {\n        var splitKeys = key.split(/;|,|\\|/);\n        if (key && splitKeys.length > 1) {\n            var keys = [];\n            for (var i = 0; i < splitKeys.length; i++) {\n                keys.push(splitKeys[i]);\n            }\n            key = keys;\n        }\n    }\n    var url = scripts[scripts.length - 1].getAttribute(\"data-url\");\n    var timeout = scripts[scripts.length - 1].getAttribute(\"data-timeout\");\n\n    // callback\n    var success = function success() {\n        // Pas de messages en mode prod\n        // console.log(\"GetConfig success!\");\n    };\n\n    // callback\n    var error = function error(e) {\n        throw new Error(\"Configuration load failed : \" + e.message);\n    };\n\n    if (!key && !url) {\n        // pas de message d'information !\n        // console.log(\"WARNING : parameters missing 'data-key' and 'data-url', the loading of configuration can not be done !\");\n        return;\n    }\n\n    var options = {\n        apiKey: key,\n        onSuccess: success,\n        onFailure: error\n    };\n\n    if (url) {\n        options.serverUrl = url;\n        options.callbackSuffix = \"\";\n    }\n\n    if (timeout) {\n        options.timeOut = timeout;\n    }\n\n    // test d'existance de la varibale globale Gp.Config\n    if (!_gp2.default.Config) {\n        // appel du service\n        _gp2.default.Services.getConfig(options);\n    }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29tbW9uL1V0aWxzL0F1dG9Mb2FkQ29uZmlnLmpzPzY3MTIiXSwibmFtZXMiOlsic2NyaXB0cyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJrZXkiLCJsZW5ndGgiLCJnZXRBdHRyaWJ1dGUiLCJzcGxpdEtleXMiLCJzcGxpdCIsImtleXMiLCJpIiwicHVzaCIsInVybCIsInRpbWVvdXQiLCJzdWNjZXNzIiwiZXJyb3IiLCJlIiwiRXJyb3IiLCJtZXNzYWdlIiwib3B0aW9ucyIsImFwaUtleSIsIm9uU3VjY2VzcyIsIm9uRmFpbHVyZSIsInNlcnZlclVybCIsImNhbGxiYWNrU3VmZml4IiwidGltZU91dCIsIkdwIiwiQ29uZmlnIiwiU2VydmljZXMiLCJnZXRDb25maWciXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7OztBQUVBLENBQUMsWUFBWTtBQUNULFFBQUlBLFVBQVVDLFNBQVNDLG9CQUFULENBQThCLFFBQTlCLENBQWQ7O0FBRUEsUUFBSUMsTUFBTUgsUUFBUUEsUUFBUUksTUFBUixHQUFpQixDQUF6QixFQUE0QkMsWUFBNUIsQ0FBeUMsVUFBekMsQ0FBVjtBQUNBO0FBQ0EsUUFBSUYsR0FBSixFQUFTO0FBQ0wsWUFBSUcsWUFBWUgsSUFBSUksS0FBSixDQUFVLFFBQVYsQ0FBaEI7QUFDQSxZQUFJSixPQUFPRyxVQUFVRixNQUFWLEdBQW1CLENBQTlCLEVBQWlDO0FBQzdCLGdCQUFJSSxPQUFPLEVBQVg7QUFDQSxpQkFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlILFVBQVVGLE1BQTlCLEVBQXNDSyxHQUF0QyxFQUEyQztBQUN2Q0QscUJBQUtFLElBQUwsQ0FBVUosVUFBVUcsQ0FBVixDQUFWO0FBQ0g7QUFDRE4sa0JBQU1LLElBQU47QUFDSDtBQUNKO0FBQ0QsUUFBSUcsTUFBTVgsUUFBUUEsUUFBUUksTUFBUixHQUFpQixDQUF6QixFQUE0QkMsWUFBNUIsQ0FBeUMsVUFBekMsQ0FBVjtBQUNBLFFBQUlPLFVBQVVaLFFBQVFBLFFBQVFJLE1BQVIsR0FBaUIsQ0FBekIsRUFBNEJDLFlBQTVCLENBQXlDLGNBQXpDLENBQWQ7O0FBRUE7QUFDQSxRQUFJUSxVQUFVLFNBQVZBLE9BQVUsR0FBWTtBQUN0QjtBQUNBO0FBQ0gsS0FIRDs7QUFLQTtBQUNBLFFBQUlDLFFBQVEsU0FBUkEsS0FBUSxDQUFVQyxDQUFWLEVBQWE7QUFDckIsY0FBTSxJQUFJQyxLQUFKLENBQVUsaUNBQWlDRCxFQUFFRSxPQUE3QyxDQUFOO0FBQ0gsS0FGRDs7QUFJQSxRQUFJLENBQUNkLEdBQUQsSUFBUSxDQUFDUSxHQUFiLEVBQWtCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQsUUFBSU8sVUFBVTtBQUNWQyxnQkFBU2hCLEdBREM7QUFFVmlCLG1CQUFZUCxPQUZGO0FBR1ZRLG1CQUFZUDtBQUhGLEtBQWQ7O0FBTUEsUUFBSUgsR0FBSixFQUFTO0FBQ0xPLGdCQUFRSSxTQUFSLEdBQW9CWCxHQUFwQjtBQUNBTyxnQkFBUUssY0FBUixHQUF5QixFQUF6QjtBQUNIOztBQUVELFFBQUlYLE9BQUosRUFBYTtBQUNUTSxnQkFBUU0sT0FBUixHQUFrQlosT0FBbEI7QUFDSDs7QUFFRDtBQUNBLFFBQUksQ0FBQ2EsYUFBR0MsTUFBUixFQUFnQjtBQUNaO0FBQ0FELHFCQUFHRSxRQUFILENBQVlDLFNBQVosQ0FBc0JWLE9BQXRCO0FBQ0g7QUFDSixDQXZERCIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHcCBmcm9tIFwiZ3BcIjtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXG4gICAgdmFyIGtleSA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWtleVwiKTtcbiAgICAvLyBpbiBjYXNlIG9mIHNldmVyYWwga2V5c1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHNwbGl0S2V5cyA9IGtleS5zcGxpdCgvO3wsfFxcfC8pO1xuICAgICAgICBpZiAoa2V5ICYmIHNwbGl0S2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goc3BsaXRLZXlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IGtleXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVybFwiKTtcbiAgICB2YXIgdGltZW91dCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRpbWVvdXRcIik7XG5cbiAgICAvLyBjYWxsYmFja1xuICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXMgZGUgbWVzc2FnZXMgZW4gbW9kZSBwcm9kXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiR2V0Q29uZmlnIHN1Y2Nlc3MhXCIpO1xuICAgIH07XG5cbiAgICAvLyBjYWxsYmFja1xuICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZ3VyYXRpb24gbG9hZCBmYWlsZWQgOiBcIiArIGUubWVzc2FnZSk7XG4gICAgfTtcblxuICAgIGlmICgha2V5ICYmICF1cmwpIHtcbiAgICAgICAgLy8gcGFzIGRlIG1lc3NhZ2UgZCdpbmZvcm1hdGlvbiAhXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiV0FSTklORyA6IHBhcmFtZXRlcnMgbWlzc2luZyAnZGF0YS1rZXknIGFuZCAnZGF0YS11cmwnLCB0aGUgbG9hZGluZyBvZiBjb25maWd1cmF0aW9uIGNhbiBub3QgYmUgZG9uZSAhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGFwaUtleSA6IGtleSxcbiAgICAgICAgb25TdWNjZXNzIDogc3VjY2VzcyxcbiAgICAgICAgb25GYWlsdXJlIDogZXJyb3JcbiAgICB9O1xuXG4gICAgaWYgKHVybCkge1xuICAgICAgICBvcHRpb25zLnNlcnZlclVybCA9IHVybDtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFja1N1ZmZpeCA9IFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgb3B0aW9ucy50aW1lT3V0ID0gdGltZW91dDtcbiAgICB9XG5cbiAgICAvLyB0ZXN0IGQnZXhpc3RhbmNlIGRlIGxhIHZhcmliYWxlIGdsb2JhbGUgR3AuQ29uZmlnXG4gICAgaWYgKCFHcC5Db25maWcpIHtcbiAgICAgICAgLy8gYXBwZWwgZHUgc2VydmljZVxuICAgICAgICBHcC5TZXJ2aWNlcy5nZXRDb25maWcob3B0aW9ucyk7XG4gICAgfVxufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21tb24vVXRpbHMvQXV0b0xvYWRDb25maWcuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n");

/***/ }),
/* 55 */
/***/ (function(module, exports) {

eval("module.exports = {\"name\":\"geoportal-extensions\",\"leafletExtName\":\"French Geoportal Extension for Leaflet\",\"olExtName\":\"French Geoportal Extension for OpenLayers\",\"itownsExtName\":\"French Geoportal Extension for Itowns\",\"olItownsExtName\":\"French Geoportal Extension for OpenLayers & Itowns\",\"version\":\"2.0.0\",\"leafletExtVersion\":\"2.0.1\",\"olExtVersion\":\"2.0.0\",\"itownsExtVersion\":\"2.0.0\",\"olItownsExtVersion\":\"2.0.1\",\"description\":\"French Geoportal Extensions for OpenLayers, Leaflet and iTowns libraries\",\"main\":\"dist/leaflet/GpPluginLeaflet.js, dist/openlayers/GpPluginOpenLayers.js, dist/itowns/GpPluginItowns.js, dist/mix/GpPluginOlItowns.js\",\"directories\":{},\"scripts\":{\"setup\":\"npm install\",\"clean\":\"echo \\\"Warning: target not yet implemented!\\\" && exit 0\",\"test\":\"cd test && mocha-webpack --require setup.js --webpack-config webpack.test.js --glob \\\"test-*.js\\\" spec/Common/*/*\",\"test:serve\":\"cd test && webpack-dev-server --hot --config webpack.test.serve.js\",\"cover\":\"nyc --reporter=lcov --reporter=text npm run test\",\"sample\":\"npm run sample:serve\",\"sample:serve\":\"npm run sample:ol:serve\",\"sample:itowns:serve\":\"webpack-dev-server --config webpack.config.itowns --open-page samples/index-itowns-src.html --contentBase . --port 9001 --open\",\"sample:leaflet:serve\":\"webpack-dev-server --config webpack.config.leaflet --open-page samples/index-leaflet-src.html --contentBase . --port 9001 --open\",\"sample:ol:serve\":\"webpack-dev-server --config webpack.config.openlayers --open-page samples/index-openlayers-src.html --contentBase . --port 9001 --open\",\"doc\":\"npm run doc:serve\",\"doc:serve\":\"npm run doc:ol:serve\",\"doc:itowns:serve\":\"webpack-dev-server --config webpack.config.itowns --contentBase jsdoc/itowns --port 9001 --open\",\"doc:leaflet:serve\":\"webpack-dev-server --config webpack.config.leaflet --contentBase jsdoc/leaflet --port 9001 --open\",\"doc:ol:serve\":\"webpack-dev-server --config webpack.config.openlayers --contentBase jsdoc/openlayers --port 9001 --open\",\"build:dev\":\"npm run build:ol:dev; npm run build:itowns:dev; npm run build:mix:dev; npm run build:leaflet:dev\",\"build:prod\":\"npm run build:ol:prod; npm run build:itowns:prod; npm run build:mix:prod; npm run build:leaflet:prod\",\"build\":\"npm run build:ol; npm run build:itowns; npm run build:mix; npm run build:leaflet\",\"build:itowns:dev\":\"webpack --config webpack.config.itowns --env.development\",\"build:itowns:prod\":\"webpack --config webpack.config.itowns --env.production\",\"build:itowns\":\"webpack --config webpack.config.itowns\",\"build:mix:dev\":\"webpack --config webpack.config.mix --env.development\",\"build:mix:prod\":\"webpack --config webpack.config.mix --env.production\",\"build:mix\":\"webpack --config webpack.config.mix\",\"build:ol:dev\":\"webpack --config webpack.config.openlayers --env.development\",\"build:ol:prod\":\"webpack --config webpack.config.openlayers --env.production\",\"build:ol\":\"webpack --config webpack.config.openlayers\",\"build:leaflet:dev\":\"webpack --config webpack.config.leaflet --env.development\",\"build:leaflet:prod\":\"webpack --config webpack.config.leaflet --env.production\",\"build:leaflet\":\"webpack --config webpack.config.leaflet\"},\"nyc\":{\"include\":[\"src/**/*.js\"],\"instrument\":false,\"sourceMap\":false},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/IGNF/geoportal-extensions.git\"},\"author\":\"IGNF\",\"keywords\":[\"geoportail\",\"javascript\",\"OpenLayers\",\"Leaflet\",\"Itowns\",\"3D\"],\"license\":\"CECILL-B\",\"bugs\":{\"url\":\"https://github.com/IGNF/geoportal-extensions/issues\"},\"homepage\":\"https://github.com/IGNF/geoportal-extensions#readme\",\"dependencies\":{\"geoportal-access-lib\":\"^2.0.0\",\"itowns\":\"2.3.0\",\"leaflet\":\"^1.3.1\",\"leaflet-draw\":\"^1.0.2\",\"loglevel\":\"^1.6.1\",\"openlayers\":\"^4.4.2\",\"proj4\":\"2.4.4\",\"proj4leaflet\":\"^1.0.2\",\"sortablejs\":\"1.4.0\",\"three\":\"^0.93.0\",\"three.meshline\":\"^1.1.0\"},\"devDependencies\":{\"babel-core\":\"^6.26.0\",\"babel-loader\":\"^7.1.2\",\"babel-preset-env\":\"^1.6.1\",\"chai\":\"^4.1.2\",\"clean-webpack-plugin\":\"^0.1.19\",\"copy-webpack-plugin\":\"^4.5.1\",\"css-loader\":\"^0.28.10\",\"eslint\":\"^4.18.2\",\"eslint-config-standard\":\"^11.0.0\",\"eslint-loader\":\"^2.0.0\",\"eslint-plugin-import\":\"^2.9.0\",\"eslint-plugin-node\":\"^6.0.1\",\"eslint-plugin-promise\":\"^3.7.0\",\"eslint-plugin-standard\":\"^3.0.1\",\"expose-loader\":\"^0.7.4\",\"extract-text-webpack-plugin\":\"^3.0.2\",\"handlebars-layouts\":\"^3.1.4\",\"handlebars-webpack-plugin\":\"^1.4.1\",\"html-webpack-plugin\":\"^3.1.0\",\"istanbul-instrumenter-loader\":\"^3.0.1\",\"jsdoc-webpack-plugin\":\"0.0.1\",\"jsdom\":\"^9.9.1\",\"mocha\":\"^5.0.5\",\"mocha-loader\":\"^1.1.3\",\"mocha-webpack\":\"^1.1.0\",\"nyc\":\"^12.0.2\",\"path\":\"^0.12.7\",\"requirejs\":\"^2.3.5\",\"speed-measure-webpack-plugin\":\"^1.2.2\",\"string-template\":\"^1.0.0\",\"style-loader\":\"^0.20.2\",\"url-loader\":\"^1.0.1\",\"webpack\":\"^3.11.0\",\"webpack-dev-server\":\"^2.11.1\",\"webpack-merge\":\"^4.1.2\",\"webpack-node-externals\":\"^1.6.0\"}}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24/ZWQ4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0Isa29CQUFrb0IsWUFBWSwwekNBQTB6QywwQkFBMEIsdUJBQXVCLGdFQUFnRSwyQkFBMkIsd0JBQXdCLHVEQUF1RCxzQkFBc0IsbUJBQW1CLDQxQkFBNDFCLFFBQVEsK0RBQStELGVBQWUsc0VBQXNFLDBIQUEwSCw0REFBNEQsa0ZBQWtGLCtPQUErTyxvQkFBb0IiLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcIm5hbWVcIjpcImdlb3BvcnRhbC1leHRlbnNpb25zXCIsXCJsZWFmbGV0RXh0TmFtZVwiOlwiRnJlbmNoIEdlb3BvcnRhbCBFeHRlbnNpb24gZm9yIExlYWZsZXRcIixcIm9sRXh0TmFtZVwiOlwiRnJlbmNoIEdlb3BvcnRhbCBFeHRlbnNpb24gZm9yIE9wZW5MYXllcnNcIixcIml0b3duc0V4dE5hbWVcIjpcIkZyZW5jaCBHZW9wb3J0YWwgRXh0ZW5zaW9uIGZvciBJdG93bnNcIixcIm9sSXRvd25zRXh0TmFtZVwiOlwiRnJlbmNoIEdlb3BvcnRhbCBFeHRlbnNpb24gZm9yIE9wZW5MYXllcnMgJiBJdG93bnNcIixcInZlcnNpb25cIjpcIjIuMC4wXCIsXCJsZWFmbGV0RXh0VmVyc2lvblwiOlwiMi4wLjFcIixcIm9sRXh0VmVyc2lvblwiOlwiMi4wLjBcIixcIml0b3duc0V4dFZlcnNpb25cIjpcIjIuMC4wXCIsXCJvbEl0b3duc0V4dFZlcnNpb25cIjpcIjIuMC4xXCIsXCJkZXNjcmlwdGlvblwiOlwiRnJlbmNoIEdlb3BvcnRhbCBFeHRlbnNpb25zIGZvciBPcGVuTGF5ZXJzLCBMZWFmbGV0IGFuZCBpVG93bnMgbGlicmFyaWVzXCIsXCJtYWluXCI6XCJkaXN0L2xlYWZsZXQvR3BQbHVnaW5MZWFmbGV0LmpzLCBkaXN0L29wZW5sYXllcnMvR3BQbHVnaW5PcGVuTGF5ZXJzLmpzLCBkaXN0L2l0b3ducy9HcFBsdWdpbkl0b3ducy5qcywgZGlzdC9taXgvR3BQbHVnaW5PbEl0b3ducy5qc1wiLFwiZGlyZWN0b3JpZXNcIjp7fSxcInNjcmlwdHNcIjp7XCJzZXR1cFwiOlwibnBtIGluc3RhbGxcIixcImNsZWFuXCI6XCJlY2hvIFxcXCJXYXJuaW5nOiB0YXJnZXQgbm90IHlldCBpbXBsZW1lbnRlZCFcXFwiICYmIGV4aXQgMFwiLFwidGVzdFwiOlwiY2QgdGVzdCAmJiBtb2NoYS13ZWJwYWNrIC0tcmVxdWlyZSBzZXR1cC5qcyAtLXdlYnBhY2stY29uZmlnIHdlYnBhY2sudGVzdC5qcyAtLWdsb2IgXFxcInRlc3QtKi5qc1xcXCIgc3BlYy9Db21tb24vKi8qXCIsXCJ0ZXN0OnNlcnZlXCI6XCJjZCB0ZXN0ICYmIHdlYnBhY2stZGV2LXNlcnZlciAtLWhvdCAtLWNvbmZpZyB3ZWJwYWNrLnRlc3Quc2VydmUuanNcIixcImNvdmVyXCI6XCJueWMgLS1yZXBvcnRlcj1sY292IC0tcmVwb3J0ZXI9dGV4dCBucG0gcnVuIHRlc3RcIixcInNhbXBsZVwiOlwibnBtIHJ1biBzYW1wbGU6c2VydmVcIixcInNhbXBsZTpzZXJ2ZVwiOlwibnBtIHJ1biBzYW1wbGU6b2w6c2VydmVcIixcInNhbXBsZTppdG93bnM6c2VydmVcIjpcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5pdG93bnMgLS1vcGVuLXBhZ2Ugc2FtcGxlcy9pbmRleC1pdG93bnMtc3JjLmh0bWwgLS1jb250ZW50QmFzZSAuIC0tcG9ydCA5MDAxIC0tb3BlblwiLFwic2FtcGxlOmxlYWZsZXQ6c2VydmVcIjpcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5sZWFmbGV0IC0tb3Blbi1wYWdlIHNhbXBsZXMvaW5kZXgtbGVhZmxldC1zcmMuaHRtbCAtLWNvbnRlbnRCYXNlIC4gLS1wb3J0IDkwMDEgLS1vcGVuXCIsXCJzYW1wbGU6b2w6c2VydmVcIjpcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5vcGVubGF5ZXJzIC0tb3Blbi1wYWdlIHNhbXBsZXMvaW5kZXgtb3BlbmxheWVycy1zcmMuaHRtbCAtLWNvbnRlbnRCYXNlIC4gLS1wb3J0IDkwMDEgLS1vcGVuXCIsXCJkb2NcIjpcIm5wbSBydW4gZG9jOnNlcnZlXCIsXCJkb2M6c2VydmVcIjpcIm5wbSBydW4gZG9jOm9sOnNlcnZlXCIsXCJkb2M6aXRvd25zOnNlcnZlXCI6XCJ3ZWJwYWNrLWRldi1zZXJ2ZXIgLS1jb25maWcgd2VicGFjay5jb25maWcuaXRvd25zIC0tY29udGVudEJhc2UganNkb2MvaXRvd25zIC0tcG9ydCA5MDAxIC0tb3BlblwiLFwiZG9jOmxlYWZsZXQ6c2VydmVcIjpcIndlYnBhY2stZGV2LXNlcnZlciAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5sZWFmbGV0IC0tY29udGVudEJhc2UganNkb2MvbGVhZmxldCAtLXBvcnQgOTAwMSAtLW9wZW5cIixcImRvYzpvbDpzZXJ2ZVwiOlwid2VicGFjay1kZXYtc2VydmVyIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLm9wZW5sYXllcnMgLS1jb250ZW50QmFzZSBqc2RvYy9vcGVubGF5ZXJzIC0tcG9ydCA5MDAxIC0tb3BlblwiLFwiYnVpbGQ6ZGV2XCI6XCJucG0gcnVuIGJ1aWxkOm9sOmRldjsgbnBtIHJ1biBidWlsZDppdG93bnM6ZGV2OyBucG0gcnVuIGJ1aWxkOm1peDpkZXY7IG5wbSBydW4gYnVpbGQ6bGVhZmxldDpkZXZcIixcImJ1aWxkOnByb2RcIjpcIm5wbSBydW4gYnVpbGQ6b2w6cHJvZDsgbnBtIHJ1biBidWlsZDppdG93bnM6cHJvZDsgbnBtIHJ1biBidWlsZDptaXg6cHJvZDsgbnBtIHJ1biBidWlsZDpsZWFmbGV0OnByb2RcIixcImJ1aWxkXCI6XCJucG0gcnVuIGJ1aWxkOm9sOyBucG0gcnVuIGJ1aWxkOml0b3duczsgbnBtIHJ1biBidWlsZDptaXg7IG5wbSBydW4gYnVpbGQ6bGVhZmxldFwiLFwiYnVpbGQ6aXRvd25zOmRldlwiOlwid2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5pdG93bnMgLS1lbnYuZGV2ZWxvcG1lbnRcIixcImJ1aWxkOml0b3duczpwcm9kXCI6XCJ3ZWJwYWNrIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLml0b3ducyAtLWVudi5wcm9kdWN0aW9uXCIsXCJidWlsZDppdG93bnNcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcuaXRvd25zXCIsXCJidWlsZDptaXg6ZGV2XCI6XCJ3ZWJwYWNrIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLm1peCAtLWVudi5kZXZlbG9wbWVudFwiLFwiYnVpbGQ6bWl4OnByb2RcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcubWl4IC0tZW52LnByb2R1Y3Rpb25cIixcImJ1aWxkOm1peFwiOlwid2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5taXhcIixcImJ1aWxkOm9sOmRldlwiOlwid2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5vcGVubGF5ZXJzIC0tZW52LmRldmVsb3BtZW50XCIsXCJidWlsZDpvbDpwcm9kXCI6XCJ3ZWJwYWNrIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLm9wZW5sYXllcnMgLS1lbnYucHJvZHVjdGlvblwiLFwiYnVpbGQ6b2xcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcub3BlbmxheWVyc1wiLFwiYnVpbGQ6bGVhZmxldDpkZXZcIjpcIndlYnBhY2sgLS1jb25maWcgd2VicGFjay5jb25maWcubGVhZmxldCAtLWVudi5kZXZlbG9wbWVudFwiLFwiYnVpbGQ6bGVhZmxldDpwcm9kXCI6XCJ3ZWJwYWNrIC0tY29uZmlnIHdlYnBhY2suY29uZmlnLmxlYWZsZXQgLS1lbnYucHJvZHVjdGlvblwiLFwiYnVpbGQ6bGVhZmxldFwiOlwid2VicGFjayAtLWNvbmZpZyB3ZWJwYWNrLmNvbmZpZy5sZWFmbGV0XCJ9LFwibnljXCI6e1wiaW5jbHVkZVwiOltcInNyYy8qKi8qLmpzXCJdLFwiaW5zdHJ1bWVudFwiOmZhbHNlLFwic291cmNlTWFwXCI6ZmFsc2V9LFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vSUdORi9nZW9wb3J0YWwtZXh0ZW5zaW9ucy5naXRcIn0sXCJhdXRob3JcIjpcIklHTkZcIixcImtleXdvcmRzXCI6W1wiZ2VvcG9ydGFpbFwiLFwiamF2YXNjcmlwdFwiLFwiT3BlbkxheWVyc1wiLFwiTGVhZmxldFwiLFwiSXRvd25zXCIsXCIzRFwiXSxcImxpY2Vuc2VcIjpcIkNFQ0lMTC1CXCIsXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vSUdORi9nZW9wb3J0YWwtZXh0ZW5zaW9ucy9pc3N1ZXNcIn0sXCJob21lcGFnZVwiOlwiaHR0cHM6Ly9naXRodWIuY29tL0lHTkYvZ2VvcG9ydGFsLWV4dGVuc2lvbnMjcmVhZG1lXCIsXCJkZXBlbmRlbmNpZXNcIjp7XCJnZW9wb3J0YWwtYWNjZXNzLWxpYlwiOlwiXjIuMC4wXCIsXCJpdG93bnNcIjpcIjIuMy4wXCIsXCJsZWFmbGV0XCI6XCJeMS4zLjFcIixcImxlYWZsZXQtZHJhd1wiOlwiXjEuMC4yXCIsXCJsb2dsZXZlbFwiOlwiXjEuNi4xXCIsXCJvcGVubGF5ZXJzXCI6XCJeNC40LjJcIixcInByb2o0XCI6XCIyLjQuNFwiLFwicHJvajRsZWFmbGV0XCI6XCJeMS4wLjJcIixcInNvcnRhYmxlanNcIjpcIjEuNC4wXCIsXCJ0aHJlZVwiOlwiXjAuOTMuMFwiLFwidGhyZWUubWVzaGxpbmVcIjpcIl4xLjEuMFwifSxcImRldkRlcGVuZGVuY2llc1wiOntcImJhYmVsLWNvcmVcIjpcIl42LjI2LjBcIixcImJhYmVsLWxvYWRlclwiOlwiXjcuMS4yXCIsXCJiYWJlbC1wcmVzZXQtZW52XCI6XCJeMS42LjFcIixcImNoYWlcIjpcIl40LjEuMlwiLFwiY2xlYW4td2VicGFjay1wbHVnaW5cIjpcIl4wLjEuMTlcIixcImNvcHktd2VicGFjay1wbHVnaW5cIjpcIl40LjUuMVwiLFwiY3NzLWxvYWRlclwiOlwiXjAuMjguMTBcIixcImVzbGludFwiOlwiXjQuMTguMlwiLFwiZXNsaW50LWNvbmZpZy1zdGFuZGFyZFwiOlwiXjExLjAuMFwiLFwiZXNsaW50LWxvYWRlclwiOlwiXjIuMC4wXCIsXCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOlwiXjIuOS4wXCIsXCJlc2xpbnQtcGx1Z2luLW5vZGVcIjpcIl42LjAuMVwiLFwiZXNsaW50LXBsdWdpbi1wcm9taXNlXCI6XCJeMy43LjBcIixcImVzbGludC1wbHVnaW4tc3RhbmRhcmRcIjpcIl4zLjAuMVwiLFwiZXhwb3NlLWxvYWRlclwiOlwiXjAuNy40XCIsXCJleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cIjpcIl4zLjAuMlwiLFwiaGFuZGxlYmFycy1sYXlvdXRzXCI6XCJeMy4xLjRcIixcImhhbmRsZWJhcnMtd2VicGFjay1wbHVnaW5cIjpcIl4xLjQuMVwiLFwiaHRtbC13ZWJwYWNrLXBsdWdpblwiOlwiXjMuMS4wXCIsXCJpc3RhbmJ1bC1pbnN0cnVtZW50ZXItbG9hZGVyXCI6XCJeMy4wLjFcIixcImpzZG9jLXdlYnBhY2stcGx1Z2luXCI6XCIwLjAuMVwiLFwianNkb21cIjpcIl45LjkuMVwiLFwibW9jaGFcIjpcIl41LjAuNVwiLFwibW9jaGEtbG9hZGVyXCI6XCJeMS4xLjNcIixcIm1vY2hhLXdlYnBhY2tcIjpcIl4xLjEuMFwiLFwibnljXCI6XCJeMTIuMC4yXCIsXCJwYXRoXCI6XCJeMC4xMi43XCIsXCJyZXF1aXJlanNcIjpcIl4yLjMuNVwiLFwic3BlZWQtbWVhc3VyZS13ZWJwYWNrLXBsdWdpblwiOlwiXjEuMi4yXCIsXCJzdHJpbmctdGVtcGxhdGVcIjpcIl4xLjAuMFwiLFwic3R5bGUtbG9hZGVyXCI6XCJeMC4yMC4yXCIsXCJ1cmwtbG9hZGVyXCI6XCJeMS4wLjFcIixcIndlYnBhY2tcIjpcIl4zLjExLjBcIixcIndlYnBhY2stZGV2LXNlcnZlclwiOlwiXjIuMTEuMVwiLFwid2VicGFjay1tZXJnZVwiOlwiXjQuMS4yXCIsXCJ3ZWJwYWNrLW5vZGUtZXh0ZXJuYWxzXCI6XCJeMS42LjBcIn19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55\n");

/***/ })
/******/ ]);
});